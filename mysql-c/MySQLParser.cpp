/*
 * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2.0,
 * as published by the Free Software Foundation.
 *
 * This program is also distributed with certain software (including
 * but not limited to OpenSSL) that is licensed under separate terms, as
 * designated in a particular file or component or in included license
 * documentation. The authors of MySQL hereby grant you an additional
 * permission to link the program and your derivative works with the
 * separately licensed software that they have included with MySQL.
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See
 * the GNU General Public License, version 2.0, for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
 */


// Generated from MySQLParser.g4 by ANTLR 4.7.2


#include "MySQLParserListener.h"

#include "MySQLParser.h"


#include "MySQLBaseRecognizer.h"


using namespace antlrcpp;
using namespace parsers;
using namespace antlr4;

MySQLParser::MySQLParser(TokenStream *input) : MySQLBaseRecognizer(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

MySQLParser::~MySQLParser() {
  delete _interpreter;
}

std::string MySQLParser::getGrammarFileName() const {
  return "MySQLParser.g4";
}

const std::vector<std::string>& MySQLParser::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& MySQLParser::getVocabulary() const {
  return _vocabulary;
}


//----------------- QueriesContext ------------------------------------------------------------------

MySQLParser::QueriesContext::QueriesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Aux_queryContext* MySQLParser::QueriesContext::aux_query() {
  return getRuleContext<MySQLParser::Aux_queryContext>(0);
}


size_t MySQLParser::QueriesContext::getRuleIndex() const {
  return MySQLParser::RuleQueries;
}

void MySQLParser::QueriesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueries(this);
}

void MySQLParser::QueriesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueries(this);
}

MySQLParser::QueriesContext* MySQLParser::queries() {
  QueriesContext *_localctx = _tracker.createInstance<QueriesContext>(_ctx, getState());
  enterRule(_localctx, 0, MySQLParser::RuleQueries);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1204);
    aux_query();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Aux_queryContext ------------------------------------------------------------------

MySQLParser::Aux_queryContext::Aux_queryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Aux_queryContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::Aux_queryContext::SEMICOLON_SYMBOL() {
  return getTokens(MySQLParser::SEMICOLON_SYMBOL);
}

tree::TerminalNode* MySQLParser::Aux_queryContext::SEMICOLON_SYMBOL(size_t i) {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, i);
}

std::vector<MySQLParser::SimpleStatementContext *> MySQLParser::Aux_queryContext::simpleStatement() {
  return getRuleContexts<MySQLParser::SimpleStatementContext>();
}

MySQLParser::SimpleStatementContext* MySQLParser::Aux_queryContext::simpleStatement(size_t i) {
  return getRuleContext<MySQLParser::SimpleStatementContext>(i);
}

std::vector<MySQLParser::BeginWorkContext *> MySQLParser::Aux_queryContext::beginWork() {
  return getRuleContexts<MySQLParser::BeginWorkContext>();
}

MySQLParser::BeginWorkContext* MySQLParser::Aux_queryContext::beginWork(size_t i) {
  return getRuleContext<MySQLParser::BeginWorkContext>(i);
}


size_t MySQLParser::Aux_queryContext::getRuleIndex() const {
  return MySQLParser::RuleAux_query;
}

void MySQLParser::Aux_queryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAux_query(this);
}

void MySQLParser::Aux_queryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAux_query(this);
}

MySQLParser::Aux_queryContext* MySQLParser::aux_query() {
  Aux_queryContext *_localctx = _tracker.createInstance<Aux_queryContext>(_ctx, getState());
  enterRule(_localctx, 2, MySQLParser::RuleAux_query);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1213);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1208);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx)) {
        case 1: {
          setState(1206);
          simpleStatement();
          break;
        }

        case 2: {
          setState(1207);
          beginWork();
          break;
        }

        }
        setState(1210);
        match(MySQLParser::SEMICOLON_SYMBOL); 
      }
      setState(1215);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1, _ctx);
    }
    setState(1216);
    match(MySQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryContext ------------------------------------------------------------------

MySQLParser::QueryContext::QueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QueryContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

MySQLParser::SimpleStatementContext* MySQLParser::QueryContext::simpleStatement() {
  return getRuleContext<MySQLParser::SimpleStatementContext>(0);
}

MySQLParser::BeginWorkContext* MySQLParser::QueryContext::beginWork() {
  return getRuleContext<MySQLParser::BeginWorkContext>(0);
}

tree::TerminalNode* MySQLParser::QueryContext::SEMICOLON_SYMBOL() {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, 0);
}


size_t MySQLParser::QueryContext::getRuleIndex() const {
  return MySQLParser::RuleQuery;
}

void MySQLParser::QueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuery(this);
}

void MySQLParser::QueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuery(this);
}

MySQLParser::QueryContext* MySQLParser::query() {
  QueryContext *_localctx = _tracker.createInstance<QueryContext>(_ctx, getState());
  enterRule(_localctx, 4, MySQLParser::RuleQuery);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1230);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1218);
      match(MySQLParser::EOF);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1221);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 2, _ctx)) {
      case 1: {
        setState(1219);
        simpleStatement();
        break;
      }

      case 2: {
        setState(1220);
        beginWork();
        break;
      }

      }
      setState(1228);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::SEMICOLON_SYMBOL: {
          setState(1223);
          match(MySQLParser::SEMICOLON_SYMBOL);
          setState(1225);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 3, _ctx)) {
          case 1: {
            setState(1224);
            match(MySQLParser::EOF);
            break;
          }

          }
          break;
        }

        case MySQLParser::EOF: {
          setState(1227);
          match(MySQLParser::EOF);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleStatementContext ------------------------------------------------------------------

MySQLParser::SimpleStatementContext::SimpleStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterStatementContext* MySQLParser::SimpleStatementContext::alterStatement() {
  return getRuleContext<MySQLParser::AlterStatementContext>(0);
}

MySQLParser::CreateStatementContext* MySQLParser::SimpleStatementContext::createStatement() {
  return getRuleContext<MySQLParser::CreateStatementContext>(0);
}

MySQLParser::DropStatementContext* MySQLParser::SimpleStatementContext::dropStatement() {
  return getRuleContext<MySQLParser::DropStatementContext>(0);
}

MySQLParser::RenameTableStatementContext* MySQLParser::SimpleStatementContext::renameTableStatement() {
  return getRuleContext<MySQLParser::RenameTableStatementContext>(0);
}

MySQLParser::TruncateTableStatementContext* MySQLParser::SimpleStatementContext::truncateTableStatement() {
  return getRuleContext<MySQLParser::TruncateTableStatementContext>(0);
}

MySQLParser::ImportStatementContext* MySQLParser::SimpleStatementContext::importStatement() {
  return getRuleContext<MySQLParser::ImportStatementContext>(0);
}

MySQLParser::CallStatementContext* MySQLParser::SimpleStatementContext::callStatement() {
  return getRuleContext<MySQLParser::CallStatementContext>(0);
}

MySQLParser::DeleteStatementContext* MySQLParser::SimpleStatementContext::deleteStatement() {
  return getRuleContext<MySQLParser::DeleteStatementContext>(0);
}

MySQLParser::DoStatementContext* MySQLParser::SimpleStatementContext::doStatement() {
  return getRuleContext<MySQLParser::DoStatementContext>(0);
}

MySQLParser::HandlerStatementContext* MySQLParser::SimpleStatementContext::handlerStatement() {
  return getRuleContext<MySQLParser::HandlerStatementContext>(0);
}

MySQLParser::InsertStatementContext* MySQLParser::SimpleStatementContext::insertStatement() {
  return getRuleContext<MySQLParser::InsertStatementContext>(0);
}

MySQLParser::LoadStatementContext* MySQLParser::SimpleStatementContext::loadStatement() {
  return getRuleContext<MySQLParser::LoadStatementContext>(0);
}

MySQLParser::ReplaceStatementContext* MySQLParser::SimpleStatementContext::replaceStatement() {
  return getRuleContext<MySQLParser::ReplaceStatementContext>(0);
}

MySQLParser::SelectStatementContext* MySQLParser::SimpleStatementContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}

MySQLParser::UpdateStatementContext* MySQLParser::SimpleStatementContext::updateStatement() {
  return getRuleContext<MySQLParser::UpdateStatementContext>(0);
}

MySQLParser::TransactionOrLockingStatementContext* MySQLParser::SimpleStatementContext::transactionOrLockingStatement() {
  return getRuleContext<MySQLParser::TransactionOrLockingStatementContext>(0);
}

MySQLParser::ReplicationStatementContext* MySQLParser::SimpleStatementContext::replicationStatement() {
  return getRuleContext<MySQLParser::ReplicationStatementContext>(0);
}

MySQLParser::PreparedStatementContext* MySQLParser::SimpleStatementContext::preparedStatement() {
  return getRuleContext<MySQLParser::PreparedStatementContext>(0);
}

MySQLParser::CloneStatementContext* MySQLParser::SimpleStatementContext::cloneStatement() {
  return getRuleContext<MySQLParser::CloneStatementContext>(0);
}

MySQLParser::AccountManagementStatementContext* MySQLParser::SimpleStatementContext::accountManagementStatement() {
  return getRuleContext<MySQLParser::AccountManagementStatementContext>(0);
}

MySQLParser::TableAdministrationStatementContext* MySQLParser::SimpleStatementContext::tableAdministrationStatement() {
  return getRuleContext<MySQLParser::TableAdministrationStatementContext>(0);
}

MySQLParser::InstallUninstallStatmentContext* MySQLParser::SimpleStatementContext::installUninstallStatment() {
  return getRuleContext<MySQLParser::InstallUninstallStatmentContext>(0);
}

MySQLParser::SetStatementContext* MySQLParser::SimpleStatementContext::setStatement() {
  return getRuleContext<MySQLParser::SetStatementContext>(0);
}

MySQLParser::ShowStatementContext* MySQLParser::SimpleStatementContext::showStatement() {
  return getRuleContext<MySQLParser::ShowStatementContext>(0);
}

MySQLParser::ResourceGroupManagementContext* MySQLParser::SimpleStatementContext::resourceGroupManagement() {
  return getRuleContext<MySQLParser::ResourceGroupManagementContext>(0);
}

MySQLParser::OtherAdministrativeStatementContext* MySQLParser::SimpleStatementContext::otherAdministrativeStatement() {
  return getRuleContext<MySQLParser::OtherAdministrativeStatementContext>(0);
}

MySQLParser::UtilityStatementContext* MySQLParser::SimpleStatementContext::utilityStatement() {
  return getRuleContext<MySQLParser::UtilityStatementContext>(0);
}

MySQLParser::GetDiagnosticsContext* MySQLParser::SimpleStatementContext::getDiagnostics() {
  return getRuleContext<MySQLParser::GetDiagnosticsContext>(0);
}

MySQLParser::SignalStatementContext* MySQLParser::SimpleStatementContext::signalStatement() {
  return getRuleContext<MySQLParser::SignalStatementContext>(0);
}

MySQLParser::ResignalStatementContext* MySQLParser::SimpleStatementContext::resignalStatement() {
  return getRuleContext<MySQLParser::ResignalStatementContext>(0);
}


size_t MySQLParser::SimpleStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleStatement;
}

void MySQLParser::SimpleStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleStatement(this);
}

void MySQLParser::SimpleStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleStatement(this);
}

MySQLParser::SimpleStatementContext* MySQLParser::simpleStatement() {
  SimpleStatementContext *_localctx = _tracker.createInstance<SimpleStatementContext>(_ctx, getState());
  enterRule(_localctx, 6, MySQLParser::RuleSimpleStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1266);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1232);
      alterStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1233);
      createStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1234);
      dropStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1235);
      renameTableStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1236);
      truncateTableStatement();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1237);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1238);
      importStatement();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1239);
      callStatement();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1240);
      deleteStatement();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1241);
      doStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1242);
      handlerStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1243);
      insertStatement();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1244);
      loadStatement();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1245);
      replaceStatement();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1246);
      selectStatement();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1247);
      updateStatement();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1248);
      transactionOrLockingStatement();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1249);
      replicationStatement();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(1250);
      preparedStatement();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(1251);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1252);
      cloneStatement();
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(1253);
      accountManagementStatement();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(1254);
      tableAdministrationStatement();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(1255);
      installUninstallStatment();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(1256);
      setStatement();
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(1257);
      showStatement();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(1258);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1259);
      resourceGroupManagement();
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(1260);
      otherAdministrativeStatement();
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(1261);
      utilityStatement();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(1262);

      if (!(serverVersion >= 50604)) throw FailedPredicateException(this, "serverVersion >= 50604");
      setState(1263);
      getDiagnostics();
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(1264);
      signalStatement();
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(1265);
      resignalStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterStatementContext ------------------------------------------------------------------

MySQLParser::AlterStatementContext::AlterStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterStatementContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

MySQLParser::AlterTableContext* MySQLParser::AlterStatementContext::alterTable() {
  return getRuleContext<MySQLParser::AlterTableContext>(0);
}

MySQLParser::AlterDatabaseContext* MySQLParser::AlterStatementContext::alterDatabase() {
  return getRuleContext<MySQLParser::AlterDatabaseContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::AlterStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionRefContext* MySQLParser::AlterStatementContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

MySQLParser::AlterViewContext* MySQLParser::AlterStatementContext::alterView() {
  return getRuleContext<MySQLParser::AlterViewContext>(0);
}

MySQLParser::AlterEventContext* MySQLParser::AlterStatementContext::alterEvent() {
  return getRuleContext<MySQLParser::AlterEventContext>(0);
}

MySQLParser::AlterTablespaceContext* MySQLParser::AlterStatementContext::alterTablespace() {
  return getRuleContext<MySQLParser::AlterTablespaceContext>(0);
}

MySQLParser::AlterUndoTablespaceContext* MySQLParser::AlterStatementContext::alterUndoTablespace() {
  return getRuleContext<MySQLParser::AlterUndoTablespaceContext>(0);
}

MySQLParser::AlterLogfileGroupContext* MySQLParser::AlterStatementContext::alterLogfileGroup() {
  return getRuleContext<MySQLParser::AlterLogfileGroupContext>(0);
}

MySQLParser::AlterServerContext* MySQLParser::AlterStatementContext::alterServer() {
  return getRuleContext<MySQLParser::AlterServerContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::AlterStatementContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterStatementContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

MySQLParser::RoutineAlterOptionsContext* MySQLParser::AlterStatementContext::routineAlterOptions() {
  return getRuleContext<MySQLParser::RoutineAlterOptionsContext>(0);
}


size_t MySQLParser::AlterStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAlterStatement;
}

void MySQLParser::AlterStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterStatement(this);
}

void MySQLParser::AlterStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterStatement(this);
}

MySQLParser::AlterStatementContext* MySQLParser::alterStatement() {
  AlterStatementContext *_localctx = _tracker.createInstance<AlterStatementContext>(_ctx, getState());
  enterRule(_localctx, 8, MySQLParser::RuleAlterStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1268);
    match(MySQLParser::ALTER_SYMBOL);
    setState(1295);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 9, _ctx)) {
    case 1: {
      setState(1269);
      alterTable();
      break;
    }

    case 2: {
      setState(1270);
      alterDatabase();
      break;
    }

    case 3: {
      setState(1271);
      match(MySQLParser::PROCEDURE_SYMBOL);
      setState(1272);
      procedureRef();
      setState(1274);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (MySQLParser::COMMENT_SYMBOL - 122))
        | (1ULL << (MySQLParser::CONTAINS_SYMBOL - 122))
        | (1ULL << (MySQLParser::DETERMINISTIC_SYMBOL - 122)))) != 0) || _la == MySQLParser::LANGUAGE_SYMBOL || ((((_la - 381) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 381)) & ((1ULL << (MySQLParser::MODIFIES_SYMBOL - 381))
        | (1ULL << (MySQLParser::NOT_SYMBOL - 381))
        | (1ULL << (MySQLParser::NO_SYMBOL - 381)))) != 0) || _la == MySQLParser::READS_SYMBOL || _la == MySQLParser::SQL_SYMBOL) {
        setState(1273);
        routineAlterOptions();
      }
      break;
    }

    case 4: {
      setState(1276);
      match(MySQLParser::FUNCTION_SYMBOL);
      setState(1277);
      functionRef();
      setState(1279);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (MySQLParser::COMMENT_SYMBOL - 122))
        | (1ULL << (MySQLParser::CONTAINS_SYMBOL - 122))
        | (1ULL << (MySQLParser::DETERMINISTIC_SYMBOL - 122)))) != 0) || _la == MySQLParser::LANGUAGE_SYMBOL || ((((_la - 381) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 381)) & ((1ULL << (MySQLParser::MODIFIES_SYMBOL - 381))
        | (1ULL << (MySQLParser::NOT_SYMBOL - 381))
        | (1ULL << (MySQLParser::NO_SYMBOL - 381)))) != 0) || _la == MySQLParser::READS_SYMBOL || _la == MySQLParser::SQL_SYMBOL) {
        setState(1278);
        routineAlterOptions();
      }
      break;
    }

    case 5: {
      setState(1281);
      alterView();
      break;
    }

    case 6: {
      setState(1282);
      alterEvent();
      break;
    }

    case 7: {
      setState(1283);
      alterTablespace();
      break;
    }

    case 8: {
      setState(1284);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1285);
      alterUndoTablespace();
      break;
    }

    case 9: {
      setState(1286);
      alterLogfileGroup();
      break;
    }

    case 10: {
      setState(1287);
      alterServer();
      break;
    }

    case 11: {
      setState(1288);

      if (!(serverVersion >= 50713)) throw FailedPredicateException(this, "serverVersion >= 50713");
      setState(1289);
      match(MySQLParser::INSTANCE_SYMBOL);
      setState(1290);
      match(MySQLParser::ROTATE_SYMBOL);
      setState(1291);
      textOrIdentifier();
      setState(1292);
      match(MySQLParser::MASTER_SYMBOL);
      setState(1293);
      match(MySQLParser::KEY_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterDatabaseContext ------------------------------------------------------------------

MySQLParser::AlterDatabaseContext::AlterDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext* MySQLParser::AlterDatabaseContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterDatabaseContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

std::vector<MySQLParser::CreateDatabaseOptionContext *> MySQLParser::AlterDatabaseContext::createDatabaseOption() {
  return getRuleContexts<MySQLParser::CreateDatabaseOptionContext>();
}

MySQLParser::CreateDatabaseOptionContext* MySQLParser::AlterDatabaseContext::createDatabaseOption(size_t i) {
  return getRuleContext<MySQLParser::CreateDatabaseOptionContext>(i);
}


size_t MySQLParser::AlterDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleAlterDatabase;
}

void MySQLParser::AlterDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterDatabase(this);
}

void MySQLParser::AlterDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterDatabase(this);
}

MySQLParser::AlterDatabaseContext* MySQLParser::alterDatabase() {
  AlterDatabaseContext *_localctx = _tracker.createInstance<AlterDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 10, MySQLParser::RuleAlterDatabase);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1297);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(1298);
    schemaRef();
    setState(1309);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(1300); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(1299);
                createDatabaseOption();
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(1302); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    case 2: {
      setState(1304);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(1305);
      match(MySQLParser::UPGRADE_SYMBOL);
      setState(1306);
      match(MySQLParser::DATA_SYMBOL);
      setState(1307);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(1308);
      match(MySQLParser::NAME_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterEventContext ------------------------------------------------------------------

MySQLParser::AlterEventContext::AlterEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventRefContext* MySQLParser::AlterEventContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::AlterEventContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterEventContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterEventContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::AlterEventContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

MySQLParser::ScheduleContext* MySQLParser::AlterEventContext::schedule() {
  return getRuleContext<MySQLParser::ScheduleContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterEventContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::AlterEventContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::AlterEventContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterEventContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}


size_t MySQLParser::AlterEventContext::getRuleIndex() const {
  return MySQLParser::RuleAlterEvent;
}

void MySQLParser::AlterEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterEvent(this);
}

void MySQLParser::AlterEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterEvent(this);
}

MySQLParser::AlterEventContext* MySQLParser::alterEvent() {
  AlterEventContext *_localctx = _tracker.createInstance<AlterEventContext>(_ctx, getState());
  enterRule(_localctx, 12, MySQLParser::RuleAlterEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1312);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1311);
      definerClause();
    }
    setState(1314);
    match(MySQLParser::EVENT_SYMBOL);
    setState(1315);
    eventRef();
    setState(1319);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 13, _ctx)) {
    case 1: {
      setState(1316);
      match(MySQLParser::ON_SYMBOL);
      setState(1317);
      match(MySQLParser::SCHEDULE_SYMBOL);
      setState(1318);
      schedule();
      break;
    }

    }
    setState(1327);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(1321);
      match(MySQLParser::ON_SYMBOL);
      setState(1322);
      match(MySQLParser::COMPLETION_SYMBOL);
      setState(1324);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(1323);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(1326);
      match(MySQLParser::PRESERVE_SYMBOL);
    }
    setState(1332);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::RENAME_SYMBOL) {
      setState(1329);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1330);
      match(MySQLParser::TO_SYMBOL);
      setState(1331);
      identifier();
    }
    setState(1340);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ENABLE_SYMBOL: {
        setState(1334);
        match(MySQLParser::ENABLE_SYMBOL);
        break;
      }

      case MySQLParser::DISABLE_SYMBOL: {
        setState(1335);
        match(MySQLParser::DISABLE_SYMBOL);
        setState(1338);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(1336);
          match(MySQLParser::ON_SYMBOL);
          setState(1337);
          match(MySQLParser::SLAVE_SYMBOL);
        }
        break;
      }

      case MySQLParser::EOF:
      case MySQLParser::SEMICOLON_SYMBOL:
      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::DO_SYMBOL: {
        break;
      }

    default:
      break;
    }
    setState(1344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL) {
      setState(1342);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(1343);
      textLiteral();
    }
    setState(1348);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DO_SYMBOL) {
      setState(1346);
      match(MySQLParser::DO_SYMBOL);
      setState(1347);
      compoundStatement();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupContext::AlterLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::AlterLogfileGroupContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::AlterLogfileGroupContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::AlterLogfileGroupOptionsContext* MySQLParser::AlterLogfileGroupContext::alterLogfileGroupOptions() {
  return getRuleContext<MySQLParser::AlterLogfileGroupOptionsContext>(0);
}


size_t MySQLParser::AlterLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroup;
}

void MySQLParser::AlterLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroup(this);
}

void MySQLParser::AlterLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroup(this);
}

MySQLParser::AlterLogfileGroupContext* MySQLParser::alterLogfileGroup() {
  AlterLogfileGroupContext *_localctx = _tracker.createInstance<AlterLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 14, MySQLParser::RuleAlterLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1350);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(1351);
    match(MySQLParser::GROUP_SYMBOL);
    setState(1352);
    logfileGroupRef();
    setState(1353);
    match(MySQLParser::ADD_SYMBOL);
    setState(1354);
    match(MySQLParser::UNDOFILE_SYMBOL);
    setState(1355);
    textLiteral();
    setState(1357);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(1356);
      alterLogfileGroupOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupOptionsContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupOptionsContext::AlterLogfileGroupOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterLogfileGroupOptionContext *> MySQLParser::AlterLogfileGroupOptionsContext::alterLogfileGroupOption() {
  return getRuleContexts<MySQLParser::AlterLogfileGroupOptionContext>();
}

MySQLParser::AlterLogfileGroupOptionContext* MySQLParser::AlterLogfileGroupOptionsContext::alterLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::AlterLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterLogfileGroupOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterLogfileGroupOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterLogfileGroupOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroupOptions;
}

void MySQLParser::AlterLogfileGroupOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroupOptions(this);
}

void MySQLParser::AlterLogfileGroupOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroupOptions(this);
}

MySQLParser::AlterLogfileGroupOptionsContext* MySQLParser::alterLogfileGroupOptions() {
  AlterLogfileGroupOptionsContext *_localctx = _tracker.createInstance<AlterLogfileGroupOptionsContext>(_ctx, getState());
  enterRule(_localctx, 16, MySQLParser::RuleAlterLogfileGroupOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1359);
    alterLogfileGroupOption();
    setState(1366);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(1361);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1360);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(1363);
      alterLogfileGroupOption();
      setState(1368);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::AlterLogfileGroupOptionContext::AlterLogfileGroupOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::AlterLogfileGroupOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::AlterLogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::AlterLogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}


size_t MySQLParser::AlterLogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLogfileGroupOption;
}

void MySQLParser::AlterLogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLogfileGroupOption(this);
}

void MySQLParser::AlterLogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLogfileGroupOption(this);
}

MySQLParser::AlterLogfileGroupOptionContext* MySQLParser::alterLogfileGroupOption() {
  AlterLogfileGroupOptionContext *_localctx = _tracker.createInstance<AlterLogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 18, MySQLParser::RuleAlterLogfileGroupOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1372);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1369);
        tsOptionInitialSize();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1370);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1371);
        tsOptionWait();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterServerContext ------------------------------------------------------------------

MySQLParser::AlterServerContext::AlterServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerRefContext* MySQLParser::AlterServerContext::serverRef() {
  return getRuleContext<MySQLParser::ServerRefContext>(0);
}

MySQLParser::ServerOptionsContext* MySQLParser::AlterServerContext::serverOptions() {
  return getRuleContext<MySQLParser::ServerOptionsContext>(0);
}


size_t MySQLParser::AlterServerContext::getRuleIndex() const {
  return MySQLParser::RuleAlterServer;
}

void MySQLParser::AlterServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterServer(this);
}

void MySQLParser::AlterServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterServer(this);
}

MySQLParser::AlterServerContext* MySQLParser::alterServer() {
  AlterServerContext *_localctx = _tracker.createInstance<AlterServerContext>(_ctx, getState());
  enterRule(_localctx, 20, MySQLParser::RuleAlterServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1374);
    match(MySQLParser::SERVER_SYMBOL);
    setState(1375);
    serverRef();
    setState(1376);
    serverOptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableContext ------------------------------------------------------------------

MySQLParser::AlterTableContext::AlterTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::AlterTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::OnlineOptionContext* MySQLParser::AlterTableContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTableContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

MySQLParser::AlterTableActionsContext* MySQLParser::AlterTableContext::alterTableActions() {
  return getRuleContext<MySQLParser::AlterTableActionsContext>(0);
}


size_t MySQLParser::AlterTableContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTable;
}

void MySQLParser::AlterTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTable(this);
}

void MySQLParser::AlterTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTable(this);
}

MySQLParser::AlterTableContext* MySQLParser::alterTable() {
  AlterTableContext *_localctx = _tracker.createInstance<AlterTableContext>(_ctx, getState());
  enterRule(_localctx, 22, MySQLParser::RuleAlterTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1379);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 25, _ctx)) {
    case 1: {
      setState(1378);
      onlineOption();
      break;
    }

    }
    setState(1383);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx)) {
    case 1: {
      setState(1381);

      if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
      setState(1382);
      match(MySQLParser::IGNORE_SYMBOL);
      break;
    }

    }
    setState(1385);
    match(MySQLParser::TABLE_SYMBOL);
    setState(1386);
    tableRef();
    setState(1388);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 27, _ctx)) {
    case 1: {
      setState(1387);
      alterTableActions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTableActionsContext ------------------------------------------------------------------

MySQLParser::AlterTableActionsContext::AlterTableActionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterCommandListContext* MySQLParser::AlterTableActionsContext::alterCommandList() {
  return getRuleContext<MySQLParser::AlterCommandListContext>(0);
}

MySQLParser::PartitionClauseContext* MySQLParser::AlterTableActionsContext::partitionClause() {
  return getRuleContext<MySQLParser::PartitionClauseContext>(0);
}

MySQLParser::RemovePartitioningContext* MySQLParser::AlterTableActionsContext::removePartitioning() {
  return getRuleContext<MySQLParser::RemovePartitioningContext>(0);
}

MySQLParser::StandaloneAlterCommandsContext* MySQLParser::AlterTableActionsContext::standaloneAlterCommands() {
  return getRuleContext<MySQLParser::StandaloneAlterCommandsContext>(0);
}

MySQLParser::AlterCommandsModifierListContext* MySQLParser::AlterTableActionsContext::alterCommandsModifierList() {
  return getRuleContext<MySQLParser::AlterCommandsModifierListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTableActionsContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::AlterTableActionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTableActions;
}

void MySQLParser::AlterTableActionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTableActions(this);
}

void MySQLParser::AlterTableActionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTableActions(this);
}

MySQLParser::AlterTableActionsContext* MySQLParser::alterTableActions() {
  AlterTableActionsContext *_localctx = _tracker.createInstance<AlterTableActionsContext>(_ctx, getState());
  enterRule(_localctx, 24, MySQLParser::RuleAlterTableActions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1403);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1390);
      alterCommandList();
      setState(1393);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::PARTITION_SYMBOL: {
          setState(1391);
          partitionClause();
          break;
        }

        case MySQLParser::REMOVE_SYMBOL: {
          setState(1392);
          removePartitioning();
          break;
        }

        case MySQLParser::EOF:
        case MySQLParser::SEMICOLON_SYMBOL: {
          break;
        }

      default:
        break;
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1395);
      partitionClause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1396);
      removePartitioning();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1400);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
      case 1: {
        setState(1397);
        alterCommandsModifierList();
        setState(1398);
        match(MySQLParser::COMMA_SYMBOL);
        break;
      }

      }
      setState(1402);
      standaloneAlterCommands();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandListContext ------------------------------------------------------------------

MySQLParser::AlterCommandListContext::AlterCommandListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterCommandsModifierListContext* MySQLParser::AlterCommandListContext::alterCommandsModifierList() {
  return getRuleContext<MySQLParser::AlterCommandsModifierListContext>(0);
}

MySQLParser::AlterListContext* MySQLParser::AlterCommandListContext::alterList() {
  return getRuleContext<MySQLParser::AlterListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterCommandListContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::AlterCommandListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandList;
}

void MySQLParser::AlterCommandListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandList(this);
}

void MySQLParser::AlterCommandListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandList(this);
}

MySQLParser::AlterCommandListContext* MySQLParser::alterCommandList() {
  AlterCommandListContext *_localctx = _tracker.createInstance<AlterCommandListContext>(_ctx, getState());
  enterRule(_localctx, 26, MySQLParser::RuleAlterCommandList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1412);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1405);
      alterCommandsModifierList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1409);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx)) {
      case 1: {
        setState(1406);
        alterCommandsModifierList();
        setState(1407);
        match(MySQLParser::COMMA_SYMBOL);
        break;
      }

      }
      setState(1411);
      alterList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierListContext ------------------------------------------------------------------

MySQLParser::AlterCommandsModifierListContext::AlterCommandsModifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterCommandsModifierContext *> MySQLParser::AlterCommandsModifierListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLParser::AlterCommandsModifierContext>();
}

MySQLParser::AlterCommandsModifierContext* MySQLParser::AlterCommandsModifierListContext::alterCommandsModifier(size_t i) {
  return getRuleContext<MySQLParser::AlterCommandsModifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterCommandsModifierListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterCommandsModifierListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterCommandsModifierListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandsModifierList;
}

void MySQLParser::AlterCommandsModifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifierList(this);
}

void MySQLParser::AlterCommandsModifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifierList(this);
}

MySQLParser::AlterCommandsModifierListContext* MySQLParser::alterCommandsModifierList() {
  AlterCommandsModifierListContext *_localctx = _tracker.createInstance<AlterCommandsModifierListContext>(_ctx, getState());
  enterRule(_localctx, 28, MySQLParser::RuleAlterCommandsModifierList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1414);
    alterCommandsModifier();
    setState(1419);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1415);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1416);
        alterCommandsModifier(); 
      }
      setState(1421);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandaloneAlterCommandsContext ------------------------------------------------------------------

MySQLParser::StandaloneAlterCommandsContext::StandaloneAlterCommandsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

MySQLParser::AlterPartitionContext* MySQLParser::StandaloneAlterCommandsContext::alterPartition() {
  return getRuleContext<MySQLParser::AlterPartitionContext>(0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StandaloneAlterCommandsContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}


size_t MySQLParser::StandaloneAlterCommandsContext::getRuleIndex() const {
  return MySQLParser::RuleStandaloneAlterCommands;
}

void MySQLParser::StandaloneAlterCommandsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandaloneAlterCommands(this);
}

void MySQLParser::StandaloneAlterCommandsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandaloneAlterCommands(this);
}

MySQLParser::StandaloneAlterCommandsContext* MySQLParser::standaloneAlterCommands() {
  StandaloneAlterCommandsContext *_localctx = _tracker.createInstance<StandaloneAlterCommandsContext>(_ctx, getState());
  enterRule(_localctx, 30, MySQLParser::RuleStandaloneAlterCommands);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1429);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1422);
      match(MySQLParser::DISCARD_SYMBOL);
      setState(1423);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1424);
      match(MySQLParser::IMPORT_SYMBOL);
      setState(1425);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1426);
      alterPartition();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1427);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1428);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::SECONDARY_LOAD_SYMBOL

      || _la == MySQLParser::SECONDARY_UNLOAD_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterPartitionContext ------------------------------------------------------------------

MySQLParser::AlterPartitionContext::AlterPartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::AlterPartitionContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::AlterPartitionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

std::vector<MySQLParser::NoWriteToBinLogContext *> MySQLParser::AlterPartitionContext::noWriteToBinLog() {
  return getRuleContexts<MySQLParser::NoWriteToBinLogContext>();
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::AlterPartitionContext::noWriteToBinLog(size_t i) {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(i);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::AlterPartitionContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::AlterPartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::OPTIMIZE_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::ANALYZE_SYMBOL() {
  return getToken(MySQLParser::ANALYZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

std::vector<MySQLParser::CheckOptionContext *> MySQLParser::AlterPartitionContext::checkOption() {
  return getRuleContexts<MySQLParser::CheckOptionContext>();
}

MySQLParser::CheckOptionContext* MySQLParser::AlterPartitionContext::checkOption(size_t i) {
  return getRuleContext<MySQLParser::CheckOptionContext>(i);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

std::vector<MySQLParser::RepairTypeContext *> MySQLParser::AlterPartitionContext::repairType() {
  return getRuleContexts<MySQLParser::RepairTypeContext>();
}

MySQLParser::RepairTypeContext* MySQLParser::AlterPartitionContext::repairType(size_t i) {
  return getRuleContext<MySQLParser::RepairTypeContext>(i);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

MySQLParser::ReorgPartitionRuleContext* MySQLParser::AlterPartitionContext::reorgPartitionRule() {
  return getRuleContext<MySQLParser::ReorgPartitionRuleContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::EXCHANGE_SYMBOL() {
  return getToken(MySQLParser::EXCHANGE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterPartitionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::AlterPartitionContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::WithValidationContext* MySQLParser::AlterPartitionContext::withValidation() {
  return getRuleContext<MySQLParser::WithValidationContext>(0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterPartitionContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}


size_t MySQLParser::AlterPartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterPartition;
}

void MySQLParser::AlterPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterPartition(this);
}

void MySQLParser::AlterPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterPartition(this);
}

MySQLParser::AlterPartitionContext* MySQLParser::alterPartition() {
  AlterPartitionContext *_localctx = _tracker.createInstance<AlterPartitionContext>(_ctx, getState());
  enterRule(_localctx, 32, MySQLParser::RuleAlterPartition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1528);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 48, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1431);
      match(MySQLParser::ADD_SYMBOL);
      setState(1432);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1434);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
        setState(1433);
        noWriteToBinLog();
      }
      setState(1439);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::OPEN_PAR_SYMBOL: {
          setState(1436);
          partitionDefinitions();
          break;
        }

        case MySQLParser::PARTITIONS_SYMBOL: {
          setState(1437);
          match(MySQLParser::PARTITIONS_SYMBOL);
          setState(1438);
          real_ulong_number();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1441);
      match(MySQLParser::DROP_SYMBOL);
      setState(1442);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1443);
      identifierList();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1444);
      match(MySQLParser::REBUILD_SYMBOL);
      setState(1445);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1447);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 37, _ctx)) {
      case 1: {
        setState(1446);
        noWriteToBinLog();
        break;
      }

      }
      setState(1449);
      allOrPartitionNameList();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1450);
      match(MySQLParser::OPTIMIZE_SYMBOL);
      setState(1451);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1453);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
      case 1: {
        setState(1452);
        noWriteToBinLog();
        break;
      }

      }
      setState(1455);
      allOrPartitionNameList();
      setState(1457);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
        setState(1456);
        noWriteToBinLog();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1459);
      match(MySQLParser::ANALYZE_SYMBOL);
      setState(1460);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1462);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 40, _ctx)) {
      case 1: {
        setState(1461);
        noWriteToBinLog();
        break;
      }

      }
      setState(1464);
      allOrPartitionNameList();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1465);
      match(MySQLParser::CHECK_SYMBOL);
      setState(1466);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1467);
      allOrPartitionNameList();
      setState(1471);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::CHANGED_SYMBOL || ((((_la - 222) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 222)) & ((1ULL << (MySQLParser::EXTENDED_SYMBOL - 222))
        | (1ULL << (MySQLParser::FAST_SYMBOL - 222))
        | (1ULL << (MySQLParser::FOR_SYMBOL - 222)))) != 0) || _la == MySQLParser::MEDIUM_SYMBOL || _la == MySQLParser::QUICK_SYMBOL) {
        setState(1468);
        checkOption();
        setState(1473);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1474);
      match(MySQLParser::REPAIR_SYMBOL);
      setState(1475);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1477);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx)) {
      case 1: {
        setState(1476);
        noWriteToBinLog();
        break;
      }

      }
      setState(1479);
      allOrPartitionNameList();
      setState(1483);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::USE_FRM_SYMBOL) {
        setState(1480);
        repairType();
        setState(1485);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1486);
      match(MySQLParser::COALESCE_SYMBOL);
      setState(1487);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1489);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
        setState(1488);
        noWriteToBinLog();
      }
      setState(1491);
      real_ulong_number();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1492);
      match(MySQLParser::TRUNCATE_SYMBOL);
      setState(1493);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1494);
      allOrPartitionNameList();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1495);
      reorgPartitionRule();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1496);
      match(MySQLParser::REORGANIZE_SYMBOL);
      setState(1497);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1499);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 45, _ctx)) {
      case 1: {
        setState(1498);
        noWriteToBinLog();
        break;
      }

      }
      setState(1505);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 46, _ctx)) {
      case 1: {
        setState(1501);
        identifierList();
        setState(1502);
        match(MySQLParser::INTO_SYMBOL);
        setState(1503);
        partitionDefinitions();
        break;
      }

      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1507);
      match(MySQLParser::EXCHANGE_SYMBOL);
      setState(1508);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1509);
      identifier();
      setState(1510);
      match(MySQLParser::WITH_SYMBOL);
      setState(1511);
      match(MySQLParser::TABLE_SYMBOL);
      setState(1512);
      tableRef();
      setState(1514);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 47, _ctx)) {
      case 1: {
        setState(1513);
        withValidation();
        break;
      }

      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1516);

      if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
      setState(1517);
      match(MySQLParser::DISCARD_SYMBOL);
      setState(1518);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1519);
      allOrPartitionNameList();
      setState(1520);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1522);

      if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
      setState(1523);
      match(MySQLParser::IMPORT_SYMBOL);
      setState(1524);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(1525);
      allOrPartitionNameList();
      setState(1526);
      match(MySQLParser::TABLESPACE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListContext ------------------------------------------------------------------

MySQLParser::AlterListContext::AlterListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterListItemContext *> MySQLParser::AlterListContext::alterListItem() {
  return getRuleContexts<MySQLParser::AlterListItemContext>();
}

MySQLParser::AlterListItemContext* MySQLParser::AlterListContext::alterListItem(size_t i) {
  return getRuleContext<MySQLParser::AlterListItemContext>(i);
}

std::vector<MySQLParser::CreateTableOptionsSpaceSeparatedContext *> MySQLParser::AlterListContext::createTableOptionsSpaceSeparated() {
  return getRuleContexts<MySQLParser::CreateTableOptionsSpaceSeparatedContext>();
}

MySQLParser::CreateTableOptionsSpaceSeparatedContext* MySQLParser::AlterListContext::createTableOptionsSpaceSeparated(size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionsSpaceSeparatedContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

std::vector<MySQLParser::AlterCommandsModifierContext *> MySQLParser::AlterListContext::alterCommandsModifier() {
  return getRuleContexts<MySQLParser::AlterCommandsModifierContext>();
}

MySQLParser::AlterCommandsModifierContext* MySQLParser::AlterListContext::alterCommandsModifier(size_t i) {
  return getRuleContext<MySQLParser::AlterCommandsModifierContext>(i);
}


size_t MySQLParser::AlterListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterList;
}

void MySQLParser::AlterListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterList(this);
}

void MySQLParser::AlterListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterList(this);
}

MySQLParser::AlterListContext* MySQLParser::alterList() {
  AlterListContext *_localctx = _tracker.createInstance<AlterListContext>(_ctx, getState());
  enterRule(_localctx, 34, MySQLParser::RuleAlterList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1532);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx)) {
    case 1: {
      setState(1530);
      alterListItem();
      break;
    }

    case 2: {
      setState(1531);
      createTableOptionsSpaceSeparated();
      break;
    }

    }
    setState(1542);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(1534);
      match(MySQLParser::COMMA_SYMBOL);
      setState(1538);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 50, _ctx)) {
      case 1: {
        setState(1535);
        alterListItem();
        break;
      }

      case 2: {
        setState(1536);
        alterCommandsModifier();
        break;
      }

      case 3: {
        setState(1537);
        createTableOptionsSpaceSeparated();
        break;
      }

      }
      setState(1544);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterCommandsModifierContext ------------------------------------------------------------------

MySQLParser::AlterCommandsModifierContext::AlterCommandsModifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterAlgorithmOptionContext* MySQLParser::AlterCommandsModifierContext::alterAlgorithmOption() {
  return getRuleContext<MySQLParser::AlterAlgorithmOptionContext>(0);
}

MySQLParser::AlterLockOptionContext* MySQLParser::AlterCommandsModifierContext::alterLockOption() {
  return getRuleContext<MySQLParser::AlterLockOptionContext>(0);
}

MySQLParser::WithValidationContext* MySQLParser::AlterCommandsModifierContext::withValidation() {
  return getRuleContext<MySQLParser::WithValidationContext>(0);
}


size_t MySQLParser::AlterCommandsModifierContext::getRuleIndex() const {
  return MySQLParser::RuleAlterCommandsModifier;
}

void MySQLParser::AlterCommandsModifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterCommandsModifier(this);
}

void MySQLParser::AlterCommandsModifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterCommandsModifier(this);
}

MySQLParser::AlterCommandsModifierContext* MySQLParser::alterCommandsModifier() {
  AlterCommandsModifierContext *_localctx = _tracker.createInstance<AlterCommandsModifierContext>(_ctx, getState());
  enterRule(_localctx, 36, MySQLParser::RuleAlterCommandsModifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1550);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1545);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(1546);
      alterAlgorithmOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1547);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(1548);
      alterLockOption();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1549);
      withValidation();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterListItemContext ------------------------------------------------------------------

MySQLParser::AlterListItemContext::AlterListItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterListItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldDefinitionContext* MySQLParser::AlterListItemContext::fieldDefinition() {
  return getRuleContext<MySQLParser::FieldDefinitionContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TableElementListContext* MySQLParser::AlterListItemContext::tableElementList() {
  return getRuleContext<MySQLParser::TableElementListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::COLUMN_SYMBOL() {
  return getToken(MySQLParser::COLUMN_SYMBOL, 0);
}

MySQLParser::CheckOrReferencesContext* MySQLParser::AlterListItemContext::checkOrReferences() {
  return getRuleContext<MySQLParser::CheckOrReferencesContext>(0);
}

MySQLParser::PlaceContext* MySQLParser::AlterListItemContext::place() {
  return getRuleContext<MySQLParser::PlaceContext>(0);
}

MySQLParser::TableConstraintDefContext* MySQLParser::AlterListItemContext::tableConstraintDef() {
  return getRuleContext<MySQLParser::TableConstraintDefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

MySQLParser::ColumnInternalRefContext* MySQLParser::AlterListItemContext::columnInternalRef() {
  return getRuleContext<MySQLParser::ColumnInternalRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::AlterListItemContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

MySQLParser::IndexRefContext* MySQLParser::AlterListItemContext::indexRef() {
  return getRuleContext<MySQLParser::IndexRefContext>(0);
}

MySQLParser::RestrictContext* MySQLParser::AlterListItemContext::restrict() {
  return getRuleContext<MySQLParser::RestrictContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::KEYS_SYMBOL() {
  return getToken(MySQLParser::KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::AlterListItemContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::SignedLiteralContext* MySQLParser::AlterListItemContext::signedLiteral() {
  return getRuleContext<MySQLParser::SignedLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::VisibilityContext* MySQLParser::AlterListItemContext::visibility() {
  return getRuleContext<MySQLParser::VisibilityContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

MySQLParser::ConstraintEnforcementContext* MySQLParser::AlterListItemContext::constraintEnforcement() {
  return getRuleContext<MySQLParser::ConstraintEnforcementContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TableNameContext* MySQLParser::AlterListItemContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::IndexNameContext* MySQLParser::AlterListItemContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

MySQLParser::CharsetContext* MySQLParser::AlterListItemContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::AlterListItemContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

MySQLParser::CollateContext* MySQLParser::AlterListItemContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::AlterOrderListContext* MySQLParser::AlterListItemContext::alterOrderList() {
  return getRuleContext<MySQLParser::AlterOrderListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterListItemContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}


size_t MySQLParser::AlterListItemContext::getRuleIndex() const {
  return MySQLParser::RuleAlterListItem;
}

void MySQLParser::AlterListItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterListItem(this);
}

void MySQLParser::AlterListItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterListItem(this);
}

MySQLParser::AlterListItemContext* MySQLParser::alterListItem() {
  AlterListItemContext *_localctx = _tracker.createInstance<AlterListItemContext>(_ctx, getState());
  enterRule(_localctx, 38, MySQLParser::RuleAlterListItem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1685);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 72, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1552);
      match(MySQLParser::ADD_SYMBOL);
      setState(1554);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 53, _ctx)) {
      case 1: {
        setState(1553);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1568);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 56, _ctx)) {
      case 1: {
        setState(1556);
        identifier();
        setState(1557);
        fieldDefinition();
        setState(1559);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 54, _ctx)) {
        case 1: {
          setState(1558);
          checkOrReferences();
          break;
        }

        }
        setState(1562);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
          setState(1561);
          place();
        }
        break;
      }

      case 2: {
        setState(1564);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(1565);
        tableElementList();
        setState(1566);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1570);
      match(MySQLParser::ADD_SYMBOL);
      setState(1571);
      tableConstraintDef();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1572);
      match(MySQLParser::CHANGE_SYMBOL);
      setState(1574);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 57, _ctx)) {
      case 1: {
        setState(1573);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1576);
      columnInternalRef();
      setState(1577);
      identifier();
      setState(1578);
      fieldDefinition();
      setState(1580);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
        setState(1579);
        place();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(1582);
      match(MySQLParser::MODIFY_SYMBOL);
      setState(1584);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 59, _ctx)) {
      case 1: {
        setState(1583);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1586);
      columnInternalRef();
      setState(1587);
      fieldDefinition();
      setState(1589);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::AFTER_SYMBOL || _la == MySQLParser::FIRST_SYMBOL) {
        setState(1588);
        place();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(1591);
      match(MySQLParser::DROP_SYMBOL);
      setState(1614);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 65, _ctx)) {
      case 1: {
        setState(1593);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 61, _ctx)) {
        case 1: {
          setState(1592);
          match(MySQLParser::COLUMN_SYMBOL);
          break;
        }

        }
        setState(1595);
        columnInternalRef();
        setState(1597);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
          setState(1596);
          restrict();
        }
        break;
      }

      case 2: {
        setState(1599);
        match(MySQLParser::FOREIGN_SYMBOL);
        setState(1600);
        match(MySQLParser::KEY_SYMBOL);
        setState(1607);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 64, _ctx)) {
        case 1: {
          setState(1601);

          if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
          setState(1602);
          columnInternalRef();
          break;
        }

        case 2: {
          setState(1603);

          if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
          setState(1605);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 63, _ctx)) {
          case 1: {
            setState(1604);
            columnInternalRef();
            break;
          }

          }
          break;
        }

        }
        break;
      }

      case 3: {
        setState(1609);
        match(MySQLParser::PRIMARY_SYMBOL);
        setState(1610);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      case 4: {
        setState(1611);
        keyOrIndex();
        setState(1612);
        indexRef();
        break;
      }

      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(1616);
      match(MySQLParser::DISABLE_SYMBOL);
      setState(1617);
      match(MySQLParser::KEYS_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(1618);
      match(MySQLParser::ENABLE_SYMBOL);
      setState(1619);
      match(MySQLParser::KEYS_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(1620);
      match(MySQLParser::ALTER_SYMBOL);
      setState(1622);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 66, _ctx)) {
      case 1: {
        setState(1621);
        match(MySQLParser::COLUMN_SYMBOL);
        break;
      }

      }
      setState(1624);
      columnInternalRef();
      setState(1634);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::SET_SYMBOL: {
          setState(1625);
          match(MySQLParser::SET_SYMBOL);
          setState(1626);
          match(MySQLParser::DEFAULT_SYMBOL);
          setState(1630);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 67, _ctx)) {
          case 1: {
            setState(1627);

            if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
            setState(1628);
            exprWithParentheses();
            break;
          }

          case 2: {
            setState(1629);
            signedLiteral();
            break;
          }

          }
          break;
        }

        case MySQLParser::DROP_SYMBOL: {
          setState(1632);
          match(MySQLParser::DROP_SYMBOL);
          setState(1633);
          match(MySQLParser::DEFAULT_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(1636);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1637);
      match(MySQLParser::ALTER_SYMBOL);
      setState(1638);
      match(MySQLParser::INDEX_SYMBOL);
      setState(1639);
      indexRef();
      setState(1640);
      visibility();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(1642);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(1643);
      match(MySQLParser::ALTER_SYMBOL);
      setState(1644);
      match(MySQLParser::CHECK_SYMBOL);
      setState(1645);
      identifier();
      setState(1646);
      constraintEnforcement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(1648);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1649);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1650);
      match(MySQLParser::COLUMN_SYMBOL);
      setState(1651);
      columnInternalRef();
      setState(1652);
      match(MySQLParser::TO_SYMBOL);
      setState(1653);
      identifier();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(1655);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1657);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 69, _ctx)) {
      case 1: {
        setState(1656);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::AS_SYMBOL || _la == MySQLParser::TO_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(1659);
      tableName();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(1660);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(1661);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1662);
      keyOrIndex();
      setState(1663);
      indexRef();
      setState(1664);
      match(MySQLParser::TO_SYMBOL);
      setState(1665);
      indexName();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(1667);
      match(MySQLParser::CONVERT_SYMBOL);
      setState(1668);
      match(MySQLParser::TO_SYMBOL);
      setState(1669);
      charset();
      setState(1673);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 70, _ctx)) {
      case 1: {
        setState(1670);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(1671);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      case 2: {
        setState(1672);
        charsetName();
        break;
      }

      }
      setState(1676);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COLLATE_SYMBOL) {
        setState(1675);
        collate();
      }
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(1678);
      match(MySQLParser::FORCE_SYMBOL);
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(1679);
      match(MySQLParser::ORDER_SYMBOL);
      setState(1680);
      match(MySQLParser::BY_SYMBOL);
      setState(1681);
      alterOrderList();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(1682);

      if (!(serverVersion >= 50708 && serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion >= 50708 && serverVersion < 80000");
      setState(1683);
      match(MySQLParser::UPGRADE_SYMBOL);
      setState(1684);
      match(MySQLParser::PARTITIONING_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PlaceContext ------------------------------------------------------------------

MySQLParser::PlaceContext::PlaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PlaceContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::PlaceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PlaceContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}


size_t MySQLParser::PlaceContext::getRuleIndex() const {
  return MySQLParser::RulePlace;
}

void MySQLParser::PlaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPlace(this);
}

void MySQLParser::PlaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPlace(this);
}

MySQLParser::PlaceContext* MySQLParser::place() {
  PlaceContext *_localctx = _tracker.createInstance<PlaceContext>(_ctx, getState());
  enterRule(_localctx, 40, MySQLParser::RulePlace);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1690);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AFTER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1687);
        match(MySQLParser::AFTER_SYMBOL);
        setState(1688);
        identifier();
        break;
      }

      case MySQLParser::FIRST_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1689);
        match(MySQLParser::FIRST_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestrictContext ------------------------------------------------------------------

MySQLParser::RestrictContext::RestrictContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RestrictContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RestrictContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}


size_t MySQLParser::RestrictContext::getRuleIndex() const {
  return MySQLParser::RuleRestrict;
}

void MySQLParser::RestrictContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestrict(this);
}

void MySQLParser::RestrictContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestrict(this);
}

MySQLParser::RestrictContext* MySQLParser::restrict() {
  RestrictContext *_localctx = _tracker.createInstance<RestrictContext>(_ctx, getState());
  enterRule(_localctx, 42, MySQLParser::RuleRestrict);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1692);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterOrderListContext ------------------------------------------------------------------

MySQLParser::AlterOrderListContext::AlterOrderListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::AlterOrderListContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext* MySQLParser::AlterOrderListContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<MySQLParser::DirectionContext *> MySQLParser::AlterOrderListContext::direction() {
  return getRuleContexts<MySQLParser::DirectionContext>();
}

MySQLParser::DirectionContext* MySQLParser::AlterOrderListContext::direction(size_t i) {
  return getRuleContext<MySQLParser::DirectionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterOrderListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterOrderListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterOrderListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterOrderList;
}

void MySQLParser::AlterOrderListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterOrderList(this);
}

void MySQLParser::AlterOrderListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterOrderList(this);
}

MySQLParser::AlterOrderListContext* MySQLParser::alterOrderList() {
  AlterOrderListContext *_localctx = _tracker.createInstance<AlterOrderListContext>(_ctx, getState());
  enterRule(_localctx, 44, MySQLParser::RuleAlterOrderList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1694);
    identifier();
    setState(1696);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
      setState(1695);
      direction();
    }
    setState(1705);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1698);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1699);
        identifier();
        setState(1701);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
          setState(1700);
          direction();
        } 
      }
      setState(1707);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 76, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterAlgorithmOptionContext ------------------------------------------------------------------

MySQLParser::AlterAlgorithmOptionContext::AlterAlgorithmOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterAlgorithmOptionContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterAlgorithmOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterAlgorithmOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterAlgorithmOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::AlterAlgorithmOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterAlgorithmOption;
}

void MySQLParser::AlterAlgorithmOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterAlgorithmOption(this);
}

void MySQLParser::AlterAlgorithmOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterAlgorithmOption(this);
}

MySQLParser::AlterAlgorithmOptionContext* MySQLParser::alterAlgorithmOption() {
  AlterAlgorithmOptionContext *_localctx = _tracker.createInstance<AlterAlgorithmOptionContext>(_ctx, getState());
  enterRule(_localctx, 46, MySQLParser::RuleAlterAlgorithmOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1708);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(1710);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 77, _ctx)) {
    case 1: {
      setState(1709);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(1714);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 78, _ctx)) {
    case 1: {
      setState(1712);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    case 2: {
      setState(1713);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterLockOptionContext ------------------------------------------------------------------

MySQLParser::AlterLockOptionContext::AlterLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterLockOptionContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterLockOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterLockOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::AlterLockOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::AlterLockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterLockOption;
}

void MySQLParser::AlterLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterLockOption(this);
}

void MySQLParser::AlterLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterLockOption(this);
}

MySQLParser::AlterLockOptionContext* MySQLParser::alterLockOption() {
  AlterLockOptionContext *_localctx = _tracker.createInstance<AlterLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 48, MySQLParser::RuleAlterLockOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1716);
    match(MySQLParser::LOCK_SYMBOL);
    setState(1718);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 79, _ctx)) {
    case 1: {
      setState(1717);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(1722);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 80, _ctx)) {
    case 1: {
      setState(1720);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    case 2: {
      setState(1721);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexLockAndAlgorithmContext ------------------------------------------------------------------

MySQLParser::IndexLockAndAlgorithmContext::IndexLockAndAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterAlgorithmOptionContext* MySQLParser::IndexLockAndAlgorithmContext::alterAlgorithmOption() {
  return getRuleContext<MySQLParser::AlterAlgorithmOptionContext>(0);
}

MySQLParser::AlterLockOptionContext* MySQLParser::IndexLockAndAlgorithmContext::alterLockOption() {
  return getRuleContext<MySQLParser::AlterLockOptionContext>(0);
}


size_t MySQLParser::IndexLockAndAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleIndexLockAndAlgorithm;
}

void MySQLParser::IndexLockAndAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexLockAndAlgorithm(this);
}

void MySQLParser::IndexLockAndAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexLockAndAlgorithm(this);
}

MySQLParser::IndexLockAndAlgorithmContext* MySQLParser::indexLockAndAlgorithm() {
  IndexLockAndAlgorithmContext *_localctx = _tracker.createInstance<IndexLockAndAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 50, MySQLParser::RuleIndexLockAndAlgorithm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1724);

    if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
    setState(1733);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ALGORITHM_SYMBOL: {
        setState(1725);
        alterAlgorithmOption();
        setState(1727);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCK_SYMBOL) {
          setState(1726);
          alterLockOption();
        }
        break;
      }

      case MySQLParser::LOCK_SYMBOL: {
        setState(1729);
        alterLockOption();
        setState(1731);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(1730);
          alterAlgorithmOption();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithValidationContext ------------------------------------------------------------------

MySQLParser::WithValidationContext::WithValidationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WithValidationContext::VALIDATION_SYMBOL() {
  return getToken(MySQLParser::VALIDATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WithValidationContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WithValidationContext::WITHOUT_SYMBOL() {
  return getToken(MySQLParser::WITHOUT_SYMBOL, 0);
}


size_t MySQLParser::WithValidationContext::getRuleIndex() const {
  return MySQLParser::RuleWithValidation;
}

void MySQLParser::WithValidationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithValidation(this);
}

void MySQLParser::WithValidationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithValidation(this);
}

MySQLParser::WithValidationContext* MySQLParser::withValidation() {
  WithValidationContext *_localctx = _tracker.createInstance<WithValidationContext>(_ctx, getState());
  enterRule(_localctx, 52, MySQLParser::RuleWithValidation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1735);

    if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
    setState(1736);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::WITH_SYMBOL

    || _la == MySQLParser::WITHOUT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1737);
    match(MySQLParser::VALIDATION_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RemovePartitioningContext ------------------------------------------------------------------

MySQLParser::RemovePartitioningContext::RemovePartitioningContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RemovePartitioningContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RemovePartitioningContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}


size_t MySQLParser::RemovePartitioningContext::getRuleIndex() const {
  return MySQLParser::RuleRemovePartitioning;
}

void MySQLParser::RemovePartitioningContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRemovePartitioning(this);
}

void MySQLParser::RemovePartitioningContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRemovePartitioning(this);
}

MySQLParser::RemovePartitioningContext* MySQLParser::removePartitioning() {
  RemovePartitioningContext *_localctx = _tracker.createInstance<RemovePartitioningContext>(_ctx, getState());
  enterRule(_localctx, 54, MySQLParser::RuleRemovePartitioning);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1739);
    match(MySQLParser::REMOVE_SYMBOL);
    setState(1740);
    match(MySQLParser::PARTITIONING_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AllOrPartitionNameListContext ------------------------------------------------------------------

MySQLParser::AllOrPartitionNameListContext::AllOrPartitionNameListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AllOrPartitionNameListContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::AllOrPartitionNameListContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}


size_t MySQLParser::AllOrPartitionNameListContext::getRuleIndex() const {
  return MySQLParser::RuleAllOrPartitionNameList;
}

void MySQLParser::AllOrPartitionNameListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAllOrPartitionNameList(this);
}

void MySQLParser::AllOrPartitionNameListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAllOrPartitionNameList(this);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::allOrPartitionNameList() {
  AllOrPartitionNameListContext *_localctx = _tracker.createInstance<AllOrPartitionNameListContext>(_ctx, getState());
  enterRule(_localctx, 56, MySQLParser::RuleAllOrPartitionNameList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1744);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 84, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1742);
      match(MySQLParser::ALL_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1743);
      identifierList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReorgPartitionRuleContext ------------------------------------------------------------------

MySQLParser::ReorgPartitionRuleContext::ReorgPartitionRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReorgPartitionRuleContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReorgPartitionRuleContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::ReorgPartitionRuleContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

MySQLParser::IdentifierListContext* MySQLParser::ReorgPartitionRuleContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::ReorgPartitionRuleContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::ReorgPartitionRuleContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}


size_t MySQLParser::ReorgPartitionRuleContext::getRuleIndex() const {
  return MySQLParser::RuleReorgPartitionRule;
}

void MySQLParser::ReorgPartitionRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReorgPartitionRule(this);
}

void MySQLParser::ReorgPartitionRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReorgPartitionRule(this);
}

MySQLParser::ReorgPartitionRuleContext* MySQLParser::reorgPartitionRule() {
  ReorgPartitionRuleContext *_localctx = _tracker.createInstance<ReorgPartitionRuleContext>(_ctx, getState());
  enterRule(_localctx, 58, MySQLParser::RuleReorgPartitionRule);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1746);
    match(MySQLParser::REORGANIZE_SYMBOL);
    setState(1747);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(1749);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 85, _ctx)) {
    case 1: {
      setState(1748);
      noWriteToBinLog();
      break;
    }

    }
    setState(1755);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx)) {
    case 1: {
      setState(1751);
      identifierList();
      setState(1752);
      match(MySQLParser::INTO_SYMBOL);
      setState(1753);
      partitionDefinitions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceContext::AlterTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::AlterTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::AlterTablespaceContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::AlterTablespaceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::AlterTablespaceOptionsContext* MySQLParser::AlterTablespaceContext::alterTablespaceOptions() {
  return getRuleContext<MySQLParser::AlterTablespaceOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::ACCESSIBLE_SYMBOL() {
  return getToken(MySQLParser::ACCESSIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::READ_ONLY_SYMBOL() {
  return getToken(MySQLParser::READ_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::READ_WRITE_SYMBOL() {
  return getToken(MySQLParser::READ_WRITE_SYMBOL, 0);
}

std::vector<MySQLParser::ChangeTablespaceOptionContext *> MySQLParser::AlterTablespaceContext::changeTablespaceOption() {
  return getRuleContexts<MySQLParser::ChangeTablespaceOptionContext>();
}

MySQLParser::ChangeTablespaceOptionContext* MySQLParser::AlterTablespaceContext::changeTablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::ChangeTablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterTablespaceContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterTablespaceContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespace;
}

void MySQLParser::AlterTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespace(this);
}

void MySQLParser::AlterTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespace(this);
}

MySQLParser::AlterTablespaceContext* MySQLParser::alterTablespace() {
  AlterTablespaceContext *_localctx = _tracker.createInstance<AlterTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 60, MySQLParser::RuleAlterTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1757);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(1758);
    tablespaceRef();
    setState(1792);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx)) {
    case 1: {
      setState(1759);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ADD_SYMBOL || _la == MySQLParser::DROP_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(1760);
      match(MySQLParser::DATAFILE_SYMBOL);
      setState(1761);
      textLiteral();
      setState(1763);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::AUTOEXTEND_SIZE_SYMBOL || _la == MySQLParser::ENCRYPTION_SYMBOL

      || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::MAX_SIZE_SYMBOL

      || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
        setState(1762);
        alterTablespaceOptions();
      }
      break;
    }

    case 2: {
      setState(1765);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(1785);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::EOF:
        case MySQLParser::SEMICOLON_SYMBOL: {
          break;
        }

        case MySQLParser::CHANGE_SYMBOL: {
          setState(1767);
          match(MySQLParser::CHANGE_SYMBOL);
          setState(1768);
          match(MySQLParser::DATAFILE_SYMBOL);
          setState(1769);
          textLiteral();
          setState(1780);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::AUTOEXTEND_SIZE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::MAX_SIZE_SYMBOL) {
            setState(1770);
            changeTablespaceOption();
            setState(1777);
            _errHandler->sync(this);
            _la = _input->LA(1);
            while (_la == MySQLParser::COMMA_SYMBOL

            || _la == MySQLParser::AUTOEXTEND_SIZE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::MAX_SIZE_SYMBOL) {
              setState(1772);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::COMMA_SYMBOL) {
                setState(1771);
                match(MySQLParser::COMMA_SYMBOL);
              }
              setState(1774);
              changeTablespaceOption();
              setState(1779);
              _errHandler->sync(this);
              _la = _input->LA(1);
            }
          }
          break;
        }

        case MySQLParser::READ_ONLY_SYMBOL:
        case MySQLParser::READ_WRITE_SYMBOL: {
          setState(1782);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::READ_ONLY_SYMBOL

          || _la == MySQLParser::READ_WRITE_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case MySQLParser::NOT_SYMBOL: {
          setState(1783);
          match(MySQLParser::NOT_SYMBOL);
          setState(1784);
          match(MySQLParser::ACCESSIBLE_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 3: {
      setState(1787);
      match(MySQLParser::RENAME_SYMBOL);
      setState(1788);
      match(MySQLParser::TO_SYMBOL);
      setState(1789);
      identifier();
      break;
    }

    case 4: {
      setState(1790);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1791);
      alterTablespaceOptions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::AlterUndoTablespaceContext::AlterUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::AlterUndoTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUndoTablespaceContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::AlterUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}


size_t MySQLParser::AlterUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUndoTablespace;
}

void MySQLParser::AlterUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUndoTablespace(this);
}

void MySQLParser::AlterUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUndoTablespace(this);
}

MySQLParser::AlterUndoTablespaceContext* MySQLParser::alterUndoTablespace() {
  AlterUndoTablespaceContext *_localctx = _tracker.createInstance<AlterUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 62, MySQLParser::RuleAlterUndoTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1794);
    match(MySQLParser::UNDO_SYMBOL);
    setState(1795);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(1796);
    tablespaceRef();
    setState(1797);
    match(MySQLParser::SET_SYMBOL);
    setState(1798);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ACTIVE_SYMBOL

    || _la == MySQLParser::INACTIVE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(1800);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(1799);
      undoTableSpaceOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UndoTableSpaceOptionsContext ------------------------------------------------------------------

MySQLParser::UndoTableSpaceOptionsContext::UndoTableSpaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UndoTableSpaceOptionContext *> MySQLParser::UndoTableSpaceOptionsContext::undoTableSpaceOption() {
  return getRuleContexts<MySQLParser::UndoTableSpaceOptionContext>();
}

MySQLParser::UndoTableSpaceOptionContext* MySQLParser::UndoTableSpaceOptionsContext::undoTableSpaceOption(size_t i) {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UndoTableSpaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UndoTableSpaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UndoTableSpaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleUndoTableSpaceOptions;
}

void MySQLParser::UndoTableSpaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUndoTableSpaceOptions(this);
}

void MySQLParser::UndoTableSpaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUndoTableSpaceOptions(this);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::undoTableSpaceOptions() {
  UndoTableSpaceOptionsContext *_localctx = _tracker.createInstance<UndoTableSpaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 64, MySQLParser::RuleUndoTableSpaceOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1802);
    undoTableSpaceOption();
    setState(1809);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(1804);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1803);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(1806);
      undoTableSpaceOption();
      setState(1811);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UndoTableSpaceOptionContext ------------------------------------------------------------------

MySQLParser::UndoTableSpaceOptionContext::UndoTableSpaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionEngineContext* MySQLParser::UndoTableSpaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}


size_t MySQLParser::UndoTableSpaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleUndoTableSpaceOption;
}

void MySQLParser::UndoTableSpaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUndoTableSpaceOption(this);
}

void MySQLParser::UndoTableSpaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUndoTableSpaceOption(this);
}

MySQLParser::UndoTableSpaceOptionContext* MySQLParser::undoTableSpaceOption() {
  UndoTableSpaceOptionContext *_localctx = _tracker.createInstance<UndoTableSpaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 66, MySQLParser::RuleUndoTableSpaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1812);
    tsOptionEngine();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceOptionsContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceOptionsContext::AlterTablespaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterTablespaceOptionContext *> MySQLParser::AlterTablespaceOptionsContext::alterTablespaceOption() {
  return getRuleContexts<MySQLParser::AlterTablespaceOptionContext>();
}

MySQLParser::AlterTablespaceOptionContext* MySQLParser::AlterTablespaceOptionsContext::alterTablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::AlterTablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterTablespaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterTablespaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterTablespaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespaceOptions;
}

void MySQLParser::AlterTablespaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceOptions(this);
}

void MySQLParser::AlterTablespaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceOptions(this);
}

MySQLParser::AlterTablespaceOptionsContext* MySQLParser::alterTablespaceOptions() {
  AlterTablespaceOptionsContext *_localctx = _tracker.createInstance<AlterTablespaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 68, MySQLParser::RuleAlterTablespaceOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1814);
    alterTablespaceOption();
    setState(1821);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL

    || _la == MySQLParser::AUTOEXTEND_SIZE_SYMBOL || _la == MySQLParser::ENCRYPTION_SYMBOL

    || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::MAX_SIZE_SYMBOL

    || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(1816);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1815);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(1818);
      alterTablespaceOption();
      setState(1823);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterTablespaceOptionContext ------------------------------------------------------------------

MySQLParser::AlterTablespaceOptionContext::AlterTablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterTablespaceOptionContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::AlterTablespaceOptionContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::AlterTablespaceOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::AlterTablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::AlterTablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::AlterTablespaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::AlterTablespaceOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionEncryptionContext* MySQLParser::AlterTablespaceOptionContext::tsOptionEncryption() {
  return getRuleContext<MySQLParser::TsOptionEncryptionContext>(0);
}


size_t MySQLParser::AlterTablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleAlterTablespaceOption;
}

void MySQLParser::AlterTablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterTablespaceOption(this);
}

void MySQLParser::AlterTablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterTablespaceOption(this);
}

MySQLParser::AlterTablespaceOptionContext* MySQLParser::alterTablespaceOption() {
  AlterTablespaceOptionContext *_localctx = _tracker.createInstance<AlterTablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 70, MySQLParser::RuleAlterTablespaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1834);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1824);
        match(MySQLParser::INITIAL_SIZE_SYMBOL);
        setState(1826);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 98, _ctx)) {
        case 1: {
          setState(1825);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(1828);
        sizeNumber();
        break;
      }

      case MySQLParser::AUTOEXTEND_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1829);
        tsOptionAutoextendSize();
        break;
      }

      case MySQLParser::MAX_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1830);
        tsOptionMaxSize();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(1831);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(1832);
        tsOptionWait();
        break;
      }

      case MySQLParser::ENCRYPTION_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(1833);
        tsOptionEncryption();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeTablespaceOptionContext ------------------------------------------------------------------

MySQLParser::ChangeTablespaceOptionContext::ChangeTablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChangeTablespaceOptionContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::ChangeTablespaceOptionContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::ChangeTablespaceOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::ChangeTablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::ChangeTablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}


size_t MySQLParser::ChangeTablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleChangeTablespaceOption;
}

void MySQLParser::ChangeTablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeTablespaceOption(this);
}

void MySQLParser::ChangeTablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeTablespaceOption(this);
}

MySQLParser::ChangeTablespaceOptionContext* MySQLParser::changeTablespaceOption() {
  ChangeTablespaceOptionContext *_localctx = _tracker.createInstance<ChangeTablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 72, MySQLParser::RuleChangeTablespaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1843);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(1836);
        match(MySQLParser::INITIAL_SIZE_SYMBOL);
        setState(1838);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 100, _ctx)) {
        case 1: {
          setState(1837);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(1840);
        sizeNumber();
        break;
      }

      case MySQLParser::AUTOEXTEND_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(1841);
        tsOptionAutoextendSize();
        break;
      }

      case MySQLParser::MAX_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(1842);
        tsOptionMaxSize();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterViewContext ------------------------------------------------------------------

MySQLParser::AlterViewContext::AlterViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewRefContext* MySQLParser::AlterViewContext::viewRef() {
  return getRuleContext<MySQLParser::ViewRefContext>(0);
}

MySQLParser::ViewTailContext* MySQLParser::AlterViewContext::viewTail() {
  return getRuleContext<MySQLParser::ViewTailContext>(0);
}

MySQLParser::ViewAlgorithmContext* MySQLParser::AlterViewContext::viewAlgorithm() {
  return getRuleContext<MySQLParser::ViewAlgorithmContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::AlterViewContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::ViewSuidContext* MySQLParser::AlterViewContext::viewSuid() {
  return getRuleContext<MySQLParser::ViewSuidContext>(0);
}


size_t MySQLParser::AlterViewContext::getRuleIndex() const {
  return MySQLParser::RuleAlterView;
}

void MySQLParser::AlterViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterView(this);
}

void MySQLParser::AlterViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterView(this);
}

MySQLParser::AlterViewContext* MySQLParser::alterView() {
  AlterViewContext *_localctx = _tracker.createInstance<AlterViewContext>(_ctx, getState());
  enterRule(_localctx, 74, MySQLParser::RuleAlterView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1846);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL) {
      setState(1845);
      viewAlgorithm();
    }
    setState(1849);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1848);
      definerClause();
    }
    setState(1852);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQL_SYMBOL) {
      setState(1851);
      viewSuid();
    }
    setState(1854);
    match(MySQLParser::VIEW_SYMBOL);
    setState(1855);
    viewRef();
    setState(1856);
    viewTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewTailContext ------------------------------------------------------------------

MySQLParser::ViewTailContext::ViewTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewTailContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::ViewSelectContext* MySQLParser::ViewTailContext::viewSelect() {
  return getRuleContext<MySQLParser::ViewSelectContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::ViewTailContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}


size_t MySQLParser::ViewTailContext::getRuleIndex() const {
  return MySQLParser::RuleViewTail;
}

void MySQLParser::ViewTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewTail(this);
}

void MySQLParser::ViewTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewTail(this);
}

MySQLParser::ViewTailContext* MySQLParser::viewTail() {
  ViewTailContext *_localctx = _tracker.createInstance<ViewTailContext>(_ctx, getState());
  enterRule(_localctx, 76, MySQLParser::RuleViewTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(1858);
      columnInternalRefList();
    }
    setState(1861);
    match(MySQLParser::AS_SYMBOL);
    setState(1862);
    viewSelect();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewSelectContext ------------------------------------------------------------------

MySQLParser::ViewSelectContext::ViewSelectContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::ViewSelectContext::queryExpressionOrParens() {
  return getRuleContext<MySQLParser::QueryExpressionOrParensContext>(0);
}

MySQLParser::ViewCheckOptionContext* MySQLParser::ViewSelectContext::viewCheckOption() {
  return getRuleContext<MySQLParser::ViewCheckOptionContext>(0);
}


size_t MySQLParser::ViewSelectContext::getRuleIndex() const {
  return MySQLParser::RuleViewSelect;
}

void MySQLParser::ViewSelectContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewSelect(this);
}

void MySQLParser::ViewSelectContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewSelect(this);
}

MySQLParser::ViewSelectContext* MySQLParser::viewSelect() {
  ViewSelectContext *_localctx = _tracker.createInstance<ViewSelectContext>(_ctx, getState());
  enterRule(_localctx, 78, MySQLParser::RuleViewSelect);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1864);
    queryExpressionOrParens();
    setState(1866);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WITH_SYMBOL) {
      setState(1865);
      viewCheckOption();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewCheckOptionContext ------------------------------------------------------------------

MySQLParser::ViewCheckOptionContext::ViewCheckOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewCheckOptionContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}


size_t MySQLParser::ViewCheckOptionContext::getRuleIndex() const {
  return MySQLParser::RuleViewCheckOption;
}

void MySQLParser::ViewCheckOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewCheckOption(this);
}

void MySQLParser::ViewCheckOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewCheckOption(this);
}

MySQLParser::ViewCheckOptionContext* MySQLParser::viewCheckOption() {
  ViewCheckOptionContext *_localctx = _tracker.createInstance<ViewCheckOptionContext>(_ctx, getState());
  enterRule(_localctx, 80, MySQLParser::RuleViewCheckOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1868);
    match(MySQLParser::WITH_SYMBOL);
    setState(1870);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADED_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL) {
      setState(1869);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADED_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(1872);
    match(MySQLParser::CHECK_SYMBOL);
    setState(1873);
    match(MySQLParser::OPTION_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateStatementContext ------------------------------------------------------------------

MySQLParser::CreateStatementContext::CreateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

MySQLParser::CreateDatabaseContext* MySQLParser::CreateStatementContext::createDatabase() {
  return getRuleContext<MySQLParser::CreateDatabaseContext>(0);
}

MySQLParser::CreateTableContext* MySQLParser::CreateStatementContext::createTable() {
  return getRuleContext<MySQLParser::CreateTableContext>(0);
}

MySQLParser::CreateFunctionContext* MySQLParser::CreateStatementContext::createFunction() {
  return getRuleContext<MySQLParser::CreateFunctionContext>(0);
}

MySQLParser::CreateProcedureContext* MySQLParser::CreateStatementContext::createProcedure() {
  return getRuleContext<MySQLParser::CreateProcedureContext>(0);
}

MySQLParser::CreateUdfContext* MySQLParser::CreateStatementContext::createUdf() {
  return getRuleContext<MySQLParser::CreateUdfContext>(0);
}

MySQLParser::CreateLogfileGroupContext* MySQLParser::CreateStatementContext::createLogfileGroup() {
  return getRuleContext<MySQLParser::CreateLogfileGroupContext>(0);
}

MySQLParser::CreateViewContext* MySQLParser::CreateStatementContext::createView() {
  return getRuleContext<MySQLParser::CreateViewContext>(0);
}

MySQLParser::CreateTriggerContext* MySQLParser::CreateStatementContext::createTrigger() {
  return getRuleContext<MySQLParser::CreateTriggerContext>(0);
}

MySQLParser::CreateIndexContext* MySQLParser::CreateStatementContext::createIndex() {
  return getRuleContext<MySQLParser::CreateIndexContext>(0);
}

MySQLParser::CreateServerContext* MySQLParser::CreateStatementContext::createServer() {
  return getRuleContext<MySQLParser::CreateServerContext>(0);
}

MySQLParser::CreateTablespaceContext* MySQLParser::CreateStatementContext::createTablespace() {
  return getRuleContext<MySQLParser::CreateTablespaceContext>(0);
}

MySQLParser::CreateEventContext* MySQLParser::CreateStatementContext::createEvent() {
  return getRuleContext<MySQLParser::CreateEventContext>(0);
}

MySQLParser::CreateRoleContext* MySQLParser::CreateStatementContext::createRole() {
  return getRuleContext<MySQLParser::CreateRoleContext>(0);
}

MySQLParser::CreateSpatialReferenceContext* MySQLParser::CreateStatementContext::createSpatialReference() {
  return getRuleContext<MySQLParser::CreateSpatialReferenceContext>(0);
}

MySQLParser::CreateUndoTablespaceContext* MySQLParser::CreateStatementContext::createUndoTablespace() {
  return getRuleContext<MySQLParser::CreateUndoTablespaceContext>(0);
}


size_t MySQLParser::CreateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCreateStatement;
}

void MySQLParser::CreateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateStatement(this);
}

void MySQLParser::CreateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateStatement(this);
}

MySQLParser::CreateStatementContext* MySQLParser::createStatement() {
  CreateStatementContext *_localctx = _tracker.createInstance<CreateStatementContext>(_ctx, getState());
  enterRule(_localctx, 82, MySQLParser::RuleCreateStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1875);
    match(MySQLParser::CREATE_SYMBOL);
    setState(1894);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 108, _ctx)) {
    case 1: {
      setState(1876);
      createDatabase();
      break;
    }

    case 2: {
      setState(1877);
      createTable();
      break;
    }

    case 3: {
      setState(1878);
      createFunction();
      break;
    }

    case 4: {
      setState(1879);
      createProcedure();
      break;
    }

    case 5: {
      setState(1880);
      createUdf();
      break;
    }

    case 6: {
      setState(1881);
      createLogfileGroup();
      break;
    }

    case 7: {
      setState(1882);
      createView();
      break;
    }

    case 8: {
      setState(1883);
      createTrigger();
      break;
    }

    case 9: {
      setState(1884);
      createIndex();
      break;
    }

    case 10: {
      setState(1885);
      createServer();
      break;
    }

    case 11: {
      setState(1886);
      createTablespace();
      break;
    }

    case 12: {
      setState(1887);
      createEvent();
      break;
    }

    case 13: {
      setState(1888);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(1889);
      createRole();
      break;
    }

    case 14: {
      setState(1890);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(1891);
      createSpatialReference();
      break;
    }

    case 15: {
      setState(1892);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(1893);
      createUndoTablespace();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseContext ------------------------------------------------------------------

MySQLParser::CreateDatabaseContext::CreateDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaNameContext* MySQLParser::CreateDatabaseContext::schemaName() {
  return getRuleContext<MySQLParser::SchemaNameContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateDatabaseContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

std::vector<MySQLParser::CreateDatabaseOptionContext *> MySQLParser::CreateDatabaseContext::createDatabaseOption() {
  return getRuleContexts<MySQLParser::CreateDatabaseOptionContext>();
}

MySQLParser::CreateDatabaseOptionContext* MySQLParser::CreateDatabaseContext::createDatabaseOption(size_t i) {
  return getRuleContext<MySQLParser::CreateDatabaseOptionContext>(i);
}


size_t MySQLParser::CreateDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleCreateDatabase;
}

void MySQLParser::CreateDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabase(this);
}

void MySQLParser::CreateDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabase(this);
}

MySQLParser::CreateDatabaseContext* MySQLParser::createDatabase() {
  CreateDatabaseContext *_localctx = _tracker.createInstance<CreateDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 84, MySQLParser::RuleCreateDatabase);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1896);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(1898);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 109, _ctx)) {
    case 1: {
      setState(1897);
      ifNotExists();
      break;
    }

    }
    setState(1900);
    schemaName();
    setState(1904);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1901);
        createDatabaseOption(); 
      }
      setState(1906);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateDatabaseOptionContext ------------------------------------------------------------------

MySQLParser::CreateDatabaseOptionContext::CreateDatabaseOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DefaultCharsetContext* MySQLParser::CreateDatabaseOptionContext::defaultCharset() {
  return getRuleContext<MySQLParser::DefaultCharsetContext>(0);
}

MySQLParser::DefaultCollationContext* MySQLParser::CreateDatabaseOptionContext::defaultCollation() {
  return getRuleContext<MySQLParser::DefaultCollationContext>(0);
}

MySQLParser::DefaultEncryptionContext* MySQLParser::CreateDatabaseOptionContext::defaultEncryption() {
  return getRuleContext<MySQLParser::DefaultEncryptionContext>(0);
}


size_t MySQLParser::CreateDatabaseOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateDatabaseOption;
}

void MySQLParser::CreateDatabaseOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateDatabaseOption(this);
}

void MySQLParser::CreateDatabaseOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateDatabaseOption(this);
}

MySQLParser::CreateDatabaseOptionContext* MySQLParser::createDatabaseOption() {
  CreateDatabaseOptionContext *_localctx = _tracker.createInstance<CreateDatabaseOptionContext>(_ctx, getState());
  enterRule(_localctx, 86, MySQLParser::RuleCreateDatabaseOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1911);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1907);
      defaultCharset();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1908);
      defaultCollation();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(1909);

      if (!(serverVersion >= 80016)) throw FailedPredicateException(this, "serverVersion >= 80016");
      setState(1910);
      defaultEncryption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableContext ------------------------------------------------------------------

MySQLParser::CreateTableContext::CreateTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableNameContext* MySQLParser::CreateTableContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::CreateTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateTableContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

MySQLParser::TableElementListContext* MySQLParser::CreateTableContext::tableElementList() {
  return getRuleContext<MySQLParser::TableElementListContext>(0);
}

MySQLParser::CreateTableOptionsContext* MySQLParser::CreateTableContext::createTableOptions() {
  return getRuleContext<MySQLParser::CreateTableOptionsContext>(0);
}

MySQLParser::PartitionClauseContext* MySQLParser::CreateTableContext::partitionClause() {
  return getRuleContext<MySQLParser::PartitionClauseContext>(0);
}

MySQLParser::DuplicateAsQueryExpressionContext* MySQLParser::CreateTableContext::duplicateAsQueryExpression() {
  return getRuleContext<MySQLParser::DuplicateAsQueryExpressionContext>(0);
}


size_t MySQLParser::CreateTableContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTable;
}

void MySQLParser::CreateTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTable(this);
}

void MySQLParser::CreateTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTable(this);
}

MySQLParser::CreateTableContext* MySQLParser::createTable() {
  CreateTableContext *_localctx = _tracker.createInstance<CreateTableContext>(_ctx, getState());
  enterRule(_localctx, 88, MySQLParser::RuleCreateTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1914);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::TEMPORARY_SYMBOL) {
      setState(1913);
      match(MySQLParser::TEMPORARY_SYMBOL);
    }
    setState(1916);
    match(MySQLParser::TABLE_SYMBOL);
    setState(1918);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      setState(1917);
      ifNotExists();
      break;
    }

    }
    setState(1920);
    tableName();
    setState(1943);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 118, _ctx)) {
    case 1: {
      setState(1925);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
      case 1: {
        setState(1921);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(1922);
        tableElementList();
        setState(1923);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      }
      setState(1928);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 115, _ctx)) {
      case 1: {
        setState(1927);
        createTableOptions();
        break;
      }

      }
      setState(1931);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 116, _ctx)) {
      case 1: {
        setState(1930);
        partitionClause();
        break;
      }

      }
      setState(1934);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 117, _ctx)) {
      case 1: {
        setState(1933);
        duplicateAsQueryExpression();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(1936);
      match(MySQLParser::LIKE_SYMBOL);
      setState(1937);
      tableRef();
      break;
    }

    case 3: {
      setState(1938);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(1939);
      match(MySQLParser::LIKE_SYMBOL);
      setState(1940);
      tableRef();
      setState(1941);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementListContext ------------------------------------------------------------------

MySQLParser::TableElementListContext::TableElementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableElementContext *> MySQLParser::TableElementListContext::tableElement() {
  return getRuleContexts<MySQLParser::TableElementContext>();
}

MySQLParser::TableElementContext* MySQLParser::TableElementListContext::tableElement(size_t i) {
  return getRuleContext<MySQLParser::TableElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableElementListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableElementListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableElementListContext::getRuleIndex() const {
  return MySQLParser::RuleTableElementList;
}

void MySQLParser::TableElementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElementList(this);
}

void MySQLParser::TableElementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElementList(this);
}

MySQLParser::TableElementListContext* MySQLParser::tableElementList() {
  TableElementListContext *_localctx = _tracker.createInstance<TableElementListContext>(_ctx, getState());
  enterRule(_localctx, 90, MySQLParser::RuleTableElementList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1945);
    tableElement();
    setState(1950);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(1946);
      match(MySQLParser::COMMA_SYMBOL);
      setState(1947);
      tableElement();
      setState(1952);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableElementContext ------------------------------------------------------------------

MySQLParser::TableElementContext::TableElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnDefinitionContext* MySQLParser::TableElementContext::columnDefinition() {
  return getRuleContext<MySQLParser::ColumnDefinitionContext>(0);
}

MySQLParser::TableConstraintDefContext* MySQLParser::TableElementContext::tableConstraintDef() {
  return getRuleContext<MySQLParser::TableConstraintDefContext>(0);
}


size_t MySQLParser::TableElementContext::getRuleIndex() const {
  return MySQLParser::RuleTableElement;
}

void MySQLParser::TableElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableElement(this);
}

void MySQLParser::TableElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableElement(this);
}

MySQLParser::TableElementContext* MySQLParser::tableElement() {
  TableElementContext *_localctx = _tracker.createInstance<TableElementContext>(_ctx, getState());
  enterRule(_localctx, 92, MySQLParser::RuleTableElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1955);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 120, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1953);
      columnDefinition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1954);
      tableConstraintDef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DuplicateAsQueryExpressionContext ------------------------------------------------------------------

MySQLParser::DuplicateAsQueryExpressionContext::DuplicateAsQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::DuplicateAsQueryExpressionContext::queryExpressionOrParens() {
  return getRuleContext<MySQLParser::QueryExpressionOrParensContext>(0);
}

tree::TerminalNode* MySQLParser::DuplicateAsQueryExpressionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DuplicateAsQueryExpressionContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DuplicateAsQueryExpressionContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::DuplicateAsQueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleDuplicateAsQueryExpression;
}

void MySQLParser::DuplicateAsQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDuplicateAsQueryExpression(this);
}

void MySQLParser::DuplicateAsQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDuplicateAsQueryExpression(this);
}

MySQLParser::DuplicateAsQueryExpressionContext* MySQLParser::duplicateAsQueryExpression() {
  DuplicateAsQueryExpressionContext *_localctx = _tracker.createInstance<DuplicateAsQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 94, MySQLParser::RuleDuplicateAsQueryExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1958);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 121, _ctx)) {
    case 1: {
      setState(1957);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(1961);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 122, _ctx)) {
    case 1: {
      setState(1960);
      match(MySQLParser::AS_SYMBOL);
      break;
    }

    }
    setState(1963);
    queryExpressionOrParens();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionOrParensContext ------------------------------------------------------------------

MySQLParser::QueryExpressionOrParensContext::QueryExpressionOrParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext* MySQLParser::QueryExpressionOrParensContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionOrParensContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}


size_t MySQLParser::QueryExpressionOrParensContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionOrParens;
}

void MySQLParser::QueryExpressionOrParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionOrParens(this);
}

void MySQLParser::QueryExpressionOrParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionOrParens(this);
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::queryExpressionOrParens() {
  QueryExpressionOrParensContext *_localctx = _tracker.createInstance<QueryExpressionOrParensContext>(_ctx, getState());
  enterRule(_localctx, 96, MySQLParser::RuleQueryExpressionOrParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(1967);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 123, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1965);
      queryExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1966);
      queryExpressionParens();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoutineContext ------------------------------------------------------------------

MySQLParser::CreateRoutineContext::CreateRoutineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateRoutineContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateRoutineContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}

MySQLParser::CreateProcedureContext* MySQLParser::CreateRoutineContext::createProcedure() {
  return getRuleContext<MySQLParser::CreateProcedureContext>(0);
}

MySQLParser::CreateFunctionContext* MySQLParser::CreateRoutineContext::createFunction() {
  return getRuleContext<MySQLParser::CreateFunctionContext>(0);
}

MySQLParser::CreateUdfContext* MySQLParser::CreateRoutineContext::createUdf() {
  return getRuleContext<MySQLParser::CreateUdfContext>(0);
}

tree::TerminalNode* MySQLParser::CreateRoutineContext::SEMICOLON_SYMBOL() {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, 0);
}


size_t MySQLParser::CreateRoutineContext::getRuleIndex() const {
  return MySQLParser::RuleCreateRoutine;
}

void MySQLParser::CreateRoutineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRoutine(this);
}

void MySQLParser::CreateRoutineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRoutine(this);
}

MySQLParser::CreateRoutineContext* MySQLParser::createRoutine() {
  CreateRoutineContext *_localctx = _tracker.createInstance<CreateRoutineContext>(_ctx, getState());
  enterRule(_localctx, 98, MySQLParser::RuleCreateRoutine);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1969);
    match(MySQLParser::CREATE_SYMBOL);
    setState(1973);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      setState(1970);
      createProcedure();
      break;
    }

    case 2: {
      setState(1971);
      createFunction();
      break;
    }

    case 3: {
      setState(1972);
      createUdf();
      break;
    }

    }
    setState(1976);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SEMICOLON_SYMBOL) {
      setState(1975);
      match(MySQLParser::SEMICOLON_SYMBOL);
    }
    setState(1978);
    match(MySQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateProcedureContext ------------------------------------------------------------------

MySQLParser::CreateProcedureContext::CreateProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureNameContext* MySQLParser::CreateProcedureContext::procedureName() {
  return getRuleContext<MySQLParser::ProcedureNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateProcedureContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateProcedureContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

std::vector<MySQLParser::ProcedureParameterContext *> MySQLParser::CreateProcedureContext::procedureParameter() {
  return getRuleContexts<MySQLParser::ProcedureParameterContext>();
}

MySQLParser::ProcedureParameterContext* MySQLParser::CreateProcedureContext::procedureParameter(size_t i) {
  return getRuleContext<MySQLParser::ProcedureParameterContext>(i);
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::CreateProcedureContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::CreateProcedureContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateProcedureContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateProcedureContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateProcedureContext::getRuleIndex() const {
  return MySQLParser::RuleCreateProcedure;
}

void MySQLParser::CreateProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateProcedure(this);
}

void MySQLParser::CreateProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateProcedure(this);
}

MySQLParser::CreateProcedureContext* MySQLParser::createProcedure() {
  CreateProcedureContext *_localctx = _tracker.createInstance<CreateProcedureContext>(_ctx, getState());
  enterRule(_localctx, 100, MySQLParser::RuleCreateProcedure);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(1981);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(1980);
      definerClause();
    }
    setState(1983);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(1984);
    procedureName();
    setState(1985);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(1994);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 128, _ctx)) {
    case 1: {
      setState(1986);
      procedureParameter();
      setState(1991);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(1987);
        match(MySQLParser::COMMA_SYMBOL);
        setState(1988);
        procedureParameter();
        setState(1993);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
    setState(1996);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(2000);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(1997);
        routineCreateOption(); 
      }
      setState(2002);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 129, _ctx);
    }
    setState(2003);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateFunctionContext ------------------------------------------------------------------

MySQLParser::CreateFunctionContext::CreateFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionNameContext* MySQLParser::CreateFunctionContext::functionName() {
  return getRuleContext<MySQLParser::FunctionNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

MySQLParser::TypeWithOptCollateContext* MySQLParser::CreateFunctionContext::typeWithOptCollate() {
  return getRuleContext<MySQLParser::TypeWithOptCollateContext>(0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateFunctionContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateFunctionContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

std::vector<MySQLParser::FunctionParameterContext *> MySQLParser::CreateFunctionContext::functionParameter() {
  return getRuleContexts<MySQLParser::FunctionParameterContext>();
}

MySQLParser::FunctionParameterContext* MySQLParser::CreateFunctionContext::functionParameter(size_t i) {
  return getRuleContext<MySQLParser::FunctionParameterContext>(i);
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::CreateFunctionContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::CreateFunctionContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateFunctionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateFunctionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateFunction;
}

void MySQLParser::CreateFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateFunction(this);
}

void MySQLParser::CreateFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateFunction(this);
}

MySQLParser::CreateFunctionContext* MySQLParser::createFunction() {
  CreateFunctionContext *_localctx = _tracker.createInstance<CreateFunctionContext>(_ctx, getState());
  enterRule(_localctx, 102, MySQLParser::RuleCreateFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2006);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2005);
      definerClause();
    }
    setState(2008);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(2009);
    functionName();
    setState(2010);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2019);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 132, _ctx)) {
    case 1: {
      setState(2011);
      functionParameter();
      setState(2016);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(2012);
        match(MySQLParser::COMMA_SYMBOL);
        setState(2013);
        functionParameter();
        setState(2018);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
    setState(2021);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(2022);
    match(MySQLParser::RETURNS_SYMBOL);
    setState(2023);
    typeWithOptCollate();
    setState(2027);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2024);
        routineCreateOption(); 
      }
      setState(2029);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 133, _ctx);
    }
    setState(2030);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUdfContext ------------------------------------------------------------------

MySQLParser::CreateUdfContext::CreateUdfContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateUdfContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::UdfNameContext* MySQLParser::CreateUdfContext::udfName() {
  return getRuleContext<MySQLParser::UdfNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CreateUdfContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUdfContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}


size_t MySQLParser::CreateUdfContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUdf;
}

void MySQLParser::CreateUdfContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUdf(this);
}

void MySQLParser::CreateUdfContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUdf(this);
}

MySQLParser::CreateUdfContext* MySQLParser::createUdf() {
  CreateUdfContext *_localctx = _tracker.createInstance<CreateUdfContext>(_ctx, getState());
  enterRule(_localctx, 104, MySQLParser::RuleCreateUdf);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2033);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::AGGREGATE_SYMBOL) {
      setState(2032);
      match(MySQLParser::AGGREGATE_SYMBOL);
    }
    setState(2035);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(2036);
    udfName();
    setState(2037);
    match(MySQLParser::RETURNS_SYMBOL);
    setState(2038);
    dynamic_cast<CreateUdfContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DECIMAL_SYMBOL || _la == MySQLParser::INT_SYMBOL || _la == MySQLParser::REAL_SYMBOL || _la == MySQLParser::STRING_SYMBOL)) {
      dynamic_cast<CreateUdfContext *>(_localctx)->type = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2039);
    match(MySQLParser::SONAME_SYMBOL);
    setState(2040);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineCreateOptionContext ------------------------------------------------------------------

MySQLParser::RoutineCreateOptionContext::RoutineCreateOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoutineOptionContext* MySQLParser::RoutineCreateOptionContext::routineOption() {
  return getRuleContext<MySQLParser::RoutineOptionContext>(0);
}

tree::TerminalNode* MySQLParser::RoutineCreateOptionContext::DETERMINISTIC_SYMBOL() {
  return getToken(MySQLParser::DETERMINISTIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineCreateOptionContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}


size_t MySQLParser::RoutineCreateOptionContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineCreateOption;
}

void MySQLParser::RoutineCreateOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineCreateOption(this);
}

void MySQLParser::RoutineCreateOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineCreateOption(this);
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::routineCreateOption() {
  RoutineCreateOptionContext *_localctx = _tracker.createInstance<RoutineCreateOptionContext>(_ctx, getState());
  enterRule(_localctx, 106, MySQLParser::RuleRoutineCreateOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2047);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::CONTAINS_SYMBOL:
      case MySQLParser::LANGUAGE_SYMBOL:
      case MySQLParser::MODIFIES_SYMBOL:
      case MySQLParser::NO_SYMBOL:
      case MySQLParser::READS_SYMBOL:
      case MySQLParser::SQL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2042);
        routineOption();
        break;
      }

      case MySQLParser::DETERMINISTIC_SYMBOL:
      case MySQLParser::NOT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2044);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT_SYMBOL) {
          setState(2043);
          match(MySQLParser::NOT_SYMBOL);
        }
        setState(2046);
        match(MySQLParser::DETERMINISTIC_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineAlterOptionsContext ------------------------------------------------------------------

MySQLParser::RoutineAlterOptionsContext::RoutineAlterOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoutineCreateOptionContext *> MySQLParser::RoutineAlterOptionsContext::routineCreateOption() {
  return getRuleContexts<MySQLParser::RoutineCreateOptionContext>();
}

MySQLParser::RoutineCreateOptionContext* MySQLParser::RoutineAlterOptionsContext::routineCreateOption(size_t i) {
  return getRuleContext<MySQLParser::RoutineCreateOptionContext>(i);
}


size_t MySQLParser::RoutineAlterOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineAlterOptions;
}

void MySQLParser::RoutineAlterOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineAlterOptions(this);
}

void MySQLParser::RoutineAlterOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineAlterOptions(this);
}

MySQLParser::RoutineAlterOptionsContext* MySQLParser::routineAlterOptions() {
  RoutineAlterOptionsContext *_localctx = _tracker.createInstance<RoutineAlterOptionsContext>(_ctx, getState());
  enterRule(_localctx, 108, MySQLParser::RuleRoutineAlterOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2050); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(2049);
      routineCreateOption();
      setState(2052); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 122) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 122)) & ((1ULL << (MySQLParser::COMMENT_SYMBOL - 122))
      | (1ULL << (MySQLParser::CONTAINS_SYMBOL - 122))
      | (1ULL << (MySQLParser::DETERMINISTIC_SYMBOL - 122)))) != 0) || _la == MySQLParser::LANGUAGE_SYMBOL || ((((_la - 381) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 381)) & ((1ULL << (MySQLParser::MODIFIES_SYMBOL - 381))
      | (1ULL << (MySQLParser::NOT_SYMBOL - 381))
      | (1ULL << (MySQLParser::NO_SYMBOL - 381)))) != 0) || _la == MySQLParser::READS_SYMBOL || _la == MySQLParser::SQL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoutineOptionContext ------------------------------------------------------------------

MySQLParser::RoutineOptionContext::RoutineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::RoutineOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::SQL_SYMBOL() {
  return getToken(MySQLParser::SQL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::READS_SYMBOL() {
  return getToken(MySQLParser::READS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::MODIFIES_SYMBOL() {
  return getToken(MySQLParser::MODIFIES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoutineOptionContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}


size_t MySQLParser::RoutineOptionContext::getRuleIndex() const {
  return MySQLParser::RuleRoutineOption;
}

void MySQLParser::RoutineOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoutineOption(this);
}

void MySQLParser::RoutineOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoutineOption(this);
}

MySQLParser::RoutineOptionContext* MySQLParser::routineOption() {
  RoutineOptionContext *_localctx = _tracker.createInstance<RoutineOptionContext>(_ctx, getState());
  enterRule(_localctx, 110, MySQLParser::RuleRoutineOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2071);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2054);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
        setState(2055);
        textLiteral();
        break;
      }

      case MySQLParser::LANGUAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2056);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::LANGUAGE_SYMBOL);
        setState(2057);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2058);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::NO_SYMBOL);
        setState(2059);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::CONTAINS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2060);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::CONTAINS_SYMBOL);
        setState(2061);
        match(MySQLParser::SQL_SYMBOL);
        break;
      }

      case MySQLParser::READS_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2062);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::READS_SYMBOL);
        setState(2063);
        match(MySQLParser::SQL_SYMBOL);
        setState(2064);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::MODIFIES_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2065);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::MODIFIES_SYMBOL);
        setState(2066);
        match(MySQLParser::SQL_SYMBOL);
        setState(2067);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::SQL_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(2068);
        dynamic_cast<RoutineOptionContext *>(_localctx)->option = match(MySQLParser::SQL_SYMBOL);
        setState(2069);
        match(MySQLParser::SECURITY_SYMBOL);
        setState(2070);
        dynamic_cast<RoutineOptionContext *>(_localctx)->security = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DEFINER_SYMBOL || _la == MySQLParser::INVOKER_SYMBOL)) {
          dynamic_cast<RoutineOptionContext *>(_localctx)->security = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexContext ------------------------------------------------------------------

MySQLParser::CreateIndexContext::CreateIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateIndexTargetContext* MySQLParser::CreateIndexContext::createIndexTarget() {
  return getRuleContext<MySQLParser::CreateIndexTargetContext>(0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IndexNameContext* MySQLParser::CreateIndexContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

MySQLParser::OnlineOptionContext* MySQLParser::CreateIndexContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::FULLTEXT_SYMBOL() {
  return getToken(MySQLParser::FULLTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

MySQLParser::IndexLockAndAlgorithmContext* MySQLParser::CreateIndexContext::indexLockAndAlgorithm() {
  return getRuleContext<MySQLParser::IndexLockAndAlgorithmContext>(0);
}

tree::TerminalNode* MySQLParser::CreateIndexContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

std::vector<MySQLParser::IndexOptionContext *> MySQLParser::CreateIndexContext::indexOption() {
  return getRuleContexts<MySQLParser::IndexOptionContext>();
}

MySQLParser::IndexOptionContext* MySQLParser::CreateIndexContext::indexOption(size_t i) {
  return getRuleContext<MySQLParser::IndexOptionContext>(i);
}

std::vector<MySQLParser::FulltextIndexOptionContext *> MySQLParser::CreateIndexContext::fulltextIndexOption() {
  return getRuleContexts<MySQLParser::FulltextIndexOptionContext>();
}

MySQLParser::FulltextIndexOptionContext* MySQLParser::CreateIndexContext::fulltextIndexOption(size_t i) {
  return getRuleContext<MySQLParser::FulltextIndexOptionContext>(i);
}

std::vector<MySQLParser::SpatialIndexOptionContext *> MySQLParser::CreateIndexContext::spatialIndexOption() {
  return getRuleContexts<MySQLParser::SpatialIndexOptionContext>();
}

MySQLParser::SpatialIndexOptionContext* MySQLParser::CreateIndexContext::spatialIndexOption(size_t i) {
  return getRuleContext<MySQLParser::SpatialIndexOptionContext>(i);
}

MySQLParser::IndexTypeClauseContext* MySQLParser::CreateIndexContext::indexTypeClause() {
  return getRuleContext<MySQLParser::IndexTypeClauseContext>(0);
}

MySQLParser::IndexNameAndTypeContext* MySQLParser::CreateIndexContext::indexNameAndType() {
  return getRuleContext<MySQLParser::IndexNameAndTypeContext>(0);
}


size_t MySQLParser::CreateIndexContext::getRuleIndex() const {
  return MySQLParser::RuleCreateIndex;
}

void MySQLParser::CreateIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndex(this);
}

void MySQLParser::CreateIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndex(this);
}

MySQLParser::CreateIndexContext* MySQLParser::createIndex() {
  CreateIndexContext *_localctx = _tracker.createInstance<CreateIndexContext>(_ctx, getState());
  enterRule(_localctx, 112, MySQLParser::RuleCreateIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2074);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 139, _ctx)) {
    case 1: {
      setState(2073);
      onlineOption();
      break;
    }

    }
    setState(2117);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INDEX_SYMBOL:
      case MySQLParser::UNIQUE_SYMBOL: {
        setState(2077);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::UNIQUE_SYMBOL) {
          setState(2076);
          match(MySQLParser::UNIQUE_SYMBOL);
        }
        setState(2079);
        dynamic_cast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::INDEX_SYMBOL);
        setState(2088);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 143, _ctx)) {
        case 1: {
          setState(2080);

          if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
          setState(2081);
          indexName();
          setState(2083);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::TYPE_SYMBOL

          || _la == MySQLParser::USING_SYMBOL) {
            setState(2082);
            indexTypeClause();
          }
          break;
        }

        case 2: {
          setState(2086);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 142, _ctx)) {
          case 1: {
            setState(2085);
            indexNameAndType();
            break;
          }

          }
          break;
        }

        }
        setState(2090);
        createIndexTarget();
        setState(2094);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2091);
            indexOption(); 
          }
          setState(2096);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 144, _ctx);
        }
        break;
      }

      case MySQLParser::FULLTEXT_SYMBOL: {
        setState(2097);
        dynamic_cast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::FULLTEXT_SYMBOL);
        setState(2098);
        match(MySQLParser::INDEX_SYMBOL);
        setState(2099);
        indexName();
        setState(2100);
        createIndexTarget();
        setState(2104);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2101);
            fulltextIndexOption(); 
          }
          setState(2106);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 145, _ctx);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        setState(2107);
        dynamic_cast<CreateIndexContext *>(_localctx)->type = match(MySQLParser::SPATIAL_SYMBOL);
        setState(2108);
        match(MySQLParser::INDEX_SYMBOL);
        setState(2109);
        indexName();
        setState(2110);
        createIndexTarget();
        setState(2114);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(2111);
            spatialIndexOption(); 
          }
          setState(2116);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 146, _ctx);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(2120);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 148, _ctx)) {
    case 1: {
      setState(2119);
      indexLockAndAlgorithm();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameAndTypeContext ------------------------------------------------------------------

MySQLParser::IndexNameAndTypeContext::IndexNameAndTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexNameContext* MySQLParser::IndexNameAndTypeContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

tree::TerminalNode* MySQLParser::IndexNameAndTypeContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::IndexTypeContext* MySQLParser::IndexNameAndTypeContext::indexType() {
  return getRuleContext<MySQLParser::IndexTypeContext>(0);
}

tree::TerminalNode* MySQLParser::IndexNameAndTypeContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}


size_t MySQLParser::IndexNameAndTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexNameAndType;
}

void MySQLParser::IndexNameAndTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexNameAndType(this);
}

void MySQLParser::IndexNameAndTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexNameAndType(this);
}

MySQLParser::IndexNameAndTypeContext* MySQLParser::indexNameAndType() {
  IndexNameAndTypeContext *_localctx = _tracker.createInstance<IndexNameAndTypeContext>(_ctx, getState());
  enterRule(_localctx, 114, MySQLParser::RuleIndexNameAndType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2131);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 150, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2122);
      indexName();
      setState(2125);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 149, _ctx)) {
      case 1: {
        setState(2123);
        match(MySQLParser::USING_SYMBOL);
        setState(2124);
        indexType();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2127);
      indexName();
      setState(2128);
      match(MySQLParser::TYPE_SYMBOL);
      setState(2129);
      indexType();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateIndexTargetContext ------------------------------------------------------------------

MySQLParser::CreateIndexTargetContext::CreateIndexTargetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateIndexTargetContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::CreateIndexTargetContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::KeyListVariantsContext* MySQLParser::CreateIndexTargetContext::keyListVariants() {
  return getRuleContext<MySQLParser::KeyListVariantsContext>(0);
}


size_t MySQLParser::CreateIndexTargetContext::getRuleIndex() const {
  return MySQLParser::RuleCreateIndexTarget;
}

void MySQLParser::CreateIndexTargetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateIndexTarget(this);
}

void MySQLParser::CreateIndexTargetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateIndexTarget(this);
}

MySQLParser::CreateIndexTargetContext* MySQLParser::createIndexTarget() {
  CreateIndexTargetContext *_localctx = _tracker.createInstance<CreateIndexTargetContext>(_ctx, getState());
  enterRule(_localctx, 116, MySQLParser::RuleCreateIndexTarget);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2133);
    match(MySQLParser::ON_SYMBOL);
    setState(2134);
    tableRef();
    setState(2135);
    keyListVariants();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateLogfileGroupContext ------------------------------------------------------------------

MySQLParser::CreateLogfileGroupContext::CreateLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupNameContext* MySQLParser::CreateLogfileGroupContext::logfileGroupName() {
  return getRuleContext<MySQLParser::LogfileGroupNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CreateLogfileGroupContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateLogfileGroupContext::REDOFILE_SYMBOL() {
  return getToken(MySQLParser::REDOFILE_SYMBOL, 0);
}

MySQLParser::LogfileGroupOptionsContext* MySQLParser::CreateLogfileGroupContext::logfileGroupOptions() {
  return getRuleContext<MySQLParser::LogfileGroupOptionsContext>(0);
}


size_t MySQLParser::CreateLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleCreateLogfileGroup;
}

void MySQLParser::CreateLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateLogfileGroup(this);
}

void MySQLParser::CreateLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateLogfileGroup(this);
}

MySQLParser::CreateLogfileGroupContext* MySQLParser::createLogfileGroup() {
  CreateLogfileGroupContext *_localctx = _tracker.createInstance<CreateLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 118, MySQLParser::RuleCreateLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2137);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(2138);
    match(MySQLParser::GROUP_SYMBOL);
    setState(2139);
    logfileGroupName();
    setState(2140);
    match(MySQLParser::ADD_SYMBOL);
    setState(2141);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::REDOFILE_SYMBOL || _la == MySQLParser::UNDOFILE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2142);
    textLiteral();
    setState(2144);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NODEGROUP_SYMBOL

    || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::REDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::UNDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(2143);
      logfileGroupOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupOptionsContext ------------------------------------------------------------------

MySQLParser::LogfileGroupOptionsContext::LogfileGroupOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::LogfileGroupOptionContext *> MySQLParser::LogfileGroupOptionsContext::logfileGroupOption() {
  return getRuleContexts<MySQLParser::LogfileGroupOptionContext>();
}

MySQLParser::LogfileGroupOptionContext* MySQLParser::LogfileGroupOptionsContext::logfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::LogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::LogfileGroupOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::LogfileGroupOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::LogfileGroupOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupOptions;
}

void MySQLParser::LogfileGroupOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupOptions(this);
}

void MySQLParser::LogfileGroupOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupOptions(this);
}

MySQLParser::LogfileGroupOptionsContext* MySQLParser::logfileGroupOptions() {
  LogfileGroupOptionsContext *_localctx = _tracker.createInstance<LogfileGroupOptionsContext>(_ctx, getState());
  enterRule(_localctx, 120, MySQLParser::RuleLogfileGroupOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2146);
    logfileGroupOption();
    setState(2153);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL || _la == MySQLParser::COMMENT_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INITIAL_SIZE_SYMBOL || _la == MySQLParser::NODEGROUP_SYMBOL

    || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::REDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::UNDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(2148);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(2147);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(2150);
      logfileGroupOption();
      setState(2155);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::LogfileGroupOptionContext::LogfileGroupOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::LogfileGroupOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionUndoRedoBufferSizeContext* MySQLParser::LogfileGroupOptionContext::tsOptionUndoRedoBufferSize() {
  return getRuleContext<MySQLParser::TsOptionUndoRedoBufferSizeContext>(0);
}

MySQLParser::TsOptionNodegroupContext* MySQLParser::LogfileGroupOptionContext::tsOptionNodegroup() {
  return getRuleContext<MySQLParser::TsOptionNodegroupContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::LogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::LogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionCommentContext* MySQLParser::LogfileGroupOptionContext::tsOptionComment() {
  return getRuleContext<MySQLParser::TsOptionCommentContext>(0);
}


size_t MySQLParser::LogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupOption;
}

void MySQLParser::LogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupOption(this);
}

void MySQLParser::LogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupOption(this);
}

MySQLParser::LogfileGroupOptionContext* MySQLParser::logfileGroupOption() {
  LogfileGroupOptionContext *_localctx = _tracker.createInstance<LogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 122, MySQLParser::RuleLogfileGroupOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2162);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INITIAL_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2156);
        tsOptionInitialSize();
        break;
      }

      case MySQLParser::REDO_BUFFER_SIZE_SYMBOL:
      case MySQLParser::UNDO_BUFFER_SIZE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2157);
        tsOptionUndoRedoBufferSize();
        break;
      }

      case MySQLParser::NODEGROUP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2158);
        tsOptionNodegroup();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2159);
        tsOptionEngine();
        break;
      }

      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2160);
        tsOptionWait();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2161);
        tsOptionComment();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateServerContext ------------------------------------------------------------------

MySQLParser::CreateServerContext::CreateServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerNameContext* MySQLParser::CreateServerContext::serverName() {
  return getRuleContext<MySQLParser::ServerNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateServerContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateServerContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateServerContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CreateServerContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::ServerOptionsContext* MySQLParser::CreateServerContext::serverOptions() {
  return getRuleContext<MySQLParser::ServerOptionsContext>(0);
}


size_t MySQLParser::CreateServerContext::getRuleIndex() const {
  return MySQLParser::RuleCreateServer;
}

void MySQLParser::CreateServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateServer(this);
}

void MySQLParser::CreateServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateServer(this);
}

MySQLParser::CreateServerContext* MySQLParser::createServer() {
  CreateServerContext *_localctx = _tracker.createInstance<CreateServerContext>(_ctx, getState());
  enterRule(_localctx, 124, MySQLParser::RuleCreateServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2164);
    match(MySQLParser::SERVER_SYMBOL);
    setState(2165);
    serverName();
    setState(2166);
    match(MySQLParser::FOREIGN_SYMBOL);
    setState(2167);
    match(MySQLParser::DATA_SYMBOL);
    setState(2168);
    match(MySQLParser::WRAPPER_SYMBOL);
    setState(2169);
    textOrIdentifier();
    setState(2170);
    serverOptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionsContext ------------------------------------------------------------------

MySQLParser::ServerOptionsContext::ServerOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ServerOptionContext *> MySQLParser::ServerOptionsContext::serverOption() {
  return getRuleContexts<MySQLParser::ServerOptionContext>();
}

MySQLParser::ServerOptionContext* MySQLParser::ServerOptionsContext::serverOption(size_t i) {
  return getRuleContext<MySQLParser::ServerOptionContext>(i);
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ServerOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ServerOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ServerOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleServerOptions;
}

void MySQLParser::ServerOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOptions(this);
}

void MySQLParser::ServerOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOptions(this);
}

MySQLParser::ServerOptionsContext* MySQLParser::serverOptions() {
  ServerOptionsContext *_localctx = _tracker.createInstance<ServerOptionsContext>(_ctx, getState());
  enterRule(_localctx, 126, MySQLParser::RuleServerOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2172);
    match(MySQLParser::OPTIONS_SYMBOL);
    setState(2173);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2174);
    serverOption();
    setState(2179);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2175);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2176);
      serverOption();
      setState(2181);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(2182);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerOptionContext ------------------------------------------------------------------

MySQLParser::ServerOptionContext::ServerOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::ServerOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::ServerOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::ServerOptionContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}


size_t MySQLParser::ServerOptionContext::getRuleIndex() const {
  return MySQLParser::RuleServerOption;
}

void MySQLParser::ServerOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerOption(this);
}

void MySQLParser::ServerOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerOption(this);
}

MySQLParser::ServerOptionContext* MySQLParser::serverOption() {
  ServerOptionContext *_localctx = _tracker.createInstance<ServerOptionContext>(_ctx, getState());
  enterRule(_localctx, 128, MySQLParser::RuleServerOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2198);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::HOST_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2184);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::HOST_SYMBOL);
        setState(2185);
        textLiteral();
        break;
      }

      case MySQLParser::DATABASE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2186);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::DATABASE_SYMBOL);
        setState(2187);
        textLiteral();
        break;
      }

      case MySQLParser::USER_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2188);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::USER_SYMBOL);
        setState(2189);
        textLiteral();
        break;
      }

      case MySQLParser::PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2190);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::PASSWORD_SYMBOL);
        setState(2191);
        textLiteral();
        break;
      }

      case MySQLParser::SOCKET_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(2192);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::SOCKET_SYMBOL);
        setState(2193);
        textLiteral();
        break;
      }

      case MySQLParser::OWNER_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(2194);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::OWNER_SYMBOL);
        setState(2195);
        textLiteral();
        break;
      }

      case MySQLParser::PORT_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(2196);
        dynamic_cast<ServerOptionContext *>(_localctx)->option = match(MySQLParser::PORT_SYMBOL);
        setState(2197);
        ulong_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTablespaceContext ------------------------------------------------------------------

MySQLParser::CreateTablespaceContext::CreateTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceNameContext* MySQLParser::CreateTablespaceContext::tablespaceName() {
  return getRuleContext<MySQLParser::TablespaceNameContext>(0);
}

MySQLParser::TsDataFileNameContext* MySQLParser::CreateTablespaceContext::tsDataFileName() {
  return getRuleContext<MySQLParser::TsDataFileNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTablespaceContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::CreateTablespaceContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

MySQLParser::TablespaceOptionsContext* MySQLParser::CreateTablespaceContext::tablespaceOptions() {
  return getRuleContext<MySQLParser::TablespaceOptionsContext>(0);
}


size_t MySQLParser::CreateTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTablespace;
}

void MySQLParser::CreateTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTablespace(this);
}

void MySQLParser::CreateTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTablespace(this);
}

MySQLParser::CreateTablespaceContext* MySQLParser::createTablespace() {
  CreateTablespaceContext *_localctx = _tracker.createInstance<CreateTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 130, MySQLParser::RuleCreateTablespace);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2200);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2201);
    tablespaceName();
    setState(2202);
    tsDataFileName();
    setState(2207);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 157, _ctx)) {
    case 1: {
      setState(2203);
      match(MySQLParser::USE_SYMBOL);
      setState(2204);
      match(MySQLParser::LOGFILE_SYMBOL);
      setState(2205);
      match(MySQLParser::GROUP_SYMBOL);
      setState(2206);
      logfileGroupRef();
      break;
    }

    }
    setState(2210);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 158, _ctx)) {
    case 1: {
      setState(2209);
      tablespaceOptions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::CreateUndoTablespaceContext::CreateUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceNameContext* MySQLParser::CreateUndoTablespaceContext::tablespaceName() {
  return getRuleContext<MySQLParser::TablespaceNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUndoTablespaceContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TsDataFileContext* MySQLParser::CreateUndoTablespaceContext::tsDataFile() {
  return getRuleContext<MySQLParser::TsDataFileContext>(0);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::CreateUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}


size_t MySQLParser::CreateUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUndoTablespace;
}

void MySQLParser::CreateUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUndoTablespace(this);
}

void MySQLParser::CreateUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUndoTablespace(this);
}

MySQLParser::CreateUndoTablespaceContext* MySQLParser::createUndoTablespace() {
  CreateUndoTablespaceContext *_localctx = _tracker.createInstance<CreateUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 132, MySQLParser::RuleCreateUndoTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2212);
    match(MySQLParser::UNDO_SYMBOL);
    setState(2213);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2214);
    tablespaceName();
    setState(2215);
    match(MySQLParser::ADD_SYMBOL);
    setState(2216);
    tsDataFile();
    setState(2218);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(2217);
      undoTableSpaceOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsDataFileNameContext ------------------------------------------------------------------

MySQLParser::TsDataFileNameContext::TsDataFileNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsDataFileNameContext::ADD_SYMBOL() {
  return getToken(MySQLParser::ADD_SYMBOL, 0);
}

MySQLParser::TsDataFileContext* MySQLParser::TsDataFileNameContext::tsDataFile() {
  return getRuleContext<MySQLParser::TsDataFileContext>(0);
}


size_t MySQLParser::TsDataFileNameContext::getRuleIndex() const {
  return MySQLParser::RuleTsDataFileName;
}

void MySQLParser::TsDataFileNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsDataFileName(this);
}

void MySQLParser::TsDataFileNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsDataFileName(this);
}

MySQLParser::TsDataFileNameContext* MySQLParser::tsDataFileName() {
  TsDataFileNameContext *_localctx = _tracker.createInstance<TsDataFileNameContext>(_ctx, getState());
  enterRule(_localctx, 134, MySQLParser::RuleTsDataFileName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2227);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 161, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2220);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(2223);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 160, _ctx)) {
      case 1: {
        setState(2221);
        match(MySQLParser::ADD_SYMBOL);
        setState(2222);
        tsDataFile();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2225);
      match(MySQLParser::ADD_SYMBOL);
      setState(2226);
      tsDataFile();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsDataFileContext ------------------------------------------------------------------

MySQLParser::TsDataFileContext::TsDataFileContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsDataFileContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::TsDataFileContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}


size_t MySQLParser::TsDataFileContext::getRuleIndex() const {
  return MySQLParser::RuleTsDataFile;
}

void MySQLParser::TsDataFileContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsDataFile(this);
}

void MySQLParser::TsDataFileContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsDataFile(this);
}

MySQLParser::TsDataFileContext* MySQLParser::tsDataFile() {
  TsDataFileContext *_localctx = _tracker.createInstance<TsDataFileContext>(_ctx, getState());
  enterRule(_localctx, 136, MySQLParser::RuleTsDataFile);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2229);
    match(MySQLParser::DATAFILE_SYMBOL);
    setState(2230);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceOptionsContext ------------------------------------------------------------------

MySQLParser::TablespaceOptionsContext::TablespaceOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TablespaceOptionContext *> MySQLParser::TablespaceOptionsContext::tablespaceOption() {
  return getRuleContexts<MySQLParser::TablespaceOptionContext>();
}

MySQLParser::TablespaceOptionContext* MySQLParser::TablespaceOptionsContext::tablespaceOption(size_t i) {
  return getRuleContext<MySQLParser::TablespaceOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TablespaceOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TablespaceOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TablespaceOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceOptions;
}

void MySQLParser::TablespaceOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceOptions(this);
}

void MySQLParser::TablespaceOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceOptions(this);
}

MySQLParser::TablespaceOptionsContext* MySQLParser::tablespaceOptions() {
  TablespaceOptionsContext *_localctx = _tracker.createInstance<TablespaceOptionsContext>(_ctx, getState());
  enterRule(_localctx, 138, MySQLParser::RuleTablespaceOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2232);
    tablespaceOption();
    setState(2239);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2234);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 162, _ctx)) {
        case 1: {
          setState(2233);
          match(MySQLParser::COMMA_SYMBOL);
          break;
        }

        }
        setState(2236);
        tablespaceOption(); 
      }
      setState(2241);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 163, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceOptionContext ------------------------------------------------------------------

MySQLParser::TablespaceOptionContext::TablespaceOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::TablespaceOptionContext::tsOptionInitialSize() {
  return getRuleContext<MySQLParser::TsOptionInitialSizeContext>(0);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::TablespaceOptionContext::tsOptionAutoextendSize() {
  return getRuleContext<MySQLParser::TsOptionAutoextendSizeContext>(0);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::TablespaceOptionContext::tsOptionMaxSize() {
  return getRuleContext<MySQLParser::TsOptionMaxSizeContext>(0);
}

MySQLParser::TsOptionExtentSizeContext* MySQLParser::TablespaceOptionContext::tsOptionExtentSize() {
  return getRuleContext<MySQLParser::TsOptionExtentSizeContext>(0);
}

MySQLParser::TsOptionNodegroupContext* MySQLParser::TablespaceOptionContext::tsOptionNodegroup() {
  return getRuleContext<MySQLParser::TsOptionNodegroupContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::TablespaceOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}

MySQLParser::TsOptionWaitContext* MySQLParser::TablespaceOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionCommentContext* MySQLParser::TablespaceOptionContext::tsOptionComment() {
  return getRuleContext<MySQLParser::TsOptionCommentContext>(0);
}

MySQLParser::TsOptionFileblockSizeContext* MySQLParser::TablespaceOptionContext::tsOptionFileblockSize() {
  return getRuleContext<MySQLParser::TsOptionFileblockSizeContext>(0);
}

MySQLParser::TsOptionEncryptionContext* MySQLParser::TablespaceOptionContext::tsOptionEncryption() {
  return getRuleContext<MySQLParser::TsOptionEncryptionContext>(0);
}


size_t MySQLParser::TablespaceOptionContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceOption;
}

void MySQLParser::TablespaceOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceOption(this);
}

void MySQLParser::TablespaceOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceOption(this);
}

MySQLParser::TablespaceOptionContext* MySQLParser::tablespaceOption() {
  TablespaceOptionContext *_localctx = _tracker.createInstance<TablespaceOptionContext>(_ctx, getState());
  enterRule(_localctx, 140, MySQLParser::RuleTablespaceOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2254);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 164, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2242);
      tsOptionInitialSize();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2243);
      tsOptionAutoextendSize();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2244);
      tsOptionMaxSize();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(2245);
      tsOptionExtentSize();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(2246);
      tsOptionNodegroup();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(2247);
      tsOptionEngine();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(2248);
      tsOptionWait();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(2249);
      tsOptionComment();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(2250);

      if (!(serverVersion >= 50707)) throw FailedPredicateException(this, "serverVersion >= 50707");
      setState(2251);
      tsOptionFileblockSize();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(2252);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(2253);
      tsOptionEncryption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionInitialSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionInitialSizeContext::TsOptionInitialSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionInitialSizeContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionInitialSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionInitialSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionInitialSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionInitialSize;
}

void MySQLParser::TsOptionInitialSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionInitialSize(this);
}

void MySQLParser::TsOptionInitialSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionInitialSize(this);
}

MySQLParser::TsOptionInitialSizeContext* MySQLParser::tsOptionInitialSize() {
  TsOptionInitialSizeContext *_localctx = _tracker.createInstance<TsOptionInitialSizeContext>(_ctx, getState());
  enterRule(_localctx, 142, MySQLParser::RuleTsOptionInitialSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2256);
    match(MySQLParser::INITIAL_SIZE_SYMBOL);
    setState(2258);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 165, _ctx)) {
    case 1: {
      setState(2257);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2260);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionUndoRedoBufferSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionUndoRedoBufferSizeContext::TsOptionUndoRedoBufferSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionUndoRedoBufferSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionUndoRedoBufferSizeContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionUndoRedoBufferSizeContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionUndoRedoBufferSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionUndoRedoBufferSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionUndoRedoBufferSize;
}

void MySQLParser::TsOptionUndoRedoBufferSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionUndoRedoBufferSize(this);
}

void MySQLParser::TsOptionUndoRedoBufferSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionUndoRedoBufferSize(this);
}

MySQLParser::TsOptionUndoRedoBufferSizeContext* MySQLParser::tsOptionUndoRedoBufferSize() {
  TsOptionUndoRedoBufferSizeContext *_localctx = _tracker.createInstance<TsOptionUndoRedoBufferSizeContext>(_ctx, getState());
  enterRule(_localctx, 144, MySQLParser::RuleTsOptionUndoRedoBufferSize);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2262);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::REDO_BUFFER_SIZE_SYMBOL || _la == MySQLParser::UNDO_BUFFER_SIZE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2264);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 166, _ctx)) {
    case 1: {
      setState(2263);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2266);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionAutoextendSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionAutoextendSizeContext::TsOptionAutoextendSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionAutoextendSizeContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionAutoextendSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionAutoextendSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionAutoextendSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionAutoextendSize;
}

void MySQLParser::TsOptionAutoextendSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionAutoextendSize(this);
}

void MySQLParser::TsOptionAutoextendSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionAutoextendSize(this);
}

MySQLParser::TsOptionAutoextendSizeContext* MySQLParser::tsOptionAutoextendSize() {
  TsOptionAutoextendSizeContext *_localctx = _tracker.createInstance<TsOptionAutoextendSizeContext>(_ctx, getState());
  enterRule(_localctx, 146, MySQLParser::RuleTsOptionAutoextendSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2268);
    match(MySQLParser::AUTOEXTEND_SIZE_SYMBOL);
    setState(2270);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 167, _ctx)) {
    case 1: {
      setState(2269);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2272);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionMaxSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionMaxSizeContext::TsOptionMaxSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionMaxSizeContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionMaxSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionMaxSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionMaxSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionMaxSize;
}

void MySQLParser::TsOptionMaxSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionMaxSize(this);
}

void MySQLParser::TsOptionMaxSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionMaxSize(this);
}

MySQLParser::TsOptionMaxSizeContext* MySQLParser::tsOptionMaxSize() {
  TsOptionMaxSizeContext *_localctx = _tracker.createInstance<TsOptionMaxSizeContext>(_ctx, getState());
  enterRule(_localctx, 148, MySQLParser::RuleTsOptionMaxSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2274);
    match(MySQLParser::MAX_SIZE_SYMBOL);
    setState(2276);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 168, _ctx)) {
    case 1: {
      setState(2275);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2278);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionExtentSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionExtentSizeContext::TsOptionExtentSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionExtentSizeContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionExtentSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionExtentSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionExtentSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionExtentSize;
}

void MySQLParser::TsOptionExtentSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionExtentSize(this);
}

void MySQLParser::TsOptionExtentSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionExtentSize(this);
}

MySQLParser::TsOptionExtentSizeContext* MySQLParser::tsOptionExtentSize() {
  TsOptionExtentSizeContext *_localctx = _tracker.createInstance<TsOptionExtentSizeContext>(_ctx, getState());
  enterRule(_localctx, 150, MySQLParser::RuleTsOptionExtentSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2280);
    match(MySQLParser::EXTENT_SIZE_SYMBOL);
    setState(2282);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 169, _ctx)) {
    case 1: {
      setState(2281);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2284);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionNodegroupContext ------------------------------------------------------------------

MySQLParser::TsOptionNodegroupContext::TsOptionNodegroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionNodegroupContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::TsOptionNodegroupContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionNodegroupContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionNodegroupContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionNodegroup;
}

void MySQLParser::TsOptionNodegroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionNodegroup(this);
}

void MySQLParser::TsOptionNodegroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionNodegroup(this);
}

MySQLParser::TsOptionNodegroupContext* MySQLParser::tsOptionNodegroup() {
  TsOptionNodegroupContext *_localctx = _tracker.createInstance<TsOptionNodegroupContext>(_ctx, getState());
  enterRule(_localctx, 152, MySQLParser::RuleTsOptionNodegroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2286);
    match(MySQLParser::NODEGROUP_SYMBOL);
    setState(2288);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR) {
      setState(2287);
      match(MySQLParser::EQUAL_OPERATOR);
    }
    setState(2290);
    real_ulong_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionEngineContext ------------------------------------------------------------------

MySQLParser::TsOptionEngineContext::TsOptionEngineContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionEngineContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

MySQLParser::EngineRefContext* MySQLParser::TsOptionEngineContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionEngineContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionEngineContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionEngineContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionEngine;
}

void MySQLParser::TsOptionEngineContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionEngine(this);
}

void MySQLParser::TsOptionEngineContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionEngine(this);
}

MySQLParser::TsOptionEngineContext* MySQLParser::tsOptionEngine() {
  TsOptionEngineContext *_localctx = _tracker.createInstance<TsOptionEngineContext>(_ctx, getState());
  enterRule(_localctx, 154, MySQLParser::RuleTsOptionEngine);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2293);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::STORAGE_SYMBOL) {
      setState(2292);
      match(MySQLParser::STORAGE_SYMBOL);
    }
    setState(2295);
    match(MySQLParser::ENGINE_SYMBOL);
    setState(2297);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 172, _ctx)) {
    case 1: {
      setState(2296);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2299);
    engineRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionWaitContext ------------------------------------------------------------------

MySQLParser::TsOptionWaitContext::TsOptionWaitContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionWaitContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TsOptionWaitContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}


size_t MySQLParser::TsOptionWaitContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionWait;
}

void MySQLParser::TsOptionWaitContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionWait(this);
}

void MySQLParser::TsOptionWaitContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionWait(this);
}

MySQLParser::TsOptionWaitContext* MySQLParser::tsOptionWait() {
  TsOptionWaitContext *_localctx = _tracker.createInstance<TsOptionWaitContext>(_ctx, getState());
  enterRule(_localctx, 156, MySQLParser::RuleTsOptionWait);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2301);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::WAIT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionCommentContext ------------------------------------------------------------------

MySQLParser::TsOptionCommentContext::TsOptionCommentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionCommentContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::TsOptionCommentContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionCommentContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionCommentContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionComment;
}

void MySQLParser::TsOptionCommentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionComment(this);
}

void MySQLParser::TsOptionCommentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionComment(this);
}

MySQLParser::TsOptionCommentContext* MySQLParser::tsOptionComment() {
  TsOptionCommentContext *_localctx = _tracker.createInstance<TsOptionCommentContext>(_ctx, getState());
  enterRule(_localctx, 158, MySQLParser::RuleTsOptionComment);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2303);
    match(MySQLParser::COMMENT_SYMBOL);
    setState(2305);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 173, _ctx)) {
    case 1: {
      setState(2304);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2307);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionFileblockSizeContext ------------------------------------------------------------------

MySQLParser::TsOptionFileblockSizeContext::TsOptionFileblockSizeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionFileblockSizeContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

MySQLParser::SizeNumberContext* MySQLParser::TsOptionFileblockSizeContext::sizeNumber() {
  return getRuleContext<MySQLParser::SizeNumberContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionFileblockSizeContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionFileblockSizeContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionFileblockSize;
}

void MySQLParser::TsOptionFileblockSizeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionFileblockSize(this);
}

void MySQLParser::TsOptionFileblockSizeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionFileblockSize(this);
}

MySQLParser::TsOptionFileblockSizeContext* MySQLParser::tsOptionFileblockSize() {
  TsOptionFileblockSizeContext *_localctx = _tracker.createInstance<TsOptionFileblockSizeContext>(_ctx, getState());
  enterRule(_localctx, 160, MySQLParser::RuleTsOptionFileblockSize);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2309);
    match(MySQLParser::FILE_BLOCK_SIZE_SYMBOL);
    setState(2311);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 174, _ctx)) {
    case 1: {
      setState(2310);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2313);
    sizeNumber();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TsOptionEncryptionContext ------------------------------------------------------------------

MySQLParser::TsOptionEncryptionContext::TsOptionEncryptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TsOptionEncryptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::TsOptionEncryptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::TsOptionEncryptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TsOptionEncryptionContext::getRuleIndex() const {
  return MySQLParser::RuleTsOptionEncryption;
}

void MySQLParser::TsOptionEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTsOptionEncryption(this);
}

void MySQLParser::TsOptionEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTsOptionEncryption(this);
}

MySQLParser::TsOptionEncryptionContext* MySQLParser::tsOptionEncryption() {
  TsOptionEncryptionContext *_localctx = _tracker.createInstance<TsOptionEncryptionContext>(_ctx, getState());
  enterRule(_localctx, 162, MySQLParser::RuleTsOptionEncryption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2315);
    match(MySQLParser::ENCRYPTION_SYMBOL);
    setState(2317);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 175, _ctx)) {
    case 1: {
      setState(2316);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(2319);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateViewContext ------------------------------------------------------------------

MySQLParser::CreateViewContext::CreateViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewNameContext* MySQLParser::CreateViewContext::viewName() {
  return getRuleContext<MySQLParser::ViewNameContext>(0);
}

MySQLParser::ViewTailContext* MySQLParser::CreateViewContext::viewTail() {
  return getRuleContext<MySQLParser::ViewTailContext>(0);
}

MySQLParser::ViewReplaceOrAlgorithmContext* MySQLParser::CreateViewContext::viewReplaceOrAlgorithm() {
  return getRuleContext<MySQLParser::ViewReplaceOrAlgorithmContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateViewContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::ViewSuidContext* MySQLParser::CreateViewContext::viewSuid() {
  return getRuleContext<MySQLParser::ViewSuidContext>(0);
}


size_t MySQLParser::CreateViewContext::getRuleIndex() const {
  return MySQLParser::RuleCreateView;
}

void MySQLParser::CreateViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateView(this);
}

void MySQLParser::CreateViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateView(this);
}

MySQLParser::CreateViewContext* MySQLParser::createView() {
  CreateViewContext *_localctx = _tracker.createInstance<CreateViewContext>(_ctx, getState());
  enterRule(_localctx, 164, MySQLParser::RuleCreateView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2322);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ALGORITHM_SYMBOL || _la == MySQLParser::OR_SYMBOL) {
      setState(2321);
      viewReplaceOrAlgorithm();
    }
    setState(2325);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2324);
      definerClause();
    }
    setState(2328);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQL_SYMBOL) {
      setState(2327);
      viewSuid();
    }
    setState(2330);
    match(MySQLParser::VIEW_SYMBOL);
    setState(2331);
    viewName();
    setState(2332);
    viewTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewReplaceOrAlgorithmContext ------------------------------------------------------------------

MySQLParser::ViewReplaceOrAlgorithmContext::ViewReplaceOrAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewReplaceOrAlgorithmContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewReplaceOrAlgorithmContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::ViewAlgorithmContext* MySQLParser::ViewReplaceOrAlgorithmContext::viewAlgorithm() {
  return getRuleContext<MySQLParser::ViewAlgorithmContext>(0);
}


size_t MySQLParser::ViewReplaceOrAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleViewReplaceOrAlgorithm;
}

void MySQLParser::ViewReplaceOrAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewReplaceOrAlgorithm(this);
}

void MySQLParser::ViewReplaceOrAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewReplaceOrAlgorithm(this);
}

MySQLParser::ViewReplaceOrAlgorithmContext* MySQLParser::viewReplaceOrAlgorithm() {
  ViewReplaceOrAlgorithmContext *_localctx = _tracker.createInstance<ViewReplaceOrAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 166, MySQLParser::RuleViewReplaceOrAlgorithm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2340);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::OR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2334);
        match(MySQLParser::OR_SYMBOL);
        setState(2335);
        match(MySQLParser::REPLACE_SYMBOL);
        setState(2337);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALGORITHM_SYMBOL) {
          setState(2336);
          viewAlgorithm();
        }
        break;
      }

      case MySQLParser::ALGORITHM_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2339);
        viewAlgorithm();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewAlgorithmContext ------------------------------------------------------------------

MySQLParser::ViewAlgorithmContext::ViewAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewAlgorithmContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}


size_t MySQLParser::ViewAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RuleViewAlgorithm;
}

void MySQLParser::ViewAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewAlgorithm(this);
}

void MySQLParser::ViewAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewAlgorithm(this);
}

MySQLParser::ViewAlgorithmContext* MySQLParser::viewAlgorithm() {
  ViewAlgorithmContext *_localctx = _tracker.createInstance<ViewAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 168, MySQLParser::RuleViewAlgorithm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2342);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(2343);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(2344);
    dynamic_cast<ViewAlgorithmContext *>(_localctx)->algorithm = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::MERGE_SYMBOL || _la == MySQLParser::TEMPTABLE_SYMBOL

    || _la == MySQLParser::UNDEFINED_SYMBOL)) {
      dynamic_cast<ViewAlgorithmContext *>(_localctx)->algorithm = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewSuidContext ------------------------------------------------------------------

MySQLParser::ViewSuidContext::ViewSuidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ViewSuidContext::SQL_SYMBOL() {
  return getToken(MySQLParser::SQL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewSuidContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewSuidContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ViewSuidContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}


size_t MySQLParser::ViewSuidContext::getRuleIndex() const {
  return MySQLParser::RuleViewSuid;
}

void MySQLParser::ViewSuidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewSuid(this);
}

void MySQLParser::ViewSuidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewSuid(this);
}

MySQLParser::ViewSuidContext* MySQLParser::viewSuid() {
  ViewSuidContext *_localctx = _tracker.createInstance<ViewSuidContext>(_ctx, getState());
  enterRule(_localctx, 170, MySQLParser::RuleViewSuid);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2346);
    match(MySQLParser::SQL_SYMBOL);
    setState(2347);
    match(MySQLParser::SECURITY_SYMBOL);
    setState(2348);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DEFINER_SYMBOL || _la == MySQLParser::INVOKER_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTriggerContext ------------------------------------------------------------------

MySQLParser::CreateTriggerContext::CreateTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

MySQLParser::TriggerNameContext* MySQLParser::CreateTriggerContext::triggerName() {
  return getRuleContext<MySQLParser::TriggerNameContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::CreateTriggerContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::EACH_SYMBOL() {
  return getToken(MySQLParser::EACH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateTriggerContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::BEFORE_SYMBOL() {
  return getToken(MySQLParser::BEFORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTriggerContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateTriggerContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::TriggerFollowsPrecedesClauseContext* MySQLParser::CreateTriggerContext::triggerFollowsPrecedesClause() {
  return getRuleContext<MySQLParser::TriggerFollowsPrecedesClauseContext>(0);
}


size_t MySQLParser::CreateTriggerContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTrigger;
}

void MySQLParser::CreateTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTrigger(this);
}

void MySQLParser::CreateTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTrigger(this);
}

MySQLParser::CreateTriggerContext* MySQLParser::createTrigger() {
  CreateTriggerContext *_localctx = _tracker.createInstance<CreateTriggerContext>(_ctx, getState());
  enterRule(_localctx, 172, MySQLParser::RuleCreateTrigger);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2351);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2350);
      definerClause();
    }
    setState(2353);
    match(MySQLParser::TRIGGER_SYMBOL);
    setState(2354);
    triggerName();
    setState(2355);
    dynamic_cast<CreateTriggerContext *>(_localctx)->timing = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::AFTER_SYMBOL

    || _la == MySQLParser::BEFORE_SYMBOL)) {
      dynamic_cast<CreateTriggerContext *>(_localctx)->timing = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2356);
    dynamic_cast<CreateTriggerContext *>(_localctx)->event = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DELETE_SYMBOL || _la == MySQLParser::INSERT_SYMBOL || _la == MySQLParser::UPDATE_SYMBOL)) {
      dynamic_cast<CreateTriggerContext *>(_localctx)->event = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2357);
    match(MySQLParser::ON_SYMBOL);
    setState(2358);
    tableRef();
    setState(2359);
    match(MySQLParser::FOR_SYMBOL);
    setState(2360);
    match(MySQLParser::EACH_SYMBOL);
    setState(2361);
    match(MySQLParser::ROW_SYMBOL);
    setState(2363);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 182, _ctx)) {
    case 1: {
      setState(2362);
      triggerFollowsPrecedesClause();
      break;
    }

    }
    setState(2365);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerFollowsPrecedesClauseContext ------------------------------------------------------------------

MySQLParser::TriggerFollowsPrecedesClauseContext::TriggerFollowsPrecedesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::TriggerFollowsPrecedesClauseContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::TriggerFollowsPrecedesClauseContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TriggerFollowsPrecedesClauseContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}


size_t MySQLParser::TriggerFollowsPrecedesClauseContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerFollowsPrecedesClause;
}

void MySQLParser::TriggerFollowsPrecedesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerFollowsPrecedesClause(this);
}

void MySQLParser::TriggerFollowsPrecedesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerFollowsPrecedesClause(this);
}

MySQLParser::TriggerFollowsPrecedesClauseContext* MySQLParser::triggerFollowsPrecedesClause() {
  TriggerFollowsPrecedesClauseContext *_localctx = _tracker.createInstance<TriggerFollowsPrecedesClauseContext>(_ctx, getState());
  enterRule(_localctx, 174, MySQLParser::RuleTriggerFollowsPrecedesClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2367);

    if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
    setState(2368);
    dynamic_cast<TriggerFollowsPrecedesClauseContext *>(_localctx)->ordering = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FOLLOWS_SYMBOL || _la == MySQLParser::PRECEDES_SYMBOL)) {
      dynamic_cast<TriggerFollowsPrecedesClauseContext *>(_localctx)->ordering = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2369);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateEventContext ------------------------------------------------------------------

MySQLParser::CreateEventContext::CreateEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventNameContext* MySQLParser::CreateEventContext::eventName() {
  return getRuleContext<MySQLParser::EventNameContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateEventContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateEventContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::CreateEventContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

MySQLParser::ScheduleContext* MySQLParser::CreateEventContext::schedule() {
  return getRuleContext<MySQLParser::ScheduleContext>(0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementContext* MySQLParser::CreateEventContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

MySQLParser::DefinerClauseContext* MySQLParser::CreateEventContext::definerClause() {
  return getRuleContext<MySQLParser::DefinerClauseContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateEventContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CreateEventContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateEventContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}


size_t MySQLParser::CreateEventContext::getRuleIndex() const {
  return MySQLParser::RuleCreateEvent;
}

void MySQLParser::CreateEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateEvent(this);
}

void MySQLParser::CreateEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateEvent(this);
}

MySQLParser::CreateEventContext* MySQLParser::createEvent() {
  CreateEventContext *_localctx = _tracker.createInstance<CreateEventContext>(_ctx, getState());
  enterRule(_localctx, 176, MySQLParser::RuleCreateEvent);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2372);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFINER_SYMBOL) {
      setState(2371);
      definerClause();
    }
    setState(2374);
    match(MySQLParser::EVENT_SYMBOL);
    setState(2376);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 184, _ctx)) {
    case 1: {
      setState(2375);
      ifNotExists();
      break;
    }

    }
    setState(2378);
    eventName();
    setState(2379);
    match(MySQLParser::ON_SYMBOL);
    setState(2380);
    match(MySQLParser::SCHEDULE_SYMBOL);
    setState(2381);
    schedule();
    setState(2388);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(2382);
      match(MySQLParser::ON_SYMBOL);
      setState(2383);
      match(MySQLParser::COMPLETION_SYMBOL);
      setState(2385);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(2384);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(2387);
      match(MySQLParser::PRESERVE_SYMBOL);
    }
    setState(2396);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ENABLE_SYMBOL: {
        setState(2390);
        match(MySQLParser::ENABLE_SYMBOL);
        break;
      }

      case MySQLParser::DISABLE_SYMBOL: {
        setState(2391);
        match(MySQLParser::DISABLE_SYMBOL);
        setState(2394);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ON_SYMBOL) {
          setState(2392);
          match(MySQLParser::ON_SYMBOL);
          setState(2393);
          match(MySQLParser::SLAVE_SYMBOL);
        }
        break;
      }

      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::DO_SYMBOL: {
        break;
      }

    default:
      break;
    }
    setState(2400);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMENT_SYMBOL) {
      setState(2398);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(2399);
      textLiteral();
    }
    setState(2402);
    match(MySQLParser::DO_SYMBOL);
    setState(2403);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateRoleContext ------------------------------------------------------------------

MySQLParser::CreateRoleContext::CreateRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::CreateRoleContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateRoleContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}


size_t MySQLParser::CreateRoleContext::getRuleIndex() const {
  return MySQLParser::RuleCreateRole;
}

void MySQLParser::CreateRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateRole(this);
}

void MySQLParser::CreateRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateRole(this);
}

MySQLParser::CreateRoleContext* MySQLParser::createRole() {
  CreateRoleContext *_localctx = _tracker.createInstance<CreateRoleContext>(_ctx, getState());
  enterRule(_localctx, 178, MySQLParser::RuleCreateRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2405);
    match(MySQLParser::ROLE_SYMBOL);
    setState(2407);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 190, _ctx)) {
    case 1: {
      setState(2406);
      ifNotExists();
      break;
    }

    }
    setState(2409);
    roleList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateSpatialReferenceContext ------------------------------------------------------------------

MySQLParser::CreateSpatialReferenceContext::CreateSpatialReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateSpatialReferenceContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::CreateSpatialReferenceContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

std::vector<MySQLParser::SrsAttributeContext *> MySQLParser::CreateSpatialReferenceContext::srsAttribute() {
  return getRuleContexts<MySQLParser::SrsAttributeContext>();
}

MySQLParser::SrsAttributeContext* MySQLParser::CreateSpatialReferenceContext::srsAttribute(size_t i) {
  return getRuleContext<MySQLParser::SrsAttributeContext>(i);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateSpatialReferenceContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}


size_t MySQLParser::CreateSpatialReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleCreateSpatialReference;
}

void MySQLParser::CreateSpatialReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateSpatialReference(this);
}

void MySQLParser::CreateSpatialReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateSpatialReference(this);
}

MySQLParser::CreateSpatialReferenceContext* MySQLParser::createSpatialReference() {
  CreateSpatialReferenceContext *_localctx = _tracker.createInstance<CreateSpatialReferenceContext>(_ctx, getState());
  enterRule(_localctx, 180, MySQLParser::RuleCreateSpatialReference);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2436);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::OR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2411);
        match(MySQLParser::OR_SYMBOL);
        setState(2412);
        match(MySQLParser::REPLACE_SYMBOL);
        setState(2413);
        match(MySQLParser::SPATIAL_SYMBOL);
        setState(2414);
        match(MySQLParser::REFERENCE_SYMBOL);
        setState(2415);
        match(MySQLParser::SYSTEM_SYMBOL);
        setState(2416);
        real_ulonglong_number();
        setState(2420);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::NAME_SYMBOL || ((((_la - 746) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 746)) & ((1ULL << (MySQLParser::DEFINITION_SYMBOL - 746))
          | (1ULL << (MySQLParser::DESCRIPTION_SYMBOL - 746))
          | (1ULL << (MySQLParser::ORGANIZATION_SYMBOL - 746)))) != 0)) {
          setState(2417);
          srsAttribute();
          setState(2422);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2423);
        match(MySQLParser::SPATIAL_SYMBOL);
        setState(2424);
        match(MySQLParser::REFERENCE_SYMBOL);
        setState(2425);
        match(MySQLParser::SYSTEM_SYMBOL);
        setState(2427);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 192, _ctx)) {
        case 1: {
          setState(2426);
          ifNotExists();
          break;
        }

        }
        setState(2429);
        real_ulonglong_number();
        setState(2433);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::NAME_SYMBOL || ((((_la - 746) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 746)) & ((1ULL << (MySQLParser::DEFINITION_SYMBOL - 746))
          | (1ULL << (MySQLParser::DESCRIPTION_SYMBOL - 746))
          | (1ULL << (MySQLParser::ORGANIZATION_SYMBOL - 746)))) != 0)) {
          setState(2430);
          srsAttribute();
          setState(2435);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SrsAttributeContext ------------------------------------------------------------------

MySQLParser::SrsAttributeContext::SrsAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::SrsAttributeContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::DEFINITION_SYMBOL() {
  return getToken(MySQLParser::DEFINITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::SrsAttributeContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::SrsAttributeContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}


size_t MySQLParser::SrsAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleSrsAttribute;
}

void MySQLParser::SrsAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSrsAttribute(this);
}

void MySQLParser::SrsAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSrsAttribute(this);
}

MySQLParser::SrsAttributeContext* MySQLParser::srsAttribute() {
  SrsAttributeContext *_localctx = _tracker.createInstance<SrsAttributeContext>(_ctx, getState());
  enterRule(_localctx, 182, MySQLParser::RuleSrsAttribute);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2453);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NAME_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2438);
        match(MySQLParser::NAME_SYMBOL);
        setState(2439);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2440);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::DEFINITION_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2441);
        match(MySQLParser::DEFINITION_SYMBOL);
        setState(2442);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2443);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::ORGANIZATION_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(2444);
        match(MySQLParser::ORGANIZATION_SYMBOL);
        setState(2445);
        textStringNoLinebreak();
        setState(2446);
        match(MySQLParser::IDENTIFIED_SYMBOL);
        setState(2447);
        match(MySQLParser::BY_SYMBOL);
        setState(2448);
        real_ulonglong_number();
        break;
      }

      case MySQLParser::DESCRIPTION_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(2450);
        match(MySQLParser::DESCRIPTION_SYMBOL);
        setState(2451);
        match(MySQLParser::TEXT_SYMBOL);
        setState(2452);
        textStringNoLinebreak();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropStatementContext ------------------------------------------------------------------

MySQLParser::DropStatementContext::DropStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropStatementContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

MySQLParser::DropDatabaseContext* MySQLParser::DropStatementContext::dropDatabase() {
  return getRuleContext<MySQLParser::DropDatabaseContext>(0);
}

MySQLParser::DropEventContext* MySQLParser::DropStatementContext::dropEvent() {
  return getRuleContext<MySQLParser::DropEventContext>(0);
}

MySQLParser::DropFunctionContext* MySQLParser::DropStatementContext::dropFunction() {
  return getRuleContext<MySQLParser::DropFunctionContext>(0);
}

MySQLParser::DropProcedureContext* MySQLParser::DropStatementContext::dropProcedure() {
  return getRuleContext<MySQLParser::DropProcedureContext>(0);
}

MySQLParser::DropIndexContext* MySQLParser::DropStatementContext::dropIndex() {
  return getRuleContext<MySQLParser::DropIndexContext>(0);
}

MySQLParser::DropLogfileGroupContext* MySQLParser::DropStatementContext::dropLogfileGroup() {
  return getRuleContext<MySQLParser::DropLogfileGroupContext>(0);
}

MySQLParser::DropServerContext* MySQLParser::DropStatementContext::dropServer() {
  return getRuleContext<MySQLParser::DropServerContext>(0);
}

MySQLParser::DropTableContext* MySQLParser::DropStatementContext::dropTable() {
  return getRuleContext<MySQLParser::DropTableContext>(0);
}

MySQLParser::DropTableSpaceContext* MySQLParser::DropStatementContext::dropTableSpace() {
  return getRuleContext<MySQLParser::DropTableSpaceContext>(0);
}

MySQLParser::DropTriggerContext* MySQLParser::DropStatementContext::dropTrigger() {
  return getRuleContext<MySQLParser::DropTriggerContext>(0);
}

MySQLParser::DropViewContext* MySQLParser::DropStatementContext::dropView() {
  return getRuleContext<MySQLParser::DropViewContext>(0);
}

MySQLParser::DropRoleContext* MySQLParser::DropStatementContext::dropRole() {
  return getRuleContext<MySQLParser::DropRoleContext>(0);
}

MySQLParser::DropSpatialReferenceContext* MySQLParser::DropStatementContext::dropSpatialReference() {
  return getRuleContext<MySQLParser::DropSpatialReferenceContext>(0);
}

MySQLParser::DropUndoTablespaceContext* MySQLParser::DropStatementContext::dropUndoTablespace() {
  return getRuleContext<MySQLParser::DropUndoTablespaceContext>(0);
}


size_t MySQLParser::DropStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDropStatement;
}

void MySQLParser::DropStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropStatement(this);
}

void MySQLParser::DropStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropStatement(this);
}

MySQLParser::DropStatementContext* MySQLParser::dropStatement() {
  DropStatementContext *_localctx = _tracker.createInstance<DropStatementContext>(_ctx, getState());
  enterRule(_localctx, 184, MySQLParser::RuleDropStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2455);
    match(MySQLParser::DROP_SYMBOL);
    setState(2473);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 196, _ctx)) {
    case 1: {
      setState(2456);
      dropDatabase();
      break;
    }

    case 2: {
      setState(2457);
      dropEvent();
      break;
    }

    case 3: {
      setState(2458);
      dropFunction();
      break;
    }

    case 4: {
      setState(2459);
      dropProcedure();
      break;
    }

    case 5: {
      setState(2460);
      dropIndex();
      break;
    }

    case 6: {
      setState(2461);
      dropLogfileGroup();
      break;
    }

    case 7: {
      setState(2462);
      dropServer();
      break;
    }

    case 8: {
      setState(2463);
      dropTable();
      break;
    }

    case 9: {
      setState(2464);
      dropTableSpace();
      break;
    }

    case 10: {
      setState(2465);
      dropTrigger();
      break;
    }

    case 11: {
      setState(2466);
      dropView();
      break;
    }

    case 12: {
      setState(2467);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(2468);
      dropRole();
      break;
    }

    case 13: {
      setState(2469);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(2470);
      dropSpatialReference();
      break;
    }

    case 14: {
      setState(2471);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(2472);
      dropUndoTablespace();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropDatabaseContext ------------------------------------------------------------------

MySQLParser::DropDatabaseContext::DropDatabaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropDatabaseContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

MySQLParser::SchemaRefContext* MySQLParser::DropDatabaseContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropDatabaseContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropDatabaseContext::getRuleIndex() const {
  return MySQLParser::RuleDropDatabase;
}

void MySQLParser::DropDatabaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropDatabase(this);
}

void MySQLParser::DropDatabaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropDatabase(this);
}

MySQLParser::DropDatabaseContext* MySQLParser::dropDatabase() {
  DropDatabaseContext *_localctx = _tracker.createInstance<DropDatabaseContext>(_ctx, getState());
  enterRule(_localctx, 186, MySQLParser::RuleDropDatabase);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2475);
    match(MySQLParser::DATABASE_SYMBOL);
    setState(2477);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 197, _ctx)) {
    case 1: {
      setState(2476);
      ifExists();
      break;
    }

    }
    setState(2479);
    schemaRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropEventContext ------------------------------------------------------------------

MySQLParser::DropEventContext::DropEventContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropEventContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

MySQLParser::EventRefContext* MySQLParser::DropEventContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropEventContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropEventContext::getRuleIndex() const {
  return MySQLParser::RuleDropEvent;
}

void MySQLParser::DropEventContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropEvent(this);
}

void MySQLParser::DropEventContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropEvent(this);
}

MySQLParser::DropEventContext* MySQLParser::dropEvent() {
  DropEventContext *_localctx = _tracker.createInstance<DropEventContext>(_ctx, getState());
  enterRule(_localctx, 188, MySQLParser::RuleDropEvent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2481);
    match(MySQLParser::EVENT_SYMBOL);
    setState(2483);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 198, _ctx)) {
    case 1: {
      setState(2482);
      ifExists();
      break;
    }

    }
    setState(2485);
    eventRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropFunctionContext ------------------------------------------------------------------

MySQLParser::DropFunctionContext::DropFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropFunctionContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::FunctionRefContext* MySQLParser::DropFunctionContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropFunctionContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleDropFunction;
}

void MySQLParser::DropFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropFunction(this);
}

void MySQLParser::DropFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropFunction(this);
}

MySQLParser::DropFunctionContext* MySQLParser::dropFunction() {
  DropFunctionContext *_localctx = _tracker.createInstance<DropFunctionContext>(_ctx, getState());
  enterRule(_localctx, 190, MySQLParser::RuleDropFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2487);
    match(MySQLParser::FUNCTION_SYMBOL);
    setState(2489);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 199, _ctx)) {
    case 1: {
      setState(2488);
      ifExists();
      break;
    }

    }
    setState(2491);
    functionRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropProcedureContext ------------------------------------------------------------------

MySQLParser::DropProcedureContext::DropProcedureContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropProcedureContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::DropProcedureContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropProcedureContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropProcedureContext::getRuleIndex() const {
  return MySQLParser::RuleDropProcedure;
}

void MySQLParser::DropProcedureContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropProcedure(this);
}

void MySQLParser::DropProcedureContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropProcedure(this);
}

MySQLParser::DropProcedureContext* MySQLParser::dropProcedure() {
  DropProcedureContext *_localctx = _tracker.createInstance<DropProcedureContext>(_ctx, getState());
  enterRule(_localctx, 192, MySQLParser::RuleDropProcedure);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2493);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(2495);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 200, _ctx)) {
    case 1: {
      setState(2494);
      ifExists();
      break;
    }

    }
    setState(2497);
    procedureRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropIndexContext ------------------------------------------------------------------

MySQLParser::DropIndexContext::DropIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexRefContext* MySQLParser::DropIndexContext::indexRef() {
  return getRuleContext<MySQLParser::IndexRefContext>(0);
}

tree::TerminalNode* MySQLParser::DropIndexContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::DropIndexContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::DropIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::OnlineOptionContext* MySQLParser::DropIndexContext::onlineOption() {
  return getRuleContext<MySQLParser::OnlineOptionContext>(0);
}

MySQLParser::IndexLockAndAlgorithmContext* MySQLParser::DropIndexContext::indexLockAndAlgorithm() {
  return getRuleContext<MySQLParser::IndexLockAndAlgorithmContext>(0);
}


size_t MySQLParser::DropIndexContext::getRuleIndex() const {
  return MySQLParser::RuleDropIndex;
}

void MySQLParser::DropIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropIndex(this);
}

void MySQLParser::DropIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropIndex(this);
}

MySQLParser::DropIndexContext* MySQLParser::dropIndex() {
  DropIndexContext *_localctx = _tracker.createInstance<DropIndexContext>(_ctx, getState());
  enterRule(_localctx, 194, MySQLParser::RuleDropIndex);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2500);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 201, _ctx)) {
    case 1: {
      setState(2499);
      onlineOption();
      break;
    }

    }
    setState(2502);
    dynamic_cast<DropIndexContext *>(_localctx)->type = match(MySQLParser::INDEX_SYMBOL);
    setState(2503);
    indexRef();
    setState(2504);
    match(MySQLParser::ON_SYMBOL);
    setState(2505);
    tableRef();
    setState(2507);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 202, _ctx)) {
    case 1: {
      setState(2506);
      indexLockAndAlgorithm();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupContext ------------------------------------------------------------------

MySQLParser::DropLogfileGroupContext::DropLogfileGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropLogfileGroupContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropLogfileGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::DropLogfileGroupContext::logfileGroupRef() {
  return getRuleContext<MySQLParser::LogfileGroupRefContext>(0);
}

std::vector<MySQLParser::DropLogfileGroupOptionContext *> MySQLParser::DropLogfileGroupContext::dropLogfileGroupOption() {
  return getRuleContexts<MySQLParser::DropLogfileGroupOptionContext>();
}

MySQLParser::DropLogfileGroupOptionContext* MySQLParser::DropLogfileGroupContext::dropLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::DropLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::DropLogfileGroupContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::DropLogfileGroupContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::DropLogfileGroupContext::getRuleIndex() const {
  return MySQLParser::RuleDropLogfileGroup;
}

void MySQLParser::DropLogfileGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroup(this);
}

void MySQLParser::DropLogfileGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroup(this);
}

MySQLParser::DropLogfileGroupContext* MySQLParser::dropLogfileGroup() {
  DropLogfileGroupContext *_localctx = _tracker.createInstance<DropLogfileGroupContext>(_ctx, getState());
  enterRule(_localctx, 196, MySQLParser::RuleDropLogfileGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2509);
    match(MySQLParser::LOGFILE_SYMBOL);
    setState(2510);
    match(MySQLParser::GROUP_SYMBOL);
    setState(2511);
    logfileGroupRef();
    setState(2522);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(2512);
      dropLogfileGroupOption();
      setState(2519);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
        setState(2514);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2513);
          match(MySQLParser::COMMA_SYMBOL);
        }
        setState(2516);
        dropLogfileGroupOption();
        setState(2521);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropLogfileGroupOptionContext ------------------------------------------------------------------

MySQLParser::DropLogfileGroupOptionContext::DropLogfileGroupOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TsOptionWaitContext* MySQLParser::DropLogfileGroupOptionContext::tsOptionWait() {
  return getRuleContext<MySQLParser::TsOptionWaitContext>(0);
}

MySQLParser::TsOptionEngineContext* MySQLParser::DropLogfileGroupOptionContext::tsOptionEngine() {
  return getRuleContext<MySQLParser::TsOptionEngineContext>(0);
}


size_t MySQLParser::DropLogfileGroupOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDropLogfileGroupOption;
}

void MySQLParser::DropLogfileGroupOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropLogfileGroupOption(this);
}

void MySQLParser::DropLogfileGroupOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropLogfileGroupOption(this);
}

MySQLParser::DropLogfileGroupOptionContext* MySQLParser::dropLogfileGroupOption() {
  DropLogfileGroupOptionContext *_localctx = _tracker.createInstance<DropLogfileGroupOptionContext>(_ctx, getState());
  enterRule(_localctx, 198, MySQLParser::RuleDropLogfileGroupOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2526);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::WAIT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(2524);
        tsOptionWait();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(2525);
        tsOptionEngine();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropServerContext ------------------------------------------------------------------

MySQLParser::DropServerContext::DropServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropServerContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

MySQLParser::ServerRefContext* MySQLParser::DropServerContext::serverRef() {
  return getRuleContext<MySQLParser::ServerRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropServerContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropServerContext::getRuleIndex() const {
  return MySQLParser::RuleDropServer;
}

void MySQLParser::DropServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropServer(this);
}

void MySQLParser::DropServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropServer(this);
}

MySQLParser::DropServerContext* MySQLParser::dropServer() {
  DropServerContext *_localctx = _tracker.createInstance<DropServerContext>(_ctx, getState());
  enterRule(_localctx, 200, MySQLParser::RuleDropServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2528);
    match(MySQLParser::SERVER_SYMBOL);
    setState(2530);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 207, _ctx)) {
    case 1: {
      setState(2529);
      ifExists();
      break;
    }

    }
    setState(2532);
    serverRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableContext ------------------------------------------------------------------

MySQLParser::DropTableContext::DropTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefListContext* MySQLParser::DropTableContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode* MySQLParser::DropTableContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropTableContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropTableContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

MySQLParser::IfExistsContext* MySQLParser::DropTableContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

tree::TerminalNode* MySQLParser::DropTableContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropTableContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}


size_t MySQLParser::DropTableContext::getRuleIndex() const {
  return MySQLParser::RuleDropTable;
}

void MySQLParser::DropTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTable(this);
}

void MySQLParser::DropTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTable(this);
}

MySQLParser::DropTableContext* MySQLParser::dropTable() {
  DropTableContext *_localctx = _tracker.createInstance<DropTableContext>(_ctx, getState());
  enterRule(_localctx, 202, MySQLParser::RuleDropTable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2535);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::TEMPORARY_SYMBOL) {
      setState(2534);
      match(MySQLParser::TEMPORARY_SYMBOL);
    }
    setState(2537);
    dynamic_cast<DropTableContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL

    || _la == MySQLParser::TABLE_SYMBOL)) {
      dynamic_cast<DropTableContext *>(_localctx)->type = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2539);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 209, _ctx)) {
    case 1: {
      setState(2538);
      ifExists();
      break;
    }

    }
    setState(2541);
    tableRefList();
    setState(2543);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
      setState(2542);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTableSpaceContext ------------------------------------------------------------------

MySQLParser::DropTableSpaceContext::DropTableSpaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropTableSpaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::DropTableSpaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

std::vector<MySQLParser::DropLogfileGroupOptionContext *> MySQLParser::DropTableSpaceContext::dropLogfileGroupOption() {
  return getRuleContexts<MySQLParser::DropLogfileGroupOptionContext>();
}

MySQLParser::DropLogfileGroupOptionContext* MySQLParser::DropTableSpaceContext::dropLogfileGroupOption(size_t i) {
  return getRuleContext<MySQLParser::DropLogfileGroupOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::DropTableSpaceContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::DropTableSpaceContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::DropTableSpaceContext::getRuleIndex() const {
  return MySQLParser::RuleDropTableSpace;
}

void MySQLParser::DropTableSpaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTableSpace(this);
}

void MySQLParser::DropTableSpaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTableSpace(this);
}

MySQLParser::DropTableSpaceContext* MySQLParser::dropTableSpace() {
  DropTableSpaceContext *_localctx = _tracker.createInstance<DropTableSpaceContext>(_ctx, getState());
  enterRule(_localctx, 204, MySQLParser::RuleDropTableSpace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2545);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2546);
    tablespaceRef();
    setState(2557);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
      setState(2547);
      dropLogfileGroupOption();
      setState(2554);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::NO_WAIT_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL || _la == MySQLParser::WAIT_SYMBOL) {
        setState(2549);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(2548);
          match(MySQLParser::COMMA_SYMBOL);
        }
        setState(2551);
        dropLogfileGroupOption();
        setState(2556);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropTriggerContext ------------------------------------------------------------------

MySQLParser::DropTriggerContext::DropTriggerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropTriggerContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

MySQLParser::TriggerRefContext* MySQLParser::DropTriggerContext::triggerRef() {
  return getRuleContext<MySQLParser::TriggerRefContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropTriggerContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropTriggerContext::getRuleIndex() const {
  return MySQLParser::RuleDropTrigger;
}

void MySQLParser::DropTriggerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropTrigger(this);
}

void MySQLParser::DropTriggerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropTrigger(this);
}

MySQLParser::DropTriggerContext* MySQLParser::dropTrigger() {
  DropTriggerContext *_localctx = _tracker.createInstance<DropTriggerContext>(_ctx, getState());
  enterRule(_localctx, 206, MySQLParser::RuleDropTrigger);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2559);
    match(MySQLParser::TRIGGER_SYMBOL);
    setState(2561);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 214, _ctx)) {
    case 1: {
      setState(2560);
      ifExists();
      break;
    }

    }
    setState(2563);
    triggerRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropViewContext ------------------------------------------------------------------

MySQLParser::DropViewContext::DropViewContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropViewContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

MySQLParser::ViewRefListContext* MySQLParser::DropViewContext::viewRefList() {
  return getRuleContext<MySQLParser::ViewRefListContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropViewContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

tree::TerminalNode* MySQLParser::DropViewContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropViewContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}


size_t MySQLParser::DropViewContext::getRuleIndex() const {
  return MySQLParser::RuleDropView;
}

void MySQLParser::DropViewContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropView(this);
}

void MySQLParser::DropViewContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropView(this);
}

MySQLParser::DropViewContext* MySQLParser::dropView() {
  DropViewContext *_localctx = _tracker.createInstance<DropViewContext>(_ctx, getState());
  enterRule(_localctx, 208, MySQLParser::RuleDropView);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2565);
    match(MySQLParser::VIEW_SYMBOL);
    setState(2567);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 215, _ctx)) {
    case 1: {
      setState(2566);
      ifExists();
      break;
    }

    }
    setState(2569);
    viewRefList();
    setState(2571);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL) {
      setState(2570);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropRoleContext ------------------------------------------------------------------

MySQLParser::DropRoleContext::DropRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::DropRoleContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropRoleContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropRoleContext::getRuleIndex() const {
  return MySQLParser::RuleDropRole;
}

void MySQLParser::DropRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropRole(this);
}

void MySQLParser::DropRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropRole(this);
}

MySQLParser::DropRoleContext* MySQLParser::dropRole() {
  DropRoleContext *_localctx = _tracker.createInstance<DropRoleContext>(_ctx, getState());
  enterRule(_localctx, 210, MySQLParser::RuleDropRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2573);
    match(MySQLParser::ROLE_SYMBOL);
    setState(2575);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 217, _ctx)) {
    case 1: {
      setState(2574);
      ifExists();
      break;
    }

    }
    setState(2577);
    roleList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropSpatialReferenceContext ------------------------------------------------------------------

MySQLParser::DropSpatialReferenceContext::DropSpatialReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropSpatialReferenceContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropSpatialReferenceContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropSpatialReferenceContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::DropSpatialReferenceContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropSpatialReferenceContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropSpatialReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleDropSpatialReference;
}

void MySQLParser::DropSpatialReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropSpatialReference(this);
}

void MySQLParser::DropSpatialReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropSpatialReference(this);
}

MySQLParser::DropSpatialReferenceContext* MySQLParser::dropSpatialReference() {
  DropSpatialReferenceContext *_localctx = _tracker.createInstance<DropSpatialReferenceContext>(_ctx, getState());
  enterRule(_localctx, 212, MySQLParser::RuleDropSpatialReference);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2579);
    match(MySQLParser::SPATIAL_SYMBOL);
    setState(2580);
    match(MySQLParser::REFERENCE_SYMBOL);
    setState(2581);
    match(MySQLParser::SYSTEM_SYMBOL);
    setState(2583);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 218, _ctx)) {
    case 1: {
      setState(2582);
      ifExists();
      break;
    }

    }
    setState(2585);
    real_ulonglong_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUndoTablespaceContext ------------------------------------------------------------------

MySQLParser::DropUndoTablespaceContext::DropUndoTablespaceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropUndoTablespaceContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropUndoTablespaceContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

MySQLParser::TablespaceRefContext* MySQLParser::DropUndoTablespaceContext::tablespaceRef() {
  return getRuleContext<MySQLParser::TablespaceRefContext>(0);
}

MySQLParser::UndoTableSpaceOptionsContext* MySQLParser::DropUndoTablespaceContext::undoTableSpaceOptions() {
  return getRuleContext<MySQLParser::UndoTableSpaceOptionsContext>(0);
}


size_t MySQLParser::DropUndoTablespaceContext::getRuleIndex() const {
  return MySQLParser::RuleDropUndoTablespace;
}

void MySQLParser::DropUndoTablespaceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUndoTablespace(this);
}

void MySQLParser::DropUndoTablespaceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUndoTablespace(this);
}

MySQLParser::DropUndoTablespaceContext* MySQLParser::dropUndoTablespace() {
  DropUndoTablespaceContext *_localctx = _tracker.createInstance<DropUndoTablespaceContext>(_ctx, getState());
  enterRule(_localctx, 214, MySQLParser::RuleDropUndoTablespace);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2587);
    match(MySQLParser::UNDO_SYMBOL);
    setState(2588);
    match(MySQLParser::TABLESPACE_SYMBOL);
    setState(2589);
    tablespaceRef();
    setState(2591);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::STORAGE_SYMBOL) {
      setState(2590);
      undoTableSpaceOptions();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameTableStatementContext ------------------------------------------------------------------

MySQLParser::RenameTableStatementContext::RenameTableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

std::vector<MySQLParser::RenamePairContext *> MySQLParser::RenameTableStatementContext::renamePair() {
  return getRuleContexts<MySQLParser::RenamePairContext>();
}

MySQLParser::RenamePairContext* MySQLParser::RenameTableStatementContext::renamePair(size_t i) {
  return getRuleContext<MySQLParser::RenamePairContext>(i);
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameTableStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RenameTableStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RenameTableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleRenameTableStatement;
}

void MySQLParser::RenameTableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameTableStatement(this);
}

void MySQLParser::RenameTableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameTableStatement(this);
}

MySQLParser::RenameTableStatementContext* MySQLParser::renameTableStatement() {
  RenameTableStatementContext *_localctx = _tracker.createInstance<RenameTableStatementContext>(_ctx, getState());
  enterRule(_localctx, 216, MySQLParser::RuleRenameTableStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2593);
    match(MySQLParser::RENAME_SYMBOL);
    setState(2594);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL

    || _la == MySQLParser::TABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2595);
    renamePair();
    setState(2600);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2596);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2597);
      renamePair();
      setState(2602);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenamePairContext ------------------------------------------------------------------

MySQLParser::RenamePairContext::RenamePairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::RenamePairContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::RenamePairContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TableNameContext* MySQLParser::RenamePairContext::tableName() {
  return getRuleContext<MySQLParser::TableNameContext>(0);
}


size_t MySQLParser::RenamePairContext::getRuleIndex() const {
  return MySQLParser::RuleRenamePair;
}

void MySQLParser::RenamePairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenamePair(this);
}

void MySQLParser::RenamePairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenamePair(this);
}

MySQLParser::RenamePairContext* MySQLParser::renamePair() {
  RenamePairContext *_localctx = _tracker.createInstance<RenamePairContext>(_ctx, getState());
  enterRule(_localctx, 218, MySQLParser::RuleRenamePair);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2603);
    tableRef();
    setState(2604);
    match(MySQLParser::TO_SYMBOL);
    setState(2605);
    tableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TruncateTableStatementContext ------------------------------------------------------------------

MySQLParser::TruncateTableStatementContext::TruncateTableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TruncateTableStatementContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::TruncateTableStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::TruncateTableStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}


size_t MySQLParser::TruncateTableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTruncateTableStatement;
}

void MySQLParser::TruncateTableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTruncateTableStatement(this);
}

void MySQLParser::TruncateTableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTruncateTableStatement(this);
}

MySQLParser::TruncateTableStatementContext* MySQLParser::truncateTableStatement() {
  TruncateTableStatementContext *_localctx = _tracker.createInstance<TruncateTableStatementContext>(_ctx, getState());
  enterRule(_localctx, 220, MySQLParser::RuleTruncateTableStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2607);
    match(MySQLParser::TRUNCATE_SYMBOL);
    setState(2609);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 221, _ctx)) {
    case 1: {
      setState(2608);
      match(MySQLParser::TABLE_SYMBOL);
      break;
    }

    }
    setState(2611);
    tableRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ImportStatementContext ------------------------------------------------------------------

MySQLParser::ImportStatementContext::ImportStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ImportStatementContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ImportStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ImportStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::TextStringLiteralListContext* MySQLParser::ImportStatementContext::textStringLiteralList() {
  return getRuleContext<MySQLParser::TextStringLiteralListContext>(0);
}


size_t MySQLParser::ImportStatementContext::getRuleIndex() const {
  return MySQLParser::RuleImportStatement;
}

void MySQLParser::ImportStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterImportStatement(this);
}

void MySQLParser::ImportStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitImportStatement(this);
}

MySQLParser::ImportStatementContext* MySQLParser::importStatement() {
  ImportStatementContext *_localctx = _tracker.createInstance<ImportStatementContext>(_ctx, getState());
  enterRule(_localctx, 222, MySQLParser::RuleImportStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2613);
    match(MySQLParser::IMPORT_SYMBOL);
    setState(2614);
    match(MySQLParser::TABLE_SYMBOL);
    setState(2615);
    match(MySQLParser::FROM_SYMBOL);
    setState(2616);
    textStringLiteralList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CallStatementContext ------------------------------------------------------------------

MySQLParser::CallStatementContext::CallStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CallStatementContext::CALL_SYMBOL() {
  return getToken(MySQLParser::CALL_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::CallStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

tree::TerminalNode* MySQLParser::CallStatementContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CallStatementContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::CallStatementContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}


size_t MySQLParser::CallStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCallStatement;
}

void MySQLParser::CallStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCallStatement(this);
}

void MySQLParser::CallStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCallStatement(this);
}

MySQLParser::CallStatementContext* MySQLParser::callStatement() {
  CallStatementContext *_localctx = _tracker.createInstance<CallStatementContext>(_ctx, getState());
  enterRule(_localctx, 224, MySQLParser::RuleCallStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2618);
    match(MySQLParser::CALL_SYMBOL);
    setState(2619);
    procedureRef();
    setState(2625);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2620);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2622);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 222, _ctx)) {
      case 1: {
        setState(2621);
        exprList();
        break;
      }

      }
      setState(2624);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementContext ------------------------------------------------------------------

MySQLParser::DeleteStatementContext::DeleteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DeleteStatementContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::TableAliasRefListContext* MySQLParser::DeleteStatementContext::tableAliasRefList() {
  return getRuleContext<MySQLParser::TableAliasRefListContext>(0);
}

MySQLParser::TableReferenceListContext* MySQLParser::DeleteStatementContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

MySQLParser::WithClauseContext* MySQLParser::DeleteStatementContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

std::vector<MySQLParser::DeleteStatementOptionContext *> MySQLParser::DeleteStatementContext::deleteStatementOption() {
  return getRuleContexts<MySQLParser::DeleteStatementOptionContext>();
}

MySQLParser::DeleteStatementOptionContext* MySQLParser::DeleteStatementContext::deleteStatementOption(size_t i) {
  return getRuleContext<MySQLParser::DeleteStatementOptionContext>(i);
}

tree::TerminalNode* MySQLParser::DeleteStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::DeleteStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::DeleteStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::DeleteStatementContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::PartitionDeleteContext* MySQLParser::DeleteStatementContext::partitionDelete() {
  return getRuleContext<MySQLParser::PartitionDeleteContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::DeleteStatementContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::SimpleLimitClauseContext* MySQLParser::DeleteStatementContext::simpleLimitClause() {
  return getRuleContext<MySQLParser::SimpleLimitClauseContext>(0);
}


size_t MySQLParser::DeleteStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteStatement;
}

void MySQLParser::DeleteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteStatement(this);
}

void MySQLParser::DeleteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteStatement(this);
}

MySQLParser::DeleteStatementContext* MySQLParser::deleteStatement() {
  DeleteStatementContext *_localctx = _tracker.createInstance<DeleteStatementContext>(_ctx, getState());
  enterRule(_localctx, 226, MySQLParser::RuleDeleteStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2629);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 224, _ctx)) {
    case 1: {
      setState(2627);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(2628);
      withClause();
      break;
    }

    }
    setState(2631);
    match(MySQLParser::DELETE_SYMBOL);
    setState(2635);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2632);
        deleteStatementOption(); 
      }
      setState(2637);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 225, _ctx);
    }
    setState(2670);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 234, _ctx)) {
    case 1: {
      setState(2638);
      match(MySQLParser::FROM_SYMBOL);
      setState(2662);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 232, _ctx)) {
      case 1: {
        setState(2639);
        tableAliasRefList();
        setState(2640);
        match(MySQLParser::USING_SYMBOL);
        setState(2641);
        tableReferenceList();
        setState(2643);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WHERE_SYMBOL) {
          setState(2642);
          whereClause();
        }
        break;
      }

      case 2: {
        setState(2645);
        tableRef();
        setState(2648);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 227, _ctx)) {
        case 1: {
          setState(2646);

          if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
          setState(2647);
          tableAlias();
          break;
        }

        }
        setState(2651);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 228, _ctx)) {
        case 1: {
          setState(2650);
          partitionDelete();
          break;
        }

        }
        setState(2654);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WHERE_SYMBOL) {
          setState(2653);
          whereClause();
        }
        setState(2657);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ORDER_SYMBOL) {
          setState(2656);
          orderClause();
        }
        setState(2660);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LIMIT_SYMBOL) {
          setState(2659);
          simpleLimitClause();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2664);
      tableAliasRefList();
      setState(2665);
      match(MySQLParser::FROM_SYMBOL);
      setState(2666);
      tableReferenceList();
      setState(2668);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WHERE_SYMBOL) {
        setState(2667);
        whereClause();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDeleteContext ------------------------------------------------------------------

MySQLParser::PartitionDeleteContext::PartitionDeleteContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionDeleteContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDeleteContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::PartitionDeleteContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDeleteContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::PartitionDeleteContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDelete;
}

void MySQLParser::PartitionDeleteContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDelete(this);
}

void MySQLParser::PartitionDeleteContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDelete(this);
}

MySQLParser::PartitionDeleteContext* MySQLParser::partitionDelete() {
  PartitionDeleteContext *_localctx = _tracker.createInstance<PartitionDeleteContext>(_ctx, getState());
  enterRule(_localctx, 228, MySQLParser::RulePartitionDelete);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2672);

    if (!(serverVersion >= 50602)) throw FailedPredicateException(this, "serverVersion >= 50602");
    setState(2673);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(2674);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2675);
    identifierList();
    setState(2676);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteStatementOptionContext ------------------------------------------------------------------

MySQLParser::DeleteStatementOptionContext::DeleteStatementOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DeleteStatementOptionContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteStatementOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteStatementOptionContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::DeleteStatementOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteStatementOption;
}

void MySQLParser::DeleteStatementOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteStatementOption(this);
}

void MySQLParser::DeleteStatementOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteStatementOption(this);
}

MySQLParser::DeleteStatementOptionContext* MySQLParser::deleteStatementOption() {
  DeleteStatementOptionContext *_localctx = _tracker.createInstance<DeleteStatementOptionContext>(_ctx, getState());
  enterRule(_localctx, 230, MySQLParser::RuleDeleteStatementOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2678);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::IGNORE_SYMBOL

    || _la == MySQLParser::LOW_PRIORITY_SYMBOL || _la == MySQLParser::QUICK_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DoStatementContext ------------------------------------------------------------------

MySQLParser::DoStatementContext::DoStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DoStatementContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::DoStatementContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

MySQLParser::SelectItemListContext* MySQLParser::DoStatementContext::selectItemList() {
  return getRuleContext<MySQLParser::SelectItemListContext>(0);
}


size_t MySQLParser::DoStatementContext::getRuleIndex() const {
  return MySQLParser::RuleDoStatement;
}

void MySQLParser::DoStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDoStatement(this);
}

void MySQLParser::DoStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDoStatement(this);
}

MySQLParser::DoStatementContext* MySQLParser::doStatement() {
  DoStatementContext *_localctx = _tracker.createInstance<DoStatementContext>(_ctx, getState());
  enterRule(_localctx, 232, MySQLParser::RuleDoStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2680);
    match(MySQLParser::DO_SYMBOL);
    setState(2685);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 235, _ctx)) {
    case 1: {
      setState(2681);

      if (!(serverVersion < 50709)) throw FailedPredicateException(this, "serverVersion < 50709");
      setState(2682);
      exprList();
      break;
    }

    case 2: {
      setState(2683);

      if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
      setState(2684);
      selectItemList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerStatementContext ------------------------------------------------------------------

MySQLParser::HandlerStatementContext::HandlerStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::HandlerStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::HandlerStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerStatementContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

MySQLParser::HandlerReadOrScanContext* MySQLParser::HandlerStatementContext::handlerReadOrScan() {
  return getRuleContext<MySQLParser::HandlerReadOrScanContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::HandlerStatementContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::HandlerStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::LimitClauseContext* MySQLParser::HandlerStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}


size_t MySQLParser::HandlerStatementContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerStatement;
}

void MySQLParser::HandlerStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerStatement(this);
}

void MySQLParser::HandlerStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerStatement(this);
}

MySQLParser::HandlerStatementContext* MySQLParser::handlerStatement() {
  HandlerStatementContext *_localctx = _tracker.createInstance<HandlerStatementContext>(_ctx, getState());
  enterRule(_localctx, 234, MySQLParser::RuleHandlerStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2687);
    match(MySQLParser::HANDLER_SYMBOL);
    setState(2705);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 240, _ctx)) {
    case 1: {
      setState(2688);
      tableRef();
      setState(2689);
      match(MySQLParser::OPEN_SYMBOL);
      setState(2691);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 236, _ctx)) {
      case 1: {
        setState(2690);
        tableAlias();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(2693);
      identifier();
      setState(2703);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::CLOSE_SYMBOL: {
          setState(2694);
          match(MySQLParser::CLOSE_SYMBOL);
          break;
        }

        case MySQLParser::READ_SYMBOL: {
          setState(2695);
          match(MySQLParser::READ_SYMBOL);
          setState(2696);
          handlerReadOrScan();
          setState(2698);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::WHERE_SYMBOL) {
            setState(2697);
            whereClause();
          }
          setState(2701);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::LIMIT_SYMBOL) {
            setState(2700);
            limitClause();
          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerReadOrScanContext ------------------------------------------------------------------

MySQLParser::HandlerReadOrScanContext::HandlerReadOrScanContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::HandlerReadOrScanContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ValuesContext* MySQLParser::HandlerReadOrScanContext::values() {
  return getRuleContext<MySQLParser::ValuesContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::LESS_THAN_OPERATOR() {
  return getToken(MySQLParser::LESS_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::GREATER_THAN_OPERATOR() {
  return getToken(MySQLParser::GREATER_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::LESS_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::LESS_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::HandlerReadOrScanContext::GREATER_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::GREATER_OR_EQUAL_OPERATOR, 0);
}


size_t MySQLParser::HandlerReadOrScanContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerReadOrScan;
}

void MySQLParser::HandlerReadOrScanContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerReadOrScan(this);
}

void MySQLParser::HandlerReadOrScanContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerReadOrScan(this);
}

MySQLParser::HandlerReadOrScanContext* MySQLParser::handlerReadOrScan() {
  HandlerReadOrScanContext *_localctx = _tracker.createInstance<HandlerReadOrScanContext>(_ctx, getState());
  enterRule(_localctx, 236, MySQLParser::RuleHandlerReadOrScan);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2717);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 242, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2707);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::NEXT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2708);
      identifier();
      setState(2715);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::FIRST_SYMBOL:
        case MySQLParser::LAST_SYMBOL:
        case MySQLParser::NEXT_SYMBOL:
        case MySQLParser::PREV_SYMBOL: {
          setState(2709);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::LAST_SYMBOL || _la == MySQLParser::NEXT_SYMBOL

          || _la == MySQLParser::PREV_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          break;
        }

        case MySQLParser::EQUAL_OPERATOR:
        case MySQLParser::GREATER_OR_EQUAL_OPERATOR:
        case MySQLParser::GREATER_THAN_OPERATOR:
        case MySQLParser::LESS_OR_EQUAL_OPERATOR:
        case MySQLParser::LESS_THAN_OPERATOR: {
          setState(2710);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & ((1ULL << MySQLParser::EQUAL_OPERATOR)
            | (1ULL << MySQLParser::GREATER_OR_EQUAL_OPERATOR)
            | (1ULL << MySQLParser::GREATER_THAN_OPERATOR)
            | (1ULL << MySQLParser::LESS_OR_EQUAL_OPERATOR)
            | (1ULL << MySQLParser::LESS_THAN_OPERATOR))) != 0))) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(2711);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(2712);
          values();
          setState(2713);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertStatementContext ------------------------------------------------------------------

MySQLParser::InsertStatementContext::InsertStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InsertStatementContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::InsertStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::InsertFromConstructorContext* MySQLParser::InsertStatementContext::insertFromConstructor() {
  return getRuleContext<MySQLParser::InsertFromConstructorContext>(0);
}

tree::TerminalNode* MySQLParser::InsertStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::InsertStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::InsertQueryExpressionContext* MySQLParser::InsertStatementContext::insertQueryExpression() {
  return getRuleContext<MySQLParser::InsertQueryExpressionContext>(0);
}

MySQLParser::InsertLockOptionContext* MySQLParser::InsertStatementContext::insertLockOption() {
  return getRuleContext<MySQLParser::InsertLockOptionContext>(0);
}

tree::TerminalNode* MySQLParser::InsertStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::UsePartitionContext* MySQLParser::InsertStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::InsertUpdateListContext* MySQLParser::InsertStatementContext::insertUpdateList() {
  return getRuleContext<MySQLParser::InsertUpdateListContext>(0);
}


size_t MySQLParser::InsertStatementContext::getRuleIndex() const {
  return MySQLParser::RuleInsertStatement;
}

void MySQLParser::InsertStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertStatement(this);
}

void MySQLParser::InsertStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertStatement(this);
}

MySQLParser::InsertStatementContext* MySQLParser::insertStatement() {
  InsertStatementContext *_localctx = _tracker.createInstance<InsertStatementContext>(_ctx, getState());
  enterRule(_localctx, 238, MySQLParser::RuleInsertStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2719);
    match(MySQLParser::INSERT_SYMBOL);
    setState(2721);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 243, _ctx)) {
    case 1: {
      setState(2720);
      insertLockOption();
      break;
    }

    }
    setState(2724);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 244, _ctx)) {
    case 1: {
      setState(2723);
      match(MySQLParser::IGNORE_SYMBOL);
      break;
    }

    }
    setState(2727);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 245, _ctx)) {
    case 1: {
      setState(2726);
      match(MySQLParser::INTO_SYMBOL);
      break;
    }

    }
    setState(2729);
    tableRef();
    setState(2731);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 246, _ctx)) {
    case 1: {
      setState(2730);
      usePartition();
      break;
    }

    }
    setState(2737);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 247, _ctx)) {
    case 1: {
      setState(2733);
      insertFromConstructor();
      break;
    }

    case 2: {
      setState(2734);
      match(MySQLParser::SET_SYMBOL);
      setState(2735);
      updateList();
      break;
    }

    case 3: {
      setState(2736);
      insertQueryExpression();
      break;
    }

    }
    setState(2740);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ON_SYMBOL) {
      setState(2739);
      insertUpdateList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertLockOptionContext ------------------------------------------------------------------

MySQLParser::InsertLockOptionContext::InsertLockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InsertLockOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertLockOptionContext::DELAYED_SYMBOL() {
  return getToken(MySQLParser::DELAYED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertLockOptionContext::HIGH_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::HIGH_PRIORITY_SYMBOL, 0);
}


size_t MySQLParser::InsertLockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleInsertLockOption;
}

void MySQLParser::InsertLockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertLockOption(this);
}

void MySQLParser::InsertLockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertLockOption(this);
}

MySQLParser::InsertLockOptionContext* MySQLParser::insertLockOption() {
  InsertLockOptionContext *_localctx = _tracker.createInstance<InsertLockOptionContext>(_ctx, getState());
  enterRule(_localctx, 240, MySQLParser::RuleInsertLockOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2742);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DELAYED_SYMBOL || _la == MySQLParser::HIGH_PRIORITY_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertFromConstructorContext ------------------------------------------------------------------

MySQLParser::InsertFromConstructorContext::InsertFromConstructorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InsertValuesContext* MySQLParser::InsertFromConstructorContext::insertValues() {
  return getRuleContext<MySQLParser::InsertValuesContext>(0);
}

tree::TerminalNode* MySQLParser::InsertFromConstructorContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertFromConstructorContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldsContext* MySQLParser::InsertFromConstructorContext::fields() {
  return getRuleContext<MySQLParser::FieldsContext>(0);
}


size_t MySQLParser::InsertFromConstructorContext::getRuleIndex() const {
  return MySQLParser::RuleInsertFromConstructor;
}

void MySQLParser::InsertFromConstructorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertFromConstructor(this);
}

void MySQLParser::InsertFromConstructorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertFromConstructor(this);
}

MySQLParser::InsertFromConstructorContext* MySQLParser::insertFromConstructor() {
  InsertFromConstructorContext *_localctx = _tracker.createInstance<InsertFromConstructorContext>(_ctx, getState());
  enterRule(_localctx, 242, MySQLParser::RuleInsertFromConstructor);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2749);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2744);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2746);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 249, _ctx)) {
      case 1: {
        setState(2745);
        fields();
        break;
      }

      }
      setState(2748);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }
    setState(2751);
    insertValues();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldsContext ------------------------------------------------------------------

MySQLParser::FieldsContext::FieldsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::InsertIdentifierContext *> MySQLParser::FieldsContext::insertIdentifier() {
  return getRuleContexts<MySQLParser::InsertIdentifierContext>();
}

MySQLParser::InsertIdentifierContext* MySQLParser::FieldsContext::insertIdentifier(size_t i) {
  return getRuleContext<MySQLParser::InsertIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FieldsContext::getRuleIndex() const {
  return MySQLParser::RuleFields;
}

void MySQLParser::FieldsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFields(this);
}

void MySQLParser::FieldsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFields(this);
}

MySQLParser::FieldsContext* MySQLParser::fields() {
  FieldsContext *_localctx = _tracker.createInstance<FieldsContext>(_ctx, getState());
  enterRule(_localctx, 244, MySQLParser::RuleFields);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2753);
    insertIdentifier();
    setState(2758);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2754);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2755);
      insertIdentifier();
      setState(2760);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertValuesContext ------------------------------------------------------------------

MySQLParser::InsertValuesContext::InsertValuesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ValueListContext* MySQLParser::InsertValuesContext::valueList() {
  return getRuleContext<MySQLParser::ValueListContext>(0);
}

tree::TerminalNode* MySQLParser::InsertValuesContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertValuesContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}


size_t MySQLParser::InsertValuesContext::getRuleIndex() const {
  return MySQLParser::RuleInsertValues;
}

void MySQLParser::InsertValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertValues(this);
}

void MySQLParser::InsertValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertValues(this);
}

MySQLParser::InsertValuesContext* MySQLParser::insertValues() {
  InsertValuesContext *_localctx = _tracker.createInstance<InsertValuesContext>(_ctx, getState());
  enterRule(_localctx, 246, MySQLParser::RuleInsertValues);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2761);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::VALUES_SYMBOL

    || _la == MySQLParser::VALUE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(2762);
    valueList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertQueryExpressionContext ------------------------------------------------------------------

MySQLParser::InsertQueryExpressionContext::InsertQueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionOrParensContext* MySQLParser::InsertQueryExpressionContext::queryExpressionOrParens() {
  return getRuleContext<MySQLParser::QueryExpressionOrParensContext>(0);
}

tree::TerminalNode* MySQLParser::InsertQueryExpressionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertQueryExpressionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldsContext* MySQLParser::InsertQueryExpressionContext::fields() {
  return getRuleContext<MySQLParser::FieldsContext>(0);
}


size_t MySQLParser::InsertQueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleInsertQueryExpression;
}

void MySQLParser::InsertQueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertQueryExpression(this);
}

void MySQLParser::InsertQueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertQueryExpression(this);
}

MySQLParser::InsertQueryExpressionContext* MySQLParser::insertQueryExpression() {
  InsertQueryExpressionContext *_localctx = _tracker.createInstance<InsertQueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 248, MySQLParser::RuleInsertQueryExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2771);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 253, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2764);
      queryExpressionOrParens();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2765);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2767);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 252, _ctx)) {
      case 1: {
        setState(2766);
        fields();
        break;
      }

      }
      setState(2769);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(2770);
      queryExpressionOrParens();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueListContext ------------------------------------------------------------------

MySQLParser::ValueListContext::ValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::OPEN_PAR_SYMBOL() {
  return getTokens(MySQLParser::OPEN_PAR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValueListContext::OPEN_PAR_SYMBOL(size_t i) {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::CLOSE_PAR_SYMBOL() {
  return getTokens(MySQLParser::CLOSE_PAR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValueListContext::CLOSE_PAR_SYMBOL(size_t i) {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, i);
}

std::vector<MySQLParser::ValuesContext *> MySQLParser::ValueListContext::values() {
  return getRuleContexts<MySQLParser::ValuesContext>();
}

MySQLParser::ValuesContext* MySQLParser::ValueListContext::values(size_t i) {
  return getRuleContext<MySQLParser::ValuesContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValueListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValueListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ValueListContext::getRuleIndex() const {
  return MySQLParser::RuleValueList;
}

void MySQLParser::ValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValueList(this);
}

void MySQLParser::ValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValueList(this);
}

MySQLParser::ValueListContext* MySQLParser::valueList() {
  ValueListContext *_localctx = _tracker.createInstance<ValueListContext>(_ctx, getState());
  enterRule(_localctx, 250, MySQLParser::RuleValueList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2773);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2775);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 254, _ctx)) {
    case 1: {
      setState(2774);
      values();
      break;
    }

    }
    setState(2777);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(2786);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2778);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2779);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2781);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 255, _ctx)) {
      case 1: {
        setState(2780);
        values();
        break;
      }

      }
      setState(2783);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(2788);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValuesContext ------------------------------------------------------------------

MySQLParser::ValuesContext::ValuesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ValuesContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ValuesContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValuesContext::DEFAULT_SYMBOL() {
  return getTokens(MySQLParser::DEFAULT_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValuesContext::DEFAULT_SYMBOL(size_t i) {
  return getToken(MySQLParser::DEFAULT_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ValuesContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ValuesContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ValuesContext::getRuleIndex() const {
  return MySQLParser::RuleValues;
}

void MySQLParser::ValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterValues(this);
}

void MySQLParser::ValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitValues(this);
}

MySQLParser::ValuesContext* MySQLParser::values() {
  ValuesContext *_localctx = _tracker.createInstance<ValuesContext>(_ctx, getState());
  enterRule(_localctx, 252, MySQLParser::RuleValues);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2791);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 257, _ctx)) {
    case 1: {
      setState(2789);
      expr(0);
      break;
    }

    case 2: {
      setState(2790);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
    setState(2800);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2793);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2796);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 258, _ctx)) {
      case 1: {
        setState(2794);
        expr(0);
        break;
      }

      case 2: {
        setState(2795);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      }
      setState(2802);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertUpdateListContext ------------------------------------------------------------------

MySQLParser::InsertUpdateListContext::InsertUpdateListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InsertUpdateListContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::InsertUpdateListContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}


size_t MySQLParser::InsertUpdateListContext::getRuleIndex() const {
  return MySQLParser::RuleInsertUpdateList;
}

void MySQLParser::InsertUpdateListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertUpdateList(this);
}

void MySQLParser::InsertUpdateListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertUpdateList(this);
}

MySQLParser::InsertUpdateListContext* MySQLParser::insertUpdateList() {
  InsertUpdateListContext *_localctx = _tracker.createInstance<InsertUpdateListContext>(_ctx, getState());
  enterRule(_localctx, 254, MySQLParser::RuleInsertUpdateList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2803);
    match(MySQLParser::ON_SYMBOL);
    setState(2804);
    match(MySQLParser::DUPLICATE_SYMBOL);
    setState(2805);
    match(MySQLParser::KEY_SYMBOL);
    setState(2806);
    match(MySQLParser::UPDATE_SYMBOL);
    setState(2807);
    updateList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadStatementContext ------------------------------------------------------------------

MySQLParser::LoadStatementContext::LoadStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LoadStatementContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

MySQLParser::DataOrXmlContext* MySQLParser::LoadStatementContext::dataOrXml() {
  return getRuleContext<MySQLParser::DataOrXmlContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::INFILE_SYMBOL() {
  return getToken(MySQLParser::INFILE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::LoadStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::LoadStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::LoadDataFileTailContext* MySQLParser::LoadStatementContext::loadDataFileTail() {
  return getRuleContext<MySQLParser::LoadDataFileTailContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

MySQLParser::UsePartitionContext* MySQLParser::LoadStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::CharsetClauseContext* MySQLParser::LoadStatementContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::XmlRowsIdentifiedByContext* MySQLParser::LoadStatementContext::xmlRowsIdentifiedBy() {
  return getRuleContext<MySQLParser::XmlRowsIdentifiedByContext>(0);
}

MySQLParser::FieldsClauseContext* MySQLParser::LoadStatementContext::fieldsClause() {
  return getRuleContext<MySQLParser::FieldsClauseContext>(0);
}

MySQLParser::LinesClauseContext* MySQLParser::LoadStatementContext::linesClause() {
  return getRuleContext<MySQLParser::LinesClauseContext>(0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::LoadStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLoadStatement;
}

void MySQLParser::LoadStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadStatement(this);
}

void MySQLParser::LoadStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadStatement(this);
}

MySQLParser::LoadStatementContext* MySQLParser::loadStatement() {
  LoadStatementContext *_localctx = _tracker.createInstance<LoadStatementContext>(_ctx, getState());
  enterRule(_localctx, 256, MySQLParser::RuleLoadStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2809);
    match(MySQLParser::LOAD_SYMBOL);
    setState(2810);
    dataOrXml();
    setState(2812);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CONCURRENT_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL) {
      setState(2811);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CONCURRENT_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2815);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LOCAL_SYMBOL) {
      setState(2814);
      match(MySQLParser::LOCAL_SYMBOL);
    }
    setState(2817);
    match(MySQLParser::INFILE_SYMBOL);
    setState(2818);
    textLiteral();
    setState(2820);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL) {
      setState(2819);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::REPLACE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2822);
    match(MySQLParser::INTO_SYMBOL);
    setState(2823);
    match(MySQLParser::TABLE_SYMBOL);
    setState(2824);
    tableRef();
    setState(2826);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 263, _ctx)) {
    case 1: {
      setState(2825);
      usePartition();
      break;
    }

    }
    setState(2829);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::CHARSET_SYMBOL

    || _la == MySQLParser::CHAR_SYMBOL) {
      setState(2828);
      charsetClause();
    }
    setState(2832);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ROWS_SYMBOL) {
      setState(2831);
      xmlRowsIdentifiedBy();
    }
    setState(2835);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COLUMNS_SYMBOL) {
      setState(2834);
      fieldsClause();
    }
    setState(2838);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LINES_SYMBOL) {
      setState(2837);
      linesClause();
    }
    setState(2840);
    loadDataFileTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataOrXmlContext ------------------------------------------------------------------

MySQLParser::DataOrXmlContext::DataOrXmlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DataOrXmlContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataOrXmlContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}


size_t MySQLParser::DataOrXmlContext::getRuleIndex() const {
  return MySQLParser::RuleDataOrXml;
}

void MySQLParser::DataOrXmlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataOrXml(this);
}

void MySQLParser::DataOrXmlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataOrXml(this);
}

MySQLParser::DataOrXmlContext* MySQLParser::dataOrXml() {
  DataOrXmlContext *_localctx = _tracker.createInstance<DataOrXmlContext>(_ctx, getState());
  enterRule(_localctx, 258, MySQLParser::RuleDataOrXml);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2842);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::XML_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XmlRowsIdentifiedByContext ------------------------------------------------------------------

MySQLParser::XmlRowsIdentifiedByContext::XmlRowsIdentifiedByContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::XmlRowsIdentifiedByContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XmlRowsIdentifiedByContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XmlRowsIdentifiedByContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::XmlRowsIdentifiedByContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}


size_t MySQLParser::XmlRowsIdentifiedByContext::getRuleIndex() const {
  return MySQLParser::RuleXmlRowsIdentifiedBy;
}

void MySQLParser::XmlRowsIdentifiedByContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXmlRowsIdentifiedBy(this);
}

void MySQLParser::XmlRowsIdentifiedByContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXmlRowsIdentifiedBy(this);
}

MySQLParser::XmlRowsIdentifiedByContext* MySQLParser::xmlRowsIdentifiedBy() {
  XmlRowsIdentifiedByContext *_localctx = _tracker.createInstance<XmlRowsIdentifiedByContext>(_ctx, getState());
  enterRule(_localctx, 260, MySQLParser::RuleXmlRowsIdentifiedBy);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2844);
    match(MySQLParser::ROWS_SYMBOL);
    setState(2845);
    match(MySQLParser::IDENTIFIED_SYMBOL);
    setState(2846);
    match(MySQLParser::BY_SYMBOL);
    setState(2847);
    textString();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataFileTailContext ------------------------------------------------------------------

MySQLParser::LoadDataFileTailContext::LoadDataFileTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::LoadDataFileTargetListContext* MySQLParser::LoadDataFileTailContext::loadDataFileTargetList() {
  return getRuleContext<MySQLParser::LoadDataFileTargetListContext>(0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::LoadDataFileTailContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::LINES_SYMBOL() {
  return getToken(MySQLParser::LINES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTailContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}


size_t MySQLParser::LoadDataFileTailContext::getRuleIndex() const {
  return MySQLParser::RuleLoadDataFileTail;
}

void MySQLParser::LoadDataFileTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataFileTail(this);
}

void MySQLParser::LoadDataFileTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataFileTail(this);
}

MySQLParser::LoadDataFileTailContext* MySQLParser::loadDataFileTail() {
  LoadDataFileTailContext *_localctx = _tracker.createInstance<LoadDataFileTailContext>(_ctx, getState());
  enterRule(_localctx, 262, MySQLParser::RuleLoadDataFileTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2852);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL) {
      setState(2849);
      match(MySQLParser::IGNORE_SYMBOL);
      setState(2850);
      match(MySQLParser::INT_NUMBER);
      setState(2851);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LINES_SYMBOL || _la == MySQLParser::ROWS_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(2855);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(2854);
      loadDataFileTargetList();
    }
    setState(2859);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(2857);
      match(MySQLParser::SET_SYMBOL);
      setState(2858);
      updateList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoadDataFileTargetListContext ------------------------------------------------------------------

MySQLParser::LoadDataFileTargetListContext::LoadDataFileTargetListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LoadDataFileTargetListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LoadDataFileTargetListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FieldOrVariableListContext* MySQLParser::LoadDataFileTargetListContext::fieldOrVariableList() {
  return getRuleContext<MySQLParser::FieldOrVariableListContext>(0);
}


size_t MySQLParser::LoadDataFileTargetListContext::getRuleIndex() const {
  return MySQLParser::RuleLoadDataFileTargetList;
}

void MySQLParser::LoadDataFileTargetListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoadDataFileTargetList(this);
}

void MySQLParser::LoadDataFileTargetListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoadDataFileTargetList(this);
}

MySQLParser::LoadDataFileTargetListContext* MySQLParser::loadDataFileTargetList() {
  LoadDataFileTargetListContext *_localctx = _tracker.createInstance<LoadDataFileTargetListContext>(_ctx, getState());
  enterRule(_localctx, 264, MySQLParser::RuleLoadDataFileTargetList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2861);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2863);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 271, _ctx)) {
    case 1: {
      setState(2862);
      fieldOrVariableList();
      break;
    }

    }
    setState(2865);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOrVariableListContext ------------------------------------------------------------------

MySQLParser::FieldOrVariableListContext::FieldOrVariableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ColumnRefContext *> MySQLParser::FieldOrVariableListContext::columnRef() {
  return getRuleContexts<MySQLParser::ColumnRefContext>();
}

MySQLParser::ColumnRefContext* MySQLParser::FieldOrVariableListContext::columnRef(size_t i) {
  return getRuleContext<MySQLParser::ColumnRefContext>(i);
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::FieldOrVariableListContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext* MySQLParser::FieldOrVariableListContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOrVariableListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOrVariableListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FieldOrVariableListContext::getRuleIndex() const {
  return MySQLParser::RuleFieldOrVariableList;
}

void MySQLParser::FieldOrVariableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOrVariableList(this);
}

void MySQLParser::FieldOrVariableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOrVariableList(this);
}

MySQLParser::FieldOrVariableListContext* MySQLParser::fieldOrVariableList() {
  FieldOrVariableListContext *_localctx = _tracker.createInstance<FieldOrVariableListContext>(_ctx, getState());
  enterRule(_localctx, 266, MySQLParser::RuleFieldOrVariableList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2869);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 272, _ctx)) {
    case 1: {
      setState(2867);
      columnRef();
      break;
    }

    case 2: {
      setState(2868);
      userVariable();
      break;
    }

    }
    setState(2878);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(2871);
      match(MySQLParser::COMMA_SYMBOL);
      setState(2874);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 273, _ctx)) {
      case 1: {
        setState(2872);
        columnRef();
        break;
      }

      case 2: {
        setState(2873);
        userVariable();
        break;
      }

      }
      setState(2880);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplaceStatementContext ------------------------------------------------------------------

MySQLParser::ReplaceStatementContext::ReplaceStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ReplaceStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::InsertFromConstructorContext* MySQLParser::ReplaceStatementContext::insertFromConstructor() {
  return getRuleContext<MySQLParser::InsertFromConstructorContext>(0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::ReplaceStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::InsertQueryExpressionContext* MySQLParser::ReplaceStatementContext::insertQueryExpression() {
  return getRuleContext<MySQLParser::InsertQueryExpressionContext>(0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::UsePartitionContext* MySQLParser::ReplaceStatementContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplaceStatementContext::DELAYED_SYMBOL() {
  return getToken(MySQLParser::DELAYED_SYMBOL, 0);
}


size_t MySQLParser::ReplaceStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReplaceStatement;
}

void MySQLParser::ReplaceStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplaceStatement(this);
}

void MySQLParser::ReplaceStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplaceStatement(this);
}

MySQLParser::ReplaceStatementContext* MySQLParser::replaceStatement() {
  ReplaceStatementContext *_localctx = _tracker.createInstance<ReplaceStatementContext>(_ctx, getState());
  enterRule(_localctx, 268, MySQLParser::RuleReplaceStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2881);
    match(MySQLParser::REPLACE_SYMBOL);
    setState(2883);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 275, _ctx)) {
    case 1: {
      setState(2882);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DELAYED_SYMBOL || _la == MySQLParser::LOW_PRIORITY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(2886);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 276, _ctx)) {
    case 1: {
      setState(2885);
      match(MySQLParser::INTO_SYMBOL);
      break;
    }

    }
    setState(2888);
    tableRef();
    setState(2890);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 277, _ctx)) {
    case 1: {
      setState(2889);
      usePartition();
      break;
    }

    }
    setState(2896);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 278, _ctx)) {
    case 1: {
      setState(2892);
      insertFromConstructor();
      break;
    }

    case 2: {
      setState(2893);
      match(MySQLParser::SET_SYMBOL);
      setState(2894);
      updateList();
      break;
    }

    case 3: {
      setState(2895);
      insertQueryExpression();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStatementContext ------------------------------------------------------------------

MySQLParser::SelectStatementContext::SelectStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionContext* MySQLParser::SelectStatementContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::SelectStatementContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::SelectStatementWithIntoContext* MySQLParser::SelectStatementContext::selectStatementWithInto() {
  return getRuleContext<MySQLParser::SelectStatementWithIntoContext>(0);
}


size_t MySQLParser::SelectStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSelectStatement;
}

void MySQLParser::SelectStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStatement(this);
}

void MySQLParser::SelectStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStatement(this);
}

MySQLParser::SelectStatementContext* MySQLParser::selectStatement() {
  SelectStatementContext *_localctx = _tracker.createInstance<SelectStatementContext>(_ctx, getState());
  enterRule(_localctx, 270, MySQLParser::RuleSelectStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2901);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 279, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2898);
      queryExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2899);
      queryExpressionParens();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(2900);
      selectStatementWithInto();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectStatementWithIntoContext ------------------------------------------------------------------

MySQLParser::SelectStatementWithIntoContext::SelectStatementWithIntoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SelectStatementWithIntoContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SelectStatementWithIntoContext* MySQLParser::SelectStatementWithIntoContext::selectStatementWithInto() {
  return getRuleContext<MySQLParser::SelectStatementWithIntoContext>(0);
}

tree::TerminalNode* MySQLParser::SelectStatementWithIntoContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::QueryExpressionContext* MySQLParser::SelectStatementWithIntoContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}

MySQLParser::IntoClauseContext* MySQLParser::SelectStatementWithIntoContext::intoClause() {
  return getRuleContext<MySQLParser::IntoClauseContext>(0);
}


size_t MySQLParser::SelectStatementWithIntoContext::getRuleIndex() const {
  return MySQLParser::RuleSelectStatementWithInto;
}

void MySQLParser::SelectStatementWithIntoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectStatementWithInto(this);
}

void MySQLParser::SelectStatementWithIntoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectStatementWithInto(this);
}

MySQLParser::SelectStatementWithIntoContext* MySQLParser::selectStatementWithInto() {
  SelectStatementWithIntoContext *_localctx = _tracker.createInstance<SelectStatementWithIntoContext>(_ctx, getState());
  enterRule(_localctx, 272, MySQLParser::RuleSelectStatementWithInto);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2910);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 280, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2903);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(2904);
      selectStatementWithInto();
      setState(2905);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2907);
      queryExpression();
      setState(2908);
      intoClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionContext ------------------------------------------------------------------

MySQLParser::QueryExpressionContext::QueryExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionBodyContext* MySQLParser::QueryExpressionContext::queryExpressionBody() {
  return getRuleContext<MySQLParser::QueryExpressionBodyContext>(0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::WithClauseContext* MySQLParser::QueryExpressionContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

MySQLParser::ProcedureAnalyseClauseContext* MySQLParser::QueryExpressionContext::procedureAnalyseClause() {
  return getRuleContext<MySQLParser::ProcedureAnalyseClauseContext>(0);
}

MySQLParser::LockingClauseContext* MySQLParser::QueryExpressionContext::lockingClause() {
  return getRuleContext<MySQLParser::LockingClauseContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::QueryExpressionContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::LimitClauseContext* MySQLParser::QueryExpressionContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}


size_t MySQLParser::QueryExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpression;
}

void MySQLParser::QueryExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpression(this);
}

void MySQLParser::QueryExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpression(this);
}

MySQLParser::QueryExpressionContext* MySQLParser::queryExpression() {
  QueryExpressionContext *_localctx = _tracker.createInstance<QueryExpressionContext>(_ctx, getState());
  enterRule(_localctx, 274, MySQLParser::RuleQueryExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(2946);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 290, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(2914);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 281, _ctx)) {
      case 1: {
        setState(2912);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(2913);
        withClause();
        break;
      }

      }
      setState(2931);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 286, _ctx)) {
      case 1: {
        setState(2916);
        queryExpressionBody(0);
        setState(2918);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 282, _ctx)) {
        case 1: {
          setState(2917);
          orderClause();
          break;
        }

        }
        setState(2921);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 283, _ctx)) {
        case 1: {
          setState(2920);
          limitClause();
          break;
        }

        }
        break;
      }

      case 2: {
        setState(2923);
        queryExpressionParens();
        setState(2929);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::ORDER_SYMBOL: {
            setState(2924);
            orderClause();
            setState(2926);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 284, _ctx)) {
            case 1: {
              setState(2925);
              limitClause();
              break;
            }

            }
            break;
          }

          case MySQLParser::LIMIT_SYMBOL: {
            setState(2928);
            limitClause();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      }
      setState(2935);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 287, _ctx)) {
      case 1: {
        setState(2933);

        if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
        setState(2934);
        procedureAnalyseClause();
        break;
      }

      }
      setState(2938);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL || _la == MySQLParser::LOCK_SYMBOL) {
        setState(2937);
        lockingClause();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(2940);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(2941);
      withClause();
      setState(2942);
      queryExpressionParens();
      setState(2944);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL || _la == MySQLParser::LOCK_SYMBOL) {
        setState(2943);
        lockingClause();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QueryExpressionBodyContext ------------------------------------------------------------------

MySQLParser::QueryExpressionBodyContext::QueryExpressionBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QuerySpecificationContext* MySQLParser::QueryExpressionBodyContext::querySpecification() {
  return getRuleContext<MySQLParser::QuerySpecificationContext>(0);
}

std::vector<MySQLParser::QueryExpressionParensContext *> MySQLParser::QueryExpressionBodyContext::queryExpressionParens() {
  return getRuleContexts<MySQLParser::QueryExpressionParensContext>();
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionBodyContext::queryExpressionParens(size_t i) {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(i);
}

tree::TerminalNode* MySQLParser::QueryExpressionBodyContext::UNION_SYMBOL() {
  return getToken(MySQLParser::UNION_SYMBOL, 0);
}

MySQLParser::UnionOptionContext* MySQLParser::QueryExpressionBodyContext::unionOption() {
  return getRuleContext<MySQLParser::UnionOptionContext>(0);
}

MySQLParser::QueryExpressionBodyContext* MySQLParser::QueryExpressionBodyContext::queryExpressionBody() {
  return getRuleContext<MySQLParser::QueryExpressionBodyContext>(0);
}


size_t MySQLParser::QueryExpressionBodyContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionBody;
}

void MySQLParser::QueryExpressionBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionBody(this);
}

void MySQLParser::QueryExpressionBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionBody(this);
}


MySQLParser::QueryExpressionBodyContext* MySQLParser::queryExpressionBody() {
   return queryExpressionBody(0);
}

MySQLParser::QueryExpressionBodyContext* MySQLParser::queryExpressionBody(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::QueryExpressionBodyContext *_localctx = _tracker.createInstance<QueryExpressionBodyContext>(_ctx, parentState);
  MySQLParser::QueryExpressionBodyContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 276;
  enterRecursionRule(_localctx, 276, MySQLParser::RuleQueryExpressionBody, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2959);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SELECT_SYMBOL: {
        setState(2949);
        querySpecification();
        break;
      }

      case MySQLParser::OPEN_PAR_SYMBOL: {
        setState(2950);
        queryExpressionParens();
        setState(2951);
        match(MySQLParser::UNION_SYMBOL);
        setState(2953);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::DISTINCT_SYMBOL) {
          setState(2952);
          unionOption();
        }
        setState(2957);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::SELECT_SYMBOL: {
            setState(2955);
            querySpecification();
            break;
          }

          case MySQLParser::OPEN_PAR_SYMBOL: {
            setState(2956);
            queryExpressionParens();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(2972);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        _localctx = _tracker.createInstance<QueryExpressionBodyContext>(parentContext, parentState);
        pushNewRecursionContext(_localctx, startState, RuleQueryExpressionBody);
        setState(2961);

        if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
        setState(2962);
        match(MySQLParser::UNION_SYMBOL);
        setState(2964);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::DISTINCT_SYMBOL) {
          setState(2963);
          unionOption();
        }
        setState(2968);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::SELECT_SYMBOL: {
            setState(2966);
            querySpecification();
            break;
          }

          case MySQLParser::OPEN_PAR_SYMBOL: {
            setState(2967);
            queryExpressionParens();
            break;
          }

        default:
          throw NoViableAltException(this);
        } 
      }
      setState(2974);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 296, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- QueryExpressionParensContext ------------------------------------------------------------------

MySQLParser::QueryExpressionParensContext::QueryExpressionParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QueryExpressionParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QueryExpressionParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::QueryExpressionParensContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}

MySQLParser::QueryExpressionContext* MySQLParser::QueryExpressionParensContext::queryExpression() {
  return getRuleContext<MySQLParser::QueryExpressionContext>(0);
}


size_t MySQLParser::QueryExpressionParensContext::getRuleIndex() const {
  return MySQLParser::RuleQueryExpressionParens;
}

void MySQLParser::QueryExpressionParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQueryExpressionParens(this);
}

void MySQLParser::QueryExpressionParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQueryExpressionParens(this);
}

MySQLParser::QueryExpressionParensContext* MySQLParser::queryExpressionParens() {
  QueryExpressionParensContext *_localctx = _tracker.createInstance<QueryExpressionParensContext>(_ctx, getState());
  enterRule(_localctx, 278, MySQLParser::RuleQueryExpressionParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(2975);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(2978);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 297, _ctx)) {
    case 1: {
      setState(2976);
      queryExpressionParens();
      break;
    }

    case 2: {
      setState(2977);
      queryExpression();
      break;
    }

    }
    setState(2980);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecificationContext ------------------------------------------------------------------

MySQLParser::QuerySpecificationContext::QuerySpecificationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QuerySpecificationContext::SELECT_SYMBOL() {
  return getToken(MySQLParser::SELECT_SYMBOL, 0);
}

MySQLParser::SelectItemListContext* MySQLParser::QuerySpecificationContext::selectItemList() {
  return getRuleContext<MySQLParser::SelectItemListContext>(0);
}

std::vector<MySQLParser::SelectOptionContext *> MySQLParser::QuerySpecificationContext::selectOption() {
  return getRuleContexts<MySQLParser::SelectOptionContext>();
}

MySQLParser::SelectOptionContext* MySQLParser::QuerySpecificationContext::selectOption(size_t i) {
  return getRuleContext<MySQLParser::SelectOptionContext>(i);
}

MySQLParser::IntoClauseContext* MySQLParser::QuerySpecificationContext::intoClause() {
  return getRuleContext<MySQLParser::IntoClauseContext>(0);
}

MySQLParser::FromClauseContext* MySQLParser::QuerySpecificationContext::fromClause() {
  return getRuleContext<MySQLParser::FromClauseContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::QuerySpecificationContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::GroupByClauseContext* MySQLParser::QuerySpecificationContext::groupByClause() {
  return getRuleContext<MySQLParser::GroupByClauseContext>(0);
}

MySQLParser::HavingClauseContext* MySQLParser::QuerySpecificationContext::havingClause() {
  return getRuleContext<MySQLParser::HavingClauseContext>(0);
}

MySQLParser::WindowClauseContext* MySQLParser::QuerySpecificationContext::windowClause() {
  return getRuleContext<MySQLParser::WindowClauseContext>(0);
}


size_t MySQLParser::QuerySpecificationContext::getRuleIndex() const {
  return MySQLParser::RuleQuerySpecification;
}

void MySQLParser::QuerySpecificationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecification(this);
}

void MySQLParser::QuerySpecificationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecification(this);
}

MySQLParser::QuerySpecificationContext* MySQLParser::querySpecification() {
  QuerySpecificationContext *_localctx = _tracker.createInstance<QuerySpecificationContext>(_ctx, getState());
  enterRule(_localctx, 280, MySQLParser::RuleQuerySpecification);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(2982);
    match(MySQLParser::SELECT_SYMBOL);
    setState(2986);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(2983);
        selectOption(); 
      }
      setState(2988);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 298, _ctx);
    }
    setState(2989);
    selectItemList();
    setState(2991);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 299, _ctx)) {
    case 1: {
      setState(2990);
      intoClause();
      break;
    }

    }
    setState(2994);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 300, _ctx)) {
    case 1: {
      setState(2993);
      fromClause();
      break;
    }

    }
    setState(2997);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 301, _ctx)) {
    case 1: {
      setState(2996);
      whereClause();
      break;
    }

    }
    setState(3000);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 302, _ctx)) {
    case 1: {
      setState(2999);
      groupByClause();
      break;
    }

    }
    setState(3003);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 303, _ctx)) {
    case 1: {
      setState(3002);
      havingClause();
      break;
    }

    }
    setState(3007);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 304, _ctx)) {
    case 1: {
      setState(3005);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3006);
      windowClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubqueryContext ------------------------------------------------------------------

MySQLParser::SubqueryContext::SubqueryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QueryExpressionParensContext* MySQLParser::SubqueryContext::queryExpressionParens() {
  return getRuleContext<MySQLParser::QueryExpressionParensContext>(0);
}


size_t MySQLParser::SubqueryContext::getRuleIndex() const {
  return MySQLParser::RuleSubquery;
}

void MySQLParser::SubqueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubquery(this);
}

void MySQLParser::SubqueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubquery(this);
}

MySQLParser::SubqueryContext* MySQLParser::subquery() {
  SubqueryContext *_localctx = _tracker.createInstance<SubqueryContext>(_ctx, getState());
  enterRule(_localctx, 282, MySQLParser::RuleSubquery);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3009);
    queryExpressionParens();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuerySpecOptionContext ------------------------------------------------------------------

MySQLParser::QuerySpecOptionContext::QuerySpecOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::STRAIGHT_JOIN_SYMBOL() {
  return getToken(MySQLParser::STRAIGHT_JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::HIGH_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::HIGH_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_SMALL_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_SMALL_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_BIG_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BIG_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::QuerySpecOptionContext::SQL_CALC_FOUND_ROWS_SYMBOL() {
  return getToken(MySQLParser::SQL_CALC_FOUND_ROWS_SYMBOL, 0);
}


size_t MySQLParser::QuerySpecOptionContext::getRuleIndex() const {
  return MySQLParser::RuleQuerySpecOption;
}

void MySQLParser::QuerySpecOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQuerySpecOption(this);
}

void MySQLParser::QuerySpecOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQuerySpecOption(this);
}

MySQLParser::QuerySpecOptionContext* MySQLParser::querySpecOption() {
  QuerySpecOptionContext *_localctx = _tracker.createInstance<QuerySpecOptionContext>(_ctx, getState());
  enterRule(_localctx, 284, MySQLParser::RuleQuerySpecOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3011);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::DISTINCT_SYMBOL || _la == MySQLParser::HIGH_PRIORITY_SYMBOL || ((((_la - 561) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 561)) & ((1ULL << (MySQLParser::SQL_BIG_RESULT_SYMBOL - 561))
      | (1ULL << (MySQLParser::SQL_BUFFER_RESULT_SYMBOL - 561))
      | (1ULL << (MySQLParser::SQL_CALC_FOUND_ROWS_SYMBOL - 561))
      | (1ULL << (MySQLParser::SQL_SMALL_RESULT_SYMBOL - 561))
      | (1ULL << (MySQLParser::STRAIGHT_JOIN_SYMBOL - 561)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitClauseContext ------------------------------------------------------------------

MySQLParser::LimitClauseContext::LimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LimitClauseContext::LIMIT_SYMBOL() {
  return getToken(MySQLParser::LIMIT_SYMBOL, 0);
}

MySQLParser::LimitOptionsContext* MySQLParser::LimitClauseContext::limitOptions() {
  return getRuleContext<MySQLParser::LimitOptionsContext>(0);
}


size_t MySQLParser::LimitClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLimitClause;
}

void MySQLParser::LimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitClause(this);
}

void MySQLParser::LimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitClause(this);
}

MySQLParser::LimitClauseContext* MySQLParser::limitClause() {
  LimitClauseContext *_localctx = _tracker.createInstance<LimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 286, MySQLParser::RuleLimitClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3013);
    match(MySQLParser::LIMIT_SYMBOL);
    setState(3014);
    limitOptions();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleLimitClauseContext ------------------------------------------------------------------

MySQLParser::SimpleLimitClauseContext::SimpleLimitClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SimpleLimitClauseContext::LIMIT_SYMBOL() {
  return getToken(MySQLParser::LIMIT_SYMBOL, 0);
}

MySQLParser::LimitOptionContext* MySQLParser::SimpleLimitClauseContext::limitOption() {
  return getRuleContext<MySQLParser::LimitOptionContext>(0);
}


size_t MySQLParser::SimpleLimitClauseContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleLimitClause;
}

void MySQLParser::SimpleLimitClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleLimitClause(this);
}

void MySQLParser::SimpleLimitClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleLimitClause(this);
}

MySQLParser::SimpleLimitClauseContext* MySQLParser::simpleLimitClause() {
  SimpleLimitClauseContext *_localctx = _tracker.createInstance<SimpleLimitClauseContext>(_ctx, getState());
  enterRule(_localctx, 288, MySQLParser::RuleSimpleLimitClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3016);
    match(MySQLParser::LIMIT_SYMBOL);
    setState(3017);
    limitOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOptionsContext ------------------------------------------------------------------

MySQLParser::LimitOptionsContext::LimitOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::LimitOptionContext *> MySQLParser::LimitOptionsContext::limitOption() {
  return getRuleContexts<MySQLParser::LimitOptionContext>();
}

MySQLParser::LimitOptionContext* MySQLParser::LimitOptionsContext::limitOption(size_t i) {
  return getRuleContext<MySQLParser::LimitOptionContext>(i);
}

tree::TerminalNode* MySQLParser::LimitOptionsContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionsContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}


size_t MySQLParser::LimitOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleLimitOptions;
}

void MySQLParser::LimitOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitOptions(this);
}

void MySQLParser::LimitOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitOptions(this);
}

MySQLParser::LimitOptionsContext* MySQLParser::limitOptions() {
  LimitOptionsContext *_localctx = _tracker.createInstance<LimitOptionsContext>(_ctx, getState());
  enterRule(_localctx, 290, MySQLParser::RuleLimitOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3019);
    limitOption();
    setState(3022);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 305, _ctx)) {
    case 1: {
      setState(3020);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::COMMA_SYMBOL || _la == MySQLParser::OFFSET_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3021);
      limitOption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LimitOptionContext ------------------------------------------------------------------

MySQLParser::LimitOptionContext::LimitOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::LimitOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LimitOptionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}


size_t MySQLParser::LimitOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLimitOption;
}

void MySQLParser::LimitOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLimitOption(this);
}

void MySQLParser::LimitOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLimitOption(this);
}

MySQLParser::LimitOptionContext* MySQLParser::limitOption() {
  LimitOptionContext *_localctx = _tracker.createInstance<LimitOptionContext>(_ctx, getState());
  enterRule(_localctx, 292, MySQLParser::RuleLimitOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3026);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 306, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3024);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3025);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLParser::INT_NUMBER)
        | (1ULL << MySQLParser::LONG_NUMBER)
        | (1ULL << MySQLParser::ULONGLONG_NUMBER)
        | (1ULL << MySQLParser::PARAM_MARKER))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntoClauseContext ------------------------------------------------------------------

MySQLParser::IntoClauseContext::IntoClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IntoClauseContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntoClauseContext::OUTFILE_SYMBOL() {
  return getToken(MySQLParser::OUTFILE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::IntoClauseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::IntoClauseContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

std::vector<MySQLParser::TextOrIdentifierContext *> MySQLParser::IntoClauseContext::textOrIdentifier() {
  return getRuleContexts<MySQLParser::TextOrIdentifierContext>();
}

MySQLParser::TextOrIdentifierContext* MySQLParser::IntoClauseContext::textOrIdentifier(size_t i) {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(i);
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::IntoClauseContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext* MySQLParser::IntoClauseContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

MySQLParser::CharsetClauseContext* MySQLParser::IntoClauseContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::FieldsClauseContext* MySQLParser::IntoClauseContext::fieldsClause() {
  return getRuleContext<MySQLParser::FieldsClauseContext>(0);
}

MySQLParser::LinesClauseContext* MySQLParser::IntoClauseContext::linesClause() {
  return getRuleContext<MySQLParser::LinesClauseContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::IntoClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IntoClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IntoClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIntoClause;
}

void MySQLParser::IntoClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntoClause(this);
}

void MySQLParser::IntoClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntoClause(this);
}

MySQLParser::IntoClauseContext* MySQLParser::intoClause() {
  IntoClauseContext *_localctx = _tracker.createInstance<IntoClauseContext>(_ctx, getState());
  enterRule(_localctx, 294, MySQLParser::RuleIntoClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3028);
    match(MySQLParser::INTO_SYMBOL);
    setState(3056);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 313, _ctx)) {
    case 1: {
      setState(3029);
      match(MySQLParser::OUTFILE_SYMBOL);
      setState(3030);
      textStringLiteral();
      setState(3032);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 307, _ctx)) {
      case 1: {
        setState(3031);
        charsetClause();
        break;
      }

      }
      setState(3035);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 308, _ctx)) {
      case 1: {
        setState(3034);
        fieldsClause();
        break;
      }

      }
      setState(3038);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 309, _ctx)) {
      case 1: {
        setState(3037);
        linesClause();
        break;
      }

      }
      break;
    }

    case 2: {
      setState(3040);
      match(MySQLParser::DUMPFILE_SYMBOL);
      setState(3041);
      textStringLiteral();
      break;
    }

    case 3: {
      setState(3044);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 310, _ctx)) {
      case 1: {
        setState(3042);
        textOrIdentifier();
        break;
      }

      case 2: {
        setState(3043);
        userVariable();
        break;
      }

      }
      setState(3053);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(3046);
          match(MySQLParser::COMMA_SYMBOL);
          setState(3049);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 311, _ctx)) {
          case 1: {
            setState(3047);
            textOrIdentifier();
            break;
          }

          case 2: {
            setState(3048);
            userVariable();
            break;
          }

          } 
        }
        setState(3055);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 312, _ctx);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureAnalyseClauseContext ------------------------------------------------------------------

MySQLParser::ProcedureAnalyseClauseContext::ProcedureAnalyseClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::ANALYSE_SYMBOL() {
  return getToken(MySQLParser::ANALYSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ProcedureAnalyseClauseContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode* MySQLParser::ProcedureAnalyseClauseContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::ProcedureAnalyseClauseContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureAnalyseClause;
}

void MySQLParser::ProcedureAnalyseClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureAnalyseClause(this);
}

void MySQLParser::ProcedureAnalyseClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureAnalyseClause(this);
}

MySQLParser::ProcedureAnalyseClauseContext* MySQLParser::procedureAnalyseClause() {
  ProcedureAnalyseClauseContext *_localctx = _tracker.createInstance<ProcedureAnalyseClauseContext>(_ctx, getState());
  enterRule(_localctx, 296, MySQLParser::RuleProcedureAnalyseClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3058);
    match(MySQLParser::PROCEDURE_SYMBOL);
    setState(3059);
    match(MySQLParser::ANALYSE_SYMBOL);
    setState(3060);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3066);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INT_NUMBER) {
      setState(3061);
      match(MySQLParser::INT_NUMBER);
      setState(3064);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3062);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3063);
        match(MySQLParser::INT_NUMBER);
      }
    }
    setState(3068);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HavingClauseContext ------------------------------------------------------------------

MySQLParser::HavingClauseContext::HavingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HavingClauseContext::HAVING_SYMBOL() {
  return getToken(MySQLParser::HAVING_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::HavingClauseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::HavingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleHavingClause;
}

void MySQLParser::HavingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHavingClause(this);
}

void MySQLParser::HavingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHavingClause(this);
}

MySQLParser::HavingClauseContext* MySQLParser::havingClause() {
  HavingClauseContext *_localctx = _tracker.createInstance<HavingClauseContext>(_ctx, getState());
  enterRule(_localctx, 298, MySQLParser::RuleHavingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3070);
    match(MySQLParser::HAVING_SYMBOL);
    setState(3071);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowClauseContext ------------------------------------------------------------------

MySQLParser::WindowClauseContext::WindowClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowClauseContext::WINDOW_SYMBOL() {
  return getToken(MySQLParser::WINDOW_SYMBOL, 0);
}

std::vector<MySQLParser::WindowDefinitionContext *> MySQLParser::WindowClauseContext::windowDefinition() {
  return getRuleContexts<MySQLParser::WindowDefinitionContext>();
}

MySQLParser::WindowDefinitionContext* MySQLParser::WindowClauseContext::windowDefinition(size_t i) {
  return getRuleContext<MySQLParser::WindowDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::WindowClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::WindowClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::WindowClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowClause;
}

void MySQLParser::WindowClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowClause(this);
}

void MySQLParser::WindowClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowClause(this);
}

MySQLParser::WindowClauseContext* MySQLParser::windowClause() {
  WindowClauseContext *_localctx = _tracker.createInstance<WindowClauseContext>(_ctx, getState());
  enterRule(_localctx, 300, MySQLParser::RuleWindowClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3073);
    match(MySQLParser::WINDOW_SYMBOL);
    setState(3074);
    windowDefinition();
    setState(3079);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3075);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3076);
        windowDefinition(); 
      }
      setState(3081);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 316, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowDefinitionContext ------------------------------------------------------------------

MySQLParser::WindowDefinitionContext::WindowDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowNameContext* MySQLParser::WindowDefinitionContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

tree::TerminalNode* MySQLParser::WindowDefinitionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::WindowSpecContext* MySQLParser::WindowDefinitionContext::windowSpec() {
  return getRuleContext<MySQLParser::WindowSpecContext>(0);
}


size_t MySQLParser::WindowDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleWindowDefinition;
}

void MySQLParser::WindowDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowDefinition(this);
}

void MySQLParser::WindowDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowDefinition(this);
}

MySQLParser::WindowDefinitionContext* MySQLParser::windowDefinition() {
  WindowDefinitionContext *_localctx = _tracker.createInstance<WindowDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 302, MySQLParser::RuleWindowDefinition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3082);
    windowName();
    setState(3083);
    match(MySQLParser::AS_SYMBOL);
    setState(3084);
    windowSpec();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecContext ------------------------------------------------------------------

MySQLParser::WindowSpecContext::WindowSpecContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowSpecContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::WindowSpecDetailsContext* MySQLParser::WindowSpecContext::windowSpecDetails() {
  return getRuleContext<MySQLParser::WindowSpecDetailsContext>(0);
}

tree::TerminalNode* MySQLParser::WindowSpecContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::WindowSpecContext::getRuleIndex() const {
  return MySQLParser::RuleWindowSpec;
}

void MySQLParser::WindowSpecContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpec(this);
}

void MySQLParser::WindowSpecContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpec(this);
}

MySQLParser::WindowSpecContext* MySQLParser::windowSpec() {
  WindowSpecContext *_localctx = _tracker.createInstance<WindowSpecContext>(_ctx, getState());
  enterRule(_localctx, 304, MySQLParser::RuleWindowSpec);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3086);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3087);
    windowSpecDetails();
    setState(3088);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowSpecDetailsContext ------------------------------------------------------------------

MySQLParser::WindowSpecDetailsContext::WindowSpecDetailsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowNameContext* MySQLParser::WindowSpecDetailsContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

tree::TerminalNode* MySQLParser::WindowSpecDetailsContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowSpecDetailsContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext* MySQLParser::WindowSpecDetailsContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::WindowSpecDetailsContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::WindowFrameClauseContext* MySQLParser::WindowSpecDetailsContext::windowFrameClause() {
  return getRuleContext<MySQLParser::WindowFrameClauseContext>(0);
}


size_t MySQLParser::WindowSpecDetailsContext::getRuleIndex() const {
  return MySQLParser::RuleWindowSpecDetails;
}

void MySQLParser::WindowSpecDetailsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowSpecDetails(this);
}

void MySQLParser::WindowSpecDetailsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowSpecDetails(this);
}

MySQLParser::WindowSpecDetailsContext* MySQLParser::windowSpecDetails() {
  WindowSpecDetailsContext *_localctx = _tracker.createInstance<WindowSpecDetailsContext>(_ctx, getState());
  enterRule(_localctx, 306, MySQLParser::RuleWindowSpecDetails);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3091);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 317, _ctx)) {
    case 1: {
      setState(3090);
      windowName();
      break;
    }

    }
    setState(3096);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::PARTITION_SYMBOL) {
      setState(3093);
      match(MySQLParser::PARTITION_SYMBOL);
      setState(3094);
      match(MySQLParser::BY_SYMBOL);
      setState(3095);
      orderList();
    }
    setState(3099);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ORDER_SYMBOL) {
      setState(3098);
      orderClause();
    }
    setState(3102);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::RANGE_SYMBOL

    || _la == MySQLParser::ROWS_SYMBOL || _la == MySQLParser::GROUPS_SYMBOL) {
      setState(3101);
      windowFrameClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameClauseContext ------------------------------------------------------------------

MySQLParser::WindowFrameClauseContext::WindowFrameClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameUnitsContext* MySQLParser::WindowFrameClauseContext::windowFrameUnits() {
  return getRuleContext<MySQLParser::WindowFrameUnitsContext>(0);
}

MySQLParser::WindowFrameExtentContext* MySQLParser::WindowFrameClauseContext::windowFrameExtent() {
  return getRuleContext<MySQLParser::WindowFrameExtentContext>(0);
}

MySQLParser::WindowFrameExclusionContext* MySQLParser::WindowFrameClauseContext::windowFrameExclusion() {
  return getRuleContext<MySQLParser::WindowFrameExclusionContext>(0);
}


size_t MySQLParser::WindowFrameClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameClause;
}

void MySQLParser::WindowFrameClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameClause(this);
}

void MySQLParser::WindowFrameClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameClause(this);
}

MySQLParser::WindowFrameClauseContext* MySQLParser::windowFrameClause() {
  WindowFrameClauseContext *_localctx = _tracker.createInstance<WindowFrameClauseContext>(_ctx, getState());
  enterRule(_localctx, 308, MySQLParser::RuleWindowFrameClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3104);
    windowFrameUnits();
    setState(3105);
    windowFrameExtent();
    setState(3107);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EXCLUDE_SYMBOL) {
      setState(3106);
      windowFrameExclusion();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameUnitsContext ------------------------------------------------------------------

MySQLParser::WindowFrameUnitsContext::WindowFrameUnitsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameUnitsContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameUnitsContext::RANGE_SYMBOL() {
  return getToken(MySQLParser::RANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameUnitsContext::GROUPS_SYMBOL() {
  return getToken(MySQLParser::GROUPS_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameUnitsContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameUnits;
}

void MySQLParser::WindowFrameUnitsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameUnits(this);
}

void MySQLParser::WindowFrameUnitsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameUnits(this);
}

MySQLParser::WindowFrameUnitsContext* MySQLParser::windowFrameUnits() {
  WindowFrameUnitsContext *_localctx = _tracker.createInstance<WindowFrameUnitsContext>(_ctx, getState());
  enterRule(_localctx, 310, MySQLParser::RuleWindowFrameUnits);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3109);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::RANGE_SYMBOL

    || _la == MySQLParser::ROWS_SYMBOL || _la == MySQLParser::GROUPS_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameExtentContext ------------------------------------------------------------------

MySQLParser::WindowFrameExtentContext::WindowFrameExtentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameStartContext* MySQLParser::WindowFrameExtentContext::windowFrameStart() {
  return getRuleContext<MySQLParser::WindowFrameStartContext>(0);
}

MySQLParser::WindowFrameBetweenContext* MySQLParser::WindowFrameExtentContext::windowFrameBetween() {
  return getRuleContext<MySQLParser::WindowFrameBetweenContext>(0);
}


size_t MySQLParser::WindowFrameExtentContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameExtent;
}

void MySQLParser::WindowFrameExtentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameExtent(this);
}

void MySQLParser::WindowFrameExtentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameExtent(this);
}

MySQLParser::WindowFrameExtentContext* MySQLParser::windowFrameExtent() {
  WindowFrameExtentContext *_localctx = _tracker.createInstance<WindowFrameExtentContext>(_ctx, getState());
  enterRule(_localctx, 312, MySQLParser::RuleWindowFrameExtent);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3113);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::PARAM_MARKER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER:
      case MySQLParser::CURRENT_SYMBOL:
      case MySQLParser::INTERVAL_SYMBOL:
      case MySQLParser::UNBOUNDED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3111);
        windowFrameStart();
        break;
      }

      case MySQLParser::BETWEEN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3112);
        windowFrameBetween();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameStartContext ------------------------------------------------------------------

MySQLParser::WindowFrameStartContext::WindowFrameStartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::WindowFrameStartContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WindowFrameStartContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext* MySQLParser::WindowFrameStartContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameStartContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameStartContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameStart;
}

void MySQLParser::WindowFrameStartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameStart(this);
}

void MySQLParser::WindowFrameStartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameStart(this);
}

MySQLParser::WindowFrameStartContext* MySQLParser::windowFrameStart() {
  WindowFrameStartContext *_localctx = _tracker.createInstance<WindowFrameStartContext>(_ctx, getState());
  enterRule(_localctx, 314, MySQLParser::RuleWindowFrameStart);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3129);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNBOUNDED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3115);
        match(MySQLParser::UNBOUNDED_SYMBOL);
        setState(3116);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 2);
        setState(3117);
        ulonglong_number();
        setState(3118);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::PARAM_MARKER: {
        enterOuterAlt(_localctx, 3);
        setState(3120);
        match(MySQLParser::PARAM_MARKER);
        setState(3121);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::INTERVAL_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3122);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(3123);
        expr(0);
        setState(3124);
        interval();
        setState(3125);
        match(MySQLParser::PRECEDING_SYMBOL);
        break;
      }

      case MySQLParser::CURRENT_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(3127);
        match(MySQLParser::CURRENT_SYMBOL);
        setState(3128);
        match(MySQLParser::ROW_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameBetweenContext ------------------------------------------------------------------

MySQLParser::WindowFrameBetweenContext::WindowFrameBetweenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameBetweenContext::BETWEEN_SYMBOL() {
  return getToken(MySQLParser::BETWEEN_SYMBOL, 0);
}

std::vector<MySQLParser::WindowFrameBoundContext *> MySQLParser::WindowFrameBetweenContext::windowFrameBound() {
  return getRuleContexts<MySQLParser::WindowFrameBoundContext>();
}

MySQLParser::WindowFrameBoundContext* MySQLParser::WindowFrameBetweenContext::windowFrameBound(size_t i) {
  return getRuleContext<MySQLParser::WindowFrameBoundContext>(i);
}

tree::TerminalNode* MySQLParser::WindowFrameBetweenContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameBetweenContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameBetween;
}

void MySQLParser::WindowFrameBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameBetween(this);
}

void MySQLParser::WindowFrameBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameBetween(this);
}

MySQLParser::WindowFrameBetweenContext* MySQLParser::windowFrameBetween() {
  WindowFrameBetweenContext *_localctx = _tracker.createInstance<WindowFrameBetweenContext>(_ctx, getState());
  enterRule(_localctx, 316, MySQLParser::RuleWindowFrameBetween);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3131);
    match(MySQLParser::BETWEEN_SYMBOL);
    setState(3132);
    windowFrameBound();
    setState(3133);
    match(MySQLParser::AND_SYMBOL);
    setState(3134);
    windowFrameBound();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameBoundContext ------------------------------------------------------------------

MySQLParser::WindowFrameBoundContext::WindowFrameBoundContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::WindowFrameStartContext* MySQLParser::WindowFrameBoundContext::windowFrameStart() {
  return getRuleContext<MySQLParser::WindowFrameStartContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::WindowFrameBoundContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameBoundContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WindowFrameBoundContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext* MySQLParser::WindowFrameBoundContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}


size_t MySQLParser::WindowFrameBoundContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameBound;
}

void MySQLParser::WindowFrameBoundContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameBound(this);
}

void MySQLParser::WindowFrameBoundContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameBound(this);
}

MySQLParser::WindowFrameBoundContext* MySQLParser::windowFrameBound() {
  WindowFrameBoundContext *_localctx = _tracker.createInstance<WindowFrameBoundContext>(_ctx, getState());
  enterRule(_localctx, 318, MySQLParser::RuleWindowFrameBound);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3149);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 324, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3136);
      windowFrameStart();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3137);
      match(MySQLParser::UNBOUNDED_SYMBOL);
      setState(3138);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3139);
      ulonglong_number();
      setState(3140);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3142);
      match(MySQLParser::PARAM_MARKER);
      setState(3143);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3144);
      match(MySQLParser::INTERVAL_SYMBOL);
      setState(3145);
      expr(0);
      setState(3146);
      interval();
      setState(3147);
      match(MySQLParser::FOLLOWING_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFrameExclusionContext ------------------------------------------------------------------

MySQLParser::WindowFrameExclusionContext::WindowFrameExclusionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFrameExclusionContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}


size_t MySQLParser::WindowFrameExclusionContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFrameExclusion;
}

void MySQLParser::WindowFrameExclusionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFrameExclusion(this);
}

void MySQLParser::WindowFrameExclusionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFrameExclusion(this);
}

MySQLParser::WindowFrameExclusionContext* MySQLParser::windowFrameExclusion() {
  WindowFrameExclusionContext *_localctx = _tracker.createInstance<WindowFrameExclusionContext>(_ctx, getState());
  enterRule(_localctx, 320, MySQLParser::RuleWindowFrameExclusion);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3151);
    match(MySQLParser::EXCLUDE_SYMBOL);
    setState(3158);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CURRENT_SYMBOL: {
        setState(3152);
        match(MySQLParser::CURRENT_SYMBOL);
        setState(3153);
        match(MySQLParser::ROW_SYMBOL);
        break;
      }

      case MySQLParser::GROUP_SYMBOL: {
        setState(3154);
        match(MySQLParser::GROUP_SYMBOL);
        break;
      }

      case MySQLParser::TIES_SYMBOL: {
        setState(3155);
        match(MySQLParser::TIES_SYMBOL);
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        setState(3156);
        match(MySQLParser::NO_SYMBOL);
        setState(3157);
        match(MySQLParser::OTHERS_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithClauseContext ------------------------------------------------------------------

MySQLParser::WithClauseContext::WithClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WithClauseContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<MySQLParser::CommonTableExpressionContext *> MySQLParser::WithClauseContext::commonTableExpression() {
  return getRuleContexts<MySQLParser::CommonTableExpressionContext>();
}

MySQLParser::CommonTableExpressionContext* MySQLParser::WithClauseContext::commonTableExpression(size_t i) {
  return getRuleContext<MySQLParser::CommonTableExpressionContext>(i);
}

tree::TerminalNode* MySQLParser::WithClauseContext::RECURSIVE_SYMBOL() {
  return getToken(MySQLParser::RECURSIVE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::WithClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::WithClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::WithClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWithClause;
}

void MySQLParser::WithClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithClause(this);
}

void MySQLParser::WithClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithClause(this);
}

MySQLParser::WithClauseContext* MySQLParser::withClause() {
  WithClauseContext *_localctx = _tracker.createInstance<WithClauseContext>(_ctx, getState());
  enterRule(_localctx, 322, MySQLParser::RuleWithClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3160);
    match(MySQLParser::WITH_SYMBOL);
    setState(3162);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 326, _ctx)) {
    case 1: {
      setState(3161);
      match(MySQLParser::RECURSIVE_SYMBOL);
      break;
    }

    }
    setState(3164);
    commonTableExpression();
    setState(3169);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3165);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3166);
      commonTableExpression();
      setState(3171);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonTableExpressionContext ------------------------------------------------------------------

MySQLParser::CommonTableExpressionContext::CommonTableExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::CommonTableExpressionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CommonTableExpressionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::SubqueryContext* MySQLParser::CommonTableExpressionContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::CommonTableExpressionContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}


size_t MySQLParser::CommonTableExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleCommonTableExpression;
}

void MySQLParser::CommonTableExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonTableExpression(this);
}

void MySQLParser::CommonTableExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonTableExpression(this);
}

MySQLParser::CommonTableExpressionContext* MySQLParser::commonTableExpression() {
  CommonTableExpressionContext *_localctx = _tracker.createInstance<CommonTableExpressionContext>(_ctx, getState());
  enterRule(_localctx, 324, MySQLParser::RuleCommonTableExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3172);
    identifier();
    setState(3174);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(3173);
      columnInternalRefList();
    }
    setState(3176);
    match(MySQLParser::AS_SYMBOL);
    setState(3177);
    subquery();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupByClauseContext ------------------------------------------------------------------

MySQLParser::GroupByClauseContext::GroupByClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GroupByClauseContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupByClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext* MySQLParser::GroupByClauseContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}

MySQLParser::OlapOptionContext* MySQLParser::GroupByClauseContext::olapOption() {
  return getRuleContext<MySQLParser::OlapOptionContext>(0);
}


size_t MySQLParser::GroupByClauseContext::getRuleIndex() const {
  return MySQLParser::RuleGroupByClause;
}

void MySQLParser::GroupByClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupByClause(this);
}

void MySQLParser::GroupByClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupByClause(this);
}

MySQLParser::GroupByClauseContext* MySQLParser::groupByClause() {
  GroupByClauseContext *_localctx = _tracker.createInstance<GroupByClauseContext>(_ctx, getState());
  enterRule(_localctx, 326, MySQLParser::RuleGroupByClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3179);
    match(MySQLParser::GROUP_SYMBOL);
    setState(3180);
    match(MySQLParser::BY_SYMBOL);
    setState(3181);
    orderList();
    setState(3183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 329, _ctx)) {
    case 1: {
      setState(3182);
      olapOption();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OlapOptionContext ------------------------------------------------------------------

MySQLParser::OlapOptionContext::OlapOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OlapOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OlapOptionContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OlapOptionContext::CUBE_SYMBOL() {
  return getToken(MySQLParser::CUBE_SYMBOL, 0);
}


size_t MySQLParser::OlapOptionContext::getRuleIndex() const {
  return MySQLParser::RuleOlapOption;
}

void MySQLParser::OlapOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOlapOption(this);
}

void MySQLParser::OlapOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOlapOption(this);
}

MySQLParser::OlapOptionContext* MySQLParser::olapOption() {
  OlapOptionContext *_localctx = _tracker.createInstance<OlapOptionContext>(_ctx, getState());
  enterRule(_localctx, 328, MySQLParser::RuleOlapOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3190);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 330, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3185);
      match(MySQLParser::WITH_SYMBOL);
      setState(3186);
      match(MySQLParser::ROLLUP_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3187);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(3188);
      match(MySQLParser::WITH_SYMBOL);
      setState(3189);
      match(MySQLParser::CUBE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderClauseContext ------------------------------------------------------------------

MySQLParser::OrderClauseContext::OrderClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OrderClauseContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OrderClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::OrderListContext* MySQLParser::OrderClauseContext::orderList() {
  return getRuleContext<MySQLParser::OrderListContext>(0);
}


size_t MySQLParser::OrderClauseContext::getRuleIndex() const {
  return MySQLParser::RuleOrderClause;
}

void MySQLParser::OrderClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderClause(this);
}

void MySQLParser::OrderClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderClause(this);
}

MySQLParser::OrderClauseContext* MySQLParser::orderClause() {
  OrderClauseContext *_localctx = _tracker.createInstance<OrderClauseContext>(_ctx, getState());
  enterRule(_localctx, 330, MySQLParser::RuleOrderClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3192);
    match(MySQLParser::ORDER_SYMBOL);
    setState(3193);
    match(MySQLParser::BY_SYMBOL);
    setState(3194);
    orderList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DirectionContext ------------------------------------------------------------------

MySQLParser::DirectionContext::DirectionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DirectionContext::ASC_SYMBOL() {
  return getToken(MySQLParser::ASC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DirectionContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}


size_t MySQLParser::DirectionContext::getRuleIndex() const {
  return MySQLParser::RuleDirection;
}

void MySQLParser::DirectionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDirection(this);
}

void MySQLParser::DirectionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDirection(this);
}

MySQLParser::DirectionContext* MySQLParser::direction() {
  DirectionContext *_localctx = _tracker.createInstance<DirectionContext>(_ctx, getState());
  enterRule(_localctx, 332, MySQLParser::RuleDirection);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3196);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromClauseContext ------------------------------------------------------------------

MySQLParser::FromClauseContext::FromClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FromClauseContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FromClauseContext::DUAL_SYMBOL() {
  return getToken(MySQLParser::DUAL_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext* MySQLParser::FromClauseContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}


size_t MySQLParser::FromClauseContext::getRuleIndex() const {
  return MySQLParser::RuleFromClause;
}

void MySQLParser::FromClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromClause(this);
}

void MySQLParser::FromClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromClause(this);
}

MySQLParser::FromClauseContext* MySQLParser::fromClause() {
  FromClauseContext *_localctx = _tracker.createInstance<FromClauseContext>(_ctx, getState());
  enterRule(_localctx, 334, MySQLParser::RuleFromClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3198);
    match(MySQLParser::FROM_SYMBOL);
    setState(3201);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 331, _ctx)) {
    case 1: {
      setState(3199);
      match(MySQLParser::DUAL_SYMBOL);
      break;
    }

    case 2: {
      setState(3200);
      tableReferenceList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceListContext ------------------------------------------------------------------

MySQLParser::TableReferenceListContext::TableReferenceListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableReferenceContext *> MySQLParser::TableReferenceListContext::tableReference() {
  return getRuleContexts<MySQLParser::TableReferenceContext>();
}

MySQLParser::TableReferenceContext* MySQLParser::TableReferenceListContext::tableReference(size_t i) {
  return getRuleContext<MySQLParser::TableReferenceContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableReferenceListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableReferenceListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableReferenceListContext::getRuleIndex() const {
  return MySQLParser::RuleTableReferenceList;
}

void MySQLParser::TableReferenceListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReferenceList(this);
}

void MySQLParser::TableReferenceListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReferenceList(this);
}

MySQLParser::TableReferenceListContext* MySQLParser::tableReferenceList() {
  TableReferenceListContext *_localctx = _tracker.createInstance<TableReferenceListContext>(_ctx, getState());
  enterRule(_localctx, 336, MySQLParser::RuleTableReferenceList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3203);
    tableReference();
    setState(3208);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3204);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3205);
        tableReference(); 
      }
      setState(3210);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 332, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectOptionContext ------------------------------------------------------------------

MySQLParser::SelectOptionContext::SelectOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QuerySpecOptionContext* MySQLParser::SelectOptionContext::querySpecOption() {
  return getRuleContext<MySQLParser::QuerySpecOptionContext>(0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::SQL_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::MAX_STATEMENT_TIME_SYMBOL() {
  return getToken(MySQLParser::MAX_STATEMENT_TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SelectOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::SelectOptionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}


size_t MySQLParser::SelectOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSelectOption;
}

void MySQLParser::SelectOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectOption(this);
}

void MySQLParser::SelectOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectOption(this);
}

MySQLParser::SelectOptionContext* MySQLParser::selectOption() {
  SelectOptionContext *_localctx = _tracker.createInstance<SelectOptionContext>(_ctx, getState());
  enterRule(_localctx, 338, MySQLParser::RuleSelectOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3219);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 333, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3211);
      querySpecOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3212);
      match(MySQLParser::SQL_NO_CACHE_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3213);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(3214);
      match(MySQLParser::SQL_CACHE_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3215);

      if (!(serverVersion >= 50704 && serverVersion < 50708)) throw FailedPredicateException(this, "serverVersion >= 50704 && serverVersion < 50708");
      setState(3216);
      match(MySQLParser::MAX_STATEMENT_TIME_SYMBOL);
      setState(3217);
      match(MySQLParser::EQUAL_OPERATOR);
      setState(3218);
      real_ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockingClauseContext ------------------------------------------------------------------

MySQLParser::LockingClauseContext::LockingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockingClauseContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::LockStrenghContext* MySQLParser::LockingClauseContext::lockStrengh() {
  return getRuleContext<MySQLParser::LockStrenghContext>(0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::OF_SYMBOL() {
  return getToken(MySQLParser::OF_SYMBOL, 0);
}

MySQLParser::TableAliasRefListContext* MySQLParser::LockingClauseContext::tableAliasRefList() {
  return getRuleContext<MySQLParser::TableAliasRefListContext>(0);
}

MySQLParser::LockedRowActionContext* MySQLParser::LockingClauseContext::lockedRowAction() {
  return getRuleContext<MySQLParser::LockedRowActionContext>(0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockingClauseContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}


size_t MySQLParser::LockingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLockingClause;
}

void MySQLParser::LockingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockingClause(this);
}

void MySQLParser::LockingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockingClause(this);
}

MySQLParser::LockingClauseContext* MySQLParser::lockingClause() {
  LockingClauseContext *_localctx = _tracker.createInstance<LockingClauseContext>(_ctx, getState());
  enterRule(_localctx, 340, MySQLParser::RuleLockingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3236);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3221);
        match(MySQLParser::FOR_SYMBOL);
        setState(3222);
        lockStrengh();
        setState(3226);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 334, _ctx)) {
        case 1: {
          setState(3223);

          if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
          setState(3224);
          match(MySQLParser::OF_SYMBOL);
          setState(3225);
          tableAliasRefList();
          break;
        }

        }
        setState(3230);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 335, _ctx)) {
        case 1: {
          setState(3228);

          if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
          setState(3229);
          lockedRowAction();
          break;
        }

        }
        break;
      }

      case MySQLParser::LOCK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3232);
        match(MySQLParser::LOCK_SYMBOL);
        setState(3233);
        match(MySQLParser::IN_SYMBOL);
        setState(3234);
        match(MySQLParser::SHARE_SYMBOL);
        setState(3235);
        match(MySQLParser::MODE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStrenghContext ------------------------------------------------------------------

MySQLParser::LockStrenghContext::LockStrenghContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockStrenghContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStrenghContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}


size_t MySQLParser::LockStrenghContext::getRuleIndex() const {
  return MySQLParser::RuleLockStrengh;
}

void MySQLParser::LockStrenghContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStrengh(this);
}

void MySQLParser::LockStrenghContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStrengh(this);
}

MySQLParser::LockStrenghContext* MySQLParser::lockStrengh() {
  LockStrenghContext *_localctx = _tracker.createInstance<LockStrenghContext>(_ctx, getState());
  enterRule(_localctx, 342, MySQLParser::RuleLockStrengh);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3241);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 337, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3238);
      match(MySQLParser::UPDATE_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3239);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3240);
      match(MySQLParser::SHARE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockedRowActionContext ------------------------------------------------------------------

MySQLParser::LockedRowActionContext::LockedRowActionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockedRowActionContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockedRowActionContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockedRowActionContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}


size_t MySQLParser::LockedRowActionContext::getRuleIndex() const {
  return MySQLParser::RuleLockedRowAction;
}

void MySQLParser::LockedRowActionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockedRowAction(this);
}

void MySQLParser::LockedRowActionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockedRowAction(this);
}

MySQLParser::LockedRowActionContext* MySQLParser::lockedRowAction() {
  LockedRowActionContext *_localctx = _tracker.createInstance<LockedRowActionContext>(_ctx, getState());
  enterRule(_localctx, 344, MySQLParser::RuleLockedRowAction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3246);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SKIP_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3243);
        match(MySQLParser::SKIP_SYMBOL);
        setState(3244);
        match(MySQLParser::LOCKED_SYMBOL);
        break;
      }

      case MySQLParser::NOWAIT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3245);
        match(MySQLParser::NOWAIT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectItemListContext ------------------------------------------------------------------

MySQLParser::SelectItemListContext::SelectItemListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SelectItemContext *> MySQLParser::SelectItemListContext::selectItem() {
  return getRuleContexts<MySQLParser::SelectItemContext>();
}

MySQLParser::SelectItemContext* MySQLParser::SelectItemListContext::selectItem(size_t i) {
  return getRuleContext<MySQLParser::SelectItemContext>(i);
}

tree::TerminalNode* MySQLParser::SelectItemListContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SelectItemListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SelectItemListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SelectItemListContext::getRuleIndex() const {
  return MySQLParser::RuleSelectItemList;
}

void MySQLParser::SelectItemListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectItemList(this);
}

void MySQLParser::SelectItemListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectItemList(this);
}

MySQLParser::SelectItemListContext* MySQLParser::selectItemList() {
  SelectItemListContext *_localctx = _tracker.createInstance<SelectItemListContext>(_ctx, getState());
  enterRule(_localctx, 346, MySQLParser::RuleSelectItemList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3250);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 339, _ctx)) {
    case 1: {
      setState(3248);
      selectItem();
      break;
    }

    case 2: {
      setState(3249);
      match(MySQLParser::MULT_OPERATOR);
      break;
    }

    }
    setState(3256);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3252);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3253);
        selectItem(); 
      }
      setState(3258);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 340, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectItemContext ------------------------------------------------------------------

MySQLParser::SelectItemContext::SelectItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableWildContext* MySQLParser::SelectItemContext::tableWild() {
  return getRuleContext<MySQLParser::TableWildContext>(0);
}

MySQLParser::ExprContext* MySQLParser::SelectItemContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SelectAliasContext* MySQLParser::SelectItemContext::selectAlias() {
  return getRuleContext<MySQLParser::SelectAliasContext>(0);
}


size_t MySQLParser::SelectItemContext::getRuleIndex() const {
  return MySQLParser::RuleSelectItem;
}

void MySQLParser::SelectItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectItem(this);
}

void MySQLParser::SelectItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectItem(this);
}

MySQLParser::SelectItemContext* MySQLParser::selectItem() {
  SelectItemContext *_localctx = _tracker.createInstance<SelectItemContext>(_ctx, getState());
  enterRule(_localctx, 348, MySQLParser::RuleSelectItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3264);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 342, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3259);
      tableWild();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3260);
      expr(0);
      setState(3262);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 341, _ctx)) {
      case 1: {
        setState(3261);
        selectAlias();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SelectAliasContext ------------------------------------------------------------------

MySQLParser::SelectAliasContext::SelectAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SelectAliasContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::SelectAliasContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::SelectAliasContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}


size_t MySQLParser::SelectAliasContext::getRuleIndex() const {
  return MySQLParser::RuleSelectAlias;
}

void MySQLParser::SelectAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSelectAlias(this);
}

void MySQLParser::SelectAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSelectAlias(this);
}

MySQLParser::SelectAliasContext* MySQLParser::selectAlias() {
  SelectAliasContext *_localctx = _tracker.createInstance<SelectAliasContext>(_ctx, getState());
  enterRule(_localctx, 350, MySQLParser::RuleSelectAlias);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3267);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 343, _ctx)) {
    case 1: {
      setState(3266);
      match(MySQLParser::AS_SYMBOL);
      break;
    }

    }
    setState(3271);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 344, _ctx)) {
    case 1: {
      setState(3269);
      identifier();
      break;
    }

    case 2: {
      setState(3270);
      textStringLiteral();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhereClauseContext ------------------------------------------------------------------

MySQLParser::WhereClauseContext::WhereClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WhereClauseContext::WHERE_SYMBOL() {
  return getToken(MySQLParser::WHERE_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WhereClauseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::WhereClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWhereClause;
}

void MySQLParser::WhereClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhereClause(this);
}

void MySQLParser::WhereClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhereClause(this);
}

MySQLParser::WhereClauseContext* MySQLParser::whereClause() {
  WhereClauseContext *_localctx = _tracker.createInstance<WhereClauseContext>(_ctx, getState());
  enterRule(_localctx, 352, MySQLParser::RuleWhereClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3273);
    match(MySQLParser::WHERE_SYMBOL);
    setState(3274);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceContext ------------------------------------------------------------------

MySQLParser::TableReferenceContext::TableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableFactorContext* MySQLParser::TableReferenceContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}

tree::TerminalNode* MySQLParser::TableReferenceContext::OPEN_CURLY_SYMBOL() {
  return getToken(MySQLParser::OPEN_CURLY_SYMBOL, 0);
}

MySQLParser::EscapedTableReferenceContext* MySQLParser::TableReferenceContext::escapedTableReference() {
  return getRuleContext<MySQLParser::EscapedTableReferenceContext>(0);
}

tree::TerminalNode* MySQLParser::TableReferenceContext::CLOSE_CURLY_SYMBOL() {
  return getToken(MySQLParser::CLOSE_CURLY_SYMBOL, 0);
}

std::vector<MySQLParser::JoinedTableContext *> MySQLParser::TableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLParser::JoinedTableContext>();
}

MySQLParser::JoinedTableContext* MySQLParser::TableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLParser::JoinedTableContext>(i);
}

MySQLParser::IdentifierContext* MySQLParser::TableReferenceContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::TableReferenceContext::OJ_SYMBOL() {
  return getToken(MySQLParser::OJ_SYMBOL, 0);
}


size_t MySQLParser::TableReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleTableReference;
}

void MySQLParser::TableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReference(this);
}

void MySQLParser::TableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReference(this);
}

MySQLParser::TableReferenceContext* MySQLParser::tableReference() {
  TableReferenceContext *_localctx = _tracker.createInstance<TableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 354, MySQLParser::RuleTableReference);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3286);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 346, _ctx)) {
    case 1: {
      setState(3276);
      tableFactor();
      break;
    }

    case 2: {
      setState(3277);
      match(MySQLParser::OPEN_CURLY_SYMBOL);
      setState(3281);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 345, _ctx)) {
      case 1: {
        setState(3278);

        if (!(serverVersion < 80017)) throw FailedPredicateException(this, "serverVersion < 80017");
        setState(3279);
        identifier();
        break;
      }

      case 2: {
        setState(3280);
        match(MySQLParser::OJ_SYMBOL);
        break;
      }

      }
      setState(3283);
      escapedTableReference();
      setState(3284);
      match(MySQLParser::CLOSE_CURLY_SYMBOL);
      break;
    }

    }
    setState(3291);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3288);
        joinedTable(); 
      }
      setState(3293);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 347, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EscapedTableReferenceContext ------------------------------------------------------------------

MySQLParser::EscapedTableReferenceContext::EscapedTableReferenceContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableFactorContext* MySQLParser::EscapedTableReferenceContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}

std::vector<MySQLParser::JoinedTableContext *> MySQLParser::EscapedTableReferenceContext::joinedTable() {
  return getRuleContexts<MySQLParser::JoinedTableContext>();
}

MySQLParser::JoinedTableContext* MySQLParser::EscapedTableReferenceContext::joinedTable(size_t i) {
  return getRuleContext<MySQLParser::JoinedTableContext>(i);
}


size_t MySQLParser::EscapedTableReferenceContext::getRuleIndex() const {
  return MySQLParser::RuleEscapedTableReference;
}

void MySQLParser::EscapedTableReferenceContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEscapedTableReference(this);
}

void MySQLParser::EscapedTableReferenceContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEscapedTableReference(this);
}

MySQLParser::EscapedTableReferenceContext* MySQLParser::escapedTableReference() {
  EscapedTableReferenceContext *_localctx = _tracker.createInstance<EscapedTableReferenceContext>(_ctx, getState());
  enterRule(_localctx, 356, MySQLParser::RuleEscapedTableReference);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3294);
    tableFactor();
    setState(3298);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::CROSS_SYMBOL || ((((_la - 278) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 278)) & ((1ULL << (MySQLParser::INNER_SYMBOL - 278))
      | (1ULL << (MySQLParser::JOIN_SYMBOL - 278))
      | (1ULL << (MySQLParser::LEFT_SYMBOL - 278)))) != 0) || _la == MySQLParser::NATURAL_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL || _la == MySQLParser::STRAIGHT_JOIN_SYMBOL) {
      setState(3295);
      joinedTable();
      setState(3300);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JoinedTableContext ------------------------------------------------------------------

MySQLParser::JoinedTableContext::JoinedTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InnerJoinTypeContext* MySQLParser::JoinedTableContext::innerJoinType() {
  return getRuleContext<MySQLParser::InnerJoinTypeContext>(0);
}

MySQLParser::TableReferenceContext* MySQLParser::JoinedTableContext::tableReference() {
  return getRuleContext<MySQLParser::TableReferenceContext>(0);
}

tree::TerminalNode* MySQLParser::JoinedTableContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::JoinedTableContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::JoinedTableContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::JoinedTableContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

MySQLParser::OuterJoinTypeContext* MySQLParser::JoinedTableContext::outerJoinType() {
  return getRuleContext<MySQLParser::OuterJoinTypeContext>(0);
}

MySQLParser::NaturalJoinTypeContext* MySQLParser::JoinedTableContext::naturalJoinType() {
  return getRuleContext<MySQLParser::NaturalJoinTypeContext>(0);
}

MySQLParser::TableFactorContext* MySQLParser::JoinedTableContext::tableFactor() {
  return getRuleContext<MySQLParser::TableFactorContext>(0);
}


size_t MySQLParser::JoinedTableContext::getRuleIndex() const {
  return MySQLParser::RuleJoinedTable;
}

void MySQLParser::JoinedTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJoinedTable(this);
}

void MySQLParser::JoinedTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJoinedTable(this);
}

MySQLParser::JoinedTableContext* MySQLParser::joinedTable() {
  JoinedTableContext *_localctx = _tracker.createInstance<JoinedTableContext>(_ctx, getState());
  enterRule(_localctx, 358, MySQLParser::RuleJoinedTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3320);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CROSS_SYMBOL:
      case MySQLParser::INNER_SYMBOL:
      case MySQLParser::JOIN_SYMBOL:
      case MySQLParser::STRAIGHT_JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3301);
        innerJoinType();
        setState(3302);
        tableReference();
        setState(3307);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 349, _ctx)) {
        case 1: {
          setState(3303);
          match(MySQLParser::ON_SYMBOL);
          setState(3304);
          expr(0);
          break;
        }

        case 2: {
          setState(3305);
          match(MySQLParser::USING_SYMBOL);
          setState(3306);
          identifierListWithParentheses();
          break;
        }

        }
        break;
      }

      case MySQLParser::LEFT_SYMBOL:
      case MySQLParser::RIGHT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3309);
        outerJoinType();
        setState(3310);
        tableReference();
        setState(3315);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::ON_SYMBOL: {
            setState(3311);
            match(MySQLParser::ON_SYMBOL);
            setState(3312);
            expr(0);
            break;
          }

          case MySQLParser::USING_SYMBOL: {
            setState(3313);
            match(MySQLParser::USING_SYMBOL);
            setState(3314);
            identifierListWithParentheses();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::NATURAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3317);
        naturalJoinType();
        setState(3318);
        tableFactor();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NaturalJoinTypeContext ------------------------------------------------------------------

MySQLParser::NaturalJoinTypeContext::NaturalJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::NATURAL_SYMBOL() {
  return getToken(MySQLParser::NATURAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::INNER_SYMBOL() {
  return getToken(MySQLParser::INNER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NaturalJoinTypeContext::OUTER_SYMBOL() {
  return getToken(MySQLParser::OUTER_SYMBOL, 0);
}


size_t MySQLParser::NaturalJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleNaturalJoinType;
}

void MySQLParser::NaturalJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNaturalJoinType(this);
}

void MySQLParser::NaturalJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNaturalJoinType(this);
}

MySQLParser::NaturalJoinTypeContext* MySQLParser::naturalJoinType() {
  NaturalJoinTypeContext *_localctx = _tracker.createInstance<NaturalJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 360, MySQLParser::RuleNaturalJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3333);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 354, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3322);
      match(MySQLParser::NATURAL_SYMBOL);
      setState(3324);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::INNER_SYMBOL) {
        setState(3323);
        match(MySQLParser::INNER_SYMBOL);
      }
      setState(3326);
      match(MySQLParser::JOIN_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3327);
      match(MySQLParser::NATURAL_SYMBOL);
      setState(3328);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LEFT_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3330);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::OUTER_SYMBOL) {
        setState(3329);
        match(MySQLParser::OUTER_SYMBOL);
      }
      setState(3332);
      match(MySQLParser::JOIN_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InnerJoinTypeContext ------------------------------------------------------------------

MySQLParser::InnerJoinTypeContext::InnerJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::INNER_SYMBOL() {
  return getToken(MySQLParser::INNER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::CROSS_SYMBOL() {
  return getToken(MySQLParser::CROSS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InnerJoinTypeContext::STRAIGHT_JOIN_SYMBOL() {
  return getToken(MySQLParser::STRAIGHT_JOIN_SYMBOL, 0);
}


size_t MySQLParser::InnerJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleInnerJoinType;
}

void MySQLParser::InnerJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInnerJoinType(this);
}

void MySQLParser::InnerJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInnerJoinType(this);
}

MySQLParser::InnerJoinTypeContext* MySQLParser::innerJoinType() {
  InnerJoinTypeContext *_localctx = _tracker.createInstance<InnerJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 362, MySQLParser::RuleInnerJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3340);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CROSS_SYMBOL:
      case MySQLParser::INNER_SYMBOL:
      case MySQLParser::JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3336);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CROSS_SYMBOL || _la == MySQLParser::INNER_SYMBOL) {
          setState(3335);
          dynamic_cast<InnerJoinTypeContext *>(_localctx)->type = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::CROSS_SYMBOL || _la == MySQLParser::INNER_SYMBOL)) {
            dynamic_cast<InnerJoinTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(3338);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      case MySQLParser::STRAIGHT_JOIN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3339);
        dynamic_cast<InnerJoinTypeContext *>(_localctx)->type = match(MySQLParser::STRAIGHT_JOIN_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OuterJoinTypeContext ------------------------------------------------------------------

MySQLParser::OuterJoinTypeContext::OuterJoinTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OuterJoinTypeContext::OUTER_SYMBOL() {
  return getToken(MySQLParser::OUTER_SYMBOL, 0);
}


size_t MySQLParser::OuterJoinTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOuterJoinType;
}

void MySQLParser::OuterJoinTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOuterJoinType(this);
}

void MySQLParser::OuterJoinTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOuterJoinType(this);
}

MySQLParser::OuterJoinTypeContext* MySQLParser::outerJoinType() {
  OuterJoinTypeContext *_localctx = _tracker.createInstance<OuterJoinTypeContext>(_ctx, getState());
  enterRule(_localctx, 364, MySQLParser::RuleOuterJoinType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3342);
    dynamic_cast<OuterJoinTypeContext *>(_localctx)->type = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::LEFT_SYMBOL || _la == MySQLParser::RIGHT_SYMBOL)) {
      dynamic_cast<OuterJoinTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(3344);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OUTER_SYMBOL) {
      setState(3343);
      match(MySQLParser::OUTER_SYMBOL);
    }
    setState(3346);
    match(MySQLParser::JOIN_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableFactorContext ------------------------------------------------------------------

MySQLParser::TableFactorContext::TableFactorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SingleTableContext* MySQLParser::TableFactorContext::singleTable() {
  return getRuleContext<MySQLParser::SingleTableContext>(0);
}

MySQLParser::SingleTableParensContext* MySQLParser::TableFactorContext::singleTableParens() {
  return getRuleContext<MySQLParser::SingleTableParensContext>(0);
}

MySQLParser::DerivedTableContext* MySQLParser::TableFactorContext::derivedTable() {
  return getRuleContext<MySQLParser::DerivedTableContext>(0);
}

MySQLParser::TableReferenceListParensContext* MySQLParser::TableFactorContext::tableReferenceListParens() {
  return getRuleContext<MySQLParser::TableReferenceListParensContext>(0);
}

MySQLParser::TableFunctionContext* MySQLParser::TableFactorContext::tableFunction() {
  return getRuleContext<MySQLParser::TableFunctionContext>(0);
}


size_t MySQLParser::TableFactorContext::getRuleIndex() const {
  return MySQLParser::RuleTableFactor;
}

void MySQLParser::TableFactorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFactor(this);
}

void MySQLParser::TableFactorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFactor(this);
}

MySQLParser::TableFactorContext* MySQLParser::tableFactor() {
  TableFactorContext *_localctx = _tracker.createInstance<TableFactorContext>(_ctx, getState());
  enterRule(_localctx, 366, MySQLParser::RuleTableFactor);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3354);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 358, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3348);
      singleTable();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3349);
      singleTableParens();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3350);
      derivedTable();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3351);
      tableReferenceListParens();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3352);

      if (!(serverVersion >= 80004)) throw FailedPredicateException(this, "serverVersion >= 80004");
      setState(3353);
      tableFunction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleTableContext ------------------------------------------------------------------

MySQLParser::SingleTableContext::SingleTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::SingleTableContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::UsePartitionContext* MySQLParser::SingleTableContext::usePartition() {
  return getRuleContext<MySQLParser::UsePartitionContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::SingleTableContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::IndexHintListContext* MySQLParser::SingleTableContext::indexHintList() {
  return getRuleContext<MySQLParser::IndexHintListContext>(0);
}


size_t MySQLParser::SingleTableContext::getRuleIndex() const {
  return MySQLParser::RuleSingleTable;
}

void MySQLParser::SingleTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleTable(this);
}

void MySQLParser::SingleTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleTable(this);
}

MySQLParser::SingleTableContext* MySQLParser::singleTable() {
  SingleTableContext *_localctx = _tracker.createInstance<SingleTableContext>(_ctx, getState());
  enterRule(_localctx, 368, MySQLParser::RuleSingleTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3356);
    tableRef();
    setState(3358);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 359, _ctx)) {
    case 1: {
      setState(3357);
      usePartition();
      break;
    }

    }
    setState(3361);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 360, _ctx)) {
    case 1: {
      setState(3360);
      tableAlias();
      break;
    }

    }
    setState(3364);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 361, _ctx)) {
    case 1: {
      setState(3363);
      indexHintList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SingleTableParensContext ------------------------------------------------------------------

MySQLParser::SingleTableParensContext::SingleTableParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SingleTableParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SingleTableParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SingleTableContext* MySQLParser::SingleTableParensContext::singleTable() {
  return getRuleContext<MySQLParser::SingleTableContext>(0);
}

MySQLParser::SingleTableParensContext* MySQLParser::SingleTableParensContext::singleTableParens() {
  return getRuleContext<MySQLParser::SingleTableParensContext>(0);
}


size_t MySQLParser::SingleTableParensContext::getRuleIndex() const {
  return MySQLParser::RuleSingleTableParens;
}

void MySQLParser::SingleTableParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSingleTableParens(this);
}

void MySQLParser::SingleTableParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSingleTableParens(this);
}

MySQLParser::SingleTableParensContext* MySQLParser::singleTableParens() {
  SingleTableParensContext *_localctx = _tracker.createInstance<SingleTableParensContext>(_ctx, getState());
  enterRule(_localctx, 370, MySQLParser::RuleSingleTableParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3366);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3369);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 362, _ctx)) {
    case 1: {
      setState(3367);
      singleTable();
      break;
    }

    case 2: {
      setState(3368);
      singleTableParens();
      break;
    }

    }
    setState(3371);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DerivedTableContext ------------------------------------------------------------------

MySQLParser::DerivedTableContext::DerivedTableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SubqueryContext* MySQLParser::DerivedTableContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::DerivedTableContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::DerivedTableContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

tree::TerminalNode* MySQLParser::DerivedTableContext::LATERAL_SYMBOL() {
  return getToken(MySQLParser::LATERAL_SYMBOL, 0);
}


size_t MySQLParser::DerivedTableContext::getRuleIndex() const {
  return MySQLParser::RuleDerivedTable;
}

void MySQLParser::DerivedTableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDerivedTable(this);
}

void MySQLParser::DerivedTableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDerivedTable(this);
}

MySQLParser::DerivedTableContext* MySQLParser::derivedTable() {
  DerivedTableContext *_localctx = _tracker.createInstance<DerivedTableContext>(_ctx, getState());
  enterRule(_localctx, 372, MySQLParser::RuleDerivedTable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3390);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 367, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3373);
      subquery();
      setState(3375);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 363, _ctx)) {
      case 1: {
        setState(3374);
        tableAlias();
        break;
      }

      }
      setState(3379);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 364, _ctx)) {
      case 1: {
        setState(3377);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(3378);
        columnInternalRefList();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3381);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(3382);
      match(MySQLParser::LATERAL_SYMBOL);
      setState(3383);
      subquery();
      setState(3385);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 365, _ctx)) {
      case 1: {
        setState(3384);
        tableAlias();
        break;
      }

      }
      setState(3388);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 366, _ctx)) {
      case 1: {
        setState(3387);
        columnInternalRefList();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableReferenceListParensContext ------------------------------------------------------------------

MySQLParser::TableReferenceListParensContext::TableReferenceListParensContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TableReferenceListParensContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableReferenceListParensContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext* MySQLParser::TableReferenceListParensContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

MySQLParser::TableReferenceListParensContext* MySQLParser::TableReferenceListParensContext::tableReferenceListParens() {
  return getRuleContext<MySQLParser::TableReferenceListParensContext>(0);
}


size_t MySQLParser::TableReferenceListParensContext::getRuleIndex() const {
  return MySQLParser::RuleTableReferenceListParens;
}

void MySQLParser::TableReferenceListParensContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableReferenceListParens(this);
}

void MySQLParser::TableReferenceListParensContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableReferenceListParens(this);
}

MySQLParser::TableReferenceListParensContext* MySQLParser::tableReferenceListParens() {
  TableReferenceListParensContext *_localctx = _tracker.createInstance<TableReferenceListParensContext>(_ctx, getState());
  enterRule(_localctx, 374, MySQLParser::RuleTableReferenceListParens);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3392);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3395);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 368, _ctx)) {
    case 1: {
      setState(3393);
      tableReferenceList();
      break;
    }

    case 2: {
      setState(3394);
      tableReferenceListParens();
      break;
    }

    }
    setState(3397);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableFunctionContext ------------------------------------------------------------------

MySQLParser::TableFunctionContext::TableFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TableFunctionContext::JSON_TABLE_SYMBOL() {
  return getToken(MySQLParser::JSON_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::TableFunctionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::TableFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::TableFunctionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::ColumnsClauseContext* MySQLParser::TableFunctionContext::columnsClause() {
  return getRuleContext<MySQLParser::ColumnsClauseContext>(0);
}

tree::TerminalNode* MySQLParser::TableFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::TableAliasContext* MySQLParser::TableFunctionContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}


size_t MySQLParser::TableFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleTableFunction;
}

void MySQLParser::TableFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableFunction(this);
}

void MySQLParser::TableFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableFunction(this);
}

MySQLParser::TableFunctionContext* MySQLParser::tableFunction() {
  TableFunctionContext *_localctx = _tracker.createInstance<TableFunctionContext>(_ctx, getState());
  enterRule(_localctx, 376, MySQLParser::RuleTableFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3399);
    match(MySQLParser::JSON_TABLE_SYMBOL);
    setState(3400);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3401);
    expr(0);
    setState(3402);
    match(MySQLParser::COMMA_SYMBOL);
    setState(3403);
    textStringLiteral();
    setState(3404);
    columnsClause();
    setState(3405);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(3407);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 369, _ctx)) {
    case 1: {
      setState(3406);
      tableAlias();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnsClauseContext ------------------------------------------------------------------

MySQLParser::ColumnsClauseContext::ColumnsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::JtColumnContext *> MySQLParser::ColumnsClauseContext::jtColumn() {
  return getRuleContexts<MySQLParser::JtColumnContext>();
}

MySQLParser::JtColumnContext* MySQLParser::ColumnsClauseContext::jtColumn(size_t i) {
  return getRuleContext<MySQLParser::JtColumnContext>(i);
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ColumnsClauseContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ColumnsClauseContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ColumnsClauseContext::getRuleIndex() const {
  return MySQLParser::RuleColumnsClause;
}

void MySQLParser::ColumnsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnsClause(this);
}

void MySQLParser::ColumnsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnsClause(this);
}

MySQLParser::ColumnsClauseContext* MySQLParser::columnsClause() {
  ColumnsClauseContext *_localctx = _tracker.createInstance<ColumnsClauseContext>(_ctx, getState());
  enterRule(_localctx, 378, MySQLParser::RuleColumnsClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3409);
    match(MySQLParser::COLUMNS_SYMBOL);
    setState(3410);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3411);
    jtColumn();
    setState(3416);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3412);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3413);
      jtColumn();
      setState(3418);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(3419);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JtColumnContext ------------------------------------------------------------------

MySQLParser::JtColumnContext::JtColumnContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::JtColumnContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

MySQLParser::DataTypeContext* MySQLParser::JtColumnContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::JtColumnContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::CollateContext* MySQLParser::JtColumnContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

MySQLParser::OnEmptyOrErrorContext* MySQLParser::JtColumnContext::onEmptyOrError() {
  return getRuleContext<MySQLParser::OnEmptyOrErrorContext>(0);
}

tree::TerminalNode* MySQLParser::JtColumnContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

MySQLParser::ColumnsClauseContext* MySQLParser::JtColumnContext::columnsClause() {
  return getRuleContext<MySQLParser::ColumnsClauseContext>(0);
}


size_t MySQLParser::JtColumnContext::getRuleIndex() const {
  return MySQLParser::RuleJtColumn;
}

void MySQLParser::JtColumnContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJtColumn(this);
}

void MySQLParser::JtColumnContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJtColumn(this);
}

MySQLParser::JtColumnContext* MySQLParser::jtColumn() {
  JtColumnContext *_localctx = _tracker.createInstance<JtColumnContext>(_ctx, getState());
  enterRule(_localctx, 380, MySQLParser::RuleJtColumn);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3444);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 374, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3421);
      identifier();
      setState(3422);
      match(MySQLParser::FOR_SYMBOL);
      setState(3423);
      match(MySQLParser::ORDINALITY_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3425);
      identifier();
      setState(3426);
      dataType();
      setState(3429);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 371, _ctx)) {
      case 1: {
        setState(3427);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(3428);
        collate();
        break;
      }

      }
      setState(3432);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EXISTS_SYMBOL) {
        setState(3431);
        match(MySQLParser::EXISTS_SYMBOL);
      }
      setState(3434);
      match(MySQLParser::PATH_SYMBOL);
      setState(3435);
      textStringLiteral();
      setState(3437);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DEFAULT_SYMBOL

      || _la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
        setState(3436);
        onEmptyOrError();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3439);
      match(MySQLParser::NESTED_SYMBOL);
      setState(3440);
      match(MySQLParser::PATH_SYMBOL);
      setState(3441);
      textStringLiteral();
      setState(3442);
      columnsClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnEmptyOrErrorContext ------------------------------------------------------------------

MySQLParser::OnEmptyOrErrorContext::OnEmptyOrErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OnEmptyContext* MySQLParser::OnEmptyOrErrorContext::onEmpty() {
  return getRuleContext<MySQLParser::OnEmptyContext>(0);
}

MySQLParser::OnErrorContext* MySQLParser::OnEmptyOrErrorContext::onError() {
  return getRuleContext<MySQLParser::OnErrorContext>(0);
}


size_t MySQLParser::OnEmptyOrErrorContext::getRuleIndex() const {
  return MySQLParser::RuleOnEmptyOrError;
}

void MySQLParser::OnEmptyOrErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnEmptyOrError(this);
}

void MySQLParser::OnEmptyOrErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnEmptyOrError(this);
}

MySQLParser::OnEmptyOrErrorContext* MySQLParser::onEmptyOrError() {
  OnEmptyOrErrorContext *_localctx = _tracker.createInstance<OnEmptyOrErrorContext>(_ctx, getState());
  enterRule(_localctx, 382, MySQLParser::RuleOnEmptyOrError);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3454);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 377, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3446);
      onEmpty();
      setState(3448);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DEFAULT_SYMBOL

      || _la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
        setState(3447);
        onError();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3450);
      onError();
      setState(3452);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DEFAULT_SYMBOL

      || _la == MySQLParser::ERROR_SYMBOL || _la == MySQLParser::NULL_SYMBOL) {
        setState(3451);
        onEmpty();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnEmptyContext ------------------------------------------------------------------

MySQLParser::OnEmptyContext::OnEmptyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::JtOnResponseContext* MySQLParser::OnEmptyContext::jtOnResponse() {
  return getRuleContext<MySQLParser::JtOnResponseContext>(0);
}

tree::TerminalNode* MySQLParser::OnEmptyContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OnEmptyContext::EMPTY_SYMBOL() {
  return getToken(MySQLParser::EMPTY_SYMBOL, 0);
}


size_t MySQLParser::OnEmptyContext::getRuleIndex() const {
  return MySQLParser::RuleOnEmpty;
}

void MySQLParser::OnEmptyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnEmpty(this);
}

void MySQLParser::OnEmptyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnEmpty(this);
}

MySQLParser::OnEmptyContext* MySQLParser::onEmpty() {
  OnEmptyContext *_localctx = _tracker.createInstance<OnEmptyContext>(_ctx, getState());
  enterRule(_localctx, 384, MySQLParser::RuleOnEmpty);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3456);
    jtOnResponse();
    setState(3457);
    match(MySQLParser::ON_SYMBOL);
    setState(3458);
    match(MySQLParser::EMPTY_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnErrorContext ------------------------------------------------------------------

MySQLParser::OnErrorContext::OnErrorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::JtOnResponseContext* MySQLParser::OnErrorContext::jtOnResponse() {
  return getRuleContext<MySQLParser::JtOnResponseContext>(0);
}

tree::TerminalNode* MySQLParser::OnErrorContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OnErrorContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}


size_t MySQLParser::OnErrorContext::getRuleIndex() const {
  return MySQLParser::RuleOnError;
}

void MySQLParser::OnErrorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnError(this);
}

void MySQLParser::OnErrorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnError(this);
}

MySQLParser::OnErrorContext* MySQLParser::onError() {
  OnErrorContext *_localctx = _tracker.createInstance<OnErrorContext>(_ctx, getState());
  enterRule(_localctx, 386, MySQLParser::RuleOnError);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3460);
    jtOnResponse();
    setState(3461);
    match(MySQLParser::ON_SYMBOL);
    setState(3462);
    match(MySQLParser::ERROR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JtOnResponseContext ------------------------------------------------------------------

MySQLParser::JtOnResponseContext::JtOnResponseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::JtOnResponseContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JtOnResponseContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JtOnResponseContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::JtOnResponseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::JtOnResponseContext::getRuleIndex() const {
  return MySQLParser::RuleJtOnResponse;
}

void MySQLParser::JtOnResponseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJtOnResponse(this);
}

void MySQLParser::JtOnResponseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJtOnResponse(this);
}

MySQLParser::JtOnResponseContext* MySQLParser::jtOnResponse() {
  JtOnResponseContext *_localctx = _tracker.createInstance<JtOnResponseContext>(_ctx, getState());
  enterRule(_localctx, 388, MySQLParser::RuleJtOnResponse);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3468);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ERROR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3464);
        match(MySQLParser::ERROR_SYMBOL);
        break;
      }

      case MySQLParser::NULL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3465);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case MySQLParser::DEFAULT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3466);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(3467);
        textStringLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnionOptionContext ------------------------------------------------------------------

MySQLParser::UnionOptionContext::UnionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UnionOptionContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UnionOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}


size_t MySQLParser::UnionOptionContext::getRuleIndex() const {
  return MySQLParser::RuleUnionOption;
}

void MySQLParser::UnionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnionOption(this);
}

void MySQLParser::UnionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnionOption(this);
}

MySQLParser::UnionOptionContext* MySQLParser::unionOption() {
  UnionOptionContext *_localctx = _tracker.createInstance<UnionOptionContext>(_ctx, getState());
  enterRule(_localctx, 390, MySQLParser::RuleUnionOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3470);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::DISTINCT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasContext ------------------------------------------------------------------

MySQLParser::TableAliasContext::TableAliasContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TableAliasContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::TableAliasContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAliasContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::TableAliasContext::getRuleIndex() const {
  return MySQLParser::RuleTableAlias;
}

void MySQLParser::TableAliasContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAlias(this);
}

void MySQLParser::TableAliasContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAlias(this);
}

MySQLParser::TableAliasContext* MySQLParser::tableAlias() {
  TableAliasContext *_localctx = _tracker.createInstance<TableAliasContext>(_ctx, getState());
  enterRule(_localctx, 392, MySQLParser::RuleTableAlias);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3475);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 379, _ctx)) {
    case 1: {
      setState(3472);
      match(MySQLParser::AS_SYMBOL);
      break;
    }

    case 2: {
      setState(3473);

      if (!(serverVersion < 80017)) throw FailedPredicateException(this, "serverVersion < 80017");
      setState(3474);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(3477);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintListContext ------------------------------------------------------------------

MySQLParser::IndexHintListContext::IndexHintListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IndexHintContext *> MySQLParser::IndexHintListContext::indexHint() {
  return getRuleContexts<MySQLParser::IndexHintContext>();
}

MySQLParser::IndexHintContext* MySQLParser::IndexHintListContext::indexHint(size_t i) {
  return getRuleContext<MySQLParser::IndexHintContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IndexHintListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IndexHintListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IndexHintListContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintList;
}

void MySQLParser::IndexHintListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintList(this);
}

void MySQLParser::IndexHintListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintList(this);
}

MySQLParser::IndexHintListContext* MySQLParser::indexHintList() {
  IndexHintListContext *_localctx = _tracker.createInstance<IndexHintListContext>(_ctx, getState());
  enterRule(_localctx, 394, MySQLParser::RuleIndexHintList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3479);
    indexHint();
    setState(3484);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3480);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3481);
        indexHint(); 
      }
      setState(3486);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 380, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintContext ------------------------------------------------------------------

MySQLParser::IndexHintContext::IndexHintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexHintTypeContext* MySQLParser::IndexHintContext::indexHintType() {
  return getRuleContext<MySQLParser::IndexHintTypeContext>(0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::IndexHintContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

tree::TerminalNode* MySQLParser::IndexHintContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IndexListContext* MySQLParser::IndexHintContext::indexList() {
  return getRuleContext<MySQLParser::IndexListContext>(0);
}

tree::TerminalNode* MySQLParser::IndexHintContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::IndexHintClauseContext* MySQLParser::IndexHintContext::indexHintClause() {
  return getRuleContext<MySQLParser::IndexHintClauseContext>(0);
}

tree::TerminalNode* MySQLParser::IndexHintContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}


size_t MySQLParser::IndexHintContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHint;
}

void MySQLParser::IndexHintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHint(this);
}

void MySQLParser::IndexHintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHint(this);
}

MySQLParser::IndexHintContext* MySQLParser::indexHint() {
  IndexHintContext *_localctx = _tracker.createInstance<IndexHintContext>(_ctx, getState());
  enterRule(_localctx, 396, MySQLParser::RuleIndexHint);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3507);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FORCE_SYMBOL:
      case MySQLParser::IGNORE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3487);
        indexHintType();
        setState(3488);
        keyOrIndex();
        setState(3490);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(3489);
          indexHintClause();
        }
        setState(3492);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3493);
        indexList();
        setState(3494);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::USE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3496);
        match(MySQLParser::USE_SYMBOL);
        setState(3497);
        keyOrIndex();
        setState(3499);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(3498);
          indexHintClause();
        }
        setState(3501);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3503);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 383, _ctx)) {
        case 1: {
          setState(3502);
          indexList();
          break;
        }

        }
        setState(3505);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintTypeContext ------------------------------------------------------------------

MySQLParser::IndexHintTypeContext::IndexHintTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IndexHintTypeContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintTypeContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::IndexHintTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintType;
}

void MySQLParser::IndexHintTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintType(this);
}

void MySQLParser::IndexHintTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintType(this);
}

MySQLParser::IndexHintTypeContext* MySQLParser::indexHintType() {
  IndexHintTypeContext *_localctx = _tracker.createInstance<IndexHintTypeContext>(_ctx, getState());
  enterRule(_localctx, 398, MySQLParser::RuleIndexHintType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3509);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FORCE_SYMBOL

    || _la == MySQLParser::IGNORE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyOrIndexContext ------------------------------------------------------------------

MySQLParser::KeyOrIndexContext::KeyOrIndexContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::KeyOrIndexContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::KeyOrIndexContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}


size_t MySQLParser::KeyOrIndexContext::getRuleIndex() const {
  return MySQLParser::RuleKeyOrIndex;
}

void MySQLParser::KeyOrIndexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyOrIndex(this);
}

void MySQLParser::KeyOrIndexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyOrIndex(this);
}

MySQLParser::KeyOrIndexContext* MySQLParser::keyOrIndex() {
  KeyOrIndexContext *_localctx = _tracker.createInstance<KeyOrIndexContext>(_ctx, getState());
  enterRule(_localctx, 400, MySQLParser::RuleKeyOrIndex);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3511);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintKeyTypeContext ------------------------------------------------------------------

MySQLParser::ConstraintKeyTypeContext::ConstraintKeyTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConstraintKeyTypeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ConstraintKeyTypeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ConstraintKeyTypeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::ConstraintKeyTypeContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}


size_t MySQLParser::ConstraintKeyTypeContext::getRuleIndex() const {
  return MySQLParser::RuleConstraintKeyType;
}

void MySQLParser::ConstraintKeyTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintKeyType(this);
}

void MySQLParser::ConstraintKeyTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintKeyType(this);
}

MySQLParser::ConstraintKeyTypeContext* MySQLParser::constraintKeyType() {
  ConstraintKeyTypeContext *_localctx = _tracker.createInstance<ConstraintKeyTypeContext>(_ctx, getState());
  enterRule(_localctx, 402, MySQLParser::RuleConstraintKeyType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3519);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PRIMARY_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3513);
        match(MySQLParser::PRIMARY_SYMBOL);
        setState(3514);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3515);
        match(MySQLParser::UNIQUE_SYMBOL);
        setState(3517);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::INDEX_SYMBOL

        || _la == MySQLParser::KEY_SYMBOL) {
          setState(3516);
          keyOrIndex();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexHintClauseContext ------------------------------------------------------------------

MySQLParser::IndexHintClauseContext::IndexHintClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::ORDER_SYMBOL() {
  return getToken(MySQLParser::ORDER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexHintClauseContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}


size_t MySQLParser::IndexHintClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIndexHintClause;
}

void MySQLParser::IndexHintClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexHintClause(this);
}

void MySQLParser::IndexHintClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexHintClause(this);
}

MySQLParser::IndexHintClauseContext* MySQLParser::indexHintClause() {
  IndexHintClauseContext *_localctx = _tracker.createInstance<IndexHintClauseContext>(_ctx, getState());
  enterRule(_localctx, 404, MySQLParser::RuleIndexHintClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3521);
    match(MySQLParser::FOR_SYMBOL);
    setState(3527);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::JOIN_SYMBOL: {
        setState(3522);
        match(MySQLParser::JOIN_SYMBOL);
        break;
      }

      case MySQLParser::ORDER_SYMBOL: {
        setState(3523);
        match(MySQLParser::ORDER_SYMBOL);
        setState(3524);
        match(MySQLParser::BY_SYMBOL);
        break;
      }

      case MySQLParser::GROUP_SYMBOL: {
        setState(3525);
        match(MySQLParser::GROUP_SYMBOL);
        setState(3526);
        match(MySQLParser::BY_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexListContext ------------------------------------------------------------------

MySQLParser::IndexListContext::IndexListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IndexListElementContext *> MySQLParser::IndexListContext::indexListElement() {
  return getRuleContexts<MySQLParser::IndexListElementContext>();
}

MySQLParser::IndexListElementContext* MySQLParser::IndexListContext::indexListElement(size_t i) {
  return getRuleContext<MySQLParser::IndexListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IndexListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IndexListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IndexListContext::getRuleIndex() const {
  return MySQLParser::RuleIndexList;
}

void MySQLParser::IndexListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexList(this);
}

void MySQLParser::IndexListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexList(this);
}

MySQLParser::IndexListContext* MySQLParser::indexList() {
  IndexListContext *_localctx = _tracker.createInstance<IndexListContext>(_ctx, getState());
  enterRule(_localctx, 406, MySQLParser::RuleIndexList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3529);
    indexListElement();
    setState(3534);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3530);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3531);
      indexListElement();
      setState(3536);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexListElementContext ------------------------------------------------------------------

MySQLParser::IndexListElementContext::IndexListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::IndexListElementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::IndexListElementContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}


size_t MySQLParser::IndexListElementContext::getRuleIndex() const {
  return MySQLParser::RuleIndexListElement;
}

void MySQLParser::IndexListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexListElement(this);
}

void MySQLParser::IndexListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexListElement(this);
}

MySQLParser::IndexListElementContext* MySQLParser::indexListElement() {
  IndexListElementContext *_localctx = _tracker.createInstance<IndexListElementContext>(_ctx, getState());
  enterRule(_localctx, 408, MySQLParser::RuleIndexListElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3539);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 389, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3537);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3538);
      match(MySQLParser::PRIMARY_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateStatementContext ------------------------------------------------------------------

MySQLParser::UpdateStatementContext::UpdateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

MySQLParser::TableReferenceListContext* MySQLParser::UpdateStatementContext::tableReferenceList() {
  return getRuleContext<MySQLParser::TableReferenceListContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::UpdateListContext* MySQLParser::UpdateStatementContext::updateList() {
  return getRuleContext<MySQLParser::UpdateListContext>(0);
}

MySQLParser::WithClauseContext* MySQLParser::UpdateStatementContext::withClause() {
  return getRuleContext<MySQLParser::WithClauseContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UpdateStatementContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

MySQLParser::WhereClauseContext* MySQLParser::UpdateStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

MySQLParser::OrderClauseContext* MySQLParser::UpdateStatementContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

MySQLParser::SimpleLimitClauseContext* MySQLParser::UpdateStatementContext::simpleLimitClause() {
  return getRuleContext<MySQLParser::SimpleLimitClauseContext>(0);
}


size_t MySQLParser::UpdateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateStatement;
}

void MySQLParser::UpdateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateStatement(this);
}

void MySQLParser::UpdateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateStatement(this);
}

MySQLParser::UpdateStatementContext* MySQLParser::updateStatement() {
  UpdateStatementContext *_localctx = _tracker.createInstance<UpdateStatementContext>(_ctx, getState());
  enterRule(_localctx, 410, MySQLParser::RuleUpdateStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3543);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 390, _ctx)) {
    case 1: {
      setState(3541);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3542);
      withClause();
      break;
    }

    }
    setState(3545);
    match(MySQLParser::UPDATE_SYMBOL);
    setState(3547);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 391, _ctx)) {
    case 1: {
      setState(3546);
      match(MySQLParser::LOW_PRIORITY_SYMBOL);
      break;
    }

    }
    setState(3550);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 392, _ctx)) {
    case 1: {
      setState(3549);
      match(MySQLParser::IGNORE_SYMBOL);
      break;
    }

    }
    setState(3552);
    tableReferenceList();
    setState(3553);
    match(MySQLParser::SET_SYMBOL);
    setState(3554);
    updateList();
    setState(3556);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WHERE_SYMBOL) {
      setState(3555);
      whereClause();
    }
    setState(3559);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ORDER_SYMBOL) {
      setState(3558);
      orderClause();
    }
    setState(3562);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LIMIT_SYMBOL) {
      setState(3561);
      simpleLimitClause();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionOrLockingStatementContext ------------------------------------------------------------------

MySQLParser::TransactionOrLockingStatementContext::TransactionOrLockingStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TransactionStatementContext* MySQLParser::TransactionOrLockingStatementContext::transactionStatement() {
  return getRuleContext<MySQLParser::TransactionStatementContext>(0);
}

MySQLParser::SavepointStatementContext* MySQLParser::TransactionOrLockingStatementContext::savepointStatement() {
  return getRuleContext<MySQLParser::SavepointStatementContext>(0);
}

MySQLParser::LockStatementContext* MySQLParser::TransactionOrLockingStatementContext::lockStatement() {
  return getRuleContext<MySQLParser::LockStatementContext>(0);
}

MySQLParser::XaStatementContext* MySQLParser::TransactionOrLockingStatementContext::xaStatement() {
  return getRuleContext<MySQLParser::XaStatementContext>(0);
}


size_t MySQLParser::TransactionOrLockingStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionOrLockingStatement;
}

void MySQLParser::TransactionOrLockingStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionOrLockingStatement(this);
}

void MySQLParser::TransactionOrLockingStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionOrLockingStatement(this);
}

MySQLParser::TransactionOrLockingStatementContext* MySQLParser::transactionOrLockingStatement() {
  TransactionOrLockingStatementContext *_localctx = _tracker.createInstance<TransactionOrLockingStatementContext>(_ctx, getState());
  enterRule(_localctx, 412, MySQLParser::RuleTransactionOrLockingStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3568);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 396, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3564);
      transactionStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3565);
      savepointStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3566);
      lockStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3567);
      xaStatement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionStatementContext ------------------------------------------------------------------

MySQLParser::TransactionStatementContext::TransactionStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

std::vector<MySQLParser::TransactionCharacteristicContext *> MySQLParser::TransactionStatementContext::transactionCharacteristic() {
  return getRuleContexts<MySQLParser::TransactionCharacteristicContext>();
}

MySQLParser::TransactionCharacteristicContext* MySQLParser::TransactionStatementContext::transactionCharacteristic(size_t i) {
  return getRuleContext<MySQLParser::TransactionCharacteristicContext>(i);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::RELEASE_SYMBOL() {
  return getToken(MySQLParser::RELEASE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::TransactionStatementContext::NO_SYMBOL() {
  return getTokens(MySQLParser::NO_SYMBOL);
}

tree::TerminalNode* MySQLParser::TransactionStatementContext::NO_SYMBOL(size_t i) {
  return getToken(MySQLParser::NO_SYMBOL, i);
}


size_t MySQLParser::TransactionStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionStatement;
}

void MySQLParser::TransactionStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionStatement(this);
}

void MySQLParser::TransactionStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionStatement(this);
}

MySQLParser::TransactionStatementContext* MySQLParser::transactionStatement() {
  TransactionStatementContext *_localctx = _tracker.createInstance<TransactionStatementContext>(_ctx, getState());
  enterRule(_localctx, 414, MySQLParser::RuleTransactionStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(3595);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::START_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3570);
        match(MySQLParser::START_SYMBOL);
        setState(3571);
        match(MySQLParser::TRANSACTION_SYMBOL);
        setState(3575);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(3572);
            transactionCharacteristic(); 
          }
          setState(3577);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 397, _ctx);
        }
        break;
      }

      case MySQLParser::COMMIT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3578);
        match(MySQLParser::COMMIT_SYMBOL);
        setState(3580);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WORK_SYMBOL) {
          setState(3579);
          match(MySQLParser::WORK_SYMBOL);
        }
        setState(3587);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AND_SYMBOL) {
          setState(3582);
          match(MySQLParser::AND_SYMBOL);
          setState(3584);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NO_SYMBOL) {
            setState(3583);
            match(MySQLParser::NO_SYMBOL);
          }
          setState(3586);
          match(MySQLParser::CHAIN_SYMBOL);
        }
        setState(3593);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NO_SYMBOL || _la == MySQLParser::RELEASE_SYMBOL) {
          setState(3590);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NO_SYMBOL) {
            setState(3589);
            match(MySQLParser::NO_SYMBOL);
          }
          setState(3592);
          match(MySQLParser::RELEASE_SYMBOL);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginWorkContext ------------------------------------------------------------------

MySQLParser::BeginWorkContext::BeginWorkContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::BeginWorkContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BeginWorkContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}


size_t MySQLParser::BeginWorkContext::getRuleIndex() const {
  return MySQLParser::RuleBeginWork;
}

void MySQLParser::BeginWorkContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginWork(this);
}

void MySQLParser::BeginWorkContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginWork(this);
}

MySQLParser::BeginWorkContext* MySQLParser::beginWork() {
  BeginWorkContext *_localctx = _tracker.createInstance<BeginWorkContext>(_ctx, getState());
  enterRule(_localctx, 416, MySQLParser::RuleBeginWork);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3597);
    match(MySQLParser::BEGIN_SYMBOL);
    setState(3599);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WORK_SYMBOL) {
      setState(3598);
      match(MySQLParser::WORK_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TransactionCharacteristicContext ------------------------------------------------------------------

MySQLParser::TransactionCharacteristicContext::TransactionCharacteristicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TransactionCharacteristicContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}


size_t MySQLParser::TransactionCharacteristicContext::getRuleIndex() const {
  return MySQLParser::RuleTransactionCharacteristic;
}

void MySQLParser::TransactionCharacteristicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTransactionCharacteristic(this);
}

void MySQLParser::TransactionCharacteristicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTransactionCharacteristic(this);
}

MySQLParser::TransactionCharacteristicContext* MySQLParser::transactionCharacteristic() {
  TransactionCharacteristicContext *_localctx = _tracker.createInstance<TransactionCharacteristicContext>(_ctx, getState());
  enterRule(_localctx, 418, MySQLParser::RuleTransactionCharacteristic);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3607);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 405, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3601);
      match(MySQLParser::WITH_SYMBOL);
      setState(3602);
      match(MySQLParser::CONSISTENT_SYMBOL);
      setState(3603);
      match(MySQLParser::SNAPSHOT_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3604);

      if (!(serverVersion >= 50605)) throw FailedPredicateException(this, "serverVersion >= 50605");
      setState(3605);
      match(MySQLParser::READ_SYMBOL);
      setState(3606);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::WRITE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetTransactionCharacteristicContext ------------------------------------------------------------------

MySQLParser::SetTransactionCharacteristicContext::SetTransactionCharacteristicContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

MySQLParser::IsolationLevelContext* MySQLParser::SetTransactionCharacteristicContext::isolationLevel() {
  return getRuleContext<MySQLParser::IsolationLevelContext>(0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetTransactionCharacteristicContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}


size_t MySQLParser::SetTransactionCharacteristicContext::getRuleIndex() const {
  return MySQLParser::RuleSetTransactionCharacteristic;
}

void MySQLParser::SetTransactionCharacteristicContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetTransactionCharacteristic(this);
}

void MySQLParser::SetTransactionCharacteristicContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetTransactionCharacteristic(this);
}

MySQLParser::SetTransactionCharacteristicContext* MySQLParser::setTransactionCharacteristic() {
  SetTransactionCharacteristicContext *_localctx = _tracker.createInstance<SetTransactionCharacteristicContext>(_ctx, getState());
  enterRule(_localctx, 420, MySQLParser::RuleSetTransactionCharacteristic);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3615);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 406, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3609);
      match(MySQLParser::ISOLATION_SYMBOL);
      setState(3610);
      match(MySQLParser::LEVEL_SYMBOL);
      setState(3611);
      isolationLevel();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3612);

      if (!(serverVersion >= 50605)) throw FailedPredicateException(this, "serverVersion >= 50605");
      setState(3613);
      match(MySQLParser::READ_SYMBOL);
      setState(3614);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::WRITE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsolationLevelContext ------------------------------------------------------------------

MySQLParser::IsolationLevelContext::IsolationLevelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IsolationLevelContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}


size_t MySQLParser::IsolationLevelContext::getRuleIndex() const {
  return MySQLParser::RuleIsolationLevel;
}

void MySQLParser::IsolationLevelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIsolationLevel(this);
}

void MySQLParser::IsolationLevelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIsolationLevel(this);
}

MySQLParser::IsolationLevelContext* MySQLParser::isolationLevel() {
  IsolationLevelContext *_localctx = _tracker.createInstance<IsolationLevelContext>(_ctx, getState());
  enterRule(_localctx, 422, MySQLParser::RuleIsolationLevel);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3622);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REPEATABLE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3617);
        match(MySQLParser::REPEATABLE_SYMBOL);
        setState(3618);
        match(MySQLParser::READ_SYMBOL);
        break;
      }

      case MySQLParser::READ_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3619);
        match(MySQLParser::READ_SYMBOL);
        setState(3620);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::COMMITTED_SYMBOL || _la == MySQLParser::UNCOMMITTED_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::SERIALIZABLE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3621);
        match(MySQLParser::SERIALIZABLE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SavepointStatementContext ------------------------------------------------------------------

MySQLParser::SavepointStatementContext::SavepointStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SavepointStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::RELEASE_SYMBOL() {
  return getToken(MySQLParser::RELEASE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SavepointStatementContext::NO_SYMBOL() {
  return getTokens(MySQLParser::NO_SYMBOL);
}

tree::TerminalNode* MySQLParser::SavepointStatementContext::NO_SYMBOL(size_t i) {
  return getToken(MySQLParser::NO_SYMBOL, i);
}


size_t MySQLParser::SavepointStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSavepointStatement;
}

void MySQLParser::SavepointStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSavepointStatement(this);
}

void MySQLParser::SavepointStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSavepointStatement(this);
}

MySQLParser::SavepointStatementContext* MySQLParser::savepointStatement() {
  SavepointStatementContext *_localctx = _tracker.createInstance<SavepointStatementContext>(_ctx, getState());
  enterRule(_localctx, 424, MySQLParser::RuleSavepointStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3653);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::SAVEPOINT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3624);
        match(MySQLParser::SAVEPOINT_SYMBOL);
        setState(3625);
        identifier();
        break;
      }

      case MySQLParser::ROLLBACK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3626);
        match(MySQLParser::ROLLBACK_SYMBOL);
        setState(3628);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WORK_SYMBOL) {
          setState(3627);
          match(MySQLParser::WORK_SYMBOL);
        }
        setState(3648);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::TO_SYMBOL: {
            setState(3630);
            match(MySQLParser::TO_SYMBOL);
            setState(3632);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 409, _ctx)) {
            case 1: {
              setState(3631);
              match(MySQLParser::SAVEPOINT_SYMBOL);
              break;
            }

            }
            setState(3634);
            identifier();
            break;
          }

          case MySQLParser::EOF:
          case MySQLParser::SEMICOLON_SYMBOL:
          case MySQLParser::AND_SYMBOL:
          case MySQLParser::NO_SYMBOL:
          case MySQLParser::RELEASE_SYMBOL: {
            setState(3640);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::AND_SYMBOL) {
              setState(3635);
              match(MySQLParser::AND_SYMBOL);
              setState(3637);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::NO_SYMBOL) {
                setState(3636);
                match(MySQLParser::NO_SYMBOL);
              }
              setState(3639);
              match(MySQLParser::CHAIN_SYMBOL);
            }
            setState(3646);
            _errHandler->sync(this);

            _la = _input->LA(1);
            if (_la == MySQLParser::NO_SYMBOL || _la == MySQLParser::RELEASE_SYMBOL) {
              setState(3643);
              _errHandler->sync(this);

              _la = _input->LA(1);
              if (_la == MySQLParser::NO_SYMBOL) {
                setState(3642);
                match(MySQLParser::NO_SYMBOL);
              }
              setState(3645);
              match(MySQLParser::RELEASE_SYMBOL);
            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      case MySQLParser::RELEASE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3650);
        match(MySQLParser::RELEASE_SYMBOL);
        setState(3651);
        match(MySQLParser::SAVEPOINT_SYMBOL);
        setState(3652);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockStatementContext ------------------------------------------------------------------

MySQLParser::LockStatementContext::LockStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockStatementContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

std::vector<MySQLParser::LockItemContext *> MySQLParser::LockStatementContext::lockItem() {
  return getRuleContexts<MySQLParser::LockItemContext>();
}

MySQLParser::LockItemContext* MySQLParser::LockStatementContext::lockItem(size_t i) {
  return getRuleContext<MySQLParser::LockItemContext>(i);
}

tree::TerminalNode* MySQLParser::LockStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::LockStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::LockStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::LockStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockStatementContext::UNLOCK_SYMBOL() {
  return getToken(MySQLParser::UNLOCK_SYMBOL, 0);
}


size_t MySQLParser::LockStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLockStatement;
}

void MySQLParser::LockStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockStatement(this);
}

void MySQLParser::LockStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockStatement(this);
}

MySQLParser::LockStatementContext* MySQLParser::lockStatement() {
  LockStatementContext *_localctx = _tracker.createInstance<LockStatementContext>(_ctx, getState());
  enterRule(_localctx, 426, MySQLParser::RuleLockStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3677);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 418, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3655);
      match(MySQLParser::LOCK_SYMBOL);
      setState(3656);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::TABLES_SYMBOL

      || _la == MySQLParser::TABLE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3657);
      lockItem();
      setState(3662);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3658);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3659);
        lockItem();
        setState(3664);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3665);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3666);
      match(MySQLParser::LOCK_SYMBOL);
      setState(3667);
      match(MySQLParser::INSTANCE_SYMBOL);
      setState(3668);
      match(MySQLParser::FOR_SYMBOL);
      setState(3669);
      match(MySQLParser::BACKUP_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3670);
      match(MySQLParser::UNLOCK_SYMBOL);
      setState(3675);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 417, _ctx)) {
      case 1: {
        setState(3671);
        match(MySQLParser::TABLES_SYMBOL);
        break;
      }

      case 2: {
        setState(3672);
        match(MySQLParser::TABLE_SYMBOL);
        break;
      }

      case 3: {
        setState(3673);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(3674);
        match(MySQLParser::INSTANCE_SYMBOL);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockItemContext ------------------------------------------------------------------

MySQLParser::LockItemContext::LockItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::LockItemContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::LockOptionContext* MySQLParser::LockItemContext::lockOption() {
  return getRuleContext<MySQLParser::LockOptionContext>(0);
}

MySQLParser::TableAliasContext* MySQLParser::LockItemContext::tableAlias() {
  return getRuleContext<MySQLParser::TableAliasContext>(0);
}


size_t MySQLParser::LockItemContext::getRuleIndex() const {
  return MySQLParser::RuleLockItem;
}

void MySQLParser::LockItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockItem(this);
}

void MySQLParser::LockItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockItem(this);
}

MySQLParser::LockItemContext* MySQLParser::lockItem() {
  LockItemContext *_localctx = _tracker.createInstance<LockItemContext>(_ctx, getState());
  enterRule(_localctx, 428, MySQLParser::RuleLockItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3679);
    tableRef();
    setState(3681);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 419, _ctx)) {
    case 1: {
      setState(3680);
      tableAlias();
      break;
    }

    }
    setState(3683);
    lockOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LockOptionContext ------------------------------------------------------------------

MySQLParser::LockOptionContext::LockOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LockOptionContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockOptionContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockOptionContext::WRITE_SYMBOL() {
  return getToken(MySQLParser::WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LockOptionContext::LOW_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::LOW_PRIORITY_SYMBOL, 0);
}


size_t MySQLParser::LockOptionContext::getRuleIndex() const {
  return MySQLParser::RuleLockOption;
}

void MySQLParser::LockOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLockOption(this);
}

void MySQLParser::LockOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLockOption(this);
}

MySQLParser::LockOptionContext* MySQLParser::lockOption() {
  LockOptionContext *_localctx = _tracker.createInstance<LockOptionContext>(_ctx, getState());
  enterRule(_localctx, 430, MySQLParser::RuleLockOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3693);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::READ_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3685);
        match(MySQLParser::READ_SYMBOL);
        setState(3687);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL) {
          setState(3686);
          match(MySQLParser::LOCAL_SYMBOL);
        }
        break;
      }

      case MySQLParser::LOW_PRIORITY_SYMBOL:
      case MySQLParser::WRITE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3690);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOW_PRIORITY_SYMBOL) {
          setState(3689);
          match(MySQLParser::LOW_PRIORITY_SYMBOL);
        }
        setState(3692);
        match(MySQLParser::WRITE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaStatementContext ------------------------------------------------------------------

MySQLParser::XaStatementContext::XaStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::XaStatementContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}

MySQLParser::XidContext* MySQLParser::XaStatementContext::xid() {
  return getRuleContext<MySQLParser::XidContext>(0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

MySQLParser::XaConvertContext* MySQLParser::XaStatementContext::xaConvert() {
  return getRuleContext<MySQLParser::XaConvertContext>(0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::JOIN_SYMBOL() {
  return getToken(MySQLParser::JOIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaStatementContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}


size_t MySQLParser::XaStatementContext::getRuleIndex() const {
  return MySQLParser::RuleXaStatement;
}

void MySQLParser::XaStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaStatement(this);
}

void MySQLParser::XaStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaStatement(this);
}

MySQLParser::XaStatementContext* MySQLParser::xaStatement() {
  XaStatementContext *_localctx = _tracker.createInstance<XaStatementContext>(_ctx, getState());
  enterRule(_localctx, 432, MySQLParser::RuleXaStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3695);
    match(MySQLParser::XA_SYMBOL);
    setState(3722);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::BEGIN_SYMBOL:
      case MySQLParser::START_SYMBOL: {
        setState(3696);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::BEGIN_SYMBOL || _la == MySQLParser::START_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(3697);
        xid();
        setState(3699);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::JOIN_SYMBOL || _la == MySQLParser::RESUME_SYMBOL) {
          setState(3698);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::JOIN_SYMBOL || _la == MySQLParser::RESUME_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

      case MySQLParser::END_SYMBOL: {
        setState(3701);
        match(MySQLParser::END_SYMBOL);
        setState(3702);
        xid();
        setState(3708);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::SUSPEND_SYMBOL) {
          setState(3703);
          match(MySQLParser::SUSPEND_SYMBOL);
          setState(3706);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::FOR_SYMBOL) {
            setState(3704);
            match(MySQLParser::FOR_SYMBOL);
            setState(3705);
            match(MySQLParser::MIGRATE_SYMBOL);
          }
        }
        break;
      }

      case MySQLParser::PREPARE_SYMBOL: {
        setState(3710);
        match(MySQLParser::PREPARE_SYMBOL);
        setState(3711);
        xid();
        break;
      }

      case MySQLParser::COMMIT_SYMBOL: {
        setState(3712);
        match(MySQLParser::COMMIT_SYMBOL);
        setState(3713);
        xid();
        setState(3716);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ONE_SYMBOL) {
          setState(3714);
          match(MySQLParser::ONE_SYMBOL);
          setState(3715);
          match(MySQLParser::PHASE_SYMBOL);
        }
        break;
      }

      case MySQLParser::ROLLBACK_SYMBOL: {
        setState(3718);
        match(MySQLParser::ROLLBACK_SYMBOL);
        setState(3719);
        xid();
        break;
      }

      case MySQLParser::RECOVER_SYMBOL: {
        setState(3720);
        match(MySQLParser::RECOVER_SYMBOL);
        setState(3721);
        xaConvert();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XaConvertContext ------------------------------------------------------------------

MySQLParser::XaConvertContext::XaConvertContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::XaConvertContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::XaConvertContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}


size_t MySQLParser::XaConvertContext::getRuleIndex() const {
  return MySQLParser::RuleXaConvert;
}

void MySQLParser::XaConvertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXaConvert(this);
}

void MySQLParser::XaConvertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXaConvert(this);
}

MySQLParser::XaConvertContext* MySQLParser::xaConvert() {
  XaConvertContext *_localctx = _tracker.createInstance<XaConvertContext>(_ctx, getState());
  enterRule(_localctx, 434, MySQLParser::RuleXaConvert);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3730);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 429, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3724);

      if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
      setState(3727);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::CONVERT_SYMBOL) {
        setState(3725);
        match(MySQLParser::CONVERT_SYMBOL);
        setState(3726);
        match(MySQLParser::XID_SYMBOL);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- XidContext ------------------------------------------------------------------

MySQLParser::XidContext::XidContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::XidContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::XidContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::XidContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::XidContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::Ulong_numberContext* MySQLParser::XidContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}


size_t MySQLParser::XidContext::getRuleIndex() const {
  return MySQLParser::RuleXid;
}

void MySQLParser::XidContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterXid(this);
}

void MySQLParser::XidContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitXid(this);
}

MySQLParser::XidContext* MySQLParser::xid() {
  XidContext *_localctx = _tracker.createInstance<XidContext>(_ctx, getState());
  enterRule(_localctx, 436, MySQLParser::RuleXid);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3732);
    textString();
    setState(3739);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3733);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3734);
      textString();
      setState(3737);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3735);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3736);
        ulong_number();
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationStatementContext ------------------------------------------------------------------

MySQLParser::ReplicationStatementContext::ReplicationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::PURGE_SYMBOL() {
  return getToken(MySQLParser::PURGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::ReplicationStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::BEFORE_SYMBOL() {
  return getToken(MySQLParser::BEFORE_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ReplicationStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ChangeMasterContext* MySQLParser::ReplicationStatementContext::changeMaster() {
  return getRuleContext<MySQLParser::ChangeMasterContext>(0);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

std::vector<MySQLParser::ResetOptionContext *> MySQLParser::ReplicationStatementContext::resetOption() {
  return getRuleContexts<MySQLParser::ResetOptionContext>();
}

MySQLParser::ResetOptionContext* MySQLParser::ReplicationStatementContext::resetOption(size_t i) {
  return getRuleContext<MySQLParser::ResetOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ReplicationStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::ReplicationStatementContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

MySQLParser::IfExistsContext* MySQLParser::ReplicationStatementContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::ReplicationStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SlaveContext* MySQLParser::ReplicationStatementContext::slave() {
  return getRuleContext<MySQLParser::SlaveContext>(0);
}

MySQLParser::ChangeReplicationContext* MySQLParser::ReplicationStatementContext::changeReplication() {
  return getRuleContext<MySQLParser::ChangeReplicationContext>(0);
}

MySQLParser::ReplicationLoadContext* MySQLParser::ReplicationStatementContext::replicationLoad() {
  return getRuleContext<MySQLParser::ReplicationLoadContext>(0);
}

MySQLParser::GroupReplicationContext* MySQLParser::ReplicationStatementContext::groupReplication() {
  return getRuleContext<MySQLParser::GroupReplicationContext>(0);
}


size_t MySQLParser::ReplicationStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReplicationStatement;
}

void MySQLParser::ReplicationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationStatement(this);
}

void MySQLParser::ReplicationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationStatement(this);
}

MySQLParser::ReplicationStatementContext* MySQLParser::replicationStatement() {
  ReplicationStatementContext *_localctx = _tracker.createInstance<ReplicationStatementContext>(_ctx, getState());
  enterRule(_localctx, 438, MySQLParser::RuleReplicationStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3774);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 435, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3741);
      match(MySQLParser::PURGE_SYMBOL);
      setState(3742);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BINARY_SYMBOL || _la == MySQLParser::MASTER_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(3743);
      match(MySQLParser::LOGS_SYMBOL);
      setState(3748);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::TO_SYMBOL: {
          setState(3744);
          match(MySQLParser::TO_SYMBOL);
          setState(3745);
          textLiteral();
          break;
        }

        case MySQLParser::BEFORE_SYMBOL: {
          setState(3746);
          match(MySQLParser::BEFORE_SYMBOL);
          setState(3747);
          expr(0);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3750);
      changeMaster();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3751);
      match(MySQLParser::RESET_SYMBOL);
      setState(3752);
      resetOption();
      setState(3757);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3753);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3754);
        resetOption();
        setState(3759);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(3760);

      if (!(serverVersion > 80000)) throw FailedPredicateException(this, "serverVersion > 80000");
      setState(3761);
      match(MySQLParser::RESET_SYMBOL);
      setState(3762);
      match(MySQLParser::PERSIST_SYMBOL);
      setState(3766);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::IF_SYMBOL) {
        setState(3763);
        ifExists();
        setState(3764);
        identifier();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(3768);
      slave();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(3769);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(3770);
      changeReplication();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(3771);
      replicationLoad();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(3772);

      if (!(serverVersion > 50706)) throw FailedPredicateException(this, "serverVersion > 50706");
      setState(3773);
      groupReplication();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResetOptionContext ------------------------------------------------------------------

MySQLParser::ResetOptionContext::ResetOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResetOptionContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

MySQLParser::MasterResetOptionsContext* MySQLParser::ResetOptionContext::masterResetOptions() {
  return getRuleContext<MySQLParser::MasterResetOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResetOptionContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::ChannelContext* MySQLParser::ResetOptionContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}


size_t MySQLParser::ResetOptionContext::getRuleIndex() const {
  return MySQLParser::RuleResetOption;
}

void MySQLParser::ResetOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResetOption(this);
}

void MySQLParser::ResetOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResetOption(this);
}

MySQLParser::ResetOptionContext* MySQLParser::resetOption() {
  ResetOptionContext *_localctx = _tracker.createInstance<ResetOptionContext>(_ctx, getState());
  enterRule(_localctx, 440, MySQLParser::RuleResetOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3790);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 439, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(3776);
      dynamic_cast<ResetOptionContext *>(_localctx)->option = match(MySQLParser::MASTER_SYMBOL);
      setState(3778);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 436, _ctx)) {
      case 1: {
        setState(3777);
        masterResetOptions();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(3780);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(3781);
      dynamic_cast<ResetOptionContext *>(_localctx)->option = match(MySQLParser::QUERY_SYMBOL);
      setState(3782);
      match(MySQLParser::CACHE_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(3783);
      dynamic_cast<ResetOptionContext *>(_localctx)->option = match(MySQLParser::SLAVE_SYMBOL);
      setState(3785);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 437, _ctx)) {
      case 1: {
        setState(3784);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      }
      setState(3788);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 438, _ctx)) {
      case 1: {
        setState(3787);
        channel();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterResetOptionsContext ------------------------------------------------------------------

MySQLParser::MasterResetOptionsContext::MasterResetOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::MasterResetOptionsContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::MasterResetOptionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::MasterResetOptionsContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}


size_t MySQLParser::MasterResetOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleMasterResetOptions;
}

void MySQLParser::MasterResetOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterResetOptions(this);
}

void MySQLParser::MasterResetOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterResetOptions(this);
}

MySQLParser::MasterResetOptionsContext* MySQLParser::masterResetOptions() {
  MasterResetOptionsContext *_localctx = _tracker.createInstance<MasterResetOptionsContext>(_ctx, getState());
  enterRule(_localctx, 442, MySQLParser::RuleMasterResetOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3792);

    if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
    setState(3793);
    match(MySQLParser::TO_SYMBOL);
    setState(3798);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 440, _ctx)) {
    case 1: {
      setState(3794);

      if (!(serverVersion < 80017)) throw FailedPredicateException(this, "serverVersion < 80017");
      setState(3795);
      real_ulong_number();
      break;
    }

    case 2: {
      setState(3796);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(3797);
      real_ulonglong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplicationLoadContext ------------------------------------------------------------------

MySQLParser::ReplicationLoadContext::ReplicationLoadContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReplicationLoadContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ReplicationLoadContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}


size_t MySQLParser::ReplicationLoadContext::getRuleIndex() const {
  return MySQLParser::RuleReplicationLoad;
}

void MySQLParser::ReplicationLoadContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplicationLoad(this);
}

void MySQLParser::ReplicationLoadContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplicationLoad(this);
}

MySQLParser::ReplicationLoadContext* MySQLParser::replicationLoad() {
  ReplicationLoadContext *_localctx = _tracker.createInstance<ReplicationLoadContext>(_ctx, getState());
  enterRule(_localctx, 444, MySQLParser::RuleReplicationLoad);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3800);
    match(MySQLParser::LOAD_SYMBOL);
    setState(3804);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DATA_SYMBOL: {
        setState(3801);
        match(MySQLParser::DATA_SYMBOL);
        break;
      }

      case MySQLParser::TABLE_SYMBOL: {
        setState(3802);
        match(MySQLParser::TABLE_SYMBOL);
        setState(3803);
        tableRef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(3806);
    match(MySQLParser::FROM_SYMBOL);
    setState(3807);
    match(MySQLParser::MASTER_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeMasterContext ------------------------------------------------------------------

MySQLParser::ChangeMasterContext::ChangeMasterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChangeMasterContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeMasterContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeMasterContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::ChangeMasterOptionsContext* MySQLParser::ChangeMasterContext::changeMasterOptions() {
  return getRuleContext<MySQLParser::ChangeMasterOptionsContext>(0);
}

MySQLParser::ChannelContext* MySQLParser::ChangeMasterContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}


size_t MySQLParser::ChangeMasterContext::getRuleIndex() const {
  return MySQLParser::RuleChangeMaster;
}

void MySQLParser::ChangeMasterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeMaster(this);
}

void MySQLParser::ChangeMasterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeMaster(this);
}

MySQLParser::ChangeMasterContext* MySQLParser::changeMaster() {
  ChangeMasterContext *_localctx = _tracker.createInstance<ChangeMasterContext>(_ctx, getState());
  enterRule(_localctx, 446, MySQLParser::RuleChangeMaster);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3809);
    match(MySQLParser::CHANGE_SYMBOL);
    setState(3810);
    match(MySQLParser::MASTER_SYMBOL);
    setState(3811);
    match(MySQLParser::TO_SYMBOL);
    setState(3812);
    changeMasterOptions();
    setState(3814);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 442, _ctx)) {
    case 1: {
      setState(3813);
      channel();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeMasterOptionsContext ------------------------------------------------------------------

MySQLParser::ChangeMasterOptionsContext::ChangeMasterOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::MasterOptionContext *> MySQLParser::ChangeMasterOptionsContext::masterOption() {
  return getRuleContexts<MySQLParser::MasterOptionContext>();
}

MySQLParser::MasterOptionContext* MySQLParser::ChangeMasterOptionsContext::masterOption(size_t i) {
  return getRuleContext<MySQLParser::MasterOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ChangeMasterOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ChangeMasterOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ChangeMasterOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleChangeMasterOptions;
}

void MySQLParser::ChangeMasterOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeMasterOptions(this);
}

void MySQLParser::ChangeMasterOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeMasterOptions(this);
}

MySQLParser::ChangeMasterOptionsContext* MySQLParser::changeMasterOptions() {
  ChangeMasterOptionsContext *_localctx = _tracker.createInstance<ChangeMasterOptionsContext>(_ctx, getState());
  enterRule(_localctx, 448, MySQLParser::RuleChangeMasterOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3816);
    masterOption();
    setState(3821);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3817);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3818);
        masterOption(); 
      }
      setState(3823);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 443, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterOptionContext ------------------------------------------------------------------

MySQLParser::MasterOptionContext::MasterOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::MasterOptionContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::NETWORK_NAMESPACE_SYMBOL() {
  return getToken(MySQLParser::NETWORK_NAMESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_BIND_SYMBOL() {
  return getToken(MySQLParser::MASTER_BIND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::MasterOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::MasterOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::GET_MASTER_PUBLIC_KEY_SYMBOL() {
  return getToken(MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

MySQLParser::ServerIdListContext* MySQLParser::MasterOptionContext::serverIdList() {
  return getRuleContext<MySQLParser::ServerIdListContext>(0);
}

tree::TerminalNode* MySQLParser::MasterOptionContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

MySQLParser::MasterFileDefContext* MySQLParser::MasterOptionContext::masterFileDef() {
  return getRuleContext<MySQLParser::MasterFileDefContext>(0);
}


size_t MySQLParser::MasterOptionContext::getRuleIndex() const {
  return MySQLParser::RuleMasterOption;
}

void MySQLParser::MasterOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterOption(this);
}

void MySQLParser::MasterOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterOption(this);
}

MySQLParser::MasterOptionContext* MySQLParser::masterOption() {
  MasterOptionContext *_localctx = _tracker.createInstance<MasterOptionContext>(_ctx, getState());
  enterRule(_localctx, 450, MySQLParser::RuleMasterOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3897);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::MASTER_HOST_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3824);
        match(MySQLParser::MASTER_HOST_SYMBOL);
        setState(3825);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3826);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::NETWORK_NAMESPACE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3827);
        match(MySQLParser::NETWORK_NAMESPACE_SYMBOL);
        setState(3828);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3829);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_BIND_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3830);
        match(MySQLParser::MASTER_BIND_SYMBOL);
        setState(3831);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3832);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_USER_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3833);
        match(MySQLParser::MASTER_USER_SYMBOL);
        setState(3834);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3835);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(3836);
        match(MySQLParser::MASTER_PASSWORD_SYMBOL);
        setState(3837);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3838);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_PORT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(3839);
        match(MySQLParser::MASTER_PORT_SYMBOL);
        setState(3840);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3841);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_CONNECT_RETRY_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(3842);
        match(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL);
        setState(3843);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3844);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_RETRY_COUNT_SYMBOL: {
        enterOuterAlt(_localctx, 8);
        setState(3845);
        match(MySQLParser::MASTER_RETRY_COUNT_SYMBOL);
        setState(3846);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3847);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_DELAY_SYMBOL: {
        enterOuterAlt(_localctx, 9);
        setState(3848);
        match(MySQLParser::MASTER_DELAY_SYMBOL);
        setState(3849);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3850);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_SSL_SYMBOL: {
        enterOuterAlt(_localctx, 10);
        setState(3851);
        match(MySQLParser::MASTER_SSL_SYMBOL);
        setState(3852);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3853);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_SSL_CA_SYMBOL: {
        enterOuterAlt(_localctx, 11);
        setState(3854);
        match(MySQLParser::MASTER_SSL_CA_SYMBOL);
        setState(3855);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3856);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_TLS_VERSION_SYMBOL: {
        enterOuterAlt(_localctx, 12);
        setState(3857);
        match(MySQLParser::MASTER_TLS_VERSION_SYMBOL);
        setState(3858);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3859);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_CAPATH_SYMBOL: {
        enterOuterAlt(_localctx, 13);
        setState(3860);
        match(MySQLParser::MASTER_SSL_CAPATH_SYMBOL);
        setState(3861);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3862);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_CERT_SYMBOL: {
        enterOuterAlt(_localctx, 14);
        setState(3863);
        match(MySQLParser::MASTER_SSL_CERT_SYMBOL);
        setState(3864);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3865);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_CIPHER_SYMBOL: {
        enterOuterAlt(_localctx, 15);
        setState(3866);
        match(MySQLParser::MASTER_SSL_CIPHER_SYMBOL);
        setState(3867);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3868);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_KEY_SYMBOL: {
        enterOuterAlt(_localctx, 16);
        setState(3869);
        match(MySQLParser::MASTER_SSL_KEY_SYMBOL);
        setState(3870);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3871);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL: {
        enterOuterAlt(_localctx, 17);
        setState(3872);
        match(MySQLParser::MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL);
        setState(3873);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3874);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_SSL_CRL_SYMBOL: {
        enterOuterAlt(_localctx, 18);
        setState(3875);
        match(MySQLParser::MASTER_SSL_CRL_SYMBOL);
        setState(3876);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3877);
        textLiteral();
        break;
      }

      case MySQLParser::MASTER_SSL_CRLPATH_SYMBOL: {
        enterOuterAlt(_localctx, 19);
        setState(3878);
        match(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL);
        setState(3879);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3880);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL: {
        enterOuterAlt(_localctx, 20);
        setState(3881);
        match(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL);
        setState(3882);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3883);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL: {
        enterOuterAlt(_localctx, 21);
        setState(3884);
        match(MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL);
        setState(3885);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3886);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL: {
        enterOuterAlt(_localctx, 22);
        setState(3887);
        match(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL);
        setState(3888);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3889);
        ulong_number();
        break;
      }

      case MySQLParser::IGNORE_SERVER_IDS_SYMBOL: {
        enterOuterAlt(_localctx, 23);
        setState(3890);
        match(MySQLParser::IGNORE_SERVER_IDS_SYMBOL);
        setState(3891);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3892);
        serverIdList();
        break;
      }

      case MySQLParser::MASTER_AUTO_POSITION_SYMBOL: {
        enterOuterAlt(_localctx, 24);
        setState(3893);
        match(MySQLParser::MASTER_AUTO_POSITION_SYMBOL);
        setState(3894);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3895);
        ulong_number();
        break;
      }

      case MySQLParser::MASTER_LOG_FILE_SYMBOL:
      case MySQLParser::MASTER_LOG_POS_SYMBOL:
      case MySQLParser::RELAY_LOG_FILE_SYMBOL:
      case MySQLParser::RELAY_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 25);
        setState(3896);
        masterFileDef();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- MasterFileDefContext ------------------------------------------------------------------

MySQLParser::MasterFileDefContext::MasterFileDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::MasterFileDefContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::MasterFileDefContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::MasterFileDefContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::MasterFileDefContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}


size_t MySQLParser::MasterFileDefContext::getRuleIndex() const {
  return MySQLParser::RuleMasterFileDef;
}

void MySQLParser::MasterFileDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterMasterFileDef(this);
}

void MySQLParser::MasterFileDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitMasterFileDef(this);
}

MySQLParser::MasterFileDefContext* MySQLParser::masterFileDef() {
  MasterFileDefContext *_localctx = _tracker.createInstance<MasterFileDefContext>(_ctx, getState());
  enterRule(_localctx, 452, MySQLParser::RuleMasterFileDef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3911);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::MASTER_LOG_FILE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3899);
        match(MySQLParser::MASTER_LOG_FILE_SYMBOL);
        setState(3900);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3901);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::MASTER_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3902);
        match(MySQLParser::MASTER_LOG_POS_SYMBOL);
        setState(3903);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3904);
        ulonglong_number();
        break;
      }

      case MySQLParser::RELAY_LOG_FILE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3905);
        match(MySQLParser::RELAY_LOG_FILE_SYMBOL);
        setState(3906);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3907);
        textStringNoLinebreak();
        break;
      }

      case MySQLParser::RELAY_LOG_POS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3908);
        match(MySQLParser::RELAY_LOG_POS_SYMBOL);
        setState(3909);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3910);
        ulong_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerIdListContext ------------------------------------------------------------------

MySQLParser::ServerIdListContext::ServerIdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ServerIdListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ServerIdListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::ServerIdListContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext* MySQLParser::ServerIdListContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ServerIdListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ServerIdListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ServerIdListContext::getRuleIndex() const {
  return MySQLParser::RuleServerIdList;
}

void MySQLParser::ServerIdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerIdList(this);
}

void MySQLParser::ServerIdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerIdList(this);
}

MySQLParser::ServerIdListContext* MySQLParser::serverIdList() {
  ServerIdListContext *_localctx = _tracker.createInstance<ServerIdListContext>(_ctx, getState());
  enterRule(_localctx, 454, MySQLParser::RuleServerIdList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3913);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(3922);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::INT_NUMBER)
      | (1ULL << MySQLParser::LONG_NUMBER)
      | (1ULL << MySQLParser::ULONGLONG_NUMBER)
      | (1ULL << MySQLParser::HEX_NUMBER)
      | (1ULL << MySQLParser::DECIMAL_NUMBER)
      | (1ULL << MySQLParser::FLOAT_NUMBER))) != 0)) {
      setState(3914);
      ulong_number();
      setState(3919);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(3915);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3916);
        ulong_number();
        setState(3921);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
    setState(3924);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChangeReplicationContext ------------------------------------------------------------------

MySQLParser::ChangeReplicationContext::ChangeReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::CHANGE_SYMBOL() {
  return getToken(MySQLParser::CHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

std::vector<MySQLParser::FilterDefinitionContext *> MySQLParser::ChangeReplicationContext::filterDefinition() {
  return getRuleContexts<MySQLParser::FilterDefinitionContext>();
}

MySQLParser::FilterDefinitionContext* MySQLParser::ChangeReplicationContext::filterDefinition(size_t i) {
  return getRuleContext<MySQLParser::FilterDefinitionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ChangeReplicationContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ChangeReplicationContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::ChannelContext* MySQLParser::ChangeReplicationContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}


size_t MySQLParser::ChangeReplicationContext::getRuleIndex() const {
  return MySQLParser::RuleChangeReplication;
}

void MySQLParser::ChangeReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChangeReplication(this);
}

void MySQLParser::ChangeReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChangeReplication(this);
}

MySQLParser::ChangeReplicationContext* MySQLParser::changeReplication() {
  ChangeReplicationContext *_localctx = _tracker.createInstance<ChangeReplicationContext>(_ctx, getState());
  enterRule(_localctx, 456, MySQLParser::RuleChangeReplication);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(3926);
    match(MySQLParser::CHANGE_SYMBOL);
    setState(3927);
    match(MySQLParser::REPLICATION_SYMBOL);
    setState(3928);
    match(MySQLParser::FILTER_SYMBOL);
    setState(3929);
    filterDefinition();
    setState(3934);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(3930);
        match(MySQLParser::COMMA_SYMBOL);
        setState(3931);
        filterDefinition(); 
      }
      setState(3936);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 448, _ctx);
    }
    setState(3939);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 449, _ctx)) {
    case 1: {
      setState(3937);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(3938);
      channel();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDefinitionContext ------------------------------------------------------------------

MySQLParser::FilterDefinitionContext::FilterDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FilterDbListContext* MySQLParser::FilterDefinitionContext::filterDbList() {
  return getRuleContext<MySQLParser::FilterDbListContext>(0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

MySQLParser::FilterTableListContext* MySQLParser::FilterDefinitionContext::filterTableList() {
  return getRuleContext<MySQLParser::FilterTableListContext>(0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

MySQLParser::FilterStringListContext* MySQLParser::FilterDefinitionContext::filterStringList() {
  return getRuleContext<MySQLParser::FilterStringListContext>(0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FilterDefinitionContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

MySQLParser::FilterDbPairListContext* MySQLParser::FilterDefinitionContext::filterDbPairList() {
  return getRuleContext<MySQLParser::FilterDbPairListContext>(0);
}


size_t MySQLParser::FilterDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDefinition;
}

void MySQLParser::FilterDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDefinition(this);
}

void MySQLParser::FilterDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDefinition(this);
}

MySQLParser::FilterDefinitionContext* MySQLParser::filterDefinition() {
  FilterDefinitionContext *_localctx = _tracker.createInstance<FilterDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 458, MySQLParser::RuleFilterDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(3990);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REPLICATE_DO_DB_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(3941);
        match(MySQLParser::REPLICATE_DO_DB_SYMBOL);
        setState(3942);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3943);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3945);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 450, _ctx)) {
        case 1: {
          setState(3944);
          filterDbList();
          break;
        }

        }
        setState(3947);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_IGNORE_DB_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(3948);
        match(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL);
        setState(3949);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3950);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3952);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 451, _ctx)) {
        case 1: {
          setState(3951);
          filterDbList();
          break;
        }

        }
        setState(3954);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_DO_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(3955);
        match(MySQLParser::REPLICATE_DO_TABLE_SYMBOL);
        setState(3956);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3957);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3959);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 452, _ctx)) {
        case 1: {
          setState(3958);
          filterTableList();
          break;
        }

        }
        setState(3961);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(3962);
        match(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL);
        setState(3963);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3964);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3966);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 453, _ctx)) {
        case 1: {
          setState(3965);
          filterTableList();
          break;
        }

        }
        setState(3968);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(3969);
        match(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL);
        setState(3970);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3971);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3973);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 454, _ctx)) {
        case 1: {
          setState(3972);
          filterStringList();
          break;
        }

        }
        setState(3975);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(3976);
        match(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL);
        setState(3977);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3978);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3980);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 455, _ctx)) {
        case 1: {
          setState(3979);
          filterStringList();
          break;
        }

        }
        setState(3982);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::REPLICATE_REWRITE_DB_SYMBOL: {
        enterOuterAlt(_localctx, 7);
        setState(3983);
        match(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL);
        setState(3984);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(3985);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(3987);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
          setState(3986);
          filterDbPairList();
        }
        setState(3989);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDbListContext ------------------------------------------------------------------

MySQLParser::FilterDbListContext::FilterDbListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SchemaRefContext *> MySQLParser::FilterDbListContext::schemaRef() {
  return getRuleContexts<MySQLParser::SchemaRefContext>();
}

MySQLParser::SchemaRefContext* MySQLParser::FilterDbListContext::schemaRef(size_t i) {
  return getRuleContext<MySQLParser::SchemaRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterDbListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterDbListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterDbListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDbList;
}

void MySQLParser::FilterDbListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDbList(this);
}

void MySQLParser::FilterDbListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDbList(this);
}

MySQLParser::FilterDbListContext* MySQLParser::filterDbList() {
  FilterDbListContext *_localctx = _tracker.createInstance<FilterDbListContext>(_ctx, getState());
  enterRule(_localctx, 460, MySQLParser::RuleFilterDbList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(3992);
    schemaRef();
    setState(3997);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(3993);
      match(MySQLParser::COMMA_SYMBOL);
      setState(3994);
      schemaRef();
      setState(3999);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterTableListContext ------------------------------------------------------------------

MySQLParser::FilterTableListContext::FilterTableListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::FilterTableRefContext *> MySQLParser::FilterTableListContext::filterTableRef() {
  return getRuleContexts<MySQLParser::FilterTableRefContext>();
}

MySQLParser::FilterTableRefContext* MySQLParser::FilterTableListContext::filterTableRef(size_t i) {
  return getRuleContext<MySQLParser::FilterTableRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterTableListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterTableListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterTableListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterTableList;
}

void MySQLParser::FilterTableListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterTableList(this);
}

void MySQLParser::FilterTableListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterTableList(this);
}

MySQLParser::FilterTableListContext* MySQLParser::filterTableList() {
  FilterTableListContext *_localctx = _tracker.createInstance<FilterTableListContext>(_ctx, getState());
  enterRule(_localctx, 462, MySQLParser::RuleFilterTableList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4000);
    filterTableRef();
    setState(4005);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4001);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4002);
      filterTableRef();
      setState(4007);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterStringListContext ------------------------------------------------------------------

MySQLParser::FilterStringListContext::FilterStringListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::FilterWildDbTableStringContext *> MySQLParser::FilterStringListContext::filterWildDbTableString() {
  return getRuleContexts<MySQLParser::FilterWildDbTableStringContext>();
}

MySQLParser::FilterWildDbTableStringContext* MySQLParser::FilterStringListContext::filterWildDbTableString(size_t i) {
  return getRuleContext<MySQLParser::FilterWildDbTableStringContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterStringListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterStringListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterStringListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterStringList;
}

void MySQLParser::FilterStringListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterStringList(this);
}

void MySQLParser::FilterStringListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterStringList(this);
}

MySQLParser::FilterStringListContext* MySQLParser::filterStringList() {
  FilterStringListContext *_localctx = _tracker.createInstance<FilterStringListContext>(_ctx, getState());
  enterRule(_localctx, 464, MySQLParser::RuleFilterStringList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4008);
    filterWildDbTableString();
    setState(4013);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4009);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4010);
      filterWildDbTableString();
      setState(4015);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterWildDbTableStringContext ------------------------------------------------------------------

MySQLParser::FilterWildDbTableStringContext::FilterWildDbTableStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::FilterWildDbTableStringContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}


size_t MySQLParser::FilterWildDbTableStringContext::getRuleIndex() const {
  return MySQLParser::RuleFilterWildDbTableString;
}

void MySQLParser::FilterWildDbTableStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterWildDbTableString(this);
}

void MySQLParser::FilterWildDbTableStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterWildDbTableString(this);
}

MySQLParser::FilterWildDbTableStringContext* MySQLParser::filterWildDbTableString() {
  FilterWildDbTableStringContext *_localctx = _tracker.createInstance<FilterWildDbTableStringContext>(_ctx, getState());
  enterRule(_localctx, 466, MySQLParser::RuleFilterWildDbTableString);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4016);
    textStringNoLinebreak();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterDbPairListContext ------------------------------------------------------------------

MySQLParser::FilterDbPairListContext::FilterDbPairListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SchemaIdentifierPairContext *> MySQLParser::FilterDbPairListContext::schemaIdentifierPair() {
  return getRuleContexts<MySQLParser::SchemaIdentifierPairContext>();
}

MySQLParser::SchemaIdentifierPairContext* MySQLParser::FilterDbPairListContext::schemaIdentifierPair(size_t i) {
  return getRuleContext<MySQLParser::SchemaIdentifierPairContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::FilterDbPairListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::FilterDbPairListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::FilterDbPairListContext::getRuleIndex() const {
  return MySQLParser::RuleFilterDbPairList;
}

void MySQLParser::FilterDbPairListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterDbPairList(this);
}

void MySQLParser::FilterDbPairListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterDbPairList(this);
}

MySQLParser::FilterDbPairListContext* MySQLParser::filterDbPairList() {
  FilterDbPairListContext *_localctx = _tracker.createInstance<FilterDbPairListContext>(_ctx, getState());
  enterRule(_localctx, 468, MySQLParser::RuleFilterDbPairList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4018);
    schemaIdentifierPair();
    setState(4023);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4019);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4020);
      schemaIdentifierPair();
      setState(4025);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveContext ------------------------------------------------------------------

MySQLParser::SlaveContext::SlaveContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SlaveContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

MySQLParser::SlaveConnectionOptionsContext* MySQLParser::SlaveContext::slaveConnectionOptions() {
  return getRuleContext<MySQLParser::SlaveConnectionOptionsContext>(0);
}

MySQLParser::SlaveThreadOptionsContext* MySQLParser::SlaveContext::slaveThreadOptions() {
  return getRuleContext<MySQLParser::SlaveThreadOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::SlaveContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

MySQLParser::SlaveUntilOptionsContext* MySQLParser::SlaveContext::slaveUntilOptions() {
  return getRuleContext<MySQLParser::SlaveUntilOptionsContext>(0);
}

MySQLParser::ChannelContext* MySQLParser::SlaveContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

tree::TerminalNode* MySQLParser::SlaveContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}


size_t MySQLParser::SlaveContext::getRuleIndex() const {
  return MySQLParser::RuleSlave;
}

void MySQLParser::SlaveContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlave(this);
}

void MySQLParser::SlaveContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlave(this);
}

MySQLParser::SlaveContext* MySQLParser::slave() {
  SlaveContext *_localctx = _tracker.createInstance<SlaveContext>(_ctx, getState());
  enterRule(_localctx, 470, MySQLParser::RuleSlave);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4047);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::START_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4026);
        match(MySQLParser::START_SYMBOL);
        setState(4027);
        match(MySQLParser::SLAVE_SYMBOL);
        setState(4029);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 462, _ctx)) {
        case 1: {
          setState(4028);
          slaveThreadOptions();
          break;
        }

        }
        setState(4033);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 463, _ctx)) {
        case 1: {
          setState(4031);
          match(MySQLParser::UNTIL_SYMBOL);
          setState(4032);
          slaveUntilOptions();
          break;
        }

        }
        setState(4035);
        slaveConnectionOptions();
        setState(4037);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 464, _ctx)) {
        case 1: {
          setState(4036);
          channel();
          break;
        }

        }
        break;
      }

      case MySQLParser::STOP_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4039);
        match(MySQLParser::STOP_SYMBOL);
        setState(4040);
        match(MySQLParser::SLAVE_SYMBOL);
        setState(4042);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 465, _ctx)) {
        case 1: {
          setState(4041);
          slaveThreadOptions();
          break;
        }

        }
        setState(4045);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 466, _ctx)) {
        case 1: {
          setState(4044);
          channel();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveUntilOptionsContext ------------------------------------------------------------------

MySQLParser::SlaveUntilOptionsContext::SlaveUntilOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::MasterFileDefContext *> MySQLParser::SlaveUntilOptionsContext::masterFileDef() {
  return getRuleContexts<MySQLParser::MasterFileDefContext>();
}

MySQLParser::MasterFileDefContext* MySQLParser::SlaveUntilOptionsContext::masterFileDef(size_t i) {
  return getRuleContext<MySQLParser::MasterFileDefContext>(i);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextStringContext* MySQLParser::SlaveUntilOptionsContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SlaveUntilOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SlaveUntilOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SlaveUntilOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveUntilOptions;
}

void MySQLParser::SlaveUntilOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveUntilOptions(this);
}

void MySQLParser::SlaveUntilOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveUntilOptions(this);
}

MySQLParser::SlaveUntilOptionsContext* MySQLParser::slaveUntilOptions() {
  SlaveUntilOptionsContext *_localctx = _tracker.createInstance<SlaveUntilOptionsContext>(_ctx, getState());
  enterRule(_localctx, 472, MySQLParser::RuleSlaveUntilOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4056);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 468, _ctx)) {
    case 1: {
      setState(4049);
      masterFileDef();
      break;
    }

    case 2: {
      setState(4050);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(4051);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::SQL_AFTER_GTIDS_SYMBOL

      || _la == MySQLParser::SQL_BEFORE_GTIDS_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4052);
      match(MySQLParser::EQUAL_OPERATOR);
      setState(4053);
      textString();
      break;
    }

    case 3: {
      setState(4054);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(4055);
      match(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL);
      break;
    }

    }
    setState(4062);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4058);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4059);
        masterFileDef(); 
      }
      setState(4064);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 469, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveConnectionOptionsContext ------------------------------------------------------------------

MySQLParser::SlaveConnectionOptionsContext::SlaveConnectionOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SlaveConnectionOptionsContext::EQUAL_OPERATOR() {
  return getTokens(MySQLParser::EQUAL_OPERATOR);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::EQUAL_OPERATOR(size_t i) {
  return getToken(MySQLParser::EQUAL_OPERATOR, i);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::SlaveConnectionOptionsContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::SlaveConnectionOptionsContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveConnectionOptionsContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}


size_t MySQLParser::SlaveConnectionOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveConnectionOptions;
}

void MySQLParser::SlaveConnectionOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveConnectionOptions(this);
}

void MySQLParser::SlaveConnectionOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveConnectionOptions(this);
}

MySQLParser::SlaveConnectionOptionsContext* MySQLParser::slaveConnectionOptions() {
  SlaveConnectionOptionsContext *_localctx = _tracker.createInstance<SlaveConnectionOptionsContext>(_ctx, getState());
  enterRule(_localctx, 474, MySQLParser::RuleSlaveConnectionOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4087);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 474, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4065);

      if (!(serverVersion >= 50604)) throw FailedPredicateException(this, "serverVersion >= 50604");
      setState(4069);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 470, _ctx)) {
      case 1: {
        setState(4066);
        match(MySQLParser::USER_SYMBOL);
        setState(4067);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4068);
        textString();
        break;
      }

      }
      setState(4074);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 471, _ctx)) {
      case 1: {
        setState(4071);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(4072);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4073);
        textString();
        break;
      }

      }
      setState(4079);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 472, _ctx)) {
      case 1: {
        setState(4076);
        match(MySQLParser::DEFAULT_AUTH_SYMBOL);
        setState(4077);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4078);
        textString();
        break;
      }

      }
      setState(4084);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 473, _ctx)) {
      case 1: {
        setState(4081);
        match(MySQLParser::PLUGIN_DIR_SYMBOL);
        setState(4082);
        match(MySQLParser::EQUAL_OPERATOR);
        setState(4083);
        textString();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveThreadOptionsContext ------------------------------------------------------------------

MySQLParser::SlaveThreadOptionsContext::SlaveThreadOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SlaveThreadOptionContext *> MySQLParser::SlaveThreadOptionsContext::slaveThreadOption() {
  return getRuleContexts<MySQLParser::SlaveThreadOptionContext>();
}

MySQLParser::SlaveThreadOptionContext* MySQLParser::SlaveThreadOptionsContext::slaveThreadOption(size_t i) {
  return getRuleContext<MySQLParser::SlaveThreadOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SlaveThreadOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SlaveThreadOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SlaveThreadOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveThreadOptions;
}

void MySQLParser::SlaveThreadOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveThreadOptions(this);
}

void MySQLParser::SlaveThreadOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveThreadOptions(this);
}

MySQLParser::SlaveThreadOptionsContext* MySQLParser::slaveThreadOptions() {
  SlaveThreadOptionsContext *_localctx = _tracker.createInstance<SlaveThreadOptionsContext>(_ctx, getState());
  enterRule(_localctx, 476, MySQLParser::RuleSlaveThreadOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4089);
    slaveThreadOption();
    setState(4094);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4090);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4091);
        slaveThreadOption(); 
      }
      setState(4096);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 475, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SlaveThreadOptionContext ------------------------------------------------------------------

MySQLParser::SlaveThreadOptionContext::SlaveThreadOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SlaveThreadOptionContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SlaveThreadOptionContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}


size_t MySQLParser::SlaveThreadOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSlaveThreadOption;
}

void MySQLParser::SlaveThreadOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSlaveThreadOption(this);
}

void MySQLParser::SlaveThreadOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSlaveThreadOption(this);
}

MySQLParser::SlaveThreadOptionContext* MySQLParser::slaveThreadOption() {
  SlaveThreadOptionContext *_localctx = _tracker.createInstance<SlaveThreadOptionContext>(_ctx, getState());
  enterRule(_localctx, 478, MySQLParser::RuleSlaveThreadOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4097);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::RELAY_THREAD_SYMBOL || _la == MySQLParser::SQL_THREAD_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupReplicationContext ------------------------------------------------------------------

MySQLParser::GroupReplicationContext::GroupReplicationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GroupReplicationContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupReplicationContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupReplicationContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}


size_t MySQLParser::GroupReplicationContext::getRuleIndex() const {
  return MySQLParser::RuleGroupReplication;
}

void MySQLParser::GroupReplicationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupReplication(this);
}

void MySQLParser::GroupReplicationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupReplication(this);
}

MySQLParser::GroupReplicationContext* MySQLParser::groupReplication() {
  GroupReplicationContext *_localctx = _tracker.createInstance<GroupReplicationContext>(_ctx, getState());
  enterRule(_localctx, 480, MySQLParser::RuleGroupReplication);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4099);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::START_SYMBOL

    || _la == MySQLParser::STOP_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(4100);
    match(MySQLParser::GROUP_REPLICATION_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreparedStatementContext ------------------------------------------------------------------

MySQLParser::PreparedStatementContext::PreparedStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::PreparedStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::PreparedStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::UserVariableContext* MySQLParser::PreparedStatementContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::ExecuteStatementContext* MySQLParser::PreparedStatementContext::executeStatement() {
  return getRuleContext<MySQLParser::ExecuteStatementContext>(0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreparedStatementContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}


size_t MySQLParser::PreparedStatementContext::getRuleIndex() const {
  return MySQLParser::RulePreparedStatement;
}

void MySQLParser::PreparedStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreparedStatement(this);
}

void MySQLParser::PreparedStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreparedStatement(this);
}

MySQLParser::PreparedStatementContext* MySQLParser::preparedStatement() {
  PreparedStatementContext *_localctx = _tracker.createInstance<PreparedStatementContext>(_ctx, getState());
  enterRule(_localctx, 482, MySQLParser::RulePreparedStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4113);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PREPARE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4102);
        dynamic_cast<PreparedStatementContext *>(_localctx)->type = match(MySQLParser::PREPARE_SYMBOL);
        setState(4103);
        identifier();
        setState(4104);
        match(MySQLParser::FROM_SYMBOL);
        setState(4107);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 476, _ctx)) {
        case 1: {
          setState(4105);
          textLiteral();
          break;
        }

        case 2: {
          setState(4106);
          userVariable();
          break;
        }

        }
        break;
      }

      case MySQLParser::EXECUTE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4109);
        executeStatement();
        break;
      }

      case MySQLParser::DEALLOCATE_SYMBOL:
      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4110);
        dynamic_cast<PreparedStatementContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DEALLOCATE_SYMBOL

        || _la == MySQLParser::DROP_SYMBOL)) {
          dynamic_cast<PreparedStatementContext *>(_localctx)->type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(4111);
        match(MySQLParser::PREPARE_SYMBOL);
        setState(4112);
        identifier();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteStatementContext ------------------------------------------------------------------

MySQLParser::ExecuteStatementContext::ExecuteStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ExecuteStatementContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::ExecuteStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::ExecuteStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::ExecuteVarListContext* MySQLParser::ExecuteStatementContext::executeVarList() {
  return getRuleContext<MySQLParser::ExecuteVarListContext>(0);
}


size_t MySQLParser::ExecuteStatementContext::getRuleIndex() const {
  return MySQLParser::RuleExecuteStatement;
}

void MySQLParser::ExecuteStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteStatement(this);
}

void MySQLParser::ExecuteStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteStatement(this);
}

MySQLParser::ExecuteStatementContext* MySQLParser::executeStatement() {
  ExecuteStatementContext *_localctx = _tracker.createInstance<ExecuteStatementContext>(_ctx, getState());
  enterRule(_localctx, 484, MySQLParser::RuleExecuteStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4115);
    match(MySQLParser::EXECUTE_SYMBOL);
    setState(4116);
    identifier();
    setState(4119);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::USING_SYMBOL) {
      setState(4117);
      match(MySQLParser::USING_SYMBOL);
      setState(4118);
      executeVarList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExecuteVarListContext ------------------------------------------------------------------

MySQLParser::ExecuteVarListContext::ExecuteVarListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UserVariableContext *> MySQLParser::ExecuteVarListContext::userVariable() {
  return getRuleContexts<MySQLParser::UserVariableContext>();
}

MySQLParser::UserVariableContext* MySQLParser::ExecuteVarListContext::userVariable(size_t i) {
  return getRuleContext<MySQLParser::UserVariableContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ExecuteVarListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ExecuteVarListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ExecuteVarListContext::getRuleIndex() const {
  return MySQLParser::RuleExecuteVarList;
}

void MySQLParser::ExecuteVarListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExecuteVarList(this);
}

void MySQLParser::ExecuteVarListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExecuteVarList(this);
}

MySQLParser::ExecuteVarListContext* MySQLParser::executeVarList() {
  ExecuteVarListContext *_localctx = _tracker.createInstance<ExecuteVarListContext>(_ctx, getState());
  enterRule(_localctx, 486, MySQLParser::RuleExecuteVarList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4121);
    userVariable();
    setState(4126);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4122);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4123);
      userVariable();
      setState(4128);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CloneStatementContext ------------------------------------------------------------------

MySQLParser::CloneStatementContext::CloneStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CloneStatementContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::CloneStatementContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::REMOTE_SYMBOL() {
  return getToken(MySQLParser::REMOTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::CloneStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::COLON_SYMBOL() {
  return getToken(MySQLParser::COLON_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::CloneStatementContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::EqualContext* MySQLParser::CloneStatementContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CloneStatementContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

MySQLParser::DataDirSSLContext* MySQLParser::CloneStatementContext::dataDirSSL() {
  return getRuleContext<MySQLParser::DataDirSSLContext>(0);
}


size_t MySQLParser::CloneStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCloneStatement;
}

void MySQLParser::CloneStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCloneStatement(this);
}

void MySQLParser::CloneStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCloneStatement(this);
}

MySQLParser::CloneStatementContext* MySQLParser::cloneStatement() {
  CloneStatementContext *_localctx = _tracker.createInstance<CloneStatementContext>(_ctx, getState());
  enterRule(_localctx, 488, MySQLParser::RuleCloneStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4129);
    match(MySQLParser::CLONE_SYMBOL);
    setState(4154);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 483, _ctx)) {
    case 1: {
      setState(4130);
      match(MySQLParser::LOCAL_SYMBOL);
      setState(4131);
      match(MySQLParser::DATA_SYMBOL);
      setState(4132);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(4134);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 480, _ctx)) {
      case 1: {
        setState(4133);
        equal();
        break;
      }

      }
      setState(4136);
      textStringLiteral();
      break;
    }

    case 2: {
      setState(4137);
      match(MySQLParser::REMOTE_SYMBOL);
      setState(4140);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL) {
        setState(4138);
        match(MySQLParser::FOR_SYMBOL);
        setState(4139);
        match(MySQLParser::REPLICATION_SYMBOL);
      }
      break;
    }

    case 3: {
      setState(4142);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4143);
      match(MySQLParser::INSTANCE_SYMBOL);
      setState(4144);
      match(MySQLParser::FROM_SYMBOL);
      setState(4145);
      user();
      setState(4146);
      match(MySQLParser::COLON_SYMBOL);
      setState(4147);
      ulong_number();
      setState(4148);
      match(MySQLParser::IDENTIFIED_SYMBOL);
      setState(4149);
      match(MySQLParser::BY_SYMBOL);
      setState(4150);
      textStringLiteral();
      setState(4152);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::REQUIRE_SYMBOL) {
        setState(4151);
        dataDirSSL();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataDirSSLContext ------------------------------------------------------------------

MySQLParser::DataDirSSLContext::DataDirSSLContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SslContext* MySQLParser::DataDirSSLContext::ssl() {
  return getRuleContext<MySQLParser::SslContext>(0);
}

tree::TerminalNode* MySQLParser::DataDirSSLContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataDirSSLContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::DataDirSSLContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

MySQLParser::EqualContext* MySQLParser::DataDirSSLContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}


size_t MySQLParser::DataDirSSLContext::getRuleIndex() const {
  return MySQLParser::RuleDataDirSSL;
}

void MySQLParser::DataDirSSLContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataDirSSL(this);
}

void MySQLParser::DataDirSSLContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataDirSSL(this);
}

MySQLParser::DataDirSSLContext* MySQLParser::dataDirSSL() {
  DataDirSSLContext *_localctx = _tracker.createInstance<DataDirSSLContext>(_ctx, getState());
  enterRule(_localctx, 490, MySQLParser::RuleDataDirSSL);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4166);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REQUIRE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4156);
        ssl();
        break;
      }

      case MySQLParser::DATA_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4157);
        match(MySQLParser::DATA_SYMBOL);
        setState(4158);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(4160);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 484, _ctx)) {
        case 1: {
          setState(4159);
          equal();
          break;
        }

        }
        setState(4162);
        textStringLiteral();
        setState(4164);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::REQUIRE_SYMBOL) {
          setState(4163);
          ssl();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SslContext ------------------------------------------------------------------

MySQLParser::SslContext::SslContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SslContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SslContext::SSL_SYMBOL() {
  return getToken(MySQLParser::SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SslContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}


size_t MySQLParser::SslContext::getRuleIndex() const {
  return MySQLParser::RuleSsl;
}

void MySQLParser::SslContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSsl(this);
}

void MySQLParser::SslContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSsl(this);
}

MySQLParser::SslContext* MySQLParser::ssl() {
  SslContext *_localctx = _tracker.createInstance<SslContext>(_ctx, getState());
  enterRule(_localctx, 492, MySQLParser::RuleSsl);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4168);
    match(MySQLParser::REQUIRE_SYMBOL);
    setState(4170);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::NO_SYMBOL) {
      setState(4169);
      match(MySQLParser::NO_SYMBOL);
    }
    setState(4172);
    match(MySQLParser::SSL_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountManagementStatementContext ------------------------------------------------------------------

MySQLParser::AccountManagementStatementContext::AccountManagementStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AlterUserContext* MySQLParser::AccountManagementStatementContext::alterUser() {
  return getRuleContext<MySQLParser::AlterUserContext>(0);
}

MySQLParser::CreateUserContext* MySQLParser::AccountManagementStatementContext::createUser() {
  return getRuleContext<MySQLParser::CreateUserContext>(0);
}

MySQLParser::DropUserContext* MySQLParser::AccountManagementStatementContext::dropUser() {
  return getRuleContext<MySQLParser::DropUserContext>(0);
}

MySQLParser::GrantContext* MySQLParser::AccountManagementStatementContext::grant() {
  return getRuleContext<MySQLParser::GrantContext>(0);
}

MySQLParser::RenameUserContext* MySQLParser::AccountManagementStatementContext::renameUser() {
  return getRuleContext<MySQLParser::RenameUserContext>(0);
}

MySQLParser::RevokeContext* MySQLParser::AccountManagementStatementContext::revoke() {
  return getRuleContext<MySQLParser::RevokeContext>(0);
}

MySQLParser::SetPasswordContext* MySQLParser::AccountManagementStatementContext::setPassword() {
  return getRuleContext<MySQLParser::SetPasswordContext>(0);
}

MySQLParser::SetRoleContext* MySQLParser::AccountManagementStatementContext::setRole() {
  return getRuleContext<MySQLParser::SetRoleContext>(0);
}


size_t MySQLParser::AccountManagementStatementContext::getRuleIndex() const {
  return MySQLParser::RuleAccountManagementStatement;
}

void MySQLParser::AccountManagementStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountManagementStatement(this);
}

void MySQLParser::AccountManagementStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountManagementStatement(this);
}

MySQLParser::AccountManagementStatementContext* MySQLParser::accountManagementStatement() {
  AccountManagementStatementContext *_localctx = _tracker.createInstance<AccountManagementStatementContext>(_ctx, getState());
  enterRule(_localctx, 494, MySQLParser::RuleAccountManagementStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4184);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 488, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4174);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(4175);
      alterUser();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4176);
      createUser();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4177);
      dropUser();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4178);
      grant();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4179);
      renameUser();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4180);
      revoke();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4181);
      setPassword();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4182);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4183);
      setRole();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserContext ------------------------------------------------------------------

MySQLParser::AlterUserContext::AlterUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterUserContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::AlterUserTailContext* MySQLParser::AlterUserContext::alterUserTail() {
  return getRuleContext<MySQLParser::AlterUserTailContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::AlterUserContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::AlterUserContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUser;
}

void MySQLParser::AlterUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUser(this);
}

void MySQLParser::AlterUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUser(this);
}

MySQLParser::AlterUserContext* MySQLParser::alterUser() {
  AlterUserContext *_localctx = _tracker.createInstance<AlterUserContext>(_ctx, getState());
  enterRule(_localctx, 496, MySQLParser::RuleAlterUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4186);
    match(MySQLParser::ALTER_SYMBOL);
    setState(4187);
    match(MySQLParser::USER_SYMBOL);
    setState(4190);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 489, _ctx)) {
    case 1: {
      setState(4188);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4189);
      ifExists();
      break;
    }

    }
    setState(4192);
    alterUserTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserTailContext ------------------------------------------------------------------

MySQLParser::AlterUserTailContext::AlterUserTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateUserTailContext* MySQLParser::AlterUserTailContext::createUserTail() {
  return getRuleContext<MySQLParser::CreateUserTailContext>(0);
}

MySQLParser::CreateUserListContext* MySQLParser::AlterUserTailContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::AlterUserListContext* MySQLParser::AlterUserTailContext::alterUserList() {
  return getRuleContext<MySQLParser::AlterUserListContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext* MySQLParser::AlterUserTailContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::AlterUserTailContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

MySQLParser::ReplacePasswordContext* MySQLParser::AlterUserTailContext::replacePassword() {
  return getRuleContext<MySQLParser::ReplacePasswordContext>(0);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::AlterUserTailContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

MySQLParser::DiscardOldPasswordContext* MySQLParser::AlterUserTailContext::discardOldPassword() {
  return getRuleContext<MySQLParser::DiscardOldPasswordContext>(0);
}

MySQLParser::UserContext* MySQLParser::AlterUserTailContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserTailContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::AlterUserTailContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}


size_t MySQLParser::AlterUserTailContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserTail;
}

void MySQLParser::AlterUserTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserTail(this);
}

void MySQLParser::AlterUserTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserTail(this);
}

MySQLParser::AlterUserTailContext* MySQLParser::alterUserTail() {
  AlterUserTailContext *_localctx = _tracker.createInstance<AlterUserTailContext>(_ctx, getState());
  enterRule(_localctx, 498, MySQLParser::RuleAlterUserTail);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4230);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 494, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4198);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 490, _ctx)) {
      case 1: {
        setState(4194);

        if (!(serverVersion < 80014)) throw FailedPredicateException(this, "serverVersion < 80014");
        setState(4195);
        createUserList();
        break;
      }

      case 2: {
        setState(4196);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(4197);
        alterUserList();
        break;
      }

      }
      setState(4200);
      createUserTail();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4202);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4203);
      match(MySQLParser::USER_SYMBOL);
      setState(4204);
      parentheses();
      setState(4205);
      match(MySQLParser::IDENTIFIED_SYMBOL);
      setState(4206);
      match(MySQLParser::BY_SYMBOL);
      setState(4207);
      textString();
      setState(4210);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 491, _ctx)) {
      case 1: {
        setState(4208);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(4209);
        replacePassword();
        break;
      }

      }
      setState(4214);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 492, _ctx)) {
      case 1: {
        setState(4212);

        if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
        setState(4213);
        retainCurrentPassword();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4216);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4217);
      match(MySQLParser::USER_SYMBOL);
      setState(4218);
      parentheses();
      setState(4219);
      discardOldPassword();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4221);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4222);
      user();
      setState(4223);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(4224);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4228);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 493, _ctx)) {
      case 1: {
        setState(4225);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      case 2: {
        setState(4226);
        match(MySQLParser::NONE_SYMBOL);
        break;
      }

      case 3: {
        setState(4227);
        roleList();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserContext ------------------------------------------------------------------

MySQLParser::CreateUserContext::CreateUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateUserContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::CreateUserListContext* MySQLParser::CreateUserContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::DefaultRoleClauseContext* MySQLParser::CreateUserContext::defaultRoleClause() {
  return getRuleContext<MySQLParser::DefaultRoleClauseContext>(0);
}

MySQLParser::CreateUserTailContext* MySQLParser::CreateUserContext::createUserTail() {
  return getRuleContext<MySQLParser::CreateUserTailContext>(0);
}

MySQLParser::IfNotExistsContext* MySQLParser::CreateUserContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}


size_t MySQLParser::CreateUserContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUser;
}

void MySQLParser::CreateUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUser(this);
}

void MySQLParser::CreateUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUser(this);
}

MySQLParser::CreateUserContext* MySQLParser::createUser() {
  CreateUserContext *_localctx = _tracker.createInstance<CreateUserContext>(_ctx, getState());
  enterRule(_localctx, 500, MySQLParser::RuleCreateUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4232);
    match(MySQLParser::CREATE_SYMBOL);
    setState(4233);
    match(MySQLParser::USER_SYMBOL);
    setState(4237);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 495, _ctx)) {
    case 1: {
      setState(4234);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4235);
      ifNotExists();
      break;
    }

    case 2: {
      break;
    }

    }
    setState(4239);
    createUserList();
    setState(4240);
    defaultRoleClause();
    setState(4241);
    createUserTail();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserTailContext ------------------------------------------------------------------

MySQLParser::CreateUserTailContext::CreateUserTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RequireClauseContext* MySQLParser::CreateUserTailContext::requireClause() {
  return getRuleContext<MySQLParser::RequireClauseContext>(0);
}

MySQLParser::ConnectOptionsContext* MySQLParser::CreateUserTailContext::connectOptions() {
  return getRuleContext<MySQLParser::ConnectOptionsContext>(0);
}

std::vector<MySQLParser::AccountLockPasswordExpireOptionsContext *> MySQLParser::CreateUserTailContext::accountLockPasswordExpireOptions() {
  return getRuleContexts<MySQLParser::AccountLockPasswordExpireOptionsContext>();
}

MySQLParser::AccountLockPasswordExpireOptionsContext* MySQLParser::CreateUserTailContext::accountLockPasswordExpireOptions(size_t i) {
  return getRuleContext<MySQLParser::AccountLockPasswordExpireOptionsContext>(i);
}


size_t MySQLParser::CreateUserTailContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserTail;
}

void MySQLParser::CreateUserTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserTail(this);
}

void MySQLParser::CreateUserTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserTail(this);
}

MySQLParser::CreateUserTailContext* MySQLParser::createUserTail() {
  CreateUserTailContext *_localctx = _tracker.createInstance<CreateUserTailContext>(_ctx, getState());
  enterRule(_localctx, 502, MySQLParser::RuleCreateUserTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4257);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 499, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4243);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4245);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::REQUIRE_SYMBOL) {
        setState(4244);
        requireClause();
      }
      setState(4248);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(4247);
        connectOptions();
      }
      setState(4253);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::ACCOUNT_SYMBOL || _la == MySQLParser::PASSWORD_SYMBOL) {
        setState(4250);
        accountLockPasswordExpireOptions();
        setState(4255);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultRoleClauseContext ------------------------------------------------------------------

MySQLParser::DefaultRoleClauseContext::DefaultRoleClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefaultRoleClauseContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultRoleClauseContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::DefaultRoleClauseContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}


size_t MySQLParser::DefaultRoleClauseContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultRoleClause;
}

void MySQLParser::DefaultRoleClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultRoleClause(this);
}

void MySQLParser::DefaultRoleClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultRoleClause(this);
}

MySQLParser::DefaultRoleClauseContext* MySQLParser::defaultRoleClause() {
  DefaultRoleClauseContext *_localctx = _tracker.createInstance<DefaultRoleClauseContext>(_ctx, getState());
  enterRule(_localctx, 504, MySQLParser::RuleDefaultRoleClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4266);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 501, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4259);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4263);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 500, _ctx)) {
      case 1: {
        setState(4260);
        match(MySQLParser::DEFAULT_SYMBOL);
        setState(4261);
        match(MySQLParser::ROLE_SYMBOL);
        setState(4262);
        roleList();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireClauseContext ------------------------------------------------------------------

MySQLParser::RequireClauseContext::RequireClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RequireClauseContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

MySQLParser::RequireListContext* MySQLParser::RequireClauseContext::requireList() {
  return getRuleContext<MySQLParser::RequireListContext>(0);
}

tree::TerminalNode* MySQLParser::RequireClauseContext::SSL_SYMBOL() {
  return getToken(MySQLParser::SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireClauseContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireClauseContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}


size_t MySQLParser::RequireClauseContext::getRuleIndex() const {
  return MySQLParser::RuleRequireClause;
}

void MySQLParser::RequireClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireClause(this);
}

void MySQLParser::RequireClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireClause(this);
}

MySQLParser::RequireClauseContext* MySQLParser::requireClause() {
  RequireClauseContext *_localctx = _tracker.createInstance<RequireClauseContext>(_ctx, getState());
  enterRule(_localctx, 506, MySQLParser::RuleRequireClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4268);
    match(MySQLParser::REQUIRE_SYMBOL);
    setState(4271);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CIPHER_SYMBOL:
      case MySQLParser::ISSUER_SYMBOL:
      case MySQLParser::SUBJECT_SYMBOL: {
        setState(4269);
        requireList();
        break;
      }

      case MySQLParser::NONE_SYMBOL:
      case MySQLParser::SSL_SYMBOL:
      case MySQLParser::X509_SYMBOL: {
        setState(4270);
        dynamic_cast<RequireClauseContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::NONE_SYMBOL || _la == MySQLParser::SSL_SYMBOL || _la == MySQLParser::X509_SYMBOL)) {
          dynamic_cast<RequireClauseContext *>(_localctx)->option = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConnectOptionsContext ------------------------------------------------------------------

MySQLParser::ConnectOptionsContext::ConnectOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_QUERIES_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, i);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::ConnectOptionsContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext* MySQLParser::ConnectOptionsContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_UPDATES_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getTokens(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::ConnectOptionsContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getTokens(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
}

tree::TerminalNode* MySQLParser::ConnectOptionsContext::MAX_USER_CONNECTIONS_SYMBOL(size_t i) {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, i);
}


size_t MySQLParser::ConnectOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleConnectOptions;
}

void MySQLParser::ConnectOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConnectOptions(this);
}

void MySQLParser::ConnectOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConnectOptions(this);
}

MySQLParser::ConnectOptionsContext* MySQLParser::connectOptions() {
  ConnectOptionsContext *_localctx = _tracker.createInstance<ConnectOptionsContext>(_ctx, getState());
  enterRule(_localctx, 508, MySQLParser::RuleConnectOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4273);
    match(MySQLParser::WITH_SYMBOL);
    setState(4282); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(4282);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL: {
          setState(4274);
          match(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
          setState(4275);
          ulong_number();
          break;
        }

        case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL: {
          setState(4276);
          match(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
          setState(4277);
          ulong_number();
          break;
        }

        case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL: {
          setState(4278);
          match(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
          setState(4279);
          ulong_number();
          break;
        }

        case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL: {
          setState(4280);
          match(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
          setState(4281);
          ulong_number();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(4284); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 356) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 356)) & ((1ULL << (MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL - 356))
      | (1ULL << (MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL - 356))
      | (1ULL << (MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL - 356))
      | (1ULL << (MySQLParser::MAX_USER_CONNECTIONS_SYMBOL - 356)))) != 0));
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AccountLockPasswordExpireOptionsContext ------------------------------------------------------------------

MySQLParser::AccountLockPasswordExpireOptionsContext::AccountLockPasswordExpireOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::UNLOCK_SYMBOL() {
  return getToken(MySQLParser::UNLOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::EXPIRE_SYMBOL() {
  return getToken(MySQLParser::EXPIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::REQUIRE_SYMBOL() {
  return getToken(MySQLParser::REQUIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::AccountLockPasswordExpireOptionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AccountLockPasswordExpireOptionsContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}


size_t MySQLParser::AccountLockPasswordExpireOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleAccountLockPasswordExpireOptions;
}

void MySQLParser::AccountLockPasswordExpireOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAccountLockPasswordExpireOptions(this);
}

void MySQLParser::AccountLockPasswordExpireOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAccountLockPasswordExpireOptions(this);
}

MySQLParser::AccountLockPasswordExpireOptionsContext* MySQLParser::accountLockPasswordExpireOptions() {
  AccountLockPasswordExpireOptionsContext *_localctx = _tracker.createInstance<AccountLockPasswordExpireOptionsContext>(_ctx, getState());
  enterRule(_localctx, 510, MySQLParser::RuleAccountLockPasswordExpireOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4319);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ACCOUNT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4286);
        match(MySQLParser::ACCOUNT_SYMBOL);
        setState(4287);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LOCK_SYMBOL || _la == MySQLParser::UNLOCK_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::PASSWORD_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4288);
        match(MySQLParser::PASSWORD_SYMBOL);
        setState(4317);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 509, _ctx)) {
        case 1: {
          setState(4289);
          match(MySQLParser::EXPIRE_SYMBOL);
          setState(4296);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLParser::INTERVAL_SYMBOL: {
              setState(4290);
              match(MySQLParser::INTERVAL_SYMBOL);
              setState(4291);
              real_ulong_number();
              setState(4292);
              match(MySQLParser::DAY_SYMBOL);
              break;
            }

            case MySQLParser::NEVER_SYMBOL: {
              setState(4294);
              match(MySQLParser::NEVER_SYMBOL);
              break;
            }

            case MySQLParser::DEFAULT_SYMBOL: {
              setState(4295);
              match(MySQLParser::DEFAULT_SYMBOL);
              break;
            }

            case MySQLParser::EOF:
            case MySQLParser::SEMICOLON_SYMBOL:
            case MySQLParser::ACCOUNT_SYMBOL:
            case MySQLParser::PASSWORD_SYMBOL: {
              break;
            }

          default:
            break;
          }
          break;
        }

        case 2: {
          setState(4298);
          match(MySQLParser::HISTORY_SYMBOL);
          setState(4301);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLParser::INT_NUMBER:
            case MySQLParser::LONG_NUMBER:
            case MySQLParser::ULONGLONG_NUMBER:
            case MySQLParser::HEX_NUMBER: {
              setState(4299);
              real_ulong_number();
              break;
            }

            case MySQLParser::DEFAULT_SYMBOL: {
              setState(4300);
              match(MySQLParser::DEFAULT_SYMBOL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case 3: {
          setState(4303);
          match(MySQLParser::REUSE_SYMBOL);
          setState(4304);
          match(MySQLParser::INTERVAL_SYMBOL);
          setState(4309);
          _errHandler->sync(this);
          switch (_input->LA(1)) {
            case MySQLParser::INT_NUMBER:
            case MySQLParser::LONG_NUMBER:
            case MySQLParser::ULONGLONG_NUMBER:
            case MySQLParser::HEX_NUMBER: {
              setState(4305);
              real_ulong_number();
              setState(4306);
              match(MySQLParser::DAY_SYMBOL);
              break;
            }

            case MySQLParser::DEFAULT_SYMBOL: {
              setState(4308);
              match(MySQLParser::DEFAULT_SYMBOL);
              break;
            }

          default:
            throw NoViableAltException(this);
          }
          break;
        }

        case 4: {
          setState(4311);

          if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
          setState(4312);
          match(MySQLParser::REQUIRE_SYMBOL);
          setState(4313);
          match(MySQLParser::CURRENT_SYMBOL);
          setState(4315);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::OPTIONAL_SYMBOL) {
            setState(4314);
            _la = _input->LA(1);
            if (!(_la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::OPTIONAL_SYMBOL)) {
            _errHandler->recoverInline(this);
            }
            else {
              _errHandler->reportMatch(this);
              consume();
            }
          }
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropUserContext ------------------------------------------------------------------

MySQLParser::DropUserContext::DropUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropUserContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::DropUserContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

MySQLParser::IfExistsContext* MySQLParser::DropUserContext::ifExists() {
  return getRuleContext<MySQLParser::IfExistsContext>(0);
}


size_t MySQLParser::DropUserContext::getRuleIndex() const {
  return MySQLParser::RuleDropUser;
}

void MySQLParser::DropUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropUser(this);
}

void MySQLParser::DropUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropUser(this);
}

MySQLParser::DropUserContext* MySQLParser::dropUser() {
  DropUserContext *_localctx = _tracker.createInstance<DropUserContext>(_ctx, getState());
  enterRule(_localctx, 512, MySQLParser::RuleDropUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4321);
    match(MySQLParser::DROP_SYMBOL);
    setState(4322);
    match(MySQLParser::USER_SYMBOL);
    setState(4325);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 511, _ctx)) {
    case 1: {
      setState(4323);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(4324);
      ifExists();
      break;
    }

    }
    setState(4327);
    userList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantContext ------------------------------------------------------------------

MySQLParser::GrantContext::GrantContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::GrantContext::GRANT_SYMBOL() {
  return getTokens(MySQLParser::GRANT_SYMBOL);
}

tree::TerminalNode* MySQLParser::GrantContext::GRANT_SYMBOL(size_t i) {
  return getToken(MySQLParser::GRANT_SYMBOL, i);
}

MySQLParser::RoleOrPrivilegesListContext* MySQLParser::GrantContext::roleOrPrivilegesList() {
  return getRuleContext<MySQLParser::RoleOrPrivilegesListContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::GrantContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::GrantIdentifierContext* MySQLParser::GrantContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

MySQLParser::GrantTargetListContext* MySQLParser::GrantContext::grantTargetList() {
  return getRuleContext<MySQLParser::GrantTargetListContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::GrantContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

MySQLParser::AclTypeContext* MySQLParser::GrantContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}

MySQLParser::VersionedRequireClauseContext* MySQLParser::GrantContext::versionedRequireClause() {
  return getRuleContext<MySQLParser::VersionedRequireClauseContext>(0);
}

MySQLParser::GrantOptionsContext* MySQLParser::GrantContext::grantOptions() {
  return getRuleContext<MySQLParser::GrantOptionsContext>(0);
}

MySQLParser::GrantAsContext* MySQLParser::GrantContext::grantAs() {
  return getRuleContext<MySQLParser::GrantAsContext>(0);
}

tree::TerminalNode* MySQLParser::GrantContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}


size_t MySQLParser::GrantContext::getRuleIndex() const {
  return MySQLParser::RuleGrant;
}

void MySQLParser::GrantContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrant(this);
}

void MySQLParser::GrantContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrant(this);
}

MySQLParser::GrantContext* MySQLParser::grant() {
  GrantContext *_localctx = _tracker.createInstance<GrantContext>(_ctx, getState());
  enterRule(_localctx, 514, MySQLParser::RuleGrant);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4329);
    match(MySQLParser::GRANT_SYMBOL);
    setState(4372);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 520, _ctx)) {
    case 1: {
      setState(4330);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4331);
      roleOrPrivilegesList();
      setState(4332);
      match(MySQLParser::TO_SYMBOL);
      setState(4333);
      userList();
      setState(4337);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(4334);
        match(MySQLParser::WITH_SYMBOL);
        setState(4335);
        match(MySQLParser::ADMIN_SYMBOL);
        setState(4336);
        match(MySQLParser::OPTION_SYMBOL);
      }
      break;
    }

    case 2: {
      setState(4344);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 514, _ctx)) {
      case 1: {
        setState(4339);
        roleOrPrivilegesList();
        break;
      }

      case 2: {
        setState(4340);
        match(MySQLParser::ALL_SYMBOL);
        setState(4342);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::PRIVILEGES_SYMBOL) {
          setState(4341);
          match(MySQLParser::PRIVILEGES_SYMBOL);
        }
        break;
      }

      }
      setState(4346);
      match(MySQLParser::ON_SYMBOL);
      setState(4348);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 515, _ctx)) {
      case 1: {
        setState(4347);
        aclType();
        break;
      }

      }
      setState(4350);
      grantIdentifier();
      setState(4351);
      match(MySQLParser::TO_SYMBOL);
      setState(4352);
      grantTargetList();
      setState(4354);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 516, _ctx)) {
      case 1: {
        setState(4353);
        versionedRequireClause();
        break;
      }

      }
      setState(4357);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 517, _ctx)) {
      case 1: {
        setState(4356);
        grantOptions();
        break;
      }

      }
      setState(4360);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::AS_SYMBOL) {
        setState(4359);
        grantAs();
      }
      break;
    }

    case 3: {
      setState(4362);
      match(MySQLParser::PROXY_SYMBOL);
      setState(4363);
      match(MySQLParser::ON_SYMBOL);
      setState(4364);
      user();
      setState(4365);
      match(MySQLParser::TO_SYMBOL);
      setState(4366);
      grantTargetList();
      setState(4370);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(4367);
        match(MySQLParser::WITH_SYMBOL);
        setState(4368);
        match(MySQLParser::GRANT_SYMBOL);
        setState(4369);
        match(MySQLParser::OPTION_SYMBOL);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantTargetListContext ------------------------------------------------------------------

MySQLParser::GrantTargetListContext::GrantTargetListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateUserListContext* MySQLParser::GrantTargetListContext::createUserList() {
  return getRuleContext<MySQLParser::CreateUserListContext>(0);
}

MySQLParser::UserListContext* MySQLParser::GrantTargetListContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}


size_t MySQLParser::GrantTargetListContext::getRuleIndex() const {
  return MySQLParser::RuleGrantTargetList;
}

void MySQLParser::GrantTargetListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantTargetList(this);
}

void MySQLParser::GrantTargetListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantTargetList(this);
}

MySQLParser::GrantTargetListContext* MySQLParser::grantTargetList() {
  GrantTargetListContext *_localctx = _tracker.createInstance<GrantTargetListContext>(_ctx, getState());
  enterRule(_localctx, 516, MySQLParser::RuleGrantTargetList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4378);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 521, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4374);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(4375);
      createUserList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4376);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(4377);
      userList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantOptionsContext ------------------------------------------------------------------

MySQLParser::GrantOptionsContext::GrantOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GrantOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

std::vector<MySQLParser::GrantOptionContext *> MySQLParser::GrantOptionsContext::grantOption() {
  return getRuleContexts<MySQLParser::GrantOptionContext>();
}

MySQLParser::GrantOptionContext* MySQLParser::GrantOptionsContext::grantOption(size_t i) {
  return getRuleContext<MySQLParser::GrantOptionContext>(i);
}

tree::TerminalNode* MySQLParser::GrantOptionsContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionsContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}


size_t MySQLParser::GrantOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleGrantOptions;
}

void MySQLParser::GrantOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantOptions(this);
}

void MySQLParser::GrantOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantOptions(this);
}

MySQLParser::GrantOptionsContext* MySQLParser::grantOptions() {
  GrantOptionsContext *_localctx = _tracker.createInstance<GrantOptionsContext>(_ctx, getState());
  enterRule(_localctx, 518, MySQLParser::RuleGrantOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4391);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 523, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4380);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(4381);
      match(MySQLParser::WITH_SYMBOL);
      setState(4383); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(4382);
        grantOption();
        setState(4385); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySQLParser::GRANT_SYMBOL || ((((_la - 356) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 356)) & ((1ULL << (MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL - 356))
        | (1ULL << (MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL - 356))
        | (1ULL << (MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL - 356))
        | (1ULL << (MySQLParser::MAX_USER_CONNECTIONS_SYMBOL - 356)))) != 0));
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4387);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(4388);
      match(MySQLParser::WITH_SYMBOL);
      setState(4389);
      match(MySQLParser::GRANT_SYMBOL);
      setState(4390);
      match(MySQLParser::OPTION_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExceptRoleListContext ------------------------------------------------------------------

MySQLParser::ExceptRoleListContext::ExceptRoleListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ExceptRoleListContext::EXCEPT_SYMBOL() {
  return getToken(MySQLParser::EXCEPT_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::ExceptRoleListContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}


size_t MySQLParser::ExceptRoleListContext::getRuleIndex() const {
  return MySQLParser::RuleExceptRoleList;
}

void MySQLParser::ExceptRoleListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExceptRoleList(this);
}

void MySQLParser::ExceptRoleListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExceptRoleList(this);
}

MySQLParser::ExceptRoleListContext* MySQLParser::exceptRoleList() {
  ExceptRoleListContext *_localctx = _tracker.createInstance<ExceptRoleListContext>(_ctx, getState());
  enterRule(_localctx, 520, MySQLParser::RuleExceptRoleList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4393);
    match(MySQLParser::EXCEPT_SYMBOL);
    setState(4394);
    roleList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WithRolesContext ------------------------------------------------------------------

MySQLParser::WithRolesContext::WithRolesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WithRolesContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WithRolesContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

MySQLParser::RoleListContext* MySQLParser::WithRolesContext::roleList() {
  return getRuleContext<MySQLParser::RoleListContext>(0);
}

tree::TerminalNode* MySQLParser::WithRolesContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WithRolesContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WithRolesContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::ExceptRoleListContext* MySQLParser::WithRolesContext::exceptRoleList() {
  return getRuleContext<MySQLParser::ExceptRoleListContext>(0);
}


size_t MySQLParser::WithRolesContext::getRuleIndex() const {
  return MySQLParser::RuleWithRoles;
}

void MySQLParser::WithRolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWithRoles(this);
}

void MySQLParser::WithRolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWithRoles(this);
}

MySQLParser::WithRolesContext* MySQLParser::withRoles() {
  WithRolesContext *_localctx = _tracker.createInstance<WithRolesContext>(_ctx, getState());
  enterRule(_localctx, 522, MySQLParser::RuleWithRoles);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4396);
    match(MySQLParser::WITH_SYMBOL);
    setState(4397);
    match(MySQLParser::ROLE_SYMBOL);
    setState(4405);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 525, _ctx)) {
    case 1: {
      setState(4398);
      roleList();
      break;
    }

    case 2: {
      setState(4399);
      match(MySQLParser::ALL_SYMBOL);
      setState(4401);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EXCEPT_SYMBOL) {
        setState(4400);
        exceptRoleList();
      }
      break;
    }

    case 3: {
      setState(4403);
      match(MySQLParser::NONE_SYMBOL);
      break;
    }

    case 4: {
      setState(4404);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantAsContext ------------------------------------------------------------------

MySQLParser::GrantAsContext::GrantAsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GrantAsContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantAsContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::WithRolesContext* MySQLParser::GrantAsContext::withRoles() {
  return getRuleContext<MySQLParser::WithRolesContext>(0);
}


size_t MySQLParser::GrantAsContext::getRuleIndex() const {
  return MySQLParser::RuleGrantAs;
}

void MySQLParser::GrantAsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantAs(this);
}

void MySQLParser::GrantAsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantAs(this);
}

MySQLParser::GrantAsContext* MySQLParser::grantAs() {
  GrantAsContext *_localctx = _tracker.createInstance<GrantAsContext>(_ctx, getState());
  enterRule(_localctx, 524, MySQLParser::RuleGrantAs);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4407);
    match(MySQLParser::AS_SYMBOL);
    setState(4408);
    match(MySQLParser::USER_SYMBOL);
    setState(4410);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::WITH_SYMBOL) {
      setState(4409);
      withRoles();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VersionedRequireClauseContext ------------------------------------------------------------------

MySQLParser::VersionedRequireClauseContext::VersionedRequireClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RequireClauseContext* MySQLParser::VersionedRequireClauseContext::requireClause() {
  return getRuleContext<MySQLParser::RequireClauseContext>(0);
}


size_t MySQLParser::VersionedRequireClauseContext::getRuleIndex() const {
  return MySQLParser::RuleVersionedRequireClause;
}

void MySQLParser::VersionedRequireClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVersionedRequireClause(this);
}

void MySQLParser::VersionedRequireClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVersionedRequireClause(this);
}

MySQLParser::VersionedRequireClauseContext* MySQLParser::versionedRequireClause() {
  VersionedRequireClauseContext *_localctx = _tracker.createInstance<VersionedRequireClauseContext>(_ctx, getState());
  enterRule(_localctx, 526, MySQLParser::RuleVersionedRequireClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4412);

    if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
    setState(4413);
    requireClause();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RenameUserContext ------------------------------------------------------------------

MySQLParser::RenameUserContext::RenameUserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RenameUserContext::RENAME_SYMBOL() {
  return getToken(MySQLParser::RENAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RenameUserContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

std::vector<MySQLParser::UserContext *> MySQLParser::RenameUserContext::user() {
  return getRuleContexts<MySQLParser::UserContext>();
}

MySQLParser::UserContext* MySQLParser::RenameUserContext::user(size_t i) {
  return getRuleContext<MySQLParser::UserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameUserContext::TO_SYMBOL() {
  return getTokens(MySQLParser::TO_SYMBOL);
}

tree::TerminalNode* MySQLParser::RenameUserContext::TO_SYMBOL(size_t i) {
  return getToken(MySQLParser::TO_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::RenameUserContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RenameUserContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RenameUserContext::getRuleIndex() const {
  return MySQLParser::RuleRenameUser;
}

void MySQLParser::RenameUserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRenameUser(this);
}

void MySQLParser::RenameUserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRenameUser(this);
}

MySQLParser::RenameUserContext* MySQLParser::renameUser() {
  RenameUserContext *_localctx = _tracker.createInstance<RenameUserContext>(_ctx, getState());
  enterRule(_localctx, 528, MySQLParser::RuleRenameUser);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4415);
    match(MySQLParser::RENAME_SYMBOL);
    setState(4416);
    match(MySQLParser::USER_SYMBOL);
    setState(4417);
    user();
    setState(4418);
    match(MySQLParser::TO_SYMBOL);
    setState(4419);
    user();
    setState(4427);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4420);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4421);
      user();
      setState(4422);
      match(MySQLParser::TO_SYMBOL);
      setState(4423);
      user();
      setState(4429);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RevokeContext ------------------------------------------------------------------

MySQLParser::RevokeContext::RevokeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RevokeContext::REVOKE_SYMBOL() {
  return getToken(MySQLParser::REVOKE_SYMBOL, 0);
}

MySQLParser::RoleOrPrivilegesListContext* MySQLParser::RevokeContext::roleOrPrivilegesList() {
  return getRuleContext<MySQLParser::RoleOrPrivilegesListContext>(0);
}

tree::TerminalNode* MySQLParser::RevokeContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::RevokeContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

MySQLParser::OnTypeToContext* MySQLParser::RevokeContext::onTypeTo() {
  return getRuleContext<MySQLParser::OnTypeToContext>(0);
}

tree::TerminalNode* MySQLParser::RevokeContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::RevokeContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::GrantIdentifierContext* MySQLParser::RevokeContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::RevokeContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RevokeContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

MySQLParser::AclTypeContext* MySQLParser::RevokeContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}


size_t MySQLParser::RevokeContext::getRuleIndex() const {
  return MySQLParser::RuleRevoke;
}

void MySQLParser::RevokeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRevoke(this);
}

void MySQLParser::RevokeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRevoke(this);
}

MySQLParser::RevokeContext* MySQLParser::revoke() {
  RevokeContext *_localctx = _tracker.createInstance<RevokeContext>(_ctx, getState());
  enterRule(_localctx, 530, MySQLParser::RuleRevoke);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4430);
    match(MySQLParser::REVOKE_SYMBOL);
    setState(4464);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 531, _ctx)) {
    case 1: {
      setState(4431);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4432);
      roleOrPrivilegesList();
      setState(4433);
      match(MySQLParser::FROM_SYMBOL);
      setState(4434);
      userList();
      break;
    }

    case 2: {
      setState(4436);
      roleOrPrivilegesList();
      setState(4437);
      onTypeTo();
      setState(4438);
      match(MySQLParser::FROM_SYMBOL);
      setState(4439);
      userList();
      break;
    }

    case 3: {
      setState(4441);
      match(MySQLParser::ALL_SYMBOL);
      setState(4443);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 528, _ctx)) {
      case 1: {
        setState(4442);
        match(MySQLParser::PRIVILEGES_SYMBOL);
        break;
      }

      }
      setState(4456);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 530, _ctx)) {
      case 1: {
        setState(4445);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(4446);
        match(MySQLParser::ON_SYMBOL);
        setState(4448);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 529, _ctx)) {
        case 1: {
          setState(4447);
          aclType();
          break;
        }

        }
        setState(4450);
        grantIdentifier();
        break;
      }

      case 2: {
        setState(4451);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4452);
        match(MySQLParser::GRANT_SYMBOL);
        setState(4453);
        match(MySQLParser::OPTION_SYMBOL);
        setState(4454);
        match(MySQLParser::FROM_SYMBOL);
        setState(4455);
        userList();
        break;
      }

      }
      break;
    }

    case 4: {
      setState(4458);
      match(MySQLParser::PROXY_SYMBOL);
      setState(4459);
      match(MySQLParser::ON_SYMBOL);
      setState(4460);
      user();
      setState(4461);
      match(MySQLParser::FROM_SYMBOL);
      setState(4462);
      userList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnTypeToContext ------------------------------------------------------------------

MySQLParser::OnTypeToContext::OnTypeToContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OnTypeToContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::GrantIdentifierContext* MySQLParser::OnTypeToContext::grantIdentifier() {
  return getRuleContext<MySQLParser::GrantIdentifierContext>(0);
}

MySQLParser::AclTypeContext* MySQLParser::OnTypeToContext::aclType() {
  return getRuleContext<MySQLParser::AclTypeContext>(0);
}


size_t MySQLParser::OnTypeToContext::getRuleIndex() const {
  return MySQLParser::RuleOnTypeTo;
}

void MySQLParser::OnTypeToContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnTypeTo(this);
}

void MySQLParser::OnTypeToContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnTypeTo(this);
}

MySQLParser::OnTypeToContext* MySQLParser::onTypeTo() {
  OnTypeToContext *_localctx = _tracker.createInstance<OnTypeToContext>(_ctx, getState());
  enterRule(_localctx, 532, MySQLParser::RuleOnTypeTo);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4480);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 535, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4466);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(4467);
      match(MySQLParser::ON_SYMBOL);
      setState(4469);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 532, _ctx)) {
      case 1: {
        setState(4468);
        aclType();
        break;
      }

      }
      setState(4471);
      grantIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4472);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4478);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ON_SYMBOL) {
        setState(4473);
        match(MySQLParser::ON_SYMBOL);
        setState(4475);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 533, _ctx)) {
        case 1: {
          setState(4474);
          aclType();
          break;
        }

        }
        setState(4477);
        grantIdentifier();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AclTypeContext ------------------------------------------------------------------

MySQLParser::AclTypeContext::AclTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AclTypeContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AclTypeContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AclTypeContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}


size_t MySQLParser::AclTypeContext::getRuleIndex() const {
  return MySQLParser::RuleAclType;
}

void MySQLParser::AclTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAclType(this);
}

void MySQLParser::AclTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAclType(this);
}

MySQLParser::AclTypeContext* MySQLParser::aclType() {
  AclTypeContext *_localctx = _tracker.createInstance<AclTypeContext>(_ctx, getState());
  enterRule(_localctx, 534, MySQLParser::RuleAclType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4482);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FUNCTION_SYMBOL || _la == MySQLParser::PROCEDURE_SYMBOL || _la == MySQLParser::TABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetPasswordContext ------------------------------------------------------------------

MySQLParser::SetPasswordContext::SetPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetPasswordContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SetPasswordContext::PASSWORD_SYMBOL() {
  return getTokens(MySQLParser::PASSWORD_SYMBOL);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::PASSWORD_SYMBOL(size_t i) {
  return getToken(MySQLParser::PASSWORD_SYMBOL, i);
}

MySQLParser::EqualContext* MySQLParser::SetPasswordContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::SetPasswordContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::OLD_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::OLD_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetPasswordContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::SetPasswordContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

MySQLParser::ReplacePasswordContext* MySQLParser::SetPasswordContext::replacePassword() {
  return getRuleContext<MySQLParser::ReplacePasswordContext>(0);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::SetPasswordContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}


size_t MySQLParser::SetPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleSetPassword;
}

void MySQLParser::SetPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetPassword(this);
}

void MySQLParser::SetPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetPassword(this);
}

MySQLParser::SetPasswordContext* MySQLParser::setPassword() {
  SetPasswordContext *_localctx = _tracker.createInstance<SetPasswordContext>(_ctx, getState());
  enterRule(_localctx, 536, MySQLParser::RuleSetPassword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4484);
    match(MySQLParser::SET_SYMBOL);
    setState(4485);
    match(MySQLParser::PASSWORD_SYMBOL);
    setState(4488);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(4486);
      match(MySQLParser::FOR_SYMBOL);
      setState(4487);
      user();
    }
    setState(4490);
    equal();
    setState(4503);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 537, _ctx)) {
    case 1: {
      setState(4491);
      match(MySQLParser::PASSWORD_SYMBOL);
      setState(4492);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(4493);
      textString();
      setState(4494);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      setState(4496);

      if (!(serverVersion < 50706)) throw FailedPredicateException(this, "serverVersion < 50706");
      setState(4497);
      match(MySQLParser::OLD_PASSWORD_SYMBOL);
      setState(4498);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(4499);
      textString();
      setState(4500);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 3: {
      setState(4502);
      textString();
      break;
    }

    }
    setState(4507);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 538, _ctx)) {
    case 1: {
      setState(4505);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4506);
      replacePassword();
      break;
    }

    }
    setState(4511);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 539, _ctx)) {
    case 1: {
      setState(4509);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(4510);
      retainCurrentPassword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrPrivilegesListContext ------------------------------------------------------------------

MySQLParser::RoleOrPrivilegesListContext::RoleOrPrivilegesListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoleOrPrivilegeContext *> MySQLParser::RoleOrPrivilegesListContext::roleOrPrivilege() {
  return getRuleContexts<MySQLParser::RoleOrPrivilegeContext>();
}

MySQLParser::RoleOrPrivilegeContext* MySQLParser::RoleOrPrivilegesListContext::roleOrPrivilege(size_t i) {
  return getRuleContext<MySQLParser::RoleOrPrivilegeContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RoleOrPrivilegesListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegesListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RoleOrPrivilegesListContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrPrivilegesList;
}

void MySQLParser::RoleOrPrivilegesListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrPrivilegesList(this);
}

void MySQLParser::RoleOrPrivilegesListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrPrivilegesList(this);
}

MySQLParser::RoleOrPrivilegesListContext* MySQLParser::roleOrPrivilegesList() {
  RoleOrPrivilegesListContext *_localctx = _tracker.createInstance<RoleOrPrivilegesListContext>(_ctx, getState());
  enterRule(_localctx, 538, MySQLParser::RuleRoleOrPrivilegesList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4513);
    roleOrPrivilege();
    setState(4518);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 540, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4514);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4515);
        roleOrPrivilege(); 
      }
      setState(4520);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 540, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrPrivilegeContext ------------------------------------------------------------------

MySQLParser::RoleOrPrivilegeContext::RoleOrPrivilegeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierOrTextContext* MySQLParser::RoleOrPrivilegeContext::roleIdentifierOrText() {
  return getRuleContext<MySQLParser::RoleIdentifierOrTextContext>(0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::RoleOrPrivilegeContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::RoleOrPrivilegeContext::columnInternalRefList() {
  return getRuleContext<MySQLParser::ColumnInternalRefListContext>(0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SELECT_SYMBOL() {
  return getToken(MySQLParser::SELECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::REFERENCES_SYMBOL() {
  return getToken(MySQLParser::REFERENCES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::USAGE_SYMBOL() {
  return getToken(MySQLParser::USAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::DATABASES_SYMBOL() {
  return getToken(MySQLParser::DATABASES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrPrivilegeContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}


size_t MySQLParser::RoleOrPrivilegeContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrPrivilege;
}

void MySQLParser::RoleOrPrivilegeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrPrivilege(this);
}

void MySQLParser::RoleOrPrivilegeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrPrivilege(this);
}

MySQLParser::RoleOrPrivilegeContext* MySQLParser::roleOrPrivilege() {
  RoleOrPrivilegeContext *_localctx = _tracker.createInstance<RoleOrPrivilegeContext>(_ctx, getState());
  enterRule(_localctx, 540, MySQLParser::RuleRoleOrPrivilege);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4562);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 547, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4521);

      if (!(serverVersion > 80000)) throw FailedPredicateException(this, "serverVersion > 80000");
      setState(4532);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 543, _ctx)) {
      case 1: {
        setState(4522);
        roleIdentifierOrText();
        setState(4524);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 541, _ctx)) {
        case 1: {
          setState(4523);
          columnInternalRefList();
          break;
        }

        }
        break;
      }

      case 2: {
        setState(4526);
        roleIdentifierOrText();
        setState(4530);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::AT_TEXT_SUFFIX: {
            setState(4527);
            match(MySQLParser::AT_TEXT_SUFFIX);
            break;
          }

          case MySQLParser::AT_SIGN_SYMBOL: {
            setState(4528);
            match(MySQLParser::AT_SIGN_SYMBOL);
            setState(4529);
            textOrIdentifier();
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4534);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::INSERT_SYMBOL || _la == MySQLParser::REFERENCES_SYMBOL

      || _la == MySQLParser::SELECT_SYMBOL || _la == MySQLParser::UPDATE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4536);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 544, _ctx)) {
      case 1: {
        setState(4535);
        columnInternalRefList();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4538);
      _la = _input->LA(1);
      if (!(((((_la - 177) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 177)) & ((1ULL << (MySQLParser::DELETE_SYMBOL - 177))
        | (1ULL << (MySQLParser::DROP_SYMBOL - 177))
        | (1ULL << (MySQLParser::EVENT_SYMBOL - 177))
        | (1ULL << (MySQLParser::EXECUTE_SYMBOL - 177))
        | (1ULL << (MySQLParser::FILE_SYMBOL - 177)))) != 0) || _la == MySQLParser::INDEX_SYMBOL || ((((_la - 457) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 457)) & ((1ULL << (MySQLParser::PROCESS_SYMBOL - 457))
        | (1ULL << (MySQLParser::PROXY_SYMBOL - 457))
        | (1ULL << (MySQLParser::RELOAD_SYMBOL - 457)))) != 0) || _la == MySQLParser::SHUTDOWN_SYMBOL

      || _la == MySQLParser::SUPER_SYMBOL || _la == MySQLParser::TRIGGER_SYMBOL

      || _la == MySQLParser::USAGE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4539);
      match(MySQLParser::GRANT_SYMBOL);
      setState(4540);
      match(MySQLParser::OPTION_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4541);
      match(MySQLParser::SHOW_SYMBOL);
      setState(4542);
      match(MySQLParser::DATABASES_SYMBOL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(4543);
      match(MySQLParser::CREATE_SYMBOL);
      setState(4547);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 545, _ctx)) {
      case 1: {
        setState(4544);
        match(MySQLParser::TEMPORARY_SYMBOL);
        setState(4545);
        dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = match(MySQLParser::TABLES_SYMBOL);
        break;
      }

      case 2: {
        setState(4546);
        dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ROUTINE_SYMBOL || ((((_la - 602) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 602)) & ((1ULL << (MySQLParser::TABLESPACE_SYMBOL - 602))
          | (1ULL << (MySQLParser::USER_SYMBOL - 602))
          | (1ULL << (MySQLParser::VIEW_SYMBOL - 602)))) != 0))) {
          dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(4549);
      match(MySQLParser::LOCK_SYMBOL);
      setState(4550);
      match(MySQLParser::TABLES_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(4551);
      match(MySQLParser::REPLICATION_SYMBOL);
      setState(4552);
      dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CLIENT_SYMBOL || _la == MySQLParser::SLAVE_SYMBOL)) {
        dynamic_cast<RoleOrPrivilegeContext *>(_localctx)->object = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(4553);
      match(MySQLParser::SHOW_SYMBOL);
      setState(4554);
      match(MySQLParser::VIEW_SYMBOL);
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(4555);
      match(MySQLParser::ALTER_SYMBOL);
      setState(4557);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 546, _ctx)) {
      case 1: {
        setState(4556);
        match(MySQLParser::ROUTINE_SYMBOL);
        break;
      }

      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(4559);

      if (!(serverVersion > 80000)) throw FailedPredicateException(this, "serverVersion > 80000");
      setState(4560);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CREATE_SYMBOL

      || _la == MySQLParser::DROP_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4561);
      match(MySQLParser::ROLE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantIdentifierContext ------------------------------------------------------------------

MySQLParser::GrantIdentifierContext::GrantIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::GrantIdentifierContext::MULT_OPERATOR() {
  return getTokens(MySQLParser::MULT_OPERATOR);
}

tree::TerminalNode* MySQLParser::GrantIdentifierContext::MULT_OPERATOR(size_t i) {
  return getToken(MySQLParser::MULT_OPERATOR, i);
}

tree::TerminalNode* MySQLParser::GrantIdentifierContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

MySQLParser::SchemaRefContext* MySQLParser::GrantIdentifierContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::TableRefContext* MySQLParser::GrantIdentifierContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}


size_t MySQLParser::GrantIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleGrantIdentifier;
}

void MySQLParser::GrantIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantIdentifier(this);
}

void MySQLParser::GrantIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantIdentifier(this);
}

MySQLParser::GrantIdentifierContext* MySQLParser::grantIdentifier() {
  GrantIdentifierContext *_localctx = _tracker.createInstance<GrantIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 542, MySQLParser::RuleGrantIdentifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4580);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 550, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4564);
      match(MySQLParser::MULT_OPERATOR);
      setState(4567);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(4565);
        match(MySQLParser::DOT_SYMBOL);
        setState(4566);
        match(MySQLParser::MULT_OPERATOR);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4569);
      schemaRef();
      setState(4572);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(4570);
        match(MySQLParser::DOT_SYMBOL);
        setState(4571);
        match(MySQLParser::MULT_OPERATOR);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4574);
      tableRef();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4575);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(4576);
      schemaRef();
      setState(4577);
      match(MySQLParser::DOT_SYMBOL);
      setState(4578);
      tableRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireListContext ------------------------------------------------------------------

MySQLParser::RequireListContext::RequireListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RequireListElementContext *> MySQLParser::RequireListContext::requireListElement() {
  return getRuleContexts<MySQLParser::RequireListElementContext>();
}

MySQLParser::RequireListElementContext* MySQLParser::RequireListContext::requireListElement(size_t i) {
  return getRuleContext<MySQLParser::RequireListElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RequireListContext::AND_SYMBOL() {
  return getTokens(MySQLParser::AND_SYMBOL);
}

tree::TerminalNode* MySQLParser::RequireListContext::AND_SYMBOL(size_t i) {
  return getToken(MySQLParser::AND_SYMBOL, i);
}


size_t MySQLParser::RequireListContext::getRuleIndex() const {
  return MySQLParser::RuleRequireList;
}

void MySQLParser::RequireListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireList(this);
}

void MySQLParser::RequireListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireList(this);
}

MySQLParser::RequireListContext* MySQLParser::requireList() {
  RequireListContext *_localctx = _tracker.createInstance<RequireListContext>(_ctx, getState());
  enterRule(_localctx, 544, MySQLParser::RuleRequireList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4582);
    requireListElement();
    setState(4589);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 552, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4584);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::AND_SYMBOL) {
          setState(4583);
          match(MySQLParser::AND_SYMBOL);
        }
        setState(4586);
        requireListElement(); 
      }
      setState(4591);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 552, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RequireListElementContext ------------------------------------------------------------------

MySQLParser::RequireListElementContext::RequireListElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringContext* MySQLParser::RequireListElementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::RequireListElementContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireListElementContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RequireListElementContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}


size_t MySQLParser::RequireListElementContext::getRuleIndex() const {
  return MySQLParser::RuleRequireListElement;
}

void MySQLParser::RequireListElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRequireListElement(this);
}

void MySQLParser::RequireListElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRequireListElement(this);
}

MySQLParser::RequireListElementContext* MySQLParser::requireListElement() {
  RequireListElementContext *_localctx = _tracker.createInstance<RequireListElementContext>(_ctx, getState());
  enterRule(_localctx, 546, MySQLParser::RuleRequireListElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4598);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CIPHER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4592);
        dynamic_cast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::CIPHER_SYMBOL);
        setState(4593);
        textString();
        break;
      }

      case MySQLParser::ISSUER_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4594);
        dynamic_cast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::ISSUER_SYMBOL);
        setState(4595);
        textString();
        break;
      }

      case MySQLParser::SUBJECT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4596);
        dynamic_cast<RequireListElementContext *>(_localctx)->element = match(MySQLParser::SUBJECT_SYMBOL);
        setState(4597);
        textString();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GrantOptionContext ------------------------------------------------------------------

MySQLParser::GrantOptionContext::GrantOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GrantOptionContext::OPTION_SYMBOL() {
  return getToken(MySQLParser::OPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::GRANT_SYMBOL() {
  return getToken(MySQLParser::GRANT_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::GrantOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GrantOptionContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}


size_t MySQLParser::GrantOptionContext::getRuleIndex() const {
  return MySQLParser::RuleGrantOption;
}

void MySQLParser::GrantOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGrantOption(this);
}

void MySQLParser::GrantOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGrantOption(this);
}

MySQLParser::GrantOptionContext* MySQLParser::grantOption() {
  GrantOptionContext *_localctx = _tracker.createInstance<GrantOptionContext>(_ctx, getState());
  enterRule(_localctx, 548, MySQLParser::RuleGrantOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4610);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::GRANT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4600);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::GRANT_SYMBOL);
        setState(4601);
        match(MySQLParser::OPTION_SYMBOL);
        break;
      }

      case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4602);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL);
        setState(4603);
        ulong_number();
        break;
      }

      case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4604);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL);
        setState(4605);
        ulong_number();
        break;
      }

      case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4606);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL);
        setState(4607);
        ulong_number();
        break;
      }

      case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(4608);
        dynamic_cast<GrantOptionContext *>(_localctx)->option = match(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL);
        setState(4609);
        ulong_number();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetRoleContext ------------------------------------------------------------------

MySQLParser::SetRoleContext::SetRoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetRoleContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

std::vector<MySQLParser::RoleListContext *> MySQLParser::SetRoleContext::roleList() {
  return getRuleContexts<MySQLParser::RoleListContext>();
}

MySQLParser::RoleListContext* MySQLParser::SetRoleContext::roleList(size_t i) {
  return getRuleContext<MySQLParser::RoleListContext>(i);
}

tree::TerminalNode* MySQLParser::SetRoleContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::TO_SYMBOL() {
  return getToken(MySQLParser::TO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetRoleContext::EXCEPT_SYMBOL() {
  return getToken(MySQLParser::EXCEPT_SYMBOL, 0);
}


size_t MySQLParser::SetRoleContext::getRuleIndex() const {
  return MySQLParser::RuleSetRole;
}

void MySQLParser::SetRoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetRole(this);
}

void MySQLParser::SetRoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetRole(this);
}

MySQLParser::SetRoleContext* MySQLParser::setRole() {
  SetRoleContext *_localctx = _tracker.createInstance<SetRoleContext>(_ctx, getState());
  enterRule(_localctx, 550, MySQLParser::RuleSetRole);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4635);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 557, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4612);
      match(MySQLParser::SET_SYMBOL);
      setState(4613);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4614);
      roleList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4615);
      match(MySQLParser::SET_SYMBOL);
      setState(4616);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4617);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::NONE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4618);
      match(MySQLParser::SET_SYMBOL);
      setState(4619);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(4620);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4624);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 555, _ctx)) {
      case 1: {
        setState(4621);
        roleList();
        break;
      }

      case 2: {
        setState(4622);
        match(MySQLParser::NONE_SYMBOL);
        break;
      }

      case 3: {
        setState(4623);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      }
      setState(4626);
      match(MySQLParser::TO_SYMBOL);
      setState(4627);
      roleList();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4628);
      match(MySQLParser::SET_SYMBOL);
      setState(4629);
      match(MySQLParser::ROLE_SYMBOL);
      setState(4630);
      match(MySQLParser::ALL_SYMBOL);
      setState(4633);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EXCEPT_SYMBOL) {
        setState(4631);
        match(MySQLParser::EXCEPT_SYMBOL);
        setState(4632);
        roleList();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleListContext ------------------------------------------------------------------

MySQLParser::RoleListContext::RoleListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::RoleContext *> MySQLParser::RoleListContext::role() {
  return getRuleContexts<MySQLParser::RoleContext>();
}

MySQLParser::RoleContext* MySQLParser::RoleListContext::role(size_t i) {
  return getRuleContext<MySQLParser::RoleContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RoleListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RoleListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::RoleListContext::getRuleIndex() const {
  return MySQLParser::RuleRoleList;
}

void MySQLParser::RoleListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleList(this);
}

void MySQLParser::RoleListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleList(this);
}

MySQLParser::RoleListContext* MySQLParser::roleList() {
  RoleListContext *_localctx = _tracker.createInstance<RoleListContext>(_ctx, getState());
  enterRule(_localctx, 552, MySQLParser::RuleRoleList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(4637);
    role();
    setState(4642);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 558, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(4638);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4639);
        role(); 
      }
      setState(4644);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 558, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleContext ------------------------------------------------------------------

MySQLParser::RoleContext::RoleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierOrTextContext* MySQLParser::RoleContext::roleIdentifierOrText() {
  return getRuleContext<MySQLParser::RoleIdentifierOrTextContext>(0);
}

tree::TerminalNode* MySQLParser::RoleContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::RoleContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::RoleContext::getRuleIndex() const {
  return MySQLParser::RuleRole;
}

void MySQLParser::RoleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRole(this);
}

void MySQLParser::RoleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRole(this);
}

MySQLParser::RoleContext* MySQLParser::role() {
  RoleContext *_localctx = _tracker.createInstance<RoleContext>(_ctx, getState());
  enterRule(_localctx, 554, MySQLParser::RuleRole);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4645);
    roleIdentifierOrText();
    setState(4648);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 559, _ctx)) {
    case 1: {
      setState(4646);
      match(MySQLParser::AT_SIGN_SYMBOL);
      setState(4647);
      textOrIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAdministrationStatementContext ------------------------------------------------------------------

MySQLParser::TableAdministrationStatementContext::TableAdministrationStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

MySQLParser::TableRefListContext* MySQLParser::TableAdministrationStatementContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::ANALYZE_SYMBOL() {
  return getToken(MySQLParser::ANALYZE_SYMBOL, 0);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::TableAdministrationStatementContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

std::vector<MySQLParser::CheckOptionContext *> MySQLParser::TableAdministrationStatementContext::checkOption() {
  return getRuleContexts<MySQLParser::CheckOptionContext>();
}

MySQLParser::CheckOptionContext* MySQLParser::TableAdministrationStatementContext::checkOption(size_t i) {
  return getRuleContext<MySQLParser::CheckOptionContext>(i);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::OPTIMIZE_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZE_SYMBOL, 0);
}

MySQLParser::HistogramContext* MySQLParser::TableAdministrationStatementContext::histogram() {
  return getRuleContext<MySQLParser::HistogramContext>(0);
}

tree::TerminalNode* MySQLParser::TableAdministrationStatementContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

std::vector<MySQLParser::RepairTypeContext *> MySQLParser::TableAdministrationStatementContext::repairType() {
  return getRuleContexts<MySQLParser::RepairTypeContext>();
}

MySQLParser::RepairTypeContext* MySQLParser::TableAdministrationStatementContext::repairType(size_t i) {
  return getRuleContext<MySQLParser::RepairTypeContext>(i);
}


size_t MySQLParser::TableAdministrationStatementContext::getRuleIndex() const {
  return MySQLParser::RuleTableAdministrationStatement;
}

void MySQLParser::TableAdministrationStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAdministrationStatement(this);
}

void MySQLParser::TableAdministrationStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAdministrationStatement(this);
}

MySQLParser::TableAdministrationStatementContext* MySQLParser::tableAdministrationStatement() {
  TableAdministrationStatementContext *_localctx = _tracker.createInstance<TableAdministrationStatementContext>(_ctx, getState());
  enterRule(_localctx, 556, MySQLParser::RuleTableAdministrationStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4693);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ANALYZE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4650);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::ANALYZE_SYMBOL);
        setState(4652);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(4651);
          noWriteToBinLog();
        }
        setState(4654);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4655);
        tableRefList();
        break;
      }

      case MySQLParser::CHECK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4656);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::CHECK_SYMBOL);
        setState(4657);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4658);
        tableRefList();
        setState(4662);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::CHANGED_SYMBOL || ((((_la - 222) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 222)) & ((1ULL << (MySQLParser::EXTENDED_SYMBOL - 222))
          | (1ULL << (MySQLParser::FAST_SYMBOL - 222))
          | (1ULL << (MySQLParser::FOR_SYMBOL - 222)))) != 0) || _la == MySQLParser::MEDIUM_SYMBOL || _la == MySQLParser::QUICK_SYMBOL) {
          setState(4659);
          checkOption();
          setState(4664);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      case MySQLParser::CHECKSUM_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(4665);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::CHECKSUM_SYMBOL);
        setState(4666);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4667);
        tableRefList();
        setState(4669);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL) {
          setState(4668);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        break;
      }

      case MySQLParser::OPTIMIZE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(4671);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::OPTIMIZE_SYMBOL);
        setState(4673);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(4672);
          noWriteToBinLog();
        }
        setState(4675);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4676);
        tableRefList();
        setState(4679);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 564, _ctx)) {
        case 1: {
          setState(4677);

          if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
          setState(4678);
          histogram();
          break;
        }

        }
        break;
      }

      case MySQLParser::REPAIR_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(4681);
        dynamic_cast<TableAdministrationStatementContext *>(_localctx)->type = match(MySQLParser::REPAIR_SYMBOL);
        setState(4683);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL) {
          setState(4682);
          noWriteToBinLog();
        }
        setState(4685);
        match(MySQLParser::TABLE_SYMBOL);
        setState(4686);
        tableRefList();
        setState(4690);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::USE_FRM_SYMBOL) {
          setState(4687);
          repairType();
          setState(4692);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HistogramContext ------------------------------------------------------------------

MySQLParser::HistogramContext::HistogramContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HistogramContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::HistogramContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::HistogramContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HistogramContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}


size_t MySQLParser::HistogramContext::getRuleIndex() const {
  return MySQLParser::RuleHistogram;
}

void MySQLParser::HistogramContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHistogram(this);
}

void MySQLParser::HistogramContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHistogram(this);
}

MySQLParser::HistogramContext* MySQLParser::histogram() {
  HistogramContext *_localctx = _tracker.createInstance<HistogramContext>(_ctx, getState());
  enterRule(_localctx, 558, MySQLParser::RuleHistogram);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4708);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UPDATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4695);
        match(MySQLParser::UPDATE_SYMBOL);
        setState(4696);
        match(MySQLParser::HISTOGRAM_SYMBOL);
        setState(4697);
        match(MySQLParser::ON_SYMBOL);
        setState(4698);
        identifierList();
        setState(4702);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL) {
          setState(4699);
          match(MySQLParser::WITH_SYMBOL);
          setState(4700);
          match(MySQLParser::INT_NUMBER);
          setState(4701);
          match(MySQLParser::BUCKETS_SYMBOL);
        }
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4704);
        match(MySQLParser::DROP_SYMBOL);
        setState(4705);
        match(MySQLParser::HISTOGRAM_SYMBOL);
        setState(4706);
        match(MySQLParser::ON_SYMBOL);
        setState(4707);
        identifierList();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckOptionContext ------------------------------------------------------------------

MySQLParser::CheckOptionContext::CheckOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CheckOptionContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CheckOptionContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}


size_t MySQLParser::CheckOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCheckOption;
}

void MySQLParser::CheckOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckOption(this);
}

void MySQLParser::CheckOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckOption(this);
}

MySQLParser::CheckOptionContext* MySQLParser::checkOption() {
  CheckOptionContext *_localctx = _tracker.createInstance<CheckOptionContext>(_ctx, getState());
  enterRule(_localctx, 560, MySQLParser::RuleCheckOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4713);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::FOR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(4710);
        match(MySQLParser::FOR_SYMBOL);
        setState(4711);
        match(MySQLParser::UPGRADE_SYMBOL);
        break;
      }

      case MySQLParser::CHANGED_SYMBOL:
      case MySQLParser::EXTENDED_SYMBOL:
      case MySQLParser::FAST_SYMBOL:
      case MySQLParser::MEDIUM_SYMBOL:
      case MySQLParser::QUICK_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(4712);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CHANGED_SYMBOL || _la == MySQLParser::EXTENDED_SYMBOL

        || _la == MySQLParser::FAST_SYMBOL || _la == MySQLParser::MEDIUM_SYMBOL || _la == MySQLParser::QUICK_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepairTypeContext ------------------------------------------------------------------

MySQLParser::RepairTypeContext::RepairTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RepairTypeContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RepairTypeContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RepairTypeContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}


size_t MySQLParser::RepairTypeContext::getRuleIndex() const {
  return MySQLParser::RuleRepairType;
}

void MySQLParser::RepairTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepairType(this);
}

void MySQLParser::RepairTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepairType(this);
}

MySQLParser::RepairTypeContext* MySQLParser::repairType() {
  RepairTypeContext *_localctx = _tracker.createInstance<RepairTypeContext>(_ctx, getState());
  enterRule(_localctx, 562, MySQLParser::RuleRepairType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4715);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EXTENDED_SYMBOL || _la == MySQLParser::QUICK_SYMBOL || _la == MySQLParser::USE_FRM_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InstallUninstallStatmentContext ------------------------------------------------------------------

MySQLParser::InstallUninstallStatmentContext::InstallUninstallStatmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::InstallUninstallStatmentContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::InstallUninstallStatmentContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

MySQLParser::TextStringLiteralListContext* MySQLParser::InstallUninstallStatmentContext::textStringLiteralList() {
  return getRuleContext<MySQLParser::TextStringLiteralListContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

MySQLParser::PluginRefContext* MySQLParser::InstallUninstallStatmentContext::pluginRef() {
  return getRuleContext<MySQLParser::PluginRefContext>(0);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

std::vector<MySQLParser::ComponentRefContext *> MySQLParser::InstallUninstallStatmentContext::componentRef() {
  return getRuleContexts<MySQLParser::ComponentRefContext>();
}

MySQLParser::ComponentRefContext* MySQLParser::InstallUninstallStatmentContext::componentRef(size_t i) {
  return getRuleContext<MySQLParser::ComponentRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::InstallUninstallStatmentContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::InstallUninstallStatmentContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::InstallUninstallStatmentContext::getRuleIndex() const {
  return MySQLParser::RuleInstallUninstallStatment;
}

void MySQLParser::InstallUninstallStatmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInstallUninstallStatment(this);
}

void MySQLParser::InstallUninstallStatmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInstallUninstallStatment(this);
}

MySQLParser::InstallUninstallStatmentContext* MySQLParser::installUninstallStatment() {
  InstallUninstallStatmentContext *_localctx = _tracker.createInstance<InstallUninstallStatmentContext>(_ctx, getState());
  enterRule(_localctx, 564, MySQLParser::RuleInstallUninstallStatment);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4739);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 572, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4717);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::INSTALL_SYMBOL);
      setState(4718);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::PLUGIN_SYMBOL);
      setState(4719);
      identifier();
      setState(4720);
      match(MySQLParser::SONAME_SYMBOL);
      setState(4721);
      textStringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4723);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::INSTALL_SYMBOL);
      setState(4724);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::COMPONENT_SYMBOL);
      setState(4725);
      textStringLiteralList();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4726);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::UNINSTALL_SYMBOL);
      setState(4727);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::PLUGIN_SYMBOL);
      setState(4728);
      pluginRef();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4729);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->action = match(MySQLParser::UNINSTALL_SYMBOL);
      setState(4730);
      dynamic_cast<InstallUninstallStatmentContext *>(_localctx)->type = match(MySQLParser::COMPONENT_SYMBOL);
      setState(4731);
      componentRef();
      setState(4736);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(4732);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4733);
        componentRef();
        setState(4738);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetStatementContext ------------------------------------------------------------------

MySQLParser::SetStatementContext::SetStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::OptionValueNoOptionTypeContext* MySQLParser::SetStatementContext::optionValueNoOptionType() {
  return getRuleContext<MySQLParser::OptionValueNoOptionTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SetStatementContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

MySQLParser::SetTransactionCharacteristicContext* MySQLParser::SetStatementContext::setTransactionCharacteristic() {
  return getRuleContext<MySQLParser::SetTransactionCharacteristicContext>(0);
}

MySQLParser::OptionValueFollowingOptionTypeContext* MySQLParser::SetStatementContext::optionValueFollowingOptionType() {
  return getRuleContext<MySQLParser::OptionValueFollowingOptionTypeContext>(0);
}

MySQLParser::OptionTypeContext* MySQLParser::SetStatementContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SetStatementContext::ONE_SHOT_SYMBOL() {
  return getToken(MySQLParser::ONE_SHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetStatementContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::OptionValueListContext* MySQLParser::SetStatementContext::optionValueList() {
  return getRuleContext<MySQLParser::OptionValueListContext>(0);
}


size_t MySQLParser::SetStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSetStatement;
}

void MySQLParser::SetStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetStatement(this);
}

void MySQLParser::SetStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetStatement(this);
}

MySQLParser::SetStatementContext* MySQLParser::setStatement() {
  SetStatementContext *_localctx = _tracker.createInstance<SetStatementContext>(_ctx, getState());
  enterRule(_localctx, 566, MySQLParser::RuleSetStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4741);
    match(MySQLParser::SET_SYMBOL);
    setState(4762);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 578, _ctx)) {
    case 1: {
      setState(4743);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 573, _ctx)) {
      case 1: {
        setState(4742);
        optionType();
        break;
      }

      }
      setState(4752);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 575, _ctx)) {
      case 1: {
        setState(4745);
        match(MySQLParser::TRANSACTION_SYMBOL);
        setState(4746);
        setTransactionCharacteristic();
        break;
      }

      case 2: {
        setState(4747);
        optionValueFollowingOptionType();
        setState(4750);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(4748);
          match(MySQLParser::COMMA_SYMBOL);
          setState(4749);
          optionValueList();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      setState(4755);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 576, _ctx)) {
      case 1: {
        setState(4754);
        match(MySQLParser::ONE_SHOT_SYMBOL);
        break;
      }

      }
      setState(4757);
      optionValueNoOptionType();
      setState(4760);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(4758);
        match(MySQLParser::COMMA_SYMBOL);
        setState(4759);
        optionValueList();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueNoOptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionValueNoOptionTypeContext::OptionValueNoOptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InternalVariableNameContext* MySQLParser::OptionValueNoOptionTypeContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::EqualContext* MySQLParser::OptionValueNoOptionTypeContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::OptionValueNoOptionTypeContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}

MySQLParser::CharsetClauseContext* MySQLParser::OptionValueNoOptionTypeContext::charsetClause() {
  return getRuleContext<MySQLParser::CharsetClauseContext>(0);
}

MySQLParser::UserVariableContext* MySQLParser::OptionValueNoOptionTypeContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

MySQLParser::ExprContext* MySQLParser::OptionValueNoOptionTypeContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SetSystemVariableContext* MySQLParser::OptionValueNoOptionTypeContext::setSystemVariable() {
  return getRuleContext<MySQLParser::SetSystemVariableContext>(0);
}

tree::TerminalNode* MySQLParser::OptionValueNoOptionTypeContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

MySQLParser::CharsetNameContext* MySQLParser::OptionValueNoOptionTypeContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::OptionValueNoOptionTypeContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::CollateContext* MySQLParser::OptionValueNoOptionTypeContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}


size_t MySQLParser::OptionValueNoOptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueNoOptionType;
}

void MySQLParser::OptionValueNoOptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueNoOptionType(this);
}

void MySQLParser::OptionValueNoOptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueNoOptionType(this);
}

MySQLParser::OptionValueNoOptionTypeContext* MySQLParser::optionValueNoOptionType() {
  OptionValueNoOptionTypeContext *_localctx = _tracker.createInstance<OptionValueNoOptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 568, MySQLParser::RuleOptionValueNoOptionType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4789);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 581, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4764);
      internalVariableName();
      setState(4765);
      equal();
      setState(4766);
      setExprOrDefault();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4768);
      charsetClause();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4769);
      userVariable();
      setState(4770);
      equal();
      setState(4771);
      expr(0);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(4773);
      setSystemVariable();
      setState(4774);
      equal();
      setState(4775);
      setExprOrDefault();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(4777);
      match(MySQLParser::NAMES_SYMBOL);
      setState(4787);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 580, _ctx)) {
      case 1: {
        setState(4778);
        equal();
        setState(4779);
        expr(0);
        break;
      }

      case 2: {
        setState(4781);
        charsetName();
        setState(4783);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COLLATE_SYMBOL) {
          setState(4782);
          collate();
        }
        break;
      }

      case 3: {
        setState(4785);

        if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
        setState(4786);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetSystemVariableContext ------------------------------------------------------------------

MySQLParser::SetSystemVariableContext::SetSystemVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetSystemVariableContext::AT_AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, 0);
}

MySQLParser::InternalVariableNameContext* MySQLParser::SetSystemVariableContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::SetVarIdentTypeContext* MySQLParser::SetSystemVariableContext::setVarIdentType() {
  return getRuleContext<MySQLParser::SetVarIdentTypeContext>(0);
}


size_t MySQLParser::SetSystemVariableContext::getRuleIndex() const {
  return MySQLParser::RuleSetSystemVariable;
}

void MySQLParser::SetSystemVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetSystemVariable(this);
}

void MySQLParser::SetSystemVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetSystemVariable(this);
}

MySQLParser::SetSystemVariableContext* MySQLParser::setSystemVariable() {
  SetSystemVariableContext *_localctx = _tracker.createInstance<SetSystemVariableContext>(_ctx, getState());
  enterRule(_localctx, 570, MySQLParser::RuleSetSystemVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4791);
    match(MySQLParser::AT_AT_SIGN_SYMBOL);
    setState(4793);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 582, _ctx)) {
    case 1: {
      setState(4792);
      setVarIdentType();
      break;
    }

    }
    setState(4795);
    internalVariableName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueFollowingOptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionValueFollowingOptionTypeContext::OptionValueFollowingOptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::InternalVariableNameContext* MySQLParser::OptionValueFollowingOptionTypeContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::EqualContext* MySQLParser::OptionValueFollowingOptionTypeContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::OptionValueFollowingOptionTypeContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}


size_t MySQLParser::OptionValueFollowingOptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueFollowingOptionType;
}

void MySQLParser::OptionValueFollowingOptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueFollowingOptionType(this);
}

void MySQLParser::OptionValueFollowingOptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueFollowingOptionType(this);
}

MySQLParser::OptionValueFollowingOptionTypeContext* MySQLParser::optionValueFollowingOptionType() {
  OptionValueFollowingOptionTypeContext *_localctx = _tracker.createInstance<OptionValueFollowingOptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 572, MySQLParser::RuleOptionValueFollowingOptionType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4797);
    internalVariableName();
    setState(4798);
    equal();
    setState(4799);
    setExprOrDefault();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetExprOrDefaultContext ------------------------------------------------------------------

MySQLParser::SetExprOrDefaultContext::SetExprOrDefaultContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::SetExprOrDefaultContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetExprOrDefaultContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}


size_t MySQLParser::SetExprOrDefaultContext::getRuleIndex() const {
  return MySQLParser::RuleSetExprOrDefault;
}

void MySQLParser::SetExprOrDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetExprOrDefault(this);
}

void MySQLParser::SetExprOrDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetExprOrDefault(this);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::setExprOrDefault() {
  SetExprOrDefaultContext *_localctx = _tracker.createInstance<SetExprOrDefaultContext>(_ctx, getState());
  enterRule(_localctx, 574, MySQLParser::RuleSetExprOrDefault);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4805);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 583, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4801);
      expr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4802);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ALL_SYMBOL

      || _la == MySQLParser::BINARY_SYMBOL || _la == MySQLParser::DEFAULT_SYMBOL || _la == MySQLParser::ON_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(4803);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(4804);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ROW_SYMBOL || _la == MySQLParser::SYSTEM_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueListContext ------------------------------------------------------------------

MySQLParser::OptionValueListContext::OptionValueListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::OptionValueContext *> MySQLParser::OptionValueListContext::optionValue() {
  return getRuleContexts<MySQLParser::OptionValueContext>();
}

MySQLParser::OptionValueContext* MySQLParser::OptionValueListContext::optionValue(size_t i) {
  return getRuleContext<MySQLParser::OptionValueContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::OptionValueListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::OptionValueListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::OptionValueListContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValueList;
}

void MySQLParser::OptionValueListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValueList(this);
}

void MySQLParser::OptionValueListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValueList(this);
}

MySQLParser::OptionValueListContext* MySQLParser::optionValueList() {
  OptionValueListContext *_localctx = _tracker.createInstance<OptionValueListContext>(_ctx, getState());
  enterRule(_localctx, 576, MySQLParser::RuleOptionValueList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4807);
    optionValue();
    setState(4812);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(4808);
      match(MySQLParser::COMMA_SYMBOL);
      setState(4809);
      optionValue();
      setState(4814);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionValueContext ------------------------------------------------------------------

MySQLParser::OptionValueContext::OptionValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::OptionTypeContext* MySQLParser::OptionValueContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

MySQLParser::InternalVariableNameContext* MySQLParser::OptionValueContext::internalVariableName() {
  return getRuleContext<MySQLParser::InternalVariableNameContext>(0);
}

MySQLParser::EqualContext* MySQLParser::OptionValueContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::SetExprOrDefaultContext* MySQLParser::OptionValueContext::setExprOrDefault() {
  return getRuleContext<MySQLParser::SetExprOrDefaultContext>(0);
}

MySQLParser::OptionValueNoOptionTypeContext* MySQLParser::OptionValueContext::optionValueNoOptionType() {
  return getRuleContext<MySQLParser::OptionValueNoOptionTypeContext>(0);
}


size_t MySQLParser::OptionValueContext::getRuleIndex() const {
  return MySQLParser::RuleOptionValue;
}

void MySQLParser::OptionValueContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionValue(this);
}

void MySQLParser::OptionValueContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionValue(this);
}

MySQLParser::OptionValueContext* MySQLParser::optionValue() {
  OptionValueContext *_localctx = _tracker.createInstance<OptionValueContext>(_ctx, getState());
  enterRule(_localctx, 578, MySQLParser::RuleOptionValue);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(4821);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 585, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(4815);
      optionType();
      setState(4816);
      internalVariableName();
      setState(4817);
      equal();
      setState(4818);
      setExprOrDefault();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(4820);
      optionValueNoOptionType();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowStatementContext ------------------------------------------------------------------

MySQLParser::ShowStatementContext::ShowStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ShowStatementContext::SHOW_SYMBOL() {
  return getToken(MySQLParser::SHOW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ShowStatementContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

MySQLParser::FromOrInContext* MySQLParser::ShowStatementContext::fromOrIn() {
  return getRuleContext<MySQLParser::FromOrInContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COUNT_SYMBOL() {
  return getToken(MySQLParser::COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CharsetContext* MySQLParser::ShowStatementContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::UserContext* MySQLParser::ShowStatementContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::UserListContext* MySQLParser::ShowStatementContext::userList() {
  return getRuleContext<MySQLParser::UserListContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

MySQLParser::ProcedureRefContext* MySQLParser::ShowStatementContext::procedureRef() {
  return getRuleContext<MySQLParser::ProcedureRefContext>(0);
}

MySQLParser::FunctionRefContext* MySQLParser::ShowStatementContext::functionRef() {
  return getRuleContext<MySQLParser::FunctionRefContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::AUTHORS_SYMBOL() {
  return getToken(MySQLParser::AUTHORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::DATABASES_SYMBOL() {
  return getToken(MySQLParser::DATABASES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CONTRIBUTORS_SYMBOL() {
  return getToken(MySQLParser::CONTRIBUTORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::PROCEDURE_SYMBOL() {
  return getToken(MySQLParser::PROCEDURE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

MySQLParser::EngineRefContext* MySQLParser::ShowStatementContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

MySQLParser::NonBlockingContext* MySQLParser::ShowStatementContext::nonBlocking() {
  return getRuleContext<MySQLParser::NonBlockingContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::KEYS_SYMBOL() {
  return getToken(MySQLParser::KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

MySQLParser::SchemaRefContext* MySQLParser::ShowStatementContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::EventRefContext* MySQLParser::ShowStatementContext::eventRef() {
  return getRuleContext<MySQLParser::EventRefContext>(0);
}

MySQLParser::TriggerRefContext* MySQLParser::ShowStatementContext::triggerRef() {
  return getRuleContext<MySQLParser::TriggerRefContext>(0);
}

MySQLParser::ViewRefContext* MySQLParser::ShowStatementContext::viewRef() {
  return getRuleContext<MySQLParser::ViewRefContext>(0);
}

MySQLParser::LikeOrWhereContext* MySQLParser::ShowStatementContext::likeOrWhere() {
  return getRuleContext<MySQLParser::LikeOrWhereContext>(0);
}

MySQLParser::ShowCommandTypeContext* MySQLParser::ShowStatementContext::showCommandType() {
  return getRuleContext<MySQLParser::ShowCommandTypeContext>(0);
}

MySQLParser::InDbContext* MySQLParser::ShowStatementContext::inDb() {
  return getRuleContext<MySQLParser::InDbContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::ShowStatementContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::ShowStatementContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

MySQLParser::LimitClauseContext* MySQLParser::ShowStatementContext::limitClause() {
  return getRuleContext<MySQLParser::LimitClauseContext>(0);
}

MySQLParser::ChannelContext* MySQLParser::ShowStatementContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

MySQLParser::WhereClauseContext* MySQLParser::ShowStatementContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

std::vector<MySQLParser::ProfileTypeContext *> MySQLParser::ShowStatementContext::profileType() {
  return getRuleContexts<MySQLParser::ProfileTypeContext>();
}

MySQLParser::ProfileTypeContext* MySQLParser::ShowStatementContext::profileType(size_t i) {
  return getRuleContext<MySQLParser::ProfileTypeContext>(i);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::OptionTypeContext* MySQLParser::ShowStatementContext::optionType() {
  return getRuleContext<MySQLParser::OptionTypeContext>(0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::TRIGGER_SYMBOL() {
  return getToken(MySQLParser::TRIGGER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

MySQLParser::IfNotExistsContext* MySQLParser::ShowStatementContext::ifNotExists() {
  return getRuleContext<MySQLParser::IfNotExistsContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::ShowStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ShowStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ShowStatementContext::getRuleIndex() const {
  return MySQLParser::RuleShowStatement;
}

void MySQLParser::ShowStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowStatement(this);
}

void MySQLParser::ShowStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowStatement(this);
}

MySQLParser::ShowStatementContext* MySQLParser::showStatement() {
  ShowStatementContext *_localctx = _tracker.createInstance<ShowStatementContext>(_ctx, getState());
  enterRule(_localctx, 580, MySQLParser::RuleShowStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(4823);
    match(MySQLParser::SHOW_SYMBOL);
    setState(5043);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 629, _ctx)) {
    case 1: {
      setState(4824);

      if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
      setState(4825);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::AUTHORS_SYMBOL);
      break;
    }

    case 2: {
      setState(4826);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::DATABASES_SYMBOL);
      setState(4828);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4827);
        likeOrWhere();
      }
      break;
    }

    case 3: {
      setState(4831);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 587, _ctx)) {
      case 1: {
        setState(4830);
        showCommandType();
        break;
      }

      }
      setState(4833);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::TABLES_SYMBOL);
      setState(4835);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4834);
        inDb();
      }
      setState(4838);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4837);
        likeOrWhere();
      }
      break;
    }

    case 4: {
      setState(4841);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FULL_SYMBOL) {
        setState(4840);
        match(MySQLParser::FULL_SYMBOL);
      }
      setState(4843);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::TRIGGERS_SYMBOL);
      setState(4845);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4844);
        inDb();
      }
      setState(4848);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4847);
        likeOrWhere();
      }
      break;
    }

    case 5: {
      setState(4850);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::EVENTS_SYMBOL);
      setState(4852);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4851);
        inDb();
      }
      setState(4855);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4854);
        likeOrWhere();
      }
      break;
    }

    case 6: {
      setState(4857);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::TABLE_SYMBOL);
      setState(4858);
      match(MySQLParser::STATUS_SYMBOL);
      setState(4860);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4859);
        inDb();
      }
      setState(4863);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4862);
        likeOrWhere();
      }
      break;
    }

    case 7: {
      setState(4865);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::OPEN_SYMBOL);
      setState(4866);
      match(MySQLParser::TABLES_SYMBOL);
      setState(4868);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4867);
        inDb();
      }
      setState(4871);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4870);
        likeOrWhere();
      }
      break;
    }

    case 8: {
      setState(4873);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PLUGINS_SYMBOL);
      break;
    }

    case 9: {
      setState(4874);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::ENGINE_SYMBOL);
      setState(4877);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 599, _ctx)) {
      case 1: {
        setState(4875);
        engineRef();
        break;
      }

      case 2: {
        setState(4876);
        match(MySQLParser::ALL_SYMBOL);
        break;
      }

      }
      setState(4879);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LOGS_SYMBOL || _la == MySQLParser::MUTEX_SYMBOL || _la == MySQLParser::STATUS_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 10: {
      setState(4881);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 600, _ctx)) {
      case 1: {
        setState(4880);
        showCommandType();
        break;
      }

      }
      setState(4883);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::COLUMNS_SYMBOL);
      setState(4884);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4885);
      tableRef();
      setState(4887);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4886);
        inDb();
      }
      setState(4890);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4889);
        likeOrWhere();
      }
      break;
    }

    case 11: {
      setState(4892);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BINARY_SYMBOL || _la == MySQLParser::MASTER_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4893);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::LOGS_SYMBOL);
      break;
    }

    case 12: {
      setState(4894);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::SLAVE_SYMBOL);
      setState(4901);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::HOSTS_SYMBOL: {
          setState(4895);
          match(MySQLParser::HOSTS_SYMBOL);
          break;
        }

        case MySQLParser::STATUS_SYMBOL: {
          setState(4896);
          match(MySQLParser::STATUS_SYMBOL);
          setState(4897);
          nonBlocking();
          setState(4899);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 603, _ctx)) {
          case 1: {
            setState(4898);
            channel();
            break;
          }

          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 13: {
      setState(4903);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BINLOG_SYMBOL || _la == MySQLParser::RELAYLOG_SYMBOL)) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4904);
      match(MySQLParser::EVENTS_SYMBOL);
      setState(4907);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 605, _ctx)) {
      case 1: {
        setState(4905);
        match(MySQLParser::IN_SYMBOL);
        setState(4906);
        textString();
        break;
      }

      }
      setState(4911);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 606, _ctx)) {
      case 1: {
        setState(4909);
        match(MySQLParser::FROM_SYMBOL);
        setState(4910);
        ulonglong_number();
        break;
      }

      }
      setState(4914);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 607, _ctx)) {
      case 1: {
        setState(4913);
        limitClause();
        break;
      }

      }
      setState(4917);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 608, _ctx)) {
      case 1: {
        setState(4916);
        channel();
        break;
      }

      }
      break;
    }

    case 14: {
      setState(4921);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 609, _ctx)) {
      case 1: {
        setState(4919);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(4920);
        match(MySQLParser::EXTENDED_SYMBOL);
        break;
      }

      }
      setState(4923);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 274) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 274)) & ((1ULL << (MySQLParser::INDEXES_SYMBOL - 274))
        | (1ULL << (MySQLParser::INDEX_SYMBOL - 274))
        | (1ULL << (MySQLParser::KEYS_SYMBOL - 274)))) != 0))) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4924);
      fromOrIn();
      setState(4925);
      tableRef();
      setState(4927);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL

      || _la == MySQLParser::IN_SYMBOL) {
        setState(4926);
        inDb();
      }
      setState(4930);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WHERE_SYMBOL) {
        setState(4929);
        whereClause();
      }
      break;
    }

    case 15: {
      setState(4933);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::STORAGE_SYMBOL) {
        setState(4932);
        match(MySQLParser::STORAGE_SYMBOL);
      }
      setState(4935);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::ENGINES_SYMBOL);
      break;
    }

    case 16: {
      setState(4936);
      match(MySQLParser::COUNT_SYMBOL);
      setState(4937);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(4938);
      match(MySQLParser::MULT_OPERATOR);
      setState(4939);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(4940);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ERRORS_SYMBOL || _la == MySQLParser::WARNINGS_SYMBOL)) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 17: {
      setState(4941);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::WARNINGS_SYMBOL);
      setState(4943);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIMIT_SYMBOL) {
        setState(4942);
        limitClause();
      }
      break;
    }

    case 18: {
      setState(4945);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::ERRORS_SYMBOL);
      setState(4947);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIMIT_SYMBOL) {
        setState(4946);
        limitClause();
      }
      break;
    }

    case 19: {
      setState(4949);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROFILES_SYMBOL);
      break;
    }

    case 20: {
      setState(4950);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROFILE_SYMBOL);
      setState(4959);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ALL_SYMBOL || ((((_la - 88) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 88)) & ((1ULL << (MySQLParser::BLOCK_SYMBOL - 88))
        | (1ULL << (MySQLParser::CONTEXT_SYMBOL - 88))
        | (1ULL << (MySQLParser::CPU_SYMBOL - 88)))) != 0) || _la == MySQLParser::IPC_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL || _la == MySQLParser::PAGE_SYMBOL || _la == MySQLParser::SOURCE_SYMBOL

      || _la == MySQLParser::SWAPS_SYMBOL) {
        setState(4951);
        profileType();
        setState(4956);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(4952);
          match(MySQLParser::COMMA_SYMBOL);
          setState(4953);
          profileType();
          setState(4958);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
      }
      setState(4964);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL) {
        setState(4961);
        match(MySQLParser::FOR_SYMBOL);
        setState(4962);
        match(MySQLParser::QUERY_SYMBOL);
        setState(4963);
        match(MySQLParser::INT_NUMBER);
      }
      setState(4967);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIMIT_SYMBOL) {
        setState(4966);
        limitClause();
      }
      break;
    }

    case 21: {
      setState(4970);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL || _la == MySQLParser::PERSIST_SYMBOL

      || _la == MySQLParser::PERSIST_ONLY_SYMBOL) {
        setState(4969);
        optionType();
      }
      setState(4972);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::STATUS_SYMBOL || _la == MySQLParser::VARIABLES_SYMBOL)) {
        dynamic_cast<ShowStatementContext *>(_localctx)->value = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(4974);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4973);
        likeOrWhere();
      }
      break;
    }

    case 22: {
      setState(4977);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FULL_SYMBOL) {
        setState(4976);
        match(MySQLParser::FULL_SYMBOL);
      }
      setState(4979);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROCESSLIST_SYMBOL);
      break;
    }

    case 23: {
      setState(4980);
      charset();
      setState(4982);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4981);
        likeOrWhere();
      }
      break;
    }

    case 24: {
      setState(4984);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::COLLATION_SYMBOL);
      setState(4986);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(4985);
        likeOrWhere();
      }
      break;
    }

    case 25: {
      setState(4988);

      if (!(serverVersion < 50700)) throw FailedPredicateException(this, "serverVersion < 50700");
      setState(4989);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::CONTRIBUTORS_SYMBOL);
      break;
    }

    case 26: {
      setState(4990);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PRIVILEGES_SYMBOL);
      break;
    }

    case 27: {
      setState(4991);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::GRANTS_SYMBOL);
      setState(4994);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FOR_SYMBOL) {
        setState(4992);
        match(MySQLParser::FOR_SYMBOL);
        setState(4993);
        user();
      }
      break;
    }

    case 28: {
      setState(4996);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::GRANTS_SYMBOL);
      setState(4997);
      match(MySQLParser::FOR_SYMBOL);
      setState(4998);
      user();
      setState(4999);
      match(MySQLParser::USING_SYMBOL);
      setState(5000);
      userList();
      break;
    }

    case 29: {
      setState(5002);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::MASTER_SYMBOL);
      setState(5003);
      match(MySQLParser::STATUS_SYMBOL);
      break;
    }

    case 30: {
      setState(5004);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::CREATE_SYMBOL);
      setState(5025);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 626, _ctx)) {
      case 1: {
        setState(5005);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::DATABASE_SYMBOL);
        setState(5007);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 625, _ctx)) {
        case 1: {
          setState(5006);
          ifNotExists();
          break;
        }

        }
        setState(5009);
        schemaRef();
        break;
      }

      case 2: {
        setState(5010);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::EVENT_SYMBOL);
        setState(5011);
        eventRef();
        break;
      }

      case 3: {
        setState(5012);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::FUNCTION_SYMBOL);
        setState(5013);
        functionRef();
        break;
      }

      case 4: {
        setState(5014);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::PROCEDURE_SYMBOL);
        setState(5015);
        procedureRef();
        break;
      }

      case 5: {
        setState(5016);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::TABLE_SYMBOL);
        setState(5017);
        tableRef();
        break;
      }

      case 6: {
        setState(5018);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::TRIGGER_SYMBOL);
        setState(5019);
        triggerRef();
        break;
      }

      case 7: {
        setState(5020);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::VIEW_SYMBOL);
        setState(5021);
        viewRef();
        break;
      }

      case 8: {
        setState(5022);

        if (!(serverVersion >= 50704)) throw FailedPredicateException(this, "serverVersion >= 50704");
        setState(5023);
        dynamic_cast<ShowStatementContext *>(_localctx)->object = match(MySQLParser::USER_SYMBOL);
        setState(5024);
        user();
        break;
      }

      }
      break;
    }

    case 31: {
      setState(5027);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROCEDURE_SYMBOL);
      setState(5028);
      match(MySQLParser::STATUS_SYMBOL);
      setState(5030);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(5029);
        likeOrWhere();
      }
      break;
    }

    case 32: {
      setState(5032);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::FUNCTION_SYMBOL);
      setState(5033);
      match(MySQLParser::STATUS_SYMBOL);
      setState(5035);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LIKE_SYMBOL || _la == MySQLParser::WHERE_SYMBOL) {
        setState(5034);
        likeOrWhere();
      }
      break;
    }

    case 33: {
      setState(5037);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::PROCEDURE_SYMBOL);
      setState(5038);
      match(MySQLParser::CODE_SYMBOL);
      setState(5039);
      procedureRef();
      break;
    }

    case 34: {
      setState(5040);
      dynamic_cast<ShowStatementContext *>(_localctx)->value = match(MySQLParser::FUNCTION_SYMBOL);
      setState(5041);
      match(MySQLParser::CODE_SYMBOL);
      setState(5042);
      functionRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ShowCommandTypeContext ------------------------------------------------------------------

MySQLParser::ShowCommandTypeContext::ShowCommandTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ShowCommandTypeContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ShowCommandTypeContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}


size_t MySQLParser::ShowCommandTypeContext::getRuleIndex() const {
  return MySQLParser::RuleShowCommandType;
}

void MySQLParser::ShowCommandTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterShowCommandType(this);
}

void MySQLParser::ShowCommandTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitShowCommandType(this);
}

MySQLParser::ShowCommandTypeContext* MySQLParser::showCommandType() {
  ShowCommandTypeContext *_localctx = _tracker.createInstance<ShowCommandTypeContext>(_ctx, getState());
  enterRule(_localctx, 582, MySQLParser::RuleShowCommandType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5051);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 631, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5045);
      match(MySQLParser::FULL_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5046);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(5047);
      match(MySQLParser::EXTENDED_SYMBOL);
      setState(5049);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FULL_SYMBOL) {
        setState(5048);
        match(MySQLParser::FULL_SYMBOL);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NonBlockingContext ------------------------------------------------------------------

MySQLParser::NonBlockingContext::NonBlockingContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NonBlockingContext::NONBLOCKING_SYMBOL() {
  return getToken(MySQLParser::NONBLOCKING_SYMBOL, 0);
}


size_t MySQLParser::NonBlockingContext::getRuleIndex() const {
  return MySQLParser::RuleNonBlocking;
}

void MySQLParser::NonBlockingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNonBlocking(this);
}

void MySQLParser::NonBlockingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNonBlocking(this);
}

MySQLParser::NonBlockingContext* MySQLParser::nonBlocking() {
  NonBlockingContext *_localctx = _tracker.createInstance<NonBlockingContext>(_ctx, getState());
  enterRule(_localctx, 584, MySQLParser::RuleNonBlocking);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5058);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 633, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5053);

      if (!(serverVersion >= 50700 && serverVersion < 50706)) throw FailedPredicateException(this, "serverVersion >= 50700 && serverVersion < 50706");
      setState(5055);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 632, _ctx)) {
      case 1: {
        setState(5054);
        match(MySQLParser::NONBLOCKING_SYMBOL);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);

      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FromOrInContext ------------------------------------------------------------------

MySQLParser::FromOrInContext::FromOrInContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FromOrInContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FromOrInContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}


size_t MySQLParser::FromOrInContext::getRuleIndex() const {
  return MySQLParser::RuleFromOrIn;
}

void MySQLParser::FromOrInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFromOrIn(this);
}

void MySQLParser::FromOrInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFromOrIn(this);
}

MySQLParser::FromOrInContext* MySQLParser::fromOrIn() {
  FromOrInContext *_localctx = _tracker.createInstance<FromOrInContext>(_ctx, getState());
  enterRule(_localctx, 586, MySQLParser::RuleFromOrIn);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5060);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FROM_SYMBOL

    || _la == MySQLParser::IN_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InDbContext ------------------------------------------------------------------

MySQLParser::InDbContext::InDbContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FromOrInContext* MySQLParser::InDbContext::fromOrIn() {
  return getRuleContext<MySQLParser::FromOrInContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::InDbContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::InDbContext::getRuleIndex() const {
  return MySQLParser::RuleInDb;
}

void MySQLParser::InDbContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInDb(this);
}

void MySQLParser::InDbContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInDb(this);
}

MySQLParser::InDbContext* MySQLParser::inDb() {
  InDbContext *_localctx = _tracker.createInstance<InDbContext>(_ctx, getState());
  enterRule(_localctx, 588, MySQLParser::RuleInDb);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5062);
    fromOrIn();
    setState(5063);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProfileTypeContext ------------------------------------------------------------------

MySQLParser::ProfileTypeContext::ProfileTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProfileTypeContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}


size_t MySQLParser::ProfileTypeContext::getRuleIndex() const {
  return MySQLParser::RuleProfileType;
}

void MySQLParser::ProfileTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProfileType(this);
}

void MySQLParser::ProfileTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProfileType(this);
}

MySQLParser::ProfileTypeContext* MySQLParser::profileType() {
  ProfileTypeContext *_localctx = _tracker.createInstance<ProfileTypeContext>(_ctx, getState());
  enterRule(_localctx, 590, MySQLParser::RuleProfileType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5072);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::BLOCK_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5065);
        match(MySQLParser::BLOCK_SYMBOL);
        setState(5066);
        match(MySQLParser::IO_SYMBOL);
        break;
      }

      case MySQLParser::CONTEXT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5067);
        match(MySQLParser::CONTEXT_SYMBOL);
        setState(5068);
        match(MySQLParser::SWITCHES_SYMBOL);
        break;
      }

      case MySQLParser::PAGE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5069);
        match(MySQLParser::PAGE_SYMBOL);
        setState(5070);
        match(MySQLParser::FAULTS_SYMBOL);
        break;
      }

      case MySQLParser::ALL_SYMBOL:
      case MySQLParser::CPU_SYMBOL:
      case MySQLParser::IPC_SYMBOL:
      case MySQLParser::MEMORY_SYMBOL:
      case MySQLParser::SOURCE_SYMBOL:
      case MySQLParser::SWAPS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5071);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ALL_SYMBOL || _la == MySQLParser::CPU_SYMBOL || _la == MySQLParser::IPC_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL || _la == MySQLParser::SOURCE_SYMBOL

        || _la == MySQLParser::SWAPS_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OtherAdministrativeStatementContext ------------------------------------------------------------------

MySQLParser::OtherAdministrativeStatementContext::OtherAdministrativeStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::OtherAdministrativeStatementContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::KeyCacheListOrPartsContext* MySQLParser::OtherAdministrativeStatementContext::keyCacheListOrParts() {
  return getRuleContext<MySQLParser::KeyCacheListOrPartsContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::OtherAdministrativeStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

MySQLParser::FlushTablesContext* MySQLParser::OtherAdministrativeStatementContext::flushTables() {
  return getRuleContext<MySQLParser::FlushTablesContext>(0);
}

std::vector<MySQLParser::FlushOptionContext *> MySQLParser::OtherAdministrativeStatementContext::flushOption() {
  return getRuleContexts<MySQLParser::FlushOptionContext>();
}

MySQLParser::FlushOptionContext* MySQLParser::OtherAdministrativeStatementContext::flushOption(size_t i) {
  return getRuleContext<MySQLParser::FlushOptionContext>(i);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::OtherAdministrativeStatementContext::noWriteToBinLog() {
  return getRuleContext<MySQLParser::NoWriteToBinLogContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::OtherAdministrativeStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::ExprContext* MySQLParser::OtherAdministrativeStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::KILL_SYMBOL() {
  return getToken(MySQLParser::KILL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::PreloadTailContext* MySQLParser::OtherAdministrativeStatementContext::preloadTail() {
  return getRuleContext<MySQLParser::PreloadTailContext>(0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::LOAD_SYMBOL() {
  return getToken(MySQLParser::LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OtherAdministrativeStatementContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}


size_t MySQLParser::OtherAdministrativeStatementContext::getRuleIndex() const {
  return MySQLParser::RuleOtherAdministrativeStatement;
}

void MySQLParser::OtherAdministrativeStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOtherAdministrativeStatement(this);
}

void MySQLParser::OtherAdministrativeStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOtherAdministrativeStatement(this);
}

MySQLParser::OtherAdministrativeStatementContext* MySQLParser::otherAdministrativeStatement() {
  OtherAdministrativeStatementContext *_localctx = _tracker.createInstance<OtherAdministrativeStatementContext>(_ctx, getState());
  enterRule(_localctx, 592, MySQLParser::RuleOtherAdministrativeStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5111);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 640, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5074);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::BINLOG_SYMBOL);
      setState(5075);
      textLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5076);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::CACHE_SYMBOL);
      setState(5077);
      match(MySQLParser::INDEX_SYMBOL);
      setState(5078);
      keyCacheListOrParts();
      setState(5079);
      match(MySQLParser::IN_SYMBOL);
      setState(5082);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 635, _ctx)) {
      case 1: {
        setState(5080);
        identifier();
        break;
      }

      case 2: {
        setState(5081);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5084);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::FLUSH_SYMBOL);
      setState(5086);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 636, _ctx)) {
      case 1: {
        setState(5085);
        noWriteToBinLog();
        break;
      }

      }
      setState(5097);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 638, _ctx)) {
      case 1: {
        setState(5088);
        flushTables();
        break;
      }

      case 2: {
        setState(5089);
        flushOption();
        setState(5094);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == MySQLParser::COMMA_SYMBOL) {
          setState(5090);
          match(MySQLParser::COMMA_SYMBOL);
          setState(5091);
          flushOption();
          setState(5096);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5099);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::KILL_SYMBOL);
      setState(5101);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 639, _ctx)) {
      case 1: {
        setState(5100);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CONNECTION_SYMBOL || _la == MySQLParser::QUERY_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(5103);
      expr(0);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5104);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::LOAD_SYMBOL);
      setState(5105);
      match(MySQLParser::INDEX_SYMBOL);
      setState(5106);
      match(MySQLParser::INTO_SYMBOL);
      setState(5107);
      match(MySQLParser::CACHE_SYMBOL);
      setState(5108);
      preloadTail();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5109);

      if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
      setState(5110);
      dynamic_cast<OtherAdministrativeStatementContext *>(_localctx)->type = match(MySQLParser::SHUTDOWN_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyCacheListOrPartsContext ------------------------------------------------------------------

MySQLParser::KeyCacheListOrPartsContext::KeyCacheListOrPartsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyCacheListContext* MySQLParser::KeyCacheListOrPartsContext::keyCacheList() {
  return getRuleContext<MySQLParser::KeyCacheListContext>(0);
}

MySQLParser::AssignToKeycachePartitionContext* MySQLParser::KeyCacheListOrPartsContext::assignToKeycachePartition() {
  return getRuleContext<MySQLParser::AssignToKeycachePartitionContext>(0);
}


size_t MySQLParser::KeyCacheListOrPartsContext::getRuleIndex() const {
  return MySQLParser::RuleKeyCacheListOrParts;
}

void MySQLParser::KeyCacheListOrPartsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyCacheListOrParts(this);
}

void MySQLParser::KeyCacheListOrPartsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyCacheListOrParts(this);
}

MySQLParser::KeyCacheListOrPartsContext* MySQLParser::keyCacheListOrParts() {
  KeyCacheListOrPartsContext *_localctx = _tracker.createInstance<KeyCacheListOrPartsContext>(_ctx, getState());
  enterRule(_localctx, 594, MySQLParser::RuleKeyCacheListOrParts);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5115);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 641, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5113);
      keyCacheList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5114);
      assignToKeycachePartition();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyCacheListContext ------------------------------------------------------------------

MySQLParser::KeyCacheListContext::KeyCacheListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AssignToKeycacheContext *> MySQLParser::KeyCacheListContext::assignToKeycache() {
  return getRuleContexts<MySQLParser::AssignToKeycacheContext>();
}

MySQLParser::AssignToKeycacheContext* MySQLParser::KeyCacheListContext::assignToKeycache(size_t i) {
  return getRuleContext<MySQLParser::AssignToKeycacheContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyCacheListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyCacheListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyCacheListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyCacheList;
}

void MySQLParser::KeyCacheListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyCacheList(this);
}

void MySQLParser::KeyCacheListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyCacheList(this);
}

MySQLParser::KeyCacheListContext* MySQLParser::keyCacheList() {
  KeyCacheListContext *_localctx = _tracker.createInstance<KeyCacheListContext>(_ctx, getState());
  enterRule(_localctx, 596, MySQLParser::RuleKeyCacheList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5117);
    assignToKeycache();
    setState(5122);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5118);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5119);
      assignToKeycache();
      setState(5124);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignToKeycacheContext ------------------------------------------------------------------

MySQLParser::AssignToKeycacheContext::AssignToKeycacheContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::AssignToKeycacheContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::CacheKeyListContext* MySQLParser::AssignToKeycacheContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}


size_t MySQLParser::AssignToKeycacheContext::getRuleIndex() const {
  return MySQLParser::RuleAssignToKeycache;
}

void MySQLParser::AssignToKeycacheContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignToKeycache(this);
}

void MySQLParser::AssignToKeycacheContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignToKeycache(this);
}

MySQLParser::AssignToKeycacheContext* MySQLParser::assignToKeycache() {
  AssignToKeycacheContext *_localctx = _tracker.createInstance<AssignToKeycacheContext>(_ctx, getState());
  enterRule(_localctx, 598, MySQLParser::RuleAssignToKeycache);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5125);
    tableRef();
    setState(5127);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL) {
      setState(5126);
      cacheKeyList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AssignToKeycachePartitionContext ------------------------------------------------------------------

MySQLParser::AssignToKeycachePartitionContext::AssignToKeycachePartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::AssignToKeycachePartitionContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::AssignToKeycachePartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AssignToKeycachePartitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::AssignToKeycachePartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode* MySQLParser::AssignToKeycachePartitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::CacheKeyListContext* MySQLParser::AssignToKeycachePartitionContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}


size_t MySQLParser::AssignToKeycachePartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAssignToKeycachePartition;
}

void MySQLParser::AssignToKeycachePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAssignToKeycachePartition(this);
}

void MySQLParser::AssignToKeycachePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAssignToKeycachePartition(this);
}

MySQLParser::AssignToKeycachePartitionContext* MySQLParser::assignToKeycachePartition() {
  AssignToKeycachePartitionContext *_localctx = _tracker.createInstance<AssignToKeycachePartitionContext>(_ctx, getState());
  enterRule(_localctx, 600, MySQLParser::RuleAssignToKeycachePartition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5129);
    tableRef();
    setState(5130);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(5131);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5132);
    allOrPartitionNameList();
    setState(5133);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
    setState(5135);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL) {
      setState(5134);
      cacheKeyList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CacheKeyListContext ------------------------------------------------------------------

MySQLParser::CacheKeyListContext::CacheKeyListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyOrIndexContext* MySQLParser::CacheKeyListContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

tree::TerminalNode* MySQLParser::CacheKeyListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CacheKeyListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::KeyUsageListContext* MySQLParser::CacheKeyListContext::keyUsageList() {
  return getRuleContext<MySQLParser::KeyUsageListContext>(0);
}


size_t MySQLParser::CacheKeyListContext::getRuleIndex() const {
  return MySQLParser::RuleCacheKeyList;
}

void MySQLParser::CacheKeyListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCacheKeyList(this);
}

void MySQLParser::CacheKeyListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCacheKeyList(this);
}

MySQLParser::CacheKeyListContext* MySQLParser::cacheKeyList() {
  CacheKeyListContext *_localctx = _tracker.createInstance<CacheKeyListContext>(_ctx, getState());
  enterRule(_localctx, 602, MySQLParser::RuleCacheKeyList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5137);
    keyOrIndex();
    setState(5138);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5140);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 645, _ctx)) {
    case 1: {
      setState(5139);
      keyUsageList();
      break;
    }

    }
    setState(5142);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyUsageElementContext ------------------------------------------------------------------

MySQLParser::KeyUsageElementContext::KeyUsageElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::KeyUsageElementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::KeyUsageElementContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}


size_t MySQLParser::KeyUsageElementContext::getRuleIndex() const {
  return MySQLParser::RuleKeyUsageElement;
}

void MySQLParser::KeyUsageElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyUsageElement(this);
}

void MySQLParser::KeyUsageElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyUsageElement(this);
}

MySQLParser::KeyUsageElementContext* MySQLParser::keyUsageElement() {
  KeyUsageElementContext *_localctx = _tracker.createInstance<KeyUsageElementContext>(_ctx, getState());
  enterRule(_localctx, 604, MySQLParser::RuleKeyUsageElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5146);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 646, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5144);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5145);
      match(MySQLParser::PRIMARY_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyUsageListContext ------------------------------------------------------------------

MySQLParser::KeyUsageListContext::KeyUsageListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::KeyUsageElementContext *> MySQLParser::KeyUsageListContext::keyUsageElement() {
  return getRuleContexts<MySQLParser::KeyUsageElementContext>();
}

MySQLParser::KeyUsageElementContext* MySQLParser::KeyUsageListContext::keyUsageElement(size_t i) {
  return getRuleContext<MySQLParser::KeyUsageElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyUsageListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyUsageListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyUsageListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyUsageList;
}

void MySQLParser::KeyUsageListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyUsageList(this);
}

void MySQLParser::KeyUsageListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyUsageList(this);
}

MySQLParser::KeyUsageListContext* MySQLParser::keyUsageList() {
  KeyUsageListContext *_localctx = _tracker.createInstance<KeyUsageListContext>(_ctx, getState());
  enterRule(_localctx, 606, MySQLParser::RuleKeyUsageList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5148);
    keyUsageElement();
    setState(5153);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5149);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5150);
      keyUsageElement();
      setState(5155);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushOptionContext ------------------------------------------------------------------

MySQLParser::FlushOptionContext::FlushOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FlushOptionContext::DES_KEY_FILE_SYMBOL() {
  return getToken(MySQLParser::DES_KEY_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

MySQLParser::LogTypeContext* MySQLParser::FlushOptionContext::logType() {
  return getRuleContext<MySQLParser::LogTypeContext>(0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

MySQLParser::ChannelContext* MySQLParser::FlushOptionContext::channel() {
  return getRuleContext<MySQLParser::ChannelContext>(0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushOptionContext::OPTIMIZER_COSTS_SYMBOL() {
  return getToken(MySQLParser::OPTIMIZER_COSTS_SYMBOL, 0);
}


size_t MySQLParser::FlushOptionContext::getRuleIndex() const {
  return MySQLParser::RuleFlushOption;
}

void MySQLParser::FlushOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushOption(this);
}

void MySQLParser::FlushOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushOption(this);
}

MySQLParser::FlushOptionContext* MySQLParser::flushOption() {
  FlushOptionContext *_localctx = _tracker.createInstance<FlushOptionContext>(_ctx, getState());
  enterRule(_localctx, 608, MySQLParser::RuleFlushOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5171);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 650, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5156);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DES_KEY_FILE_SYMBOL || _la == MySQLParser::HOSTS_SYMBOL || _la == MySQLParser::PRIVILEGES_SYMBOL || _la == MySQLParser::STATUS_SYMBOL || _la == MySQLParser::USER_RESOURCES_SYMBOL)) {
        dynamic_cast<FlushOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5158);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::BINARY_SYMBOL || ((((_la - 206) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 206)) & ((1ULL << (MySQLParser::ENGINE_SYMBOL - 206))
        | (1ULL << (MySQLParser::ERROR_SYMBOL - 206))
        | (1ULL << (MySQLParser::GENERAL_SYMBOL - 206)))) != 0) || _la == MySQLParser::SLOW_SYMBOL) {
        setState(5157);
        logType();
      }
      setState(5160);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::LOGS_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5161);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::RELAY_SYMBOL);
      setState(5162);
      match(MySQLParser::LOGS_SYMBOL);
      setState(5164);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 649, _ctx)) {
      case 1: {
        setState(5163);
        channel();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5166);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(5167);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::QUERY_SYMBOL);
      setState(5168);
      match(MySQLParser::CACHE_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5169);

      if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
      setState(5170);
      dynamic_cast<FlushOptionContext *>(_localctx)->option = match(MySQLParser::OPTIMIZER_COSTS_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogTypeContext ------------------------------------------------------------------

MySQLParser::LogTypeContext::LogTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LogTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LogTypeContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}


size_t MySQLParser::LogTypeContext::getRuleIndex() const {
  return MySQLParser::RuleLogType;
}

void MySQLParser::LogTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogType(this);
}

void MySQLParser::LogTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogType(this);
}

MySQLParser::LogTypeContext* MySQLParser::logType() {
  LogTypeContext *_localctx = _tracker.createInstance<LogTypeContext>(_ctx, getState());
  enterRule(_localctx, 610, MySQLParser::RuleLogType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5173);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::BINARY_SYMBOL || ((((_la - 206) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 206)) & ((1ULL << (MySQLParser::ENGINE_SYMBOL - 206))
      | (1ULL << (MySQLParser::ERROR_SYMBOL - 206))
      | (1ULL << (MySQLParser::GENERAL_SYMBOL - 206)))) != 0) || _la == MySQLParser::SLOW_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushTablesContext ------------------------------------------------------------------

MySQLParser::FlushTablesContext::FlushTablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FlushTablesContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::TABLE_SYMBOL() {
  return getToken(MySQLParser::TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::FlushTablesContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::FlushTablesOptionsContext* MySQLParser::FlushTablesContext::flushTablesOptions() {
  return getRuleContext<MySQLParser::FlushTablesOptionsContext>(0);
}


size_t MySQLParser::FlushTablesContext::getRuleIndex() const {
  return MySQLParser::RuleFlushTables;
}

void MySQLParser::FlushTablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushTables(this);
}

void MySQLParser::FlushTablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushTables(this);
}

MySQLParser::FlushTablesContext* MySQLParser::flushTables() {
  FlushTablesContext *_localctx = _tracker.createInstance<FlushTablesContext>(_ctx, getState());
  enterRule(_localctx, 612, MySQLParser::RuleFlushTables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5175);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TABLES_SYMBOL

    || _la == MySQLParser::TABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 652, _ctx)) {
    case 1: {
      setState(5176);
      match(MySQLParser::WITH_SYMBOL);
      setState(5177);
      match(MySQLParser::READ_SYMBOL);
      setState(5178);
      match(MySQLParser::LOCK_SYMBOL);
      break;
    }

    case 2: {
      setState(5179);
      identifierList();
      setState(5181);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 651, _ctx)) {
      case 1: {
        setState(5180);
        flushTablesOptions();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FlushTablesOptionsContext ------------------------------------------------------------------

MySQLParser::FlushTablesOptionsContext::FlushTablesOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::READ_SYMBOL() {
  return getToken(MySQLParser::READ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FlushTablesOptionsContext::LOCK_SYMBOL() {
  return getToken(MySQLParser::LOCK_SYMBOL, 0);
}


size_t MySQLParser::FlushTablesOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFlushTablesOptions;
}

void MySQLParser::FlushTablesOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFlushTablesOptions(this);
}

void MySQLParser::FlushTablesOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFlushTablesOptions(this);
}

MySQLParser::FlushTablesOptionsContext* MySQLParser::flushTablesOptions() {
  FlushTablesOptionsContext *_localctx = _tracker.createInstance<FlushTablesOptionsContext>(_ctx, getState());
  enterRule(_localctx, 614, MySQLParser::RuleFlushTablesOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5191);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 653, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5185);

      if (!(serverVersion >= 50606)) throw FailedPredicateException(this, "serverVersion >= 50606");
      setState(5186);
      match(MySQLParser::FOR_SYMBOL);
      setState(5187);
      match(MySQLParser::EXPORT_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5188);
      match(MySQLParser::WITH_SYMBOL);
      setState(5189);
      match(MySQLParser::READ_SYMBOL);
      setState(5190);
      match(MySQLParser::LOCK_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadTailContext ------------------------------------------------------------------

MySQLParser::PreloadTailContext::PreloadTailContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::PreloadTailContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::AdminPartitionContext* MySQLParser::PreloadTailContext::adminPartition() {
  return getRuleContext<MySQLParser::AdminPartitionContext>(0);
}

MySQLParser::CacheKeyListContext* MySQLParser::PreloadTailContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

tree::TerminalNode* MySQLParser::PreloadTailContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreloadTailContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

MySQLParser::PreloadListContext* MySQLParser::PreloadTailContext::preloadList() {
  return getRuleContext<MySQLParser::PreloadListContext>(0);
}


size_t MySQLParser::PreloadTailContext::getRuleIndex() const {
  return MySQLParser::RulePreloadTail;
}

void MySQLParser::PreloadTailContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadTail(this);
}

void MySQLParser::PreloadTailContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadTail(this);
}

MySQLParser::PreloadTailContext* MySQLParser::preloadTail() {
  PreloadTailContext *_localctx = _tracker.createInstance<PreloadTailContext>(_ctx, getState());
  enterRule(_localctx, 616, MySQLParser::RulePreloadTail);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5203);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 656, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5193);
      tableRef();
      setState(5194);
      adminPartition();
      setState(5196);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::INDEX_SYMBOL

      || _la == MySQLParser::KEY_SYMBOL) {
        setState(5195);
        cacheKeyList();
      }
      setState(5200);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::IGNORE_SYMBOL) {
        setState(5198);
        match(MySQLParser::IGNORE_SYMBOL);
        setState(5199);
        match(MySQLParser::LEAVES_SYMBOL);
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5202);
      preloadList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadListContext ------------------------------------------------------------------

MySQLParser::PreloadListContext::PreloadListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::PreloadKeysContext *> MySQLParser::PreloadListContext::preloadKeys() {
  return getRuleContexts<MySQLParser::PreloadKeysContext>();
}

MySQLParser::PreloadKeysContext* MySQLParser::PreloadListContext::preloadKeys(size_t i) {
  return getRuleContext<MySQLParser::PreloadKeysContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::PreloadListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PreloadListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PreloadListContext::getRuleIndex() const {
  return MySQLParser::RulePreloadList;
}

void MySQLParser::PreloadListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadList(this);
}

void MySQLParser::PreloadListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadList(this);
}

MySQLParser::PreloadListContext* MySQLParser::preloadList() {
  PreloadListContext *_localctx = _tracker.createInstance<PreloadListContext>(_ctx, getState());
  enterRule(_localctx, 618, MySQLParser::RulePreloadList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5205);
    preloadKeys();
    setState(5210);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5206);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5207);
      preloadKeys();
      setState(5212);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PreloadKeysContext ------------------------------------------------------------------

MySQLParser::PreloadKeysContext::PreloadKeysContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::PreloadKeysContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::CacheKeyListContext* MySQLParser::PreloadKeysContext::cacheKeyList() {
  return getRuleContext<MySQLParser::CacheKeyListContext>(0);
}

tree::TerminalNode* MySQLParser::PreloadKeysContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PreloadKeysContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}


size_t MySQLParser::PreloadKeysContext::getRuleIndex() const {
  return MySQLParser::RulePreloadKeys;
}

void MySQLParser::PreloadKeysContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPreloadKeys(this);
}

void MySQLParser::PreloadKeysContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPreloadKeys(this);
}

MySQLParser::PreloadKeysContext* MySQLParser::preloadKeys() {
  PreloadKeysContext *_localctx = _tracker.createInstance<PreloadKeysContext>(_ctx, getState());
  enterRule(_localctx, 620, MySQLParser::RulePreloadKeys);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5213);
    tableRef();
    setState(5215);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::INDEX_SYMBOL

    || _la == MySQLParser::KEY_SYMBOL) {
      setState(5214);
      cacheKeyList();
    }
    setState(5219);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::IGNORE_SYMBOL) {
      setState(5217);
      match(MySQLParser::IGNORE_SYMBOL);
      setState(5218);
      match(MySQLParser::LEAVES_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AdminPartitionContext ------------------------------------------------------------------

MySQLParser::AdminPartitionContext::AdminPartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AdminPartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AdminPartitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::AllOrPartitionNameListContext* MySQLParser::AdminPartitionContext::allOrPartitionNameList() {
  return getRuleContext<MySQLParser::AllOrPartitionNameListContext>(0);
}

tree::TerminalNode* MySQLParser::AdminPartitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::AdminPartitionContext::getRuleIndex() const {
  return MySQLParser::RuleAdminPartition;
}

void MySQLParser::AdminPartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAdminPartition(this);
}

void MySQLParser::AdminPartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAdminPartition(this);
}

MySQLParser::AdminPartitionContext* MySQLParser::adminPartition() {
  AdminPartitionContext *_localctx = _tracker.createInstance<AdminPartitionContext>(_ctx, getState());
  enterRule(_localctx, 622, MySQLParser::RuleAdminPartition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5221);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(5222);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5223);
    allOrPartitionNameList();
    setState(5224);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupManagementContext ------------------------------------------------------------------

MySQLParser::ResourceGroupManagementContext::ResourceGroupManagementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CreateResourceGroupContext* MySQLParser::ResourceGroupManagementContext::createResourceGroup() {
  return getRuleContext<MySQLParser::CreateResourceGroupContext>(0);
}

MySQLParser::AlterResourceGroupContext* MySQLParser::ResourceGroupManagementContext::alterResourceGroup() {
  return getRuleContext<MySQLParser::AlterResourceGroupContext>(0);
}

MySQLParser::SetResourceGroupContext* MySQLParser::ResourceGroupManagementContext::setResourceGroup() {
  return getRuleContext<MySQLParser::SetResourceGroupContext>(0);
}

MySQLParser::DropResourceGroupContext* MySQLParser::ResourceGroupManagementContext::dropResourceGroup() {
  return getRuleContext<MySQLParser::DropResourceGroupContext>(0);
}


size_t MySQLParser::ResourceGroupManagementContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupManagement;
}

void MySQLParser::ResourceGroupManagementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupManagement(this);
}

void MySQLParser::ResourceGroupManagementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupManagement(this);
}

MySQLParser::ResourceGroupManagementContext* MySQLParser::resourceGroupManagement() {
  ResourceGroupManagementContext *_localctx = _tracker.createInstance<ResourceGroupManagementContext>(_ctx, getState());
  enterRule(_localctx, 624, MySQLParser::RuleResourceGroupManagement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5230);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CREATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5226);
        createResourceGroup();
        break;
      }

      case MySQLParser::ALTER_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5227);
        alterResourceGroup();
        break;
      }

      case MySQLParser::SET_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5228);
        setResourceGroup();
        break;
      }

      case MySQLParser::DROP_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5229);
        dropResourceGroup();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateResourceGroupContext ------------------------------------------------------------------

MySQLParser::CreateResourceGroupContext::CreateResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::CREATE_SYMBOL() {
  return getToken(MySQLParser::CREATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CreateResourceGroupContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateResourceGroupContext::SYSTEM_SYMBOL() {
  return getToken(MySQLParser::SYSTEM_SYMBOL, 0);
}

MySQLParser::EqualContext* MySQLParser::CreateResourceGroupContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::ResourceGroupVcpuListContext* MySQLParser::CreateResourceGroupContext::resourceGroupVcpuList() {
  return getRuleContext<MySQLParser::ResourceGroupVcpuListContext>(0);
}

MySQLParser::ResourceGroupPriorityContext* MySQLParser::CreateResourceGroupContext::resourceGroupPriority() {
  return getRuleContext<MySQLParser::ResourceGroupPriorityContext>(0);
}

MySQLParser::ResourceGroupEnableDisableContext* MySQLParser::CreateResourceGroupContext::resourceGroupEnableDisable() {
  return getRuleContext<MySQLParser::ResourceGroupEnableDisableContext>(0);
}


size_t MySQLParser::CreateResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleCreateResourceGroup;
}

void MySQLParser::CreateResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateResourceGroup(this);
}

void MySQLParser::CreateResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateResourceGroup(this);
}

MySQLParser::CreateResourceGroupContext* MySQLParser::createResourceGroup() {
  CreateResourceGroupContext *_localctx = _tracker.createInstance<CreateResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 626, MySQLParser::RuleCreateResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5232);
    match(MySQLParser::CREATE_SYMBOL);
    setState(5233);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5234);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5235);
    identifier();
    setState(5236);
    match(MySQLParser::TYPE_SYMBOL);
    setState(5238);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5237);
      equal();
    }
    setState(5240);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::USER_SYMBOL || _la == MySQLParser::SYSTEM_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5242);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::VCPU_SYMBOL) {
      setState(5241);
      resourceGroupVcpuList();
    }
    setState(5245);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::THREAD_PRIORITY_SYMBOL) {
      setState(5244);
      resourceGroupPriority();
    }
    setState(5248);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DISABLE_SYMBOL

    || _la == MySQLParser::ENABLE_SYMBOL) {
      setState(5247);
      resourceGroupEnableDisable();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupVcpuListContext ------------------------------------------------------------------

MySQLParser::ResourceGroupVcpuListContext::ResourceGroupVcpuListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResourceGroupVcpuListContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

std::vector<MySQLParser::VcpuNumOrRangeContext *> MySQLParser::ResourceGroupVcpuListContext::vcpuNumOrRange() {
  return getRuleContexts<MySQLParser::VcpuNumOrRangeContext>();
}

MySQLParser::VcpuNumOrRangeContext* MySQLParser::ResourceGroupVcpuListContext::vcpuNumOrRange(size_t i) {
  return getRuleContext<MySQLParser::VcpuNumOrRangeContext>(i);
}

MySQLParser::EqualContext* MySQLParser::ResourceGroupVcpuListContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

std::vector<tree::TerminalNode *> MySQLParser::ResourceGroupVcpuListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ResourceGroupVcpuListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ResourceGroupVcpuListContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupVcpuList;
}

void MySQLParser::ResourceGroupVcpuListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupVcpuList(this);
}

void MySQLParser::ResourceGroupVcpuListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupVcpuList(this);
}

MySQLParser::ResourceGroupVcpuListContext* MySQLParser::resourceGroupVcpuList() {
  ResourceGroupVcpuListContext *_localctx = _tracker.createInstance<ResourceGroupVcpuListContext>(_ctx, getState());
  enterRule(_localctx, 628, MySQLParser::RuleResourceGroupVcpuList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5250);
    match(MySQLParser::VCPU_SYMBOL);
    setState(5252);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5251);
      equal();
    }
    setState(5254);
    vcpuNumOrRange();
    setState(5261);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::INT_NUMBER

    || _la == MySQLParser::COMMA_SYMBOL) {
      setState(5256);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5255);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(5258);
      vcpuNumOrRange();
      setState(5263);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VcpuNumOrRangeContext ------------------------------------------------------------------

MySQLParser::VcpuNumOrRangeContext::VcpuNumOrRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::VcpuNumOrRangeContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode* MySQLParser::VcpuNumOrRangeContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode* MySQLParser::VcpuNumOrRangeContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}


size_t MySQLParser::VcpuNumOrRangeContext::getRuleIndex() const {
  return MySQLParser::RuleVcpuNumOrRange;
}

void MySQLParser::VcpuNumOrRangeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVcpuNumOrRange(this);
}

void MySQLParser::VcpuNumOrRangeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVcpuNumOrRange(this);
}

MySQLParser::VcpuNumOrRangeContext* MySQLParser::vcpuNumOrRange() {
  VcpuNumOrRangeContext *_localctx = _tracker.createInstance<VcpuNumOrRangeContext>(_ctx, getState());
  enterRule(_localctx, 630, MySQLParser::RuleVcpuNumOrRange);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5264);
    match(MySQLParser::INT_NUMBER);
    setState(5267);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::MINUS_OPERATOR) {
      setState(5265);
      match(MySQLParser::MINUS_OPERATOR);
      setState(5266);
      match(MySQLParser::INT_NUMBER);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupPriorityContext ------------------------------------------------------------------

MySQLParser::ResourceGroupPriorityContext::ResourceGroupPriorityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResourceGroupPriorityContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResourceGroupPriorityContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

MySQLParser::EqualContext* MySQLParser::ResourceGroupPriorityContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}


size_t MySQLParser::ResourceGroupPriorityContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupPriority;
}

void MySQLParser::ResourceGroupPriorityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupPriority(this);
}

void MySQLParser::ResourceGroupPriorityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupPriority(this);
}

MySQLParser::ResourceGroupPriorityContext* MySQLParser::resourceGroupPriority() {
  ResourceGroupPriorityContext *_localctx = _tracker.createInstance<ResourceGroupPriorityContext>(_ctx, getState());
  enterRule(_localctx, 632, MySQLParser::RuleResourceGroupPriority);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5269);
    match(MySQLParser::THREAD_PRIORITY_SYMBOL);
    setState(5271);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR) {
      setState(5270);
      equal();
    }
    setState(5273);
    match(MySQLParser::INT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupEnableDisableContext ------------------------------------------------------------------

MySQLParser::ResourceGroupEnableDisableContext::ResourceGroupEnableDisableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResourceGroupEnableDisableContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResourceGroupEnableDisableContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}


size_t MySQLParser::ResourceGroupEnableDisableContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupEnableDisable;
}

void MySQLParser::ResourceGroupEnableDisableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupEnableDisable(this);
}

void MySQLParser::ResourceGroupEnableDisableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupEnableDisable(this);
}

MySQLParser::ResourceGroupEnableDisableContext* MySQLParser::resourceGroupEnableDisable() {
  ResourceGroupEnableDisableContext *_localctx = _tracker.createInstance<ResourceGroupEnableDisableContext>(_ctx, getState());
  enterRule(_localctx, 634, MySQLParser::RuleResourceGroupEnableDisable);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5275);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DISABLE_SYMBOL

    || _la == MySQLParser::ENABLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterResourceGroupContext ------------------------------------------------------------------

MySQLParser::AlterResourceGroupContext::AlterResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::ALTER_SYMBOL() {
  return getToken(MySQLParser::ALTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::ResourceGroupRefContext* MySQLParser::AlterResourceGroupContext::resourceGroupRef() {
  return getRuleContext<MySQLParser::ResourceGroupRefContext>(0);
}

MySQLParser::ResourceGroupVcpuListContext* MySQLParser::AlterResourceGroupContext::resourceGroupVcpuList() {
  return getRuleContext<MySQLParser::ResourceGroupVcpuListContext>(0);
}

MySQLParser::ResourceGroupPriorityContext* MySQLParser::AlterResourceGroupContext::resourceGroupPriority() {
  return getRuleContext<MySQLParser::ResourceGroupPriorityContext>(0);
}

MySQLParser::ResourceGroupEnableDisableContext* MySQLParser::AlterResourceGroupContext::resourceGroupEnableDisable() {
  return getRuleContext<MySQLParser::ResourceGroupEnableDisableContext>(0);
}

tree::TerminalNode* MySQLParser::AlterResourceGroupContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}


size_t MySQLParser::AlterResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleAlterResourceGroup;
}

void MySQLParser::AlterResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterResourceGroup(this);
}

void MySQLParser::AlterResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterResourceGroup(this);
}

MySQLParser::AlterResourceGroupContext* MySQLParser::alterResourceGroup() {
  AlterResourceGroupContext *_localctx = _tracker.createInstance<AlterResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 636, MySQLParser::RuleAlterResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5277);
    match(MySQLParser::ALTER_SYMBOL);
    setState(5278);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5279);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5280);
    resourceGroupRef();
    setState(5282);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::VCPU_SYMBOL) {
      setState(5281);
      resourceGroupVcpuList();
    }
    setState(5285);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::THREAD_PRIORITY_SYMBOL) {
      setState(5284);
      resourceGroupPriority();
    }
    setState(5288);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DISABLE_SYMBOL

    || _la == MySQLParser::ENABLE_SYMBOL) {
      setState(5287);
      resourceGroupEnableDisable();
    }
    setState(5291);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FORCE_SYMBOL) {
      setState(5290);
      match(MySQLParser::FORCE_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetResourceGroupContext ------------------------------------------------------------------

MySQLParser::SetResourceGroupContext::SetResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SetResourceGroupContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SetResourceGroupContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::ThreadIdListContext* MySQLParser::SetResourceGroupContext::threadIdList() {
  return getRuleContext<MySQLParser::ThreadIdListContext>(0);
}


size_t MySQLParser::SetResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleSetResourceGroup;
}

void MySQLParser::SetResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetResourceGroup(this);
}

void MySQLParser::SetResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetResourceGroup(this);
}

MySQLParser::SetResourceGroupContext* MySQLParser::setResourceGroup() {
  SetResourceGroupContext *_localctx = _tracker.createInstance<SetResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 638, MySQLParser::RuleSetResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5293);
    match(MySQLParser::SET_SYMBOL);
    setState(5294);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5295);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5296);
    identifier();
    setState(5299);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FOR_SYMBOL) {
      setState(5297);
      match(MySQLParser::FOR_SYMBOL);
      setState(5298);
      threadIdList();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThreadIdListContext ------------------------------------------------------------------

MySQLParser::ThreadIdListContext::ThreadIdListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::Real_ulong_numberContext *> MySQLParser::ThreadIdListContext::real_ulong_number() {
  return getRuleContexts<MySQLParser::Real_ulong_numberContext>();
}

MySQLParser::Real_ulong_numberContext* MySQLParser::ThreadIdListContext::real_ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ThreadIdListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ThreadIdListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ThreadIdListContext::getRuleIndex() const {
  return MySQLParser::RuleThreadIdList;
}

void MySQLParser::ThreadIdListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThreadIdList(this);
}

void MySQLParser::ThreadIdListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThreadIdList(this);
}

MySQLParser::ThreadIdListContext* MySQLParser::threadIdList() {
  ThreadIdListContext *_localctx = _tracker.createInstance<ThreadIdListContext>(_ctx, getState());
  enterRule(_localctx, 640, MySQLParser::RuleThreadIdList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5301);
    real_ulong_number();
    setState(5308);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::INT_NUMBER)
      | (1ULL << MySQLParser::LONG_NUMBER)
      | (1ULL << MySQLParser::ULONGLONG_NUMBER)
      | (1ULL << MySQLParser::COMMA_SYMBOL)
      | (1ULL << MySQLParser::HEX_NUMBER))) != 0)) {
      setState(5303);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5302);
        match(MySQLParser::COMMA_SYMBOL);
      }
      setState(5305);
      real_ulong_number();
      setState(5310);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DropResourceGroupContext ------------------------------------------------------------------

MySQLParser::DropResourceGroupContext::DropResourceGroupContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::DROP_SYMBOL() {
  return getToken(MySQLParser::DROP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::GROUP_SYMBOL() {
  return getToken(MySQLParser::GROUP_SYMBOL, 0);
}

MySQLParser::ResourceGroupRefContext* MySQLParser::DropResourceGroupContext::resourceGroupRef() {
  return getRuleContext<MySQLParser::ResourceGroupRefContext>(0);
}

tree::TerminalNode* MySQLParser::DropResourceGroupContext::FORCE_SYMBOL() {
  return getToken(MySQLParser::FORCE_SYMBOL, 0);
}


size_t MySQLParser::DropResourceGroupContext::getRuleIndex() const {
  return MySQLParser::RuleDropResourceGroup;
}

void MySQLParser::DropResourceGroupContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDropResourceGroup(this);
}

void MySQLParser::DropResourceGroupContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDropResourceGroup(this);
}

MySQLParser::DropResourceGroupContext* MySQLParser::dropResourceGroup() {
  DropResourceGroupContext *_localctx = _tracker.createInstance<DropResourceGroupContext>(_ctx, getState());
  enterRule(_localctx, 642, MySQLParser::RuleDropResourceGroup);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5311);
    match(MySQLParser::DROP_SYMBOL);
    setState(5312);
    match(MySQLParser::RESOURCE_SYMBOL);
    setState(5313);
    match(MySQLParser::GROUP_SYMBOL);
    setState(5314);
    resourceGroupRef();
    setState(5316);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::FORCE_SYMBOL) {
      setState(5315);
      match(MySQLParser::FORCE_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UtilityStatementContext ------------------------------------------------------------------

MySQLParser::UtilityStatementContext::UtilityStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DescribeCommandContext* MySQLParser::UtilityStatementContext::describeCommand() {
  return getRuleContext<MySQLParser::DescribeCommandContext>(0);
}

MySQLParser::ExplainCommandContext* MySQLParser::UtilityStatementContext::explainCommand() {
  return getRuleContext<MySQLParser::ExplainCommandContext>(0);
}

MySQLParser::HelpCommandContext* MySQLParser::UtilityStatementContext::helpCommand() {
  return getRuleContext<MySQLParser::HelpCommandContext>(0);
}

MySQLParser::UseCommandContext* MySQLParser::UtilityStatementContext::useCommand() {
  return getRuleContext<MySQLParser::UseCommandContext>(0);
}

MySQLParser::RestartServerContext* MySQLParser::UtilityStatementContext::restartServer() {
  return getRuleContext<MySQLParser::RestartServerContext>(0);
}


size_t MySQLParser::UtilityStatementContext::getRuleIndex() const {
  return MySQLParser::RuleUtilityStatement;
}

void MySQLParser::UtilityStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUtilityStatement(this);
}

void MySQLParser::UtilityStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUtilityStatement(this);
}

MySQLParser::UtilityStatementContext* MySQLParser::utilityStatement() {
  UtilityStatementContext *_localctx = _tracker.createInstance<UtilityStatementContext>(_ctx, getState());
  enterRule(_localctx, 644, MySQLParser::RuleUtilityStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5324);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 678, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5318);
      describeCommand();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5319);
      explainCommand();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5320);
      helpCommand();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5321);
      useCommand();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5322);

      if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
      setState(5323);
      restartServer();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DescribeCommandContext ------------------------------------------------------------------

MySQLParser::DescribeCommandContext::DescribeCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TableRefContext* MySQLParser::DescribeCommandContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

tree::TerminalNode* MySQLParser::DescribeCommandContext::DESCRIBE_SYMBOL() {
  return getToken(MySQLParser::DESCRIBE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DescribeCommandContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::DescribeCommandContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

MySQLParser::ColumnRefContext* MySQLParser::DescribeCommandContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}


size_t MySQLParser::DescribeCommandContext::getRuleIndex() const {
  return MySQLParser::RuleDescribeCommand;
}

void MySQLParser::DescribeCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDescribeCommand(this);
}

void MySQLParser::DescribeCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDescribeCommand(this);
}

MySQLParser::DescribeCommandContext* MySQLParser::describeCommand() {
  DescribeCommandContext *_localctx = _tracker.createInstance<DescribeCommandContext>(_ctx, getState());
  enterRule(_localctx, 646, MySQLParser::RuleDescribeCommand);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5326);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DESC_SYMBOL

    || _la == MySQLParser::DESCRIBE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5327);
    tableRef();
    setState(5330);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 679, _ctx)) {
    case 1: {
      setState(5328);
      textString();
      break;
    }

    case 2: {
      setState(5329);
      columnRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainCommandContext ------------------------------------------------------------------

MySQLParser::ExplainCommandContext::ExplainCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExplainableStatementContext* MySQLParser::ExplainCommandContext::explainableStatement() {
  return getRuleContext<MySQLParser::ExplainableStatementContext>(0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::DESCRIBE_SYMBOL() {
  return getToken(MySQLParser::DESCRIBE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainCommandContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ExplainCommandContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::ExplainCommandContext::getRuleIndex() const {
  return MySQLParser::RuleExplainCommand;
}

void MySQLParser::ExplainCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainCommand(this);
}

void MySQLParser::ExplainCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainCommand(this);
}

MySQLParser::ExplainCommandContext* MySQLParser::explainCommand() {
  ExplainCommandContext *_localctx = _tracker.createInstance<ExplainCommandContext>(_ctx, getState());
  enterRule(_localctx, 648, MySQLParser::RuleExplainCommand);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5332);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DESC_SYMBOL

    || _la == MySQLParser::DESCRIBE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5341);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 680, _ctx)) {
    case 1: {
      setState(5333);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(5334);
      match(MySQLParser::EXTENDED_SYMBOL);
      break;
    }

    case 2: {
      setState(5335);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(5336);
      match(MySQLParser::PARTITIONS_SYMBOL);
      break;
    }

    case 3: {
      setState(5337);

      if (!(serverVersion >= 50605)) throw FailedPredicateException(this, "serverVersion >= 50605");
      setState(5338);
      match(MySQLParser::FORMAT_SYMBOL);
      setState(5339);
      match(MySQLParser::EQUAL_OPERATOR);
      setState(5340);
      textOrIdentifier();
      break;
    }

    }
    setState(5343);
    explainableStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExplainableStatementContext ------------------------------------------------------------------

MySQLParser::ExplainableStatementContext::ExplainableStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SelectStatementContext* MySQLParser::ExplainableStatementContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}

MySQLParser::DeleteStatementContext* MySQLParser::ExplainableStatementContext::deleteStatement() {
  return getRuleContext<MySQLParser::DeleteStatementContext>(0);
}

MySQLParser::InsertStatementContext* MySQLParser::ExplainableStatementContext::insertStatement() {
  return getRuleContext<MySQLParser::InsertStatementContext>(0);
}

MySQLParser::ReplaceStatementContext* MySQLParser::ExplainableStatementContext::replaceStatement() {
  return getRuleContext<MySQLParser::ReplaceStatementContext>(0);
}

MySQLParser::UpdateStatementContext* MySQLParser::ExplainableStatementContext::updateStatement() {
  return getRuleContext<MySQLParser::UpdateStatementContext>(0);
}

tree::TerminalNode* MySQLParser::ExplainableStatementContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExplainableStatementContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::ExplainableStatementContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}


size_t MySQLParser::ExplainableStatementContext::getRuleIndex() const {
  return MySQLParser::RuleExplainableStatement;
}

void MySQLParser::ExplainableStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExplainableStatement(this);
}

void MySQLParser::ExplainableStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExplainableStatement(this);
}

MySQLParser::ExplainableStatementContext* MySQLParser::explainableStatement() {
  ExplainableStatementContext *_localctx = _tracker.createInstance<ExplainableStatementContext>(_ctx, getState());
  enterRule(_localctx, 650, MySQLParser::RuleExplainableStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5357);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 682, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5345);
      selectStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5346);

      if (!(serverVersion >= 50603)) throw FailedPredicateException(this, "serverVersion >= 50603");
      setState(5351);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 681, _ctx)) {
      case 1: {
        setState(5347);
        deleteStatement();
        break;
      }

      case 2: {
        setState(5348);
        insertStatement();
        break;
      }

      case 3: {
        setState(5349);
        replaceStatement();
        break;
      }

      case 4: {
        setState(5350);
        updateStatement();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5353);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(5354);
      match(MySQLParser::FOR_SYMBOL);
      setState(5355);
      match(MySQLParser::CONNECTION_SYMBOL);
      setState(5356);
      real_ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HelpCommandContext ------------------------------------------------------------------

MySQLParser::HelpCommandContext::HelpCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HelpCommandContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::HelpCommandContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::HelpCommandContext::getRuleIndex() const {
  return MySQLParser::RuleHelpCommand;
}

void MySQLParser::HelpCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHelpCommand(this);
}

void MySQLParser::HelpCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHelpCommand(this);
}

MySQLParser::HelpCommandContext* MySQLParser::helpCommand() {
  HelpCommandContext *_localctx = _tracker.createInstance<HelpCommandContext>(_ctx, getState());
  enterRule(_localctx, 652, MySQLParser::RuleHelpCommand);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5359);
    match(MySQLParser::HELP_SYMBOL);
    setState(5360);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UseCommandContext ------------------------------------------------------------------

MySQLParser::UseCommandContext::UseCommandContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UseCommandContext::USE_SYMBOL() {
  return getToken(MySQLParser::USE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::UseCommandContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::UseCommandContext::getRuleIndex() const {
  return MySQLParser::RuleUseCommand;
}

void MySQLParser::UseCommandContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUseCommand(this);
}

void MySQLParser::UseCommandContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUseCommand(this);
}

MySQLParser::UseCommandContext* MySQLParser::useCommand() {
  UseCommandContext *_localctx = _tracker.createInstance<UseCommandContext>(_ctx, getState());
  enterRule(_localctx, 654, MySQLParser::RuleUseCommand);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5362);
    match(MySQLParser::USE_SYMBOL);
    setState(5363);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RestartServerContext ------------------------------------------------------------------

MySQLParser::RestartServerContext::RestartServerContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RestartServerContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}


size_t MySQLParser::RestartServerContext::getRuleIndex() const {
  return MySQLParser::RuleRestartServer;
}

void MySQLParser::RestartServerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRestartServer(this);
}

void MySQLParser::RestartServerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRestartServer(this);
}

MySQLParser::RestartServerContext* MySQLParser::restartServer() {
  RestartServerContext *_localctx = _tracker.createInstance<RestartServerContext>(_ctx, getState());
  enterRule(_localctx, 656, MySQLParser::RuleRestartServer);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5365);
    match(MySQLParser::RESTART_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

MySQLParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::ExprContext::getRuleIndex() const {
  return MySQLParser::RuleExpr;
}

void MySQLParser::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- ExprOrContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprOrContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprOrContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ExprOrContext::OR_SYMBOL() {
  return getToken(MySQLParser::OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprOrContext::LOGICAL_OR_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_OR_OPERATOR, 0);
}

MySQLParser::ExprOrContext::ExprOrContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprOrContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprOr(this);
}
void MySQLParser::ExprOrContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprOr(this);
}
//----------------- ExprNotContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::ExprNotContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ExprNotContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ExprNotContext::ExprNotContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprNot(this);
}
void MySQLParser::ExprNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprNot(this);
}
//----------------- ExprIsContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::ExprIsContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::IS_SYMBOL() {
  return getToken(MySQLParser::IS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::TRUE_SYMBOL() {
  return getToken(MySQLParser::TRUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::FALSE_SYMBOL() {
  return getToken(MySQLParser::FALSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprIsContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::ExprIsContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

MySQLParser::ExprIsContext::ExprIsContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprIsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprIs(this);
}
void MySQLParser::ExprIsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprIs(this);
}
//----------------- ExprAndContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprAndContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprAndContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ExprAndContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ExprAndContext::LOGICAL_AND_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_AND_OPERATOR, 0);
}

MySQLParser::ExprAndContext::ExprAndContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprAndContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprAnd(this);
}
void MySQLParser::ExprAndContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprAnd(this);
}
//----------------- ExprXorContext ------------------------------------------------------------------

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprXorContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprXorContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ExprXorContext::XOR_SYMBOL() {
  return getToken(MySQLParser::XOR_SYMBOL, 0);
}

MySQLParser::ExprXorContext::ExprXorContext(ExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::ExprXorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprXor(this);
}
void MySQLParser::ExprXorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprXor(this);
}

MySQLParser::ExprContext* MySQLParser::expr() {
   return expr(0);
}

MySQLParser::ExprContext* MySQLParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  MySQLParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 658;
  enterRecursionRule(_localctx, 658, MySQLParser::RuleExpr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5378);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 685, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<ExprIsContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(5368);
      boolPri(0);
      setState(5374);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 684, _ctx)) {
      case 1: {
        setState(5369);
        match(MySQLParser::IS_SYMBOL);
        setState(5371);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
          setState(5370);
          notRule();
        }
        setState(5373);
        dynamic_cast<ExprIsContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::FALSE_SYMBOL || _la == MySQLParser::TRUE_SYMBOL

        || _la == MySQLParser::UNKNOWN_SYMBOL)) {
          dynamic_cast<ExprIsContext *>(_localctx)->type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<ExprNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5376);
      match(MySQLParser::NOT_SYMBOL);
      setState(5377);
      expr(4);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5391);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 687, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5389);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 686, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<ExprAndContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(5380);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5381);
          dynamic_cast<ExprAndContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::LOGICAL_AND_OPERATOR

          || _la == MySQLParser::AND_SYMBOL)) {
            dynamic_cast<ExprAndContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5382);
          expr(4);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<ExprXorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(5383);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5384);
          match(MySQLParser::XOR_SYMBOL);
          setState(5385);
          expr(3);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ExprOrContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(5386);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5387);
          dynamic_cast<ExprOrContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::LOGICAL_OR_OPERATOR || _la == MySQLParser::OR_SYMBOL)) {
            dynamic_cast<ExprOrContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5388);
          expr(2);
          break;
        }

        } 
      }
      setState(5393);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 687, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- BoolPriContext ------------------------------------------------------------------

MySQLParser::BoolPriContext::BoolPriContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::BoolPriContext::getRuleIndex() const {
  return MySQLParser::RuleBoolPri;
}

void MySQLParser::BoolPriContext::copyFrom(BoolPriContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PrimaryExprPredicateContext ------------------------------------------------------------------

MySQLParser::PredicateContext* MySQLParser::PrimaryExprPredicateContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PrimaryExprPredicateContext::PrimaryExprPredicateContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprPredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprPredicate(this);
}
void MySQLParser::PrimaryExprPredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprPredicate(this);
}
//----------------- PrimaryExprCompareContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::PrimaryExprCompareContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

MySQLParser::CompOpContext* MySQLParser::PrimaryExprCompareContext::compOp() {
  return getRuleContext<MySQLParser::CompOpContext>(0);
}

MySQLParser::PredicateContext* MySQLParser::PrimaryExprCompareContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PrimaryExprCompareContext::PrimaryExprCompareContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprCompareContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprCompare(this);
}
void MySQLParser::PrimaryExprCompareContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprCompare(this);
}
//----------------- PrimaryExprAllAnyContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::PrimaryExprAllAnyContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

MySQLParser::CompOpContext* MySQLParser::PrimaryExprAllAnyContext::compOp() {
  return getRuleContext<MySQLParser::CompOpContext>(0);
}

MySQLParser::SubqueryContext* MySQLParser::PrimaryExprAllAnyContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLParser::PrimaryExprAllAnyContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PrimaryExprAllAnyContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

MySQLParser::PrimaryExprAllAnyContext::PrimaryExprAllAnyContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprAllAnyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprAllAny(this);
}
void MySQLParser::PrimaryExprAllAnyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprAllAny(this);
}
//----------------- PrimaryExprIsNullContext ------------------------------------------------------------------

MySQLParser::BoolPriContext* MySQLParser::PrimaryExprIsNullContext::boolPri() {
  return getRuleContext<MySQLParser::BoolPriContext>(0);
}

tree::TerminalNode* MySQLParser::PrimaryExprIsNullContext::IS_SYMBOL() {
  return getToken(MySQLParser::IS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PrimaryExprIsNullContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::PrimaryExprIsNullContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

MySQLParser::PrimaryExprIsNullContext::PrimaryExprIsNullContext(BoolPriContext *ctx) { copyFrom(ctx); }

void MySQLParser::PrimaryExprIsNullContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrimaryExprIsNull(this);
}
void MySQLParser::PrimaryExprIsNullContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrimaryExprIsNull(this);
}

MySQLParser::BoolPriContext* MySQLParser::boolPri() {
   return boolPri(0);
}

MySQLParser::BoolPriContext* MySQLParser::boolPri(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::BoolPriContext *_localctx = _tracker.createInstance<BoolPriContext>(_ctx, parentState);
  MySQLParser::BoolPriContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 660;
  enterRecursionRule(_localctx, 660, MySQLParser::RuleBoolPri, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    _localctx = _tracker.createInstance<PrimaryExprPredicateContext>(_localctx);
    _ctx = _localctx;
    previousContext = _localctx;

    setState(5395);
    predicate();
    _ctx->stop = _input->LT(-1);
    setState(5414);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 690, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5412);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 689, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<PrimaryExprIsNullContext>(_tracker.createInstance<BoolPriContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleBoolPri);
          setState(5397);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5398);
          match(MySQLParser::IS_SYMBOL);
          setState(5400);
          _errHandler->sync(this);

          _la = _input->LA(1);
          if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
            setState(5399);
            notRule();
          }
          setState(5402);
          match(MySQLParser::NULL_SYMBOL);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<PrimaryExprCompareContext>(_tracker.createInstance<BoolPriContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleBoolPri);
          setState(5403);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5404);
          compOp();
          setState(5405);
          predicate();
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<PrimaryExprAllAnyContext>(_tracker.createInstance<BoolPriContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleBoolPri);
          setState(5407);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5408);
          compOp();
          setState(5409);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::ALL_SYMBOL

          || _la == MySQLParser::ANY_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5410);
          subquery();
          break;
        }

        } 
      }
      setState(5416);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 690, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- CompOpContext ------------------------------------------------------------------

MySQLParser::CompOpContext::CompOpContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CompOpContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::NULL_SAFE_EQUAL_OPERATOR() {
  return getToken(MySQLParser::NULL_SAFE_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::GREATER_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::GREATER_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::GREATER_THAN_OPERATOR() {
  return getToken(MySQLParser::GREATER_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::LESS_OR_EQUAL_OPERATOR() {
  return getToken(MySQLParser::LESS_OR_EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::LESS_THAN_OPERATOR() {
  return getToken(MySQLParser::LESS_THAN_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CompOpContext::NOT_EQUAL_OPERATOR() {
  return getToken(MySQLParser::NOT_EQUAL_OPERATOR, 0);
}


size_t MySQLParser::CompOpContext::getRuleIndex() const {
  return MySQLParser::RuleCompOp;
}

void MySQLParser::CompOpContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompOp(this);
}

void MySQLParser::CompOpContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompOp(this);
}

MySQLParser::CompOpContext* MySQLParser::compOp() {
  CompOpContext *_localctx = _tracker.createInstance<CompOpContext>(_ctx, getState());
  enterRule(_localctx, 662, MySQLParser::RuleCompOp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5417);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::EQUAL_OPERATOR)
      | (1ULL << MySQLParser::NULL_SAFE_EQUAL_OPERATOR)
      | (1ULL << MySQLParser::GREATER_OR_EQUAL_OPERATOR)
      | (1ULL << MySQLParser::GREATER_THAN_OPERATOR)
      | (1ULL << MySQLParser::LESS_OR_EQUAL_OPERATOR)
      | (1ULL << MySQLParser::LESS_THAN_OPERATOR)
      | (1ULL << MySQLParser::NOT_EQUAL_OPERATOR))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateContext ------------------------------------------------------------------

MySQLParser::PredicateContext::PredicateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::BitExprContext *> MySQLParser::PredicateContext::bitExpr() {
  return getRuleContexts<MySQLParser::BitExprContext>();
}

MySQLParser::BitExprContext* MySQLParser::PredicateContext::bitExpr(size_t i) {
  return getRuleContext<MySQLParser::BitExprContext>(i);
}

MySQLParser::PredicateOperationsContext* MySQLParser::PredicateContext::predicateOperations() {
  return getRuleContext<MySQLParser::PredicateOperationsContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateContext::MEMBER_SYMBOL() {
  return getToken(MySQLParser::MEMBER_SYMBOL, 0);
}

MySQLParser::SimpleExprWithParenthesesContext* MySQLParser::PredicateContext::simpleExprWithParentheses() {
  return getRuleContext<MySQLParser::SimpleExprWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PredicateContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::PredicateContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateContext::OF_SYMBOL() {
  return getToken(MySQLParser::OF_SYMBOL, 0);
}


size_t MySQLParser::PredicateContext::getRuleIndex() const {
  return MySQLParser::RulePredicate;
}

void MySQLParser::PredicateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicate(this);
}

void MySQLParser::PredicateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicate(this);
}

MySQLParser::PredicateContext* MySQLParser::predicate() {
  PredicateContext *_localctx = _tracker.createInstance<PredicateContext>(_ctx, getState());
  enterRule(_localctx, 664, MySQLParser::RulePredicate);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5419);
    bitExpr(0);
    setState(5433);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 693, _ctx)) {
    case 1: {
      setState(5421);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
        setState(5420);
        notRule();
      }
      setState(5423);
      predicateOperations();
      break;
    }

    case 2: {
      setState(5424);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(5425);
      match(MySQLParser::MEMBER_SYMBOL);
      setState(5427);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::OF_SYMBOL) {
        setState(5426);
        match(MySQLParser::OF_SYMBOL);
      }
      setState(5429);
      simpleExprWithParentheses();
      break;
    }

    case 3: {
      setState(5430);
      match(MySQLParser::SOUNDS_SYMBOL);
      setState(5431);
      match(MySQLParser::LIKE_SYMBOL);
      setState(5432);
      bitExpr(0);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PredicateOperationsContext ------------------------------------------------------------------

MySQLParser::PredicateOperationsContext::PredicateOperationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::PredicateOperationsContext::getRuleIndex() const {
  return MySQLParser::RulePredicateOperations;
}

void MySQLParser::PredicateOperationsContext::copyFrom(PredicateOperationsContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PredicateExprRegexContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprRegexContext::REGEXP_SYMBOL() {
  return getToken(MySQLParser::REGEXP_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PredicateExprRegexContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

MySQLParser::PredicateExprRegexContext::PredicateExprRegexContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprRegexContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprRegex(this);
}
void MySQLParser::PredicateExprRegexContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprRegex(this);
}
//----------------- PredicateExprBetweenContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprBetweenContext::BETWEEN_SYMBOL() {
  return getToken(MySQLParser::BETWEEN_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PredicateExprBetweenContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateExprBetweenContext::AND_SYMBOL() {
  return getToken(MySQLParser::AND_SYMBOL, 0);
}

MySQLParser::PredicateContext* MySQLParser::PredicateExprBetweenContext::predicate() {
  return getRuleContext<MySQLParser::PredicateContext>(0);
}

MySQLParser::PredicateExprBetweenContext::PredicateExprBetweenContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprBetweenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprBetween(this);
}
void MySQLParser::PredicateExprBetweenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprBetween(this);
}
//----------------- PredicateExprInContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprInContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::SubqueryContext* MySQLParser::PredicateExprInContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateExprInContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::PredicateExprInContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::PredicateExprInContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::PredicateExprInContext::PredicateExprInContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprIn(this);
}
void MySQLParser::PredicateExprInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprIn(this);
}
//----------------- PredicateExprLikeContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PredicateExprLikeContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

std::vector<MySQLParser::SimpleExprContext *> MySQLParser::PredicateExprLikeContext::simpleExpr() {
  return getRuleContexts<MySQLParser::SimpleExprContext>();
}

MySQLParser::SimpleExprContext* MySQLParser::PredicateExprLikeContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLParser::SimpleExprContext>(i);
}

tree::TerminalNode* MySQLParser::PredicateExprLikeContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

MySQLParser::PredicateExprLikeContext::PredicateExprLikeContext(PredicateOperationsContext *ctx) { copyFrom(ctx); }

void MySQLParser::PredicateExprLikeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPredicateExprLike(this);
}
void MySQLParser::PredicateExprLikeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPredicateExprLike(this);
}
MySQLParser::PredicateOperationsContext* MySQLParser::predicateOperations() {
  PredicateOperationsContext *_localctx = _tracker.createInstance<PredicateOperationsContext>(_ctx, getState());
  enterRule(_localctx, 666, MySQLParser::RulePredicateOperations);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5456);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::IN_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprInContext>(_localctx));
        enterOuterAlt(_localctx, 1);
        setState(5435);
        match(MySQLParser::IN_SYMBOL);
        setState(5441);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 694, _ctx)) {
        case 1: {
          setState(5436);
          subquery();
          break;
        }

        case 2: {
          setState(5437);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(5438);
          exprList();
          setState(5439);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::BETWEEN_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprBetweenContext>(_localctx));
        enterOuterAlt(_localctx, 2);
        setState(5443);
        match(MySQLParser::BETWEEN_SYMBOL);
        setState(5444);
        bitExpr(0);
        setState(5445);
        match(MySQLParser::AND_SYMBOL);
        setState(5446);
        predicate();
        break;
      }

      case MySQLParser::LIKE_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprLikeContext>(_localctx));
        enterOuterAlt(_localctx, 3);
        setState(5448);
        match(MySQLParser::LIKE_SYMBOL);
        setState(5449);
        simpleExpr(0);
        setState(5452);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 695, _ctx)) {
        case 1: {
          setState(5450);
          match(MySQLParser::ESCAPE_SYMBOL);
          setState(5451);
          simpleExpr(0);
          break;
        }

        }
        break;
      }

      case MySQLParser::REGEXP_SYMBOL: {
        _localctx = dynamic_cast<PredicateOperationsContext *>(_tracker.createInstance<MySQLParser::PredicateExprRegexContext>(_localctx));
        enterOuterAlt(_localctx, 4);
        setState(5454);
        match(MySQLParser::REGEXP_SYMBOL);
        setState(5455);
        bitExpr(0);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BitExprContext ------------------------------------------------------------------

MySQLParser::BitExprContext::BitExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SimpleExprContext* MySQLParser::BitExprContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

std::vector<MySQLParser::BitExprContext *> MySQLParser::BitExprContext::bitExpr() {
  return getRuleContexts<MySQLParser::BitExprContext>();
}

MySQLParser::BitExprContext* MySQLParser::BitExprContext::bitExpr(size_t i) {
  return getRuleContext<MySQLParser::BitExprContext>(i);
}

tree::TerminalNode* MySQLParser::BitExprContext::BITWISE_XOR_OPERATOR() {
  return getToken(MySQLParser::BITWISE_XOR_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::DIV_OPERATOR() {
  return getToken(MySQLParser::DIV_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MOD_OPERATOR() {
  return getToken(MySQLParser::MOD_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::DIV_SYMBOL() {
  return getToken(MySQLParser::DIV_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MOD_SYMBOL() {
  return getToken(MySQLParser::MOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::SHIFT_LEFT_OPERATOR() {
  return getToken(MySQLParser::SHIFT_LEFT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::SHIFT_RIGHT_OPERATOR() {
  return getToken(MySQLParser::SHIFT_RIGHT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::BITWISE_AND_OPERATOR() {
  return getToken(MySQLParser::BITWISE_AND_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::BITWISE_OR_OPERATOR() {
  return getToken(MySQLParser::BITWISE_OR_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::BitExprContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::BitExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::IntervalContext* MySQLParser::BitExprContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}


size_t MySQLParser::BitExprContext::getRuleIndex() const {
  return MySQLParser::RuleBitExpr;
}

void MySQLParser::BitExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBitExpr(this);
}

void MySQLParser::BitExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBitExpr(this);
}


MySQLParser::BitExprContext* MySQLParser::bitExpr() {
   return bitExpr(0);
}

MySQLParser::BitExprContext* MySQLParser::bitExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::BitExprContext *_localctx = _tracker.createInstance<BitExprContext>(_ctx, parentState);
  MySQLParser::BitExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 668;
  enterRecursionRule(_localctx, 668, MySQLParser::RuleBitExpr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5459);
    simpleExpr(0);
    _ctx->stop = _input->LT(-1);
    setState(5487);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 698, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5485);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 697, _ctx)) {
        case 1: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5461);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(5462);
          dynamic_cast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_XOR_OPERATOR);
          setState(5463);
          bitExpr(8);
          break;
        }

        case 2: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5464);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(5465);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!((((_la & ~ 0x3fULL) == 0) &&
            ((1ULL << _la) & ((1ULL << MySQLParser::MULT_OPERATOR)
            | (1ULL << MySQLParser::DIV_OPERATOR)
            | (1ULL << MySQLParser::MOD_OPERATOR))) != 0) || _la == MySQLParser::DIV_SYMBOL || _la == MySQLParser::MOD_SYMBOL)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5466);
          bitExpr(7);
          break;
        }

        case 3: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5467);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(5468);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::PLUS_OPERATOR

          || _la == MySQLParser::MINUS_OPERATOR)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5469);
          bitExpr(6);
          break;
        }

        case 4: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5470);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(5471);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::SHIFT_LEFT_OPERATOR

          || _la == MySQLParser::SHIFT_RIGHT_OPERATOR)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5472);
          bitExpr(4);
          break;
        }

        case 5: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5473);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(5474);
          dynamic_cast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_AND_OPERATOR);
          setState(5475);
          bitExpr(3);
          break;
        }

        case 6: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5476);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(5477);
          dynamic_cast<BitExprContext *>(_localctx)->op = match(MySQLParser::BITWISE_OR_OPERATOR);
          setState(5478);
          bitExpr(2);
          break;
        }

        case 7: {
          _localctx = _tracker.createInstance<BitExprContext>(parentContext, parentState);
          pushNewRecursionContext(_localctx, startState, RuleBitExpr);
          setState(5479);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(5480);
          dynamic_cast<BitExprContext *>(_localctx)->op = _input->LT(1);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::PLUS_OPERATOR

          || _la == MySQLParser::MINUS_OPERATOR)) {
            dynamic_cast<BitExprContext *>(_localctx)->op = _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
          setState(5481);
          match(MySQLParser::INTERVAL_SYMBOL);
          setState(5482);
          expr(0);
          setState(5483);
          interval();
          break;
        }

        } 
      }
      setState(5489);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 698, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- SimpleExprContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext::SimpleExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::SimpleExprContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleExpr;
}

void MySQLParser::SimpleExprContext::copyFrom(SimpleExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SimpleExprConvertContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprConvertContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::CastTypeContext* MySQLParser::SimpleExprConvertContext::castType() {
  return getRuleContext<MySQLParser::CastTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprConvertContext::SimpleExprConvertContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprConvertContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConvert(this);
}
void MySQLParser::SimpleExprConvertContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConvert(this);
}
//----------------- SimpleExprVariableContext ------------------------------------------------------------------

MySQLParser::VariableContext* MySQLParser::SimpleExprVariableContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::SimpleExprVariableContext::SimpleExprVariableContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprVariable(this);
}
void MySQLParser::SimpleExprVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprVariable(this);
}
//----------------- SimpleExprCastContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprCastContext::CAST_SYMBOL() {
  return getToken(MySQLParser::CAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprCastContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprCastContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprCastContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::CastTypeContext* MySQLParser::SimpleExprCastContext::castType() {
  return getRuleContext<MySQLParser::CastTypeContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprCastContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::ArrayCastContext* MySQLParser::SimpleExprCastContext::arrayCast() {
  return getRuleContext<MySQLParser::ArrayCastContext>(0);
}

MySQLParser::SimpleExprCastContext::SimpleExprCastContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprCastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCast(this);
}
void MySQLParser::SimpleExprCastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCast(this);
}
//----------------- SimpleExprUnaryContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprUnaryContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprUnaryContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprUnaryContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprUnaryContext::BITWISE_NOT_OPERATOR() {
  return getToken(MySQLParser::BITWISE_NOT_OPERATOR, 0);
}

MySQLParser::SimpleExprUnaryContext::SimpleExprUnaryContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprUnaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprUnary(this);
}
void MySQLParser::SimpleExprUnaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprUnary(this);
}
//----------------- SimpleExprOdbcContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprOdbcContext::OPEN_CURLY_SYMBOL() {
  return getToken(MySQLParser::OPEN_CURLY_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SimpleExprOdbcContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprOdbcContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprOdbcContext::CLOSE_CURLY_SYMBOL() {
  return getToken(MySQLParser::CLOSE_CURLY_SYMBOL, 0);
}

MySQLParser::SimpleExprOdbcContext::SimpleExprOdbcContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprOdbcContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprOdbc(this);
}
void MySQLParser::SimpleExprOdbcContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprOdbc(this);
}
//----------------- SimpleExprRuntimeFunctionContext ------------------------------------------------------------------

MySQLParser::RuntimeFunctionCallContext* MySQLParser::SimpleExprRuntimeFunctionContext::runtimeFunctionCall() {
  return getRuleContext<MySQLParser::RuntimeFunctionCallContext>(0);
}

MySQLParser::SimpleExprRuntimeFunctionContext::SimpleExprRuntimeFunctionContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprRuntimeFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprRuntimeFunction(this);
}
void MySQLParser::SimpleExprRuntimeFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprRuntimeFunction(this);
}
//----------------- SimpleExprFunctionContext ------------------------------------------------------------------

MySQLParser::FunctionCallContext* MySQLParser::SimpleExprFunctionContext::functionCall() {
  return getRuleContext<MySQLParser::FunctionCallContext>(0);
}

MySQLParser::SimpleExprFunctionContext::SimpleExprFunctionContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprFunction(this);
}
void MySQLParser::SimpleExprFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprFunction(this);
}
//----------------- SimpleExprCollateContext ------------------------------------------------------------------

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprCollateContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprCollateContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::SimpleExprCollateContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::SimpleExprCollateContext::SimpleExprCollateContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprCollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCollate(this);
}
void MySQLParser::SimpleExprCollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCollate(this);
}
//----------------- SimpleExprMatchContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::MATCH_SYMBOL() {
  return getToken(MySQLParser::MATCH_SYMBOL, 0);
}

MySQLParser::IdentListArgContext* MySQLParser::SimpleExprMatchContext::identListArg() {
  return getRuleContext<MySQLParser::IdentListArgContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::SimpleExprMatchContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprMatchContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FulltextOptionsContext* MySQLParser::SimpleExprMatchContext::fulltextOptions() {
  return getRuleContext<MySQLParser::FulltextOptionsContext>(0);
}

MySQLParser::SimpleExprMatchContext::SimpleExprMatchContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprMatchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprMatch(this);
}
void MySQLParser::SimpleExprMatchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprMatch(this);
}
//----------------- SimpleExprWindowingFunctionContext ------------------------------------------------------------------

MySQLParser::WindowFunctionCallContext* MySQLParser::SimpleExprWindowingFunctionContext::windowFunctionCall() {
  return getRuleContext<MySQLParser::WindowFunctionCallContext>(0);
}

MySQLParser::SimpleExprWindowingFunctionContext::SimpleExprWindowingFunctionContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprWindowingFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprWindowingFunction(this);
}
void MySQLParser::SimpleExprWindowingFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprWindowingFunction(this);
}
//----------------- SimpleExprBinaryContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprBinaryContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprBinaryContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

MySQLParser::SimpleExprBinaryContext::SimpleExprBinaryContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprBinary(this);
}
void MySQLParser::SimpleExprBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprBinary(this);
}
//----------------- SimpleExprColumnRefContext ------------------------------------------------------------------

MySQLParser::ColumnRefContext* MySQLParser::SimpleExprColumnRefContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

MySQLParser::JsonOperatorContext* MySQLParser::SimpleExprColumnRefContext::jsonOperator() {
  return getRuleContext<MySQLParser::JsonOperatorContext>(0);
}

MySQLParser::SimpleExprColumnRefContext::SimpleExprColumnRefContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprColumnRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprColumnRef(this);
}
void MySQLParser::SimpleExprColumnRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprColumnRef(this);
}
//----------------- SimpleExprParamMarkerContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprParamMarkerContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

MySQLParser::SimpleExprParamMarkerContext::SimpleExprParamMarkerContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprParamMarkerContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprParamMarker(this);
}
void MySQLParser::SimpleExprParamMarkerContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprParamMarker(this);
}
//----------------- SimpleExprSumContext ------------------------------------------------------------------

MySQLParser::SumExprContext* MySQLParser::SimpleExprSumContext::sumExpr() {
  return getRuleContext<MySQLParser::SumExprContext>(0);
}

MySQLParser::SimpleExprSumContext::SimpleExprSumContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprSumContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprSum(this);
}
void MySQLParser::SimpleExprSumContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprSum(this);
}
//----------------- SimpleExprConvertUsingContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::CONVERT_SYMBOL() {
  return getToken(MySQLParser::CONVERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprConvertUsingContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::CharsetNameContext* MySQLParser::SimpleExprConvertUsingContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprConvertUsingContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprConvertUsingContext::SimpleExprConvertUsingContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprConvertUsingContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConvertUsing(this);
}
void MySQLParser::SimpleExprConvertUsingContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConvertUsing(this);
}
//----------------- SimpleExprSubQueryContext ------------------------------------------------------------------

MySQLParser::SubqueryContext* MySQLParser::SimpleExprSubQueryContext::subquery() {
  return getRuleContext<MySQLParser::SubqueryContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprSubQueryContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}

MySQLParser::SimpleExprSubQueryContext::SimpleExprSubQueryContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprSubQueryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprSubQuery(this);
}
void MySQLParser::SimpleExprSubQueryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprSubQuery(this);
}
//----------------- SimpleExprGroupingOperationContext ------------------------------------------------------------------

MySQLParser::GroupingOperationContext* MySQLParser::SimpleExprGroupingOperationContext::groupingOperation() {
  return getRuleContext<MySQLParser::GroupingOperationContext>(0);
}

MySQLParser::SimpleExprGroupingOperationContext::SimpleExprGroupingOperationContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprGroupingOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprGroupingOperation(this);
}
void MySQLParser::SimpleExprGroupingOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprGroupingOperation(this);
}
//----------------- SimpleExprNotContext ------------------------------------------------------------------

MySQLParser::Not2RuleContext* MySQLParser::SimpleExprNotContext::not2Rule() {
  return getRuleContext<MySQLParser::Not2RuleContext>(0);
}

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprNotContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

MySQLParser::SimpleExprNotContext::SimpleExprNotContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprNotContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprNot(this);
}
void MySQLParser::SimpleExprNotContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprNot(this);
}
//----------------- SimpleExprValuesContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprValuesContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprValuesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleIdentifierContext* MySQLParser::SimpleExprValuesContext::simpleIdentifier() {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprValuesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprValuesContext::SimpleExprValuesContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprValuesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprValues(this);
}
void MySQLParser::SimpleExprValuesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprValues(this);
}
//----------------- SimpleExprDefaultContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprDefaultContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprDefaultContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleIdentifierContext* MySQLParser::SimpleExprDefaultContext::simpleIdentifier() {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprDefaultContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprDefaultContext::SimpleExprDefaultContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprDefaultContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprDefault(this);
}
void MySQLParser::SimpleExprDefaultContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprDefault(this);
}
//----------------- SimpleExprListContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::SimpleExprListContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprListContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

MySQLParser::SimpleExprListContext::SimpleExprListContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprList(this);
}
void MySQLParser::SimpleExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprList(this);
}
//----------------- SimpleExprIntervalContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprIntervalContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::SimpleExprIntervalContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::SimpleExprIntervalContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

MySQLParser::IntervalContext* MySQLParser::SimpleExprIntervalContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprIntervalContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

MySQLParser::SimpleExprIntervalContext::SimpleExprIntervalContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprIntervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprInterval(this);
}
void MySQLParser::SimpleExprIntervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprInterval(this);
}
//----------------- SimpleExprCaseContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::SimpleExprCaseContext::CASE_SYMBOL() {
  return getToken(MySQLParser::CASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SimpleExprCaseContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::SimpleExprCaseContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

std::vector<MySQLParser::WhenExpressionContext *> MySQLParser::SimpleExprCaseContext::whenExpression() {
  return getRuleContexts<MySQLParser::WhenExpressionContext>();
}

MySQLParser::WhenExpressionContext* MySQLParser::SimpleExprCaseContext::whenExpression(size_t i) {
  return getRuleContext<MySQLParser::WhenExpressionContext>(i);
}

std::vector<MySQLParser::ThenExpressionContext *> MySQLParser::SimpleExprCaseContext::thenExpression() {
  return getRuleContexts<MySQLParser::ThenExpressionContext>();
}

MySQLParser::ThenExpressionContext* MySQLParser::SimpleExprCaseContext::thenExpression(size_t i) {
  return getRuleContext<MySQLParser::ThenExpressionContext>(i);
}

MySQLParser::ElseExpressionContext* MySQLParser::SimpleExprCaseContext::elseExpression() {
  return getRuleContext<MySQLParser::ElseExpressionContext>(0);
}

MySQLParser::SimpleExprCaseContext::SimpleExprCaseContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprCaseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprCase(this);
}
void MySQLParser::SimpleExprCaseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprCase(this);
}
//----------------- SimpleExprConcatContext ------------------------------------------------------------------

std::vector<MySQLParser::SimpleExprContext *> MySQLParser::SimpleExprConcatContext::simpleExpr() {
  return getRuleContexts<MySQLParser::SimpleExprContext>();
}

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprConcatContext::simpleExpr(size_t i) {
  return getRuleContext<MySQLParser::SimpleExprContext>(i);
}

tree::TerminalNode* MySQLParser::SimpleExprConcatContext::CONCAT_PIPES_SYMBOL() {
  return getToken(MySQLParser::CONCAT_PIPES_SYMBOL, 0);
}

MySQLParser::SimpleExprConcatContext::SimpleExprConcatContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprConcatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprConcat(this);
}
void MySQLParser::SimpleExprConcatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprConcat(this);
}
//----------------- SimpleExprLiteralContext ------------------------------------------------------------------

MySQLParser::LiteralContext* MySQLParser::SimpleExprLiteralContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

MySQLParser::SimpleExprLiteralContext::SimpleExprLiteralContext(SimpleExprContext *ctx) { copyFrom(ctx); }

void MySQLParser::SimpleExprLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprLiteral(this);
}
void MySQLParser::SimpleExprLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprLiteral(this);
}

MySQLParser::SimpleExprContext* MySQLParser::simpleExpr() {
   return simpleExpr(0);
}

MySQLParser::SimpleExprContext* MySQLParser::simpleExpr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  MySQLParser::SimpleExprContext *_localctx = _tracker.createInstance<SimpleExprContext>(_ctx, parentState);
  MySQLParser::SimpleExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 670;
  enterRecursionRule(_localctx, 670, MySQLParser::RuleSimpleExpr, precedence);

    size_t _la = 0;

  auto onExit = finally([=] {
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(5594);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 707, _ctx)) {
    case 1: {
      _localctx = _tracker.createInstance<SimpleExprVariableContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;

      setState(5491);
      variable();
      break;
    }

    case 2: {
      _localctx = _tracker.createInstance<SimpleExprColumnRefContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5492);
      columnRef();
      setState(5494);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 699, _ctx)) {
      case 1: {
        setState(5493);
        jsonOperator();
        break;
      }

      }
      break;
    }

    case 3: {
      _localctx = _tracker.createInstance<SimpleExprRuntimeFunctionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5496);
      runtimeFunctionCall();
      break;
    }

    case 4: {
      _localctx = _tracker.createInstance<SimpleExprFunctionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5497);
      functionCall();
      break;
    }

    case 5: {
      _localctx = _tracker.createInstance<SimpleExprLiteralContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5498);
      literal();
      break;
    }

    case 6: {
      _localctx = _tracker.createInstance<SimpleExprParamMarkerContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5499);
      match(MySQLParser::PARAM_MARKER);
      break;
    }

    case 7: {
      _localctx = _tracker.createInstance<SimpleExprSumContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5500);
      sumExpr();
      break;
    }

    case 8: {
      _localctx = _tracker.createInstance<SimpleExprGroupingOperationContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5501);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(5502);
      groupingOperation();
      break;
    }

    case 9: {
      _localctx = _tracker.createInstance<SimpleExprWindowingFunctionContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5503);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(5504);
      windowFunctionCall();
      break;
    }

    case 10: {
      _localctx = _tracker.createInstance<SimpleExprUnaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5505);
      dynamic_cast<SimpleExprUnaryContext *>(_localctx)->op = _input->LT(1);
      _la = _input->LA(1);
      if (!((((_la & ~ 0x3fULL) == 0) &&
        ((1ULL << _la) & ((1ULL << MySQLParser::PLUS_OPERATOR)
        | (1ULL << MySQLParser::MINUS_OPERATOR)
        | (1ULL << MySQLParser::BITWISE_NOT_OPERATOR))) != 0))) {
        dynamic_cast<SimpleExprUnaryContext *>(_localctx)->op = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5506);
      simpleExpr(14);
      break;
    }

    case 11: {
      _localctx = _tracker.createInstance<SimpleExprNotContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5507);
      not2Rule();
      setState(5508);
      simpleExpr(13);
      break;
    }

    case 12: {
      _localctx = _tracker.createInstance<SimpleExprListContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5511);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ROW_SYMBOL) {
        setState(5510);
        match(MySQLParser::ROW_SYMBOL);
      }
      setState(5513);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5514);
      exprList();
      setState(5515);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 13: {
      _localctx = _tracker.createInstance<SimpleExprSubQueryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5518);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EXISTS_SYMBOL) {
        setState(5517);
        match(MySQLParser::EXISTS_SYMBOL);
      }
      setState(5520);
      subquery();
      break;
    }

    case 14: {
      _localctx = _tracker.createInstance<SimpleExprOdbcContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5521);
      match(MySQLParser::OPEN_CURLY_SYMBOL);
      setState(5522);
      identifier();
      setState(5523);
      expr(0);
      setState(5524);
      match(MySQLParser::CLOSE_CURLY_SYMBOL);
      break;
    }

    case 15: {
      _localctx = _tracker.createInstance<SimpleExprMatchContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5526);
      match(MySQLParser::MATCH_SYMBOL);
      setState(5527);
      identListArg();
      setState(5528);
      match(MySQLParser::AGAINST_SYMBOL);
      setState(5529);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5530);
      bitExpr(0);
      setState(5532);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::IN_SYMBOL || _la == MySQLParser::WITH_SYMBOL) {
        setState(5531);
        fulltextOptions();
      }
      setState(5534);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 16: {
      _localctx = _tracker.createInstance<SimpleExprBinaryContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5536);
      match(MySQLParser::BINARY_SYMBOL);
      setState(5537);
      simpleExpr(8);
      break;
    }

    case 17: {
      _localctx = _tracker.createInstance<SimpleExprCastContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5538);
      match(MySQLParser::CAST_SYMBOL);
      setState(5539);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5540);
      expr(0);
      setState(5541);
      match(MySQLParser::AS_SYMBOL);
      setState(5542);
      castType();
      setState(5544);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 703, _ctx)) {
      case 1: {
        setState(5543);
        arrayCast();
        break;
      }

      }
      setState(5546);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 18: {
      _localctx = _tracker.createInstance<SimpleExprCaseContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5548);
      match(MySQLParser::CASE_SYMBOL);
      setState(5550);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 704, _ctx)) {
      case 1: {
        setState(5549);
        expr(0);
        break;
      }

      }
      setState(5555); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(5552);
        whenExpression();
        setState(5553);
        thenExpression();
        setState(5557); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySQLParser::WHEN_SYMBOL);
      setState(5560);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ELSE_SYMBOL) {
        setState(5559);
        elseExpression();
      }
      setState(5562);
      match(MySQLParser::END_SYMBOL);
      break;
    }

    case 19: {
      _localctx = _tracker.createInstance<SimpleExprConvertContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5564);
      match(MySQLParser::CONVERT_SYMBOL);
      setState(5565);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5566);
      expr(0);
      setState(5567);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5568);
      castType();
      setState(5569);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 20: {
      _localctx = _tracker.createInstance<SimpleExprConvertUsingContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5571);
      match(MySQLParser::CONVERT_SYMBOL);
      setState(5572);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5573);
      expr(0);
      setState(5574);
      match(MySQLParser::USING_SYMBOL);
      setState(5575);
      charsetName();
      setState(5576);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 21: {
      _localctx = _tracker.createInstance<SimpleExprDefaultContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5578);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(5579);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5580);
      simpleIdentifier();
      setState(5581);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 22: {
      _localctx = _tracker.createInstance<SimpleExprValuesContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5583);
      match(MySQLParser::VALUES_SYMBOL);
      setState(5584);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5585);
      simpleIdentifier();
      setState(5586);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 23: {
      _localctx = _tracker.createInstance<SimpleExprIntervalContext>(_localctx);
      _ctx = _localctx;
      previousContext = _localctx;
      setState(5588);
      match(MySQLParser::INTERVAL_SYMBOL);
      setState(5589);
      expr(0);
      setState(5590);
      interval();
      setState(5591);
      match(MySQLParser::PLUS_OPERATOR);
      setState(5592);
      expr(0);
      break;
    }

    }
    _ctx->stop = _input->LT(-1);
    setState(5604);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 709, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(5602);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 708, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<SimpleExprConcatContext>(_tracker.createInstance<SimpleExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimpleExpr);
          setState(5596);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(5597);
          match(MySQLParser::CONCAT_PIPES_SYMBOL);
          setState(5598);
          simpleExpr(16);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<SimpleExprCollateContext>(_tracker.createInstance<SimpleExprContext>(parentContext, parentState));
          _localctx = newContext;
          pushNewRecursionContext(newContext, startState, RuleSimpleExpr);
          setState(5599);

          if (!(precpred(_ctx, 21))) throw FailedPredicateException(this, "precpred(_ctx, 21)");
          setState(5600);
          match(MySQLParser::COLLATE_SYMBOL);
          setState(5601);
          textOrIdentifier();
          break;
        }

        } 
      }
      setState(5606);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 709, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- ArrayCastContext ------------------------------------------------------------------

MySQLParser::ArrayCastContext::ArrayCastContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ArrayCastContext::ARRAY_SYMBOL() {
  return getToken(MySQLParser::ARRAY_SYMBOL, 0);
}


size_t MySQLParser::ArrayCastContext::getRuleIndex() const {
  return MySQLParser::RuleArrayCast;
}

void MySQLParser::ArrayCastContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterArrayCast(this);
}

void MySQLParser::ArrayCastContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitArrayCast(this);
}

MySQLParser::ArrayCastContext* MySQLParser::arrayCast() {
  ArrayCastContext *_localctx = _tracker.createInstance<ArrayCastContext>(_ctx, getState());
  enterRule(_localctx, 672, MySQLParser::RuleArrayCast);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5607);

    if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
    setState(5608);
    match(MySQLParser::ARRAY_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonOperatorContext ------------------------------------------------------------------

MySQLParser::JsonOperatorContext::JsonOperatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::JsonOperatorContext::JSON_SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::JSON_SEPARATOR_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::JsonOperatorContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::JsonOperatorContext::JSON_UNQUOTED_SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::JSON_UNQUOTED_SEPARATOR_SYMBOL, 0);
}


size_t MySQLParser::JsonOperatorContext::getRuleIndex() const {
  return MySQLParser::RuleJsonOperator;
}

void MySQLParser::JsonOperatorContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonOperator(this);
}

void MySQLParser::JsonOperatorContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonOperator(this);
}

MySQLParser::JsonOperatorContext* MySQLParser::jsonOperator() {
  JsonOperatorContext *_localctx = _tracker.createInstance<JsonOperatorContext>(_ctx, getState());
  enterRule(_localctx, 674, MySQLParser::RuleJsonOperator);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5616);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 710, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5610);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(5611);
      match(MySQLParser::JSON_SEPARATOR_SYMBOL);
      setState(5612);
      textStringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5613);

      if (!(serverVersion >= 50713)) throw FailedPredicateException(this, "serverVersion >= 50713");
      setState(5614);
      match(MySQLParser::JSON_UNQUOTED_SEPARATOR_SYMBOL);
      setState(5615);
      textStringLiteral();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SumExprContext ------------------------------------------------------------------

MySQLParser::SumExprContext::SumExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SumExprContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::InSumExprContext* MySQLParser::SumExprContext::inSumExpr() {
  return getRuleContext<MySQLParser::InSumExprContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::DISTINCT_SYMBOL() {
  return getToken(MySQLParser::DISTINCT_SYMBOL, 0);
}

MySQLParser::WindowingClauseContext* MySQLParser::SumExprContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::BIT_AND_SYMBOL() {
  return getToken(MySQLParser::BIT_AND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::BIT_OR_SYMBOL() {
  return getToken(MySQLParser::BIT_OR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::BIT_XOR_SYMBOL() {
  return getToken(MySQLParser::BIT_XOR_SYMBOL, 0);
}

MySQLParser::JsonFunctionContext* MySQLParser::SumExprContext::jsonFunction() {
  return getRuleContext<MySQLParser::JsonFunctionContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::COUNT_SYMBOL() {
  return getToken(MySQLParser::COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::SumExprContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::MIN_SYMBOL() {
  return getToken(MySQLParser::MIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::MAX_SYMBOL() {
  return getToken(MySQLParser::MAX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::STD_SYMBOL() {
  return getToken(MySQLParser::STD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::VARIANCE_SYMBOL() {
  return getToken(MySQLParser::VARIANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::STDDEV_SAMP_SYMBOL() {
  return getToken(MySQLParser::STDDEV_SAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::VAR_SAMP_SYMBOL() {
  return getToken(MySQLParser::VAR_SAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::SUM_SYMBOL() {
  return getToken(MySQLParser::SUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SumExprContext::GROUP_CONCAT_SYMBOL() {
  return getToken(MySQLParser::GROUP_CONCAT_SYMBOL, 0);
}

MySQLParser::OrderClauseContext* MySQLParser::SumExprContext::orderClause() {
  return getRuleContext<MySQLParser::OrderClauseContext>(0);
}

tree::TerminalNode* MySQLParser::SumExprContext::SEPARATOR_SYMBOL() {
  return getToken(MySQLParser::SEPARATOR_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::SumExprContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}


size_t MySQLParser::SumExprContext::getRuleIndex() const {
  return MySQLParser::RuleSumExpr;
}

void MySQLParser::SumExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSumExpr(this);
}

void MySQLParser::SumExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSumExpr(this);
}

MySQLParser::SumExprContext* MySQLParser::sumExpr() {
  SumExprContext *_localctx = _tracker.createInstance<SumExprContext>(_ctx, getState());
  enterRule(_localctx, 676, MySQLParser::RuleSumExpr);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5749);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 733, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5618);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::AVG_SYMBOL);
      setState(5619);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5621);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 711, _ctx)) {
      case 1: {
        setState(5620);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5623);
      inSumExpr();
      setState(5624);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5627);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 712, _ctx)) {
      case 1: {
        setState(5625);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5626);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5629);
      dynamic_cast<SumExprContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 83) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 83)) & ((1ULL << (MySQLParser::BIT_AND_SYMBOL - 83))
        | (1ULL << (MySQLParser::BIT_OR_SYMBOL - 83))
        | (1ULL << (MySQLParser::BIT_XOR_SYMBOL - 83)))) != 0))) {
        dynamic_cast<SumExprContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5630);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5631);
      inSumExpr();
      setState(5632);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5635);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 713, _ctx)) {
      case 1: {
        setState(5633);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5634);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5637);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(5638);
      jsonFunction();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5639);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::COUNT_SYMBOL);
      setState(5640);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5642);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ALL_SYMBOL) {
        setState(5641);
        match(MySQLParser::ALL_SYMBOL);
      }
      setState(5644);
      match(MySQLParser::MULT_OPERATOR);
      setState(5645);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5648);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 715, _ctx)) {
      case 1: {
        setState(5646);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5647);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5650);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::COUNT_SYMBOL);
      setState(5651);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5659);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 717, _ctx)) {
      case 1: {
        setState(5653);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ALL_SYMBOL) {
          setState(5652);
          match(MySQLParser::ALL_SYMBOL);
        }
        setState(5655);
        match(MySQLParser::MULT_OPERATOR);
        break;
      }

      case 2: {
        setState(5656);
        inSumExpr();
        break;
      }

      case 3: {
        setState(5657);
        match(MySQLParser::DISTINCT_SYMBOL);
        setState(5658);
        exprList();
        break;
      }

      }
      setState(5661);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5664);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 718, _ctx)) {
      case 1: {
        setState(5662);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5663);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5666);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::MIN_SYMBOL);
      setState(5667);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5669);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 719, _ctx)) {
      case 1: {
        setState(5668);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5671);
      inSumExpr();
      setState(5672);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5675);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 720, _ctx)) {
      case 1: {
        setState(5673);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5674);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5677);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::MAX_SYMBOL);
      setState(5678);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5680);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 721, _ctx)) {
      case 1: {
        setState(5679);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5682);
      inSumExpr();
      setState(5683);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5686);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 722, _ctx)) {
      case 1: {
        setState(5684);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5685);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5688);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::STD_SYMBOL);
      setState(5689);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5690);
      inSumExpr();
      setState(5691);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5694);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 723, _ctx)) {
      case 1: {
        setState(5692);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5693);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5696);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::VARIANCE_SYMBOL);
      setState(5697);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5698);
      inSumExpr();
      setState(5699);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5702);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 724, _ctx)) {
      case 1: {
        setState(5700);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5701);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5704);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::STDDEV_SAMP_SYMBOL);
      setState(5705);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5706);
      inSumExpr();
      setState(5707);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5710);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 725, _ctx)) {
      case 1: {
        setState(5708);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5709);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5712);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::VAR_SAMP_SYMBOL);
      setState(5713);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5714);
      inSumExpr();
      setState(5715);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5718);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 726, _ctx)) {
      case 1: {
        setState(5716);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5717);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5720);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::SUM_SYMBOL);
      setState(5721);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5723);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 727, _ctx)) {
      case 1: {
        setState(5722);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5725);
      inSumExpr();
      setState(5726);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5729);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 728, _ctx)) {
      case 1: {
        setState(5727);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5728);
        windowingClause();
        break;
      }

      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5731);
      dynamic_cast<SumExprContext *>(_localctx)->name = match(MySQLParser::GROUP_CONCAT_SYMBOL);
      setState(5732);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5734);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 729, _ctx)) {
      case 1: {
        setState(5733);
        match(MySQLParser::DISTINCT_SYMBOL);
        break;
      }

      }
      setState(5736);
      exprList();
      setState(5738);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ORDER_SYMBOL) {
        setState(5737);
        orderClause();
      }
      setState(5742);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::SEPARATOR_SYMBOL) {
        setState(5740);
        match(MySQLParser::SEPARATOR_SYMBOL);
        setState(5741);
        textString();
      }
      setState(5744);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      setState(5747);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 732, _ctx)) {
      case 1: {
        setState(5745);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(5746);
        windowingClause();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingOperationContext ------------------------------------------------------------------

MySQLParser::GroupingOperationContext::GroupingOperationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GroupingOperationContext::GROUPING_SYMBOL() {
  return getToken(MySQLParser::GROUPING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GroupingOperationContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::GroupingOperationContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::GroupingOperationContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::GroupingOperationContext::getRuleIndex() const {
  return MySQLParser::RuleGroupingOperation;
}

void MySQLParser::GroupingOperationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingOperation(this);
}

void MySQLParser::GroupingOperationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingOperation(this);
}

MySQLParser::GroupingOperationContext* MySQLParser::groupingOperation() {
  GroupingOperationContext *_localctx = _tracker.createInstance<GroupingOperationContext>(_ctx, getState());
  enterRule(_localctx, 678, MySQLParser::RuleGroupingOperation);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5751);
    match(MySQLParser::GROUPING_SYMBOL);
    setState(5752);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(5753);
    exprList();
    setState(5754);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowFunctionCallContext ------------------------------------------------------------------

MySQLParser::WindowFunctionCallContext::WindowFunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ParenthesesContext* MySQLParser::WindowFunctionCallContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

MySQLParser::WindowingClauseContext* MySQLParser::WindowFunctionCallContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::ROW_NUMBER_SYMBOL() {
  return getToken(MySQLParser::ROW_NUMBER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::RANK_SYMBOL() {
  return getToken(MySQLParser::RANK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::DENSE_RANK_SYMBOL() {
  return getToken(MySQLParser::DENSE_RANK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::CUME_DIST_SYMBOL() {
  return getToken(MySQLParser::CUME_DIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::PERCENT_RANK_SYMBOL() {
  return getToken(MySQLParser::PERCENT_RANK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::NTILE_SYMBOL() {
  return getToken(MySQLParser::NTILE_SYMBOL, 0);
}

MySQLParser::SimpleExprWithParenthesesContext* MySQLParser::WindowFunctionCallContext::simpleExprWithParentheses() {
  return getRuleContext<MySQLParser::SimpleExprWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WindowFunctionCallContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LEAD_SYMBOL() {
  return getToken(MySQLParser::LEAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LAG_SYMBOL() {
  return getToken(MySQLParser::LAG_SYMBOL, 0);
}

MySQLParser::LeadLagInfoContext* MySQLParser::WindowFunctionCallContext::leadLagInfo() {
  return getRuleContext<MySQLParser::LeadLagInfoContext>(0);
}

MySQLParser::NullTreatmentContext* MySQLParser::WindowFunctionCallContext::nullTreatment() {
  return getRuleContext<MySQLParser::NullTreatmentContext>(0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::WindowFunctionCallContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::FIRST_VALUE_SYMBOL() {
  return getToken(MySQLParser::FIRST_VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LAST_VALUE_SYMBOL() {
  return getToken(MySQLParser::LAST_VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::NTH_VALUE_SYMBOL() {
  return getToken(MySQLParser::NTH_VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

MySQLParser::SimpleExprContext* MySQLParser::WindowFunctionCallContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WindowFunctionCallContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}


size_t MySQLParser::WindowFunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleWindowFunctionCall;
}

void MySQLParser::WindowFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowFunctionCall(this);
}

void MySQLParser::WindowFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowFunctionCall(this);
}

MySQLParser::WindowFunctionCallContext* MySQLParser::windowFunctionCall() {
  WindowFunctionCallContext *_localctx = _tracker.createInstance<WindowFunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 680, MySQLParser::RuleWindowFunctionCall);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5798);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CUME_DIST_SYMBOL:
      case MySQLParser::DENSE_RANK_SYMBOL:
      case MySQLParser::PERCENT_RANK_SYMBOL:
      case MySQLParser::RANK_SYMBOL:
      case MySQLParser::ROW_NUMBER_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5756);
        _la = _input->LA(1);
        if (!(((((_la - 709) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 709)) & ((1ULL << (MySQLParser::CUME_DIST_SYMBOL - 709))
          | (1ULL << (MySQLParser::DENSE_RANK_SYMBOL - 709))
          | (1ULL << (MySQLParser::PERCENT_RANK_SYMBOL - 709))
          | (1ULL << (MySQLParser::RANK_SYMBOL - 709))
          | (1ULL << (MySQLParser::ROW_NUMBER_SYMBOL - 709)))) != 0))) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5757);
        parentheses();
        setState(5758);
        windowingClause();
        break;
      }

      case MySQLParser::NTILE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5760);
        match(MySQLParser::NTILE_SYMBOL);
        setState(5761);
        simpleExprWithParentheses();
        setState(5762);
        windowingClause();
        break;
      }

      case MySQLParser::LAG_SYMBOL:
      case MySQLParser::LEAD_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(5764);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::LAG_SYMBOL

        || _la == MySQLParser::LEAD_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5765);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5766);
        expr(0);
        setState(5768);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(5767);
          leadLagInfo();
        }
        setState(5770);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5772);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(5771);
          nullTreatment();
        }
        setState(5774);
        windowingClause();
        break;
      }

      case MySQLParser::FIRST_VALUE_SYMBOL:
      case MySQLParser::LAST_VALUE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(5776);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::FIRST_VALUE_SYMBOL

        || _la == MySQLParser::LAST_VALUE_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(5777);
        exprWithParentheses();
        setState(5779);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(5778);
          nullTreatment();
        }
        setState(5781);
        windowingClause();
        break;
      }

      case MySQLParser::NTH_VALUE_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(5783);
        match(MySQLParser::NTH_VALUE_SYMBOL);
        setState(5784);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5785);
        expr(0);
        setState(5786);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5787);
        simpleExpr(0);
        setState(5788);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5791);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FROM_SYMBOL) {
          setState(5789);
          match(MySQLParser::FROM_SYMBOL);
          setState(5790);
          _la = _input->LA(1);
          if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::LAST_SYMBOL)) {
          _errHandler->recoverInline(this);
          }
          else {
            _errHandler->reportMatch(this);
            consume();
          }
        }
        setState(5794);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL) {
          setState(5793);
          nullTreatment();
        }
        setState(5796);
        windowingClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowingClauseContext ------------------------------------------------------------------

MySQLParser::WindowingClauseContext::WindowingClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WindowingClauseContext::OVER_SYMBOL() {
  return getToken(MySQLParser::OVER_SYMBOL, 0);
}

MySQLParser::WindowNameContext* MySQLParser::WindowingClauseContext::windowName() {
  return getRuleContext<MySQLParser::WindowNameContext>(0);
}

MySQLParser::WindowSpecContext* MySQLParser::WindowingClauseContext::windowSpec() {
  return getRuleContext<MySQLParser::WindowSpecContext>(0);
}


size_t MySQLParser::WindowingClauseContext::getRuleIndex() const {
  return MySQLParser::RuleWindowingClause;
}

void MySQLParser::WindowingClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowingClause(this);
}

void MySQLParser::WindowingClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowingClause(this);
}

MySQLParser::WindowingClauseContext* MySQLParser::windowingClause() {
  WindowingClauseContext *_localctx = _tracker.createInstance<WindowingClauseContext>(_ctx, getState());
  enterRule(_localctx, 682, MySQLParser::RuleWindowingClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5800);
    match(MySQLParser::OVER_SYMBOL);
    setState(5803);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 740, _ctx)) {
    case 1: {
      setState(5801);
      windowName();
      break;
    }

    case 2: {
      setState(5802);
      windowSpec();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeadLagInfoContext ------------------------------------------------------------------

MySQLParser::LeadLagInfoContext::LeadLagInfoContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::LeadLagInfoContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::LeadLagInfoContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::LeadLagInfoContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::LeadLagInfoContext::PARAM_MARKER() {
  return getToken(MySQLParser::PARAM_MARKER, 0);
}

MySQLParser::ExprContext* MySQLParser::LeadLagInfoContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::LeadLagInfoContext::getRuleIndex() const {
  return MySQLParser::RuleLeadLagInfo;
}

void MySQLParser::LeadLagInfoContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeadLagInfo(this);
}

void MySQLParser::LeadLagInfoContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeadLagInfo(this);
}

MySQLParser::LeadLagInfoContext* MySQLParser::leadLagInfo() {
  LeadLagInfoContext *_localctx = _tracker.createInstance<LeadLagInfoContext>(_ctx, getState());
  enterRule(_localctx, 684, MySQLParser::RuleLeadLagInfo);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5805);
    match(MySQLParser::COMMA_SYMBOL);
    setState(5808);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        setState(5806);
        ulonglong_number();
        break;
      }

      case MySQLParser::PARAM_MARKER: {
        setState(5807);
        match(MySQLParser::PARAM_MARKER);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(5812);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5810);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5811);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullTreatmentContext ------------------------------------------------------------------

MySQLParser::NullTreatmentContext::NullTreatmentContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NullTreatmentContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NullTreatmentContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NullTreatmentContext::IGNORE_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SYMBOL, 0);
}


size_t MySQLParser::NullTreatmentContext::getRuleIndex() const {
  return MySQLParser::RuleNullTreatment;
}

void MySQLParser::NullTreatmentContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullTreatment(this);
}

void MySQLParser::NullTreatmentContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullTreatment(this);
}

MySQLParser::NullTreatmentContext* MySQLParser::nullTreatment() {
  NullTreatmentContext *_localctx = _tracker.createInstance<NullTreatmentContext>(_ctx, getState());
  enterRule(_localctx, 686, MySQLParser::RuleNullTreatment);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5814);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::IGNORE_SYMBOL || _la == MySQLParser::RESPECT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(5815);
    match(MySQLParser::NULLS_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- JsonFunctionContext ------------------------------------------------------------------

MySQLParser::JsonFunctionContext::JsonFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::JSON_ARRAYAGG_SYMBOL() {
  return getToken(MySQLParser::JSON_ARRAYAGG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::InSumExprContext *> MySQLParser::JsonFunctionContext::inSumExpr() {
  return getRuleContexts<MySQLParser::InSumExprContext>();
}

MySQLParser::InSumExprContext* MySQLParser::JsonFunctionContext::inSumExpr(size_t i) {
  return getRuleContext<MySQLParser::InSumExprContext>(i);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::WindowingClauseContext* MySQLParser::JsonFunctionContext::windowingClause() {
  return getRuleContext<MySQLParser::WindowingClauseContext>(0);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::JSON_OBJECTAGG_SYMBOL() {
  return getToken(MySQLParser::JSON_OBJECTAGG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::JsonFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}


size_t MySQLParser::JsonFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleJsonFunction;
}

void MySQLParser::JsonFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterJsonFunction(this);
}

void MySQLParser::JsonFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitJsonFunction(this);
}

MySQLParser::JsonFunctionContext* MySQLParser::jsonFunction() {
  JsonFunctionContext *_localctx = _tracker.createInstance<JsonFunctionContext>(_ctx, getState());
  enterRule(_localctx, 688, MySQLParser::RuleJsonFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5833);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::JSON_ARRAYAGG_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(5817);
        match(MySQLParser::JSON_ARRAYAGG_SYMBOL);
        setState(5818);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5819);
        inSumExpr();
        setState(5820);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5822);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 743, _ctx)) {
        case 1: {
          setState(5821);
          windowingClause();
          break;
        }

        }
        break;
      }

      case MySQLParser::JSON_OBJECTAGG_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(5824);
        match(MySQLParser::JSON_OBJECTAGG_SYMBOL);
        setState(5825);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(5826);
        inSumExpr();
        setState(5827);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5828);
        inSumExpr();
        setState(5829);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        setState(5831);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 744, _ctx)) {
        case 1: {
          setState(5830);
          windowingClause();
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InSumExprContext ------------------------------------------------------------------

MySQLParser::InSumExprContext::InSumExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::InSumExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::InSumExprContext::ALL_SYMBOL() {
  return getToken(MySQLParser::ALL_SYMBOL, 0);
}


size_t MySQLParser::InSumExprContext::getRuleIndex() const {
  return MySQLParser::RuleInSumExpr;
}

void MySQLParser::InSumExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInSumExpr(this);
}

void MySQLParser::InSumExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInSumExpr(this);
}

MySQLParser::InSumExprContext* MySQLParser::inSumExpr() {
  InSumExprContext *_localctx = _tracker.createInstance<InSumExprContext>(_ctx, getState());
  enterRule(_localctx, 690, MySQLParser::RuleInSumExpr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5836);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 746, _ctx)) {
    case 1: {
      setState(5835);
      match(MySQLParser::ALL_SYMBOL);
      break;
    }

    }
    setState(5838);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentListArgContext ------------------------------------------------------------------

MySQLParser::IdentListArgContext::IdentListArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentListContext* MySQLParser::IdentListArgContext::identList() {
  return getRuleContext<MySQLParser::IdentListContext>(0);
}

tree::TerminalNode* MySQLParser::IdentListArgContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentListArgContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::IdentListArgContext::getRuleIndex() const {
  return MySQLParser::RuleIdentListArg;
}

void MySQLParser::IdentListArgContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentListArg(this);
}

void MySQLParser::IdentListArgContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentListArg(this);
}

MySQLParser::IdentListArgContext* MySQLParser::identListArg() {
  IdentListArgContext *_localctx = _tracker.createInstance<IdentListArgContext>(_ctx, getState());
  enterRule(_localctx, 692, MySQLParser::RuleIdentListArg);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5845);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 747, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5840);
      identList();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5841);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5842);
      identList();
      setState(5843);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentListContext ------------------------------------------------------------------

MySQLParser::IdentListContext::IdentListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SimpleIdentifierContext *> MySQLParser::IdentListContext::simpleIdentifier() {
  return getRuleContexts<MySQLParser::SimpleIdentifierContext>();
}

MySQLParser::SimpleIdentifierContext* MySQLParser::IdentListContext::simpleIdentifier(size_t i) {
  return getRuleContext<MySQLParser::SimpleIdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IdentListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IdentListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IdentListContext::getRuleIndex() const {
  return MySQLParser::RuleIdentList;
}

void MySQLParser::IdentListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentList(this);
}

void MySQLParser::IdentListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentList(this);
}

MySQLParser::IdentListContext* MySQLParser::identList() {
  IdentListContext *_localctx = _tracker.createInstance<IdentListContext>(_ctx, getState());
  enterRule(_localctx, 694, MySQLParser::RuleIdentList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(5847);
    simpleIdentifier();
    setState(5852);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(5848);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5849);
      simpleIdentifier();
      setState(5854);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FulltextOptionsContext ------------------------------------------------------------------

MySQLParser::FulltextOptionsContext::FulltextOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::NATURAL_SYMBOL() {
  return getToken(MySQLParser::NATURAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextOptionsContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}


size_t MySQLParser::FulltextOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFulltextOptions;
}

void MySQLParser::FulltextOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFulltextOptions(this);
}

void MySQLParser::FulltextOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFulltextOptions(this);
}

MySQLParser::FulltextOptionsContext* MySQLParser::fulltextOptions() {
  FulltextOptionsContext *_localctx = _tracker.createInstance<FulltextOptionsContext>(_ctx, getState());
  enterRule(_localctx, 696, MySQLParser::RuleFulltextOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(5870);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 750, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5855);
      match(MySQLParser::IN_SYMBOL);
      setState(5856);
      match(MySQLParser::BOOLEAN_SYMBOL);
      setState(5857);
      match(MySQLParser::MODE_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5858);
      match(MySQLParser::IN_SYMBOL);
      setState(5859);
      match(MySQLParser::NATURAL_SYMBOL);
      setState(5860);
      match(MySQLParser::LANGUAGE_SYMBOL);
      setState(5861);
      match(MySQLParser::MODE_SYMBOL);
      setState(5865);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::WITH_SYMBOL) {
        setState(5862);
        match(MySQLParser::WITH_SYMBOL);
        setState(5863);
        match(MySQLParser::QUERY_SYMBOL);
        setState(5864);
        match(MySQLParser::EXPANSION_SYMBOL);
      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5867);
      match(MySQLParser::WITH_SYMBOL);
      setState(5868);
      match(MySQLParser::QUERY_SYMBOL);
      setState(5869);
      match(MySQLParser::EXPANSION_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuntimeFunctionCallContext ------------------------------------------------------------------

MySQLParser::RuntimeFunctionCallContext::RuntimeFunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::RuntimeFunctionCallContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

MySQLParser::CharsetNameContext* MySQLParser::RuntimeFunctionCallContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CURRENT_USER_SYMBOL() {
  return getToken(MySQLParser::CURRENT_USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext* MySQLParser::RuntimeFunctionCallContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::RuntimeFunctionCallContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::RuntimeFunctionCallContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::RuntimeFunctionCallContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::RuntimeFunctionCallContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::INSERT_SYMBOL() {
  return getToken(MySQLParser::INSERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::INTERVAL_SYMBOL() {
  return getToken(MySQLParser::INTERVAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::LEFT_SYMBOL() {
  return getToken(MySQLParser::LEFT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::RIGHT_SYMBOL() {
  return getToken(MySQLParser::RIGHT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

MySQLParser::TrimFunctionContext* MySQLParser::RuntimeFunctionCallContext::trimFunction() {
  return getRuleContext<MySQLParser::TrimFunctionContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

MySQLParser::IntervalContext* MySQLParser::RuntimeFunctionCallContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CURDATE_SYMBOL() {
  return getToken(MySQLParser::CURDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CURTIME_SYMBOL() {
  return getToken(MySQLParser::CURTIME_SYMBOL, 0);
}

MySQLParser::TimeFunctionParametersContext* MySQLParser::RuntimeFunctionCallContext::timeFunctionParameters() {
  return getRuleContext<MySQLParser::TimeFunctionParametersContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATE_ADD_SYMBOL() {
  return getToken(MySQLParser::DATE_ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATE_SUB_SYMBOL() {
  return getToken(MySQLParser::DATE_SUB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::EXTRACT_SYMBOL() {
  return getToken(MySQLParser::EXTRACT_SYMBOL, 0);
}

MySQLParser::DateTimeTtypeContext* MySQLParser::RuntimeFunctionCallContext::dateTimeTtype() {
  return getRuleContext<MySQLParser::DateTimeTtypeContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::NOW_SYMBOL() {
  return getToken(MySQLParser::NOW_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::RuntimeFunctionCallContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::POSITION_SYMBOL() {
  return getToken(MySQLParser::POSITION_SYMBOL, 0);
}

MySQLParser::SubstringFunctionContext* MySQLParser::RuntimeFunctionCallContext::substringFunction() {
  return getRuleContext<MySQLParser::SubstringFunctionContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::SYSDATE_SYMBOL() {
  return getToken(MySQLParser::SYSDATE_SYMBOL, 0);
}

MySQLParser::IntervalTimeStampContext* MySQLParser::RuntimeFunctionCallContext::intervalTimeStamp() {
  return getRuleContext<MySQLParser::IntervalTimeStampContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIMESTAMP_ADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TIMESTAMP_DIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_DIFF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::UTC_DATE_SYMBOL() {
  return getToken(MySQLParser::UTC_DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::UTC_TIME_SYMBOL() {
  return getToken(MySQLParser::UTC_TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::UTC_TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::UTC_TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

MySQLParser::ExprListWithParenthesesContext* MySQLParser::RuntimeFunctionCallContext::exprListWithParentheses() {
  return getRuleContext<MySQLParser::ExprListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::DATABASE_SYMBOL() {
  return getToken(MySQLParser::DATABASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::MOD_SYMBOL() {
  return getToken(MySQLParser::MOD_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::RuntimeFunctionCallContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::OLD_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::OLD_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::REPEAT_SYMBOL() {
  return getToken(MySQLParser::REPEAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RuntimeFunctionCallContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::WsNumCodepointsContext* MySQLParser::RuntimeFunctionCallContext::wsNumCodepoints() {
  return getRuleContext<MySQLParser::WsNumCodepointsContext>(0);
}

std::vector<MySQLParser::Ulong_numberContext *> MySQLParser::RuntimeFunctionCallContext::ulong_number() {
  return getRuleContexts<MySQLParser::Ulong_numberContext>();
}

MySQLParser::Ulong_numberContext* MySQLParser::RuntimeFunctionCallContext::ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Ulong_numberContext>(i);
}

MySQLParser::WeightStringLevelsContext* MySQLParser::RuntimeFunctionCallContext::weightStringLevels() {
  return getRuleContext<MySQLParser::WeightStringLevelsContext>(0);
}

MySQLParser::GeometryFunctionContext* MySQLParser::RuntimeFunctionCallContext::geometryFunction() {
  return getRuleContext<MySQLParser::GeometryFunctionContext>(0);
}


size_t MySQLParser::RuntimeFunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleRuntimeFunctionCall;
}

void MySQLParser::RuntimeFunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRuntimeFunctionCall(this);
}

void MySQLParser::RuntimeFunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRuntimeFunctionCall(this);
}

MySQLParser::RuntimeFunctionCallContext* MySQLParser::runtimeFunctionCall() {
  RuntimeFunctionCallContext *_localctx = _tracker.createInstance<RuntimeFunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 698, MySQLParser::RuleRuntimeFunctionCall);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6146);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 768, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(5872);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CHAR_SYMBOL);
      setState(5873);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5874);
      exprList();
      setState(5877);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::USING_SYMBOL) {
        setState(5875);
        match(MySQLParser::USING_SYMBOL);
        setState(5876);
        charsetName();
      }
      setState(5879);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(5881);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CURRENT_USER_SYMBOL);
      setState(5883);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 752, _ctx)) {
      case 1: {
        setState(5882);
        parentheses();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(5885);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::DATE_SYMBOL);
      setState(5886);
      exprWithParentheses();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(5887);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::DAY_SYMBOL);
      setState(5888);
      exprWithParentheses();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(5889);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::HOUR_SYMBOL);
      setState(5890);
      exprWithParentheses();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(5891);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::INSERT_SYMBOL);
      setState(5892);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5893);
      expr(0);
      setState(5894);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5895);
      expr(0);
      setState(5896);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5897);
      expr(0);
      setState(5898);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5899);
      expr(0);
      setState(5900);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(5902);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::INTERVAL_SYMBOL);
      setState(5903);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5904);
      expr(0);
      setState(5907); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(5905);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5906);
        expr(0);
        setState(5909); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == MySQLParser::COMMA_SYMBOL);
      setState(5911);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(5913);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::LEFT_SYMBOL);
      setState(5914);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5915);
      expr(0);
      setState(5916);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5917);
      expr(0);
      setState(5918);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(5920);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MINUTE_SYMBOL);
      setState(5921);
      exprWithParentheses();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(5922);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MONTH_SYMBOL);
      setState(5923);
      exprWithParentheses();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(5924);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::RIGHT_SYMBOL);
      setState(5925);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5926);
      expr(0);
      setState(5927);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5928);
      expr(0);
      setState(5929);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(5931);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::SECOND_SYMBOL);
      setState(5932);
      exprWithParentheses();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(5933);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::TIME_SYMBOL);
      setState(5934);
      exprWithParentheses();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(5935);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::TIMESTAMP_SYMBOL);
      setState(5936);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5937);
      expr(0);
      setState(5940);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(5938);
        match(MySQLParser::COMMA_SYMBOL);
        setState(5939);
        expr(0);
      }
      setState(5942);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(5944);
      trimFunction();
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(5945);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::USER_SYMBOL);
      setState(5946);
      parentheses();
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(5947);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::VALUES_SYMBOL);
      setState(5948);
      exprWithParentheses();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(5949);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::YEAR_SYMBOL);
      setState(5950);
      exprWithParentheses();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(5951);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::ADDDATE_SYMBOL || _la == MySQLParser::SUBDATE_SYMBOL)) {
        dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5952);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5953);
      expr(0);
      setState(5954);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5960);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 755, _ctx)) {
      case 1: {
        setState(5955);
        expr(0);
        break;
      }

      case 2: {
        setState(5956);
        match(MySQLParser::INTERVAL_SYMBOL);
        setState(5957);
        expr(0);
        setState(5958);
        interval();
        break;
      }

      }
      setState(5962);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(5964);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CURDATE_SYMBOL);
      setState(5966);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 756, _ctx)) {
      case 1: {
        setState(5965);
        parentheses();
        break;
      }

      }
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(5968);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CURTIME_SYMBOL);
      setState(5970);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 757, _ctx)) {
      case 1: {
        setState(5969);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(5972);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DATE_ADD_SYMBOL

      || _la == MySQLParser::DATE_SUB_SYMBOL)) {
        dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(5973);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5974);
      expr(0);
      setState(5975);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5976);
      match(MySQLParser::INTERVAL_SYMBOL);
      setState(5977);
      expr(0);
      setState(5978);
      interval();
      setState(5979);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(5981);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::EXTRACT_SYMBOL);
      setState(5982);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5983);
      interval();
      setState(5984);
      match(MySQLParser::FROM_SYMBOL);
      setState(5985);
      expr(0);
      setState(5986);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(5988);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::GET_FORMAT_SYMBOL);
      setState(5989);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(5990);
      dateTimeTtype();
      setState(5991);
      match(MySQLParser::COMMA_SYMBOL);
      setState(5992);
      expr(0);
      setState(5993);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(5995);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::NOW_SYMBOL);
      setState(5997);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 758, _ctx)) {
      case 1: {
        setState(5996);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(5999);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::POSITION_SYMBOL);
      setState(6000);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6001);
      bitExpr(0);
      setState(6002);
      match(MySQLParser::IN_SYMBOL);
      setState(6003);
      expr(0);
      setState(6004);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(6006);
      substringFunction();
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(6007);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::SYSDATE_SYMBOL);
      setState(6009);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 759, _ctx)) {
      case 1: {
        setState(6008);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(6011);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::TIMESTAMP_ADD_SYMBOL

      || _la == MySQLParser::TIMESTAMP_DIFF_SYMBOL)) {
        dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(6012);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6013);
      intervalTimeStamp();
      setState(6014);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6015);
      expr(0);
      setState(6016);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6017);
      expr(0);
      setState(6018);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(6020);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::UTC_DATE_SYMBOL);
      setState(6022);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 760, _ctx)) {
      case 1: {
        setState(6021);
        parentheses();
        break;
      }

      }
      break;
    }

    case 31: {
      enterOuterAlt(_localctx, 31);
      setState(6024);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::UTC_TIME_SYMBOL);
      setState(6026);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 761, _ctx)) {
      case 1: {
        setState(6025);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 32: {
      enterOuterAlt(_localctx, 32);
      setState(6028);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::UTC_TIMESTAMP_SYMBOL);
      setState(6030);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 762, _ctx)) {
      case 1: {
        setState(6029);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 33: {
      enterOuterAlt(_localctx, 33);
      setState(6032);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::ASCII_SYMBOL);
      setState(6033);
      exprWithParentheses();
      break;
    }

    case 34: {
      enterOuterAlt(_localctx, 34);
      setState(6034);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::CHARSET_SYMBOL);
      setState(6035);
      exprWithParentheses();
      break;
    }

    case 35: {
      enterOuterAlt(_localctx, 35);
      setState(6036);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::COALESCE_SYMBOL);
      setState(6037);
      exprListWithParentheses();
      break;
    }

    case 36: {
      enterOuterAlt(_localctx, 36);
      setState(6038);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::COLLATION_SYMBOL);
      setState(6039);
      exprWithParentheses();
      break;
    }

    case 37: {
      enterOuterAlt(_localctx, 37);
      setState(6040);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::DATABASE_SYMBOL);
      setState(6041);
      parentheses();
      break;
    }

    case 38: {
      enterOuterAlt(_localctx, 38);
      setState(6042);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::IF_SYMBOL);
      setState(6043);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6044);
      expr(0);
      setState(6045);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6046);
      expr(0);
      setState(6047);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6048);
      expr(0);
      setState(6049);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 39: {
      enterOuterAlt(_localctx, 39);
      setState(6051);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::FORMAT_SYMBOL);
      setState(6052);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6053);
      expr(0);
      setState(6054);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6055);
      expr(0);
      setState(6058);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6056);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6057);
        expr(0);
      }
      setState(6060);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 40: {
      enterOuterAlt(_localctx, 40);
      setState(6062);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MICROSECOND_SYMBOL);
      setState(6063);
      exprWithParentheses();
      break;
    }

    case 41: {
      enterOuterAlt(_localctx, 41);
      setState(6064);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::MOD_SYMBOL);
      setState(6065);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6066);
      expr(0);
      setState(6067);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6068);
      expr(0);
      setState(6069);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 42: {
      enterOuterAlt(_localctx, 42);
      setState(6071);

      if (!(serverVersion < 50607)) throw FailedPredicateException(this, "serverVersion < 50607");
      setState(6072);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::OLD_PASSWORD_SYMBOL);
      setState(6073);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6074);
      textLiteral();
      setState(6075);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 43: {
      enterOuterAlt(_localctx, 43);
      setState(6077);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(6078);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::PASSWORD_SYMBOL);
      setState(6079);
      exprWithParentheses();
      break;
    }

    case 44: {
      enterOuterAlt(_localctx, 44);
      setState(6080);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::QUARTER_SYMBOL);
      setState(6081);
      exprWithParentheses();
      break;
    }

    case 45: {
      enterOuterAlt(_localctx, 45);
      setState(6082);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::REPEAT_SYMBOL);
      setState(6083);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6084);
      expr(0);
      setState(6085);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6086);
      expr(0);
      setState(6087);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 46: {
      enterOuterAlt(_localctx, 46);
      setState(6089);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::REPLACE_SYMBOL);
      setState(6090);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6091);
      expr(0);
      setState(6092);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6093);
      expr(0);
      setState(6094);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6095);
      expr(0);
      setState(6096);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 47: {
      enterOuterAlt(_localctx, 47);
      setState(6098);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::REVERSE_SYMBOL);
      setState(6099);
      exprWithParentheses();
      break;
    }

    case 48: {
      enterOuterAlt(_localctx, 48);
      setState(6100);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::ROW_COUNT_SYMBOL);
      setState(6101);
      parentheses();
      break;
    }

    case 49: {
      enterOuterAlt(_localctx, 49);
      setState(6102);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::TRUNCATE_SYMBOL);
      setState(6103);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6104);
      expr(0);
      setState(6105);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6106);
      expr(0);
      setState(6107);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 50: {
      enterOuterAlt(_localctx, 50);
      setState(6109);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::WEEK_SYMBOL);
      setState(6110);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6111);
      expr(0);
      setState(6114);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6112);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6113);
        expr(0);
      }
      setState(6116);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 51: {
      enterOuterAlt(_localctx, 51);
      setState(6118);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(6119);
      dynamic_cast<RuntimeFunctionCallContext *>(_localctx)->name = match(MySQLParser::WEIGHT_STRING_SYMBOL);
      setState(6120);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6121);
      expr(0);
      setState(6141);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 767, _ctx)) {
      case 1: {
        setState(6125);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 765, _ctx)) {
        case 1: {
          setState(6122);
          match(MySQLParser::AS_SYMBOL);
          setState(6123);
          match(MySQLParser::CHAR_SYMBOL);
          setState(6124);
          wsNumCodepoints();
          break;
        }

        }
        setState(6129);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 766, _ctx)) {
        case 1: {
          setState(6127);

          if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
          setState(6128);
          weightStringLevels();
          break;
        }

        }
        break;
      }

      case 2: {
        setState(6131);
        match(MySQLParser::AS_SYMBOL);
        setState(6132);
        match(MySQLParser::BINARY_SYMBOL);
        setState(6133);
        wsNumCodepoints();
        break;
      }

      case 3: {
        setState(6134);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6135);
        ulong_number();
        setState(6136);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6137);
        ulong_number();
        setState(6138);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6139);
        ulong_number();
        break;
      }

      }
      setState(6143);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 52: {
      enterOuterAlt(_localctx, 52);
      setState(6145);
      geometryFunction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GeometryFunctionContext ------------------------------------------------------------------

MySQLParser::GeometryFunctionContext::GeometryFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::GeometryFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::GeometryFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::GeometryFunctionContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

MySQLParser::ExprListWithParenthesesContext* MySQLParser::GeometryFunctionContext::exprListWithParentheses() {
  return getRuleContext<MySQLParser::ExprListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GeometryFunctionContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}


size_t MySQLParser::GeometryFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleGeometryFunction;
}

void MySQLParser::GeometryFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGeometryFunction(this);
}

void MySQLParser::GeometryFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGeometryFunction(this);
}

MySQLParser::GeometryFunctionContext* MySQLParser::geometryFunction() {
  GeometryFunctionContext *_localctx = _tracker.createInstance<GeometryFunctionContext>(_ctx, getState());
  enterRule(_localctx, 700, MySQLParser::RuleGeometryFunction);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6179);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 770, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6148);

      if (!(serverVersion < 50706)) throw FailedPredicateException(this, "serverVersion < 50706");
      setState(6149);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::CONTAINS_SYMBOL);
      setState(6150);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6151);
      expr(0);
      setState(6152);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6153);
      expr(0);
      setState(6154);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6156);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::GEOMETRYCOLLECTION_SYMBOL);
      setState(6157);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6159);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 769, _ctx)) {
      case 1: {
        setState(6158);
        exprList();
        break;
      }

      }
      setState(6161);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6162);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::LINESTRING_SYMBOL);
      setState(6163);
      exprListWithParentheses();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6164);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::MULTILINESTRING_SYMBOL);
      setState(6165);
      exprListWithParentheses();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6166);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::MULTIPOINT_SYMBOL);
      setState(6167);
      exprListWithParentheses();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6168);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::MULTIPOLYGON_SYMBOL);
      setState(6169);
      exprListWithParentheses();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6170);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::POINT_SYMBOL);
      setState(6171);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6172);
      expr(0);
      setState(6173);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6174);
      expr(0);
      setState(6175);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6177);
      dynamic_cast<GeometryFunctionContext *>(_localctx)->name = match(MySQLParser::POLYGON_SYMBOL);
      setState(6178);
      exprListWithParentheses();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TimeFunctionParametersContext ------------------------------------------------------------------

MySQLParser::TimeFunctionParametersContext::TimeFunctionParametersContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TimeFunctionParametersContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TimeFunctionParametersContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::FractionalPrecisionContext* MySQLParser::TimeFunctionParametersContext::fractionalPrecision() {
  return getRuleContext<MySQLParser::FractionalPrecisionContext>(0);
}


size_t MySQLParser::TimeFunctionParametersContext::getRuleIndex() const {
  return MySQLParser::RuleTimeFunctionParameters;
}

void MySQLParser::TimeFunctionParametersContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTimeFunctionParameters(this);
}

void MySQLParser::TimeFunctionParametersContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTimeFunctionParameters(this);
}

MySQLParser::TimeFunctionParametersContext* MySQLParser::timeFunctionParameters() {
  TimeFunctionParametersContext *_localctx = _tracker.createInstance<TimeFunctionParametersContext>(_ctx, getState());
  enterRule(_localctx, 702, MySQLParser::RuleTimeFunctionParameters);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6181);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6183);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 771, _ctx)) {
    case 1: {
      setState(6182);
      fractionalPrecision();
      break;
    }

    }
    setState(6185);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FractionalPrecisionContext ------------------------------------------------------------------

MySQLParser::FractionalPrecisionContext::FractionalPrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FractionalPrecisionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}


size_t MySQLParser::FractionalPrecisionContext::getRuleIndex() const {
  return MySQLParser::RuleFractionalPrecision;
}

void MySQLParser::FractionalPrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFractionalPrecision(this);
}

void MySQLParser::FractionalPrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFractionalPrecision(this);
}

MySQLParser::FractionalPrecisionContext* MySQLParser::fractionalPrecision() {
  FractionalPrecisionContext *_localctx = _tracker.createInstance<FractionalPrecisionContext>(_ctx, getState());
  enterRule(_localctx, 704, MySQLParser::RuleFractionalPrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6187);

    if (!(serverVersion >= 50604)) throw FailedPredicateException(this, "serverVersion >= 50604");
    setState(6188);
    match(MySQLParser::INT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WeightStringLevelsContext ------------------------------------------------------------------

MySQLParser::WeightStringLevelsContext::WeightStringLevelsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WeightStringLevelsContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

std::vector<MySQLParser::Real_ulong_numberContext *> MySQLParser::WeightStringLevelsContext::real_ulong_number() {
  return getRuleContexts<MySQLParser::Real_ulong_numberContext>();
}

MySQLParser::Real_ulong_numberContext* MySQLParser::WeightStringLevelsContext::real_ulong_number(size_t i) {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(i);
}

tree::TerminalNode* MySQLParser::WeightStringLevelsContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}

std::vector<MySQLParser::WeightStringLevelListItemContext *> MySQLParser::WeightStringLevelsContext::weightStringLevelListItem() {
  return getRuleContexts<MySQLParser::WeightStringLevelListItemContext>();
}

MySQLParser::WeightStringLevelListItemContext* MySQLParser::WeightStringLevelsContext::weightStringLevelListItem(size_t i) {
  return getRuleContext<MySQLParser::WeightStringLevelListItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::WeightStringLevelsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::WeightStringLevelsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::WeightStringLevelsContext::getRuleIndex() const {
  return MySQLParser::RuleWeightStringLevels;
}

void MySQLParser::WeightStringLevelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightStringLevels(this);
}

void MySQLParser::WeightStringLevelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightStringLevels(this);
}

MySQLParser::WeightStringLevelsContext* MySQLParser::weightStringLevels() {
  WeightStringLevelsContext *_localctx = _tracker.createInstance<WeightStringLevelsContext>(_ctx, getState());
  enterRule(_localctx, 706, MySQLParser::RuleWeightStringLevels);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6190);
    match(MySQLParser::LEVEL_SYMBOL);
    setState(6203);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 773, _ctx)) {
    case 1: {
      setState(6191);
      real_ulong_number();
      setState(6192);
      match(MySQLParser::MINUS_OPERATOR);
      setState(6193);
      real_ulong_number();
      break;
    }

    case 2: {
      setState(6195);
      weightStringLevelListItem();
      setState(6200);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6196);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6197);
        weightStringLevelListItem();
        setState(6202);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WeightStringLevelListItemContext ------------------------------------------------------------------

MySQLParser::WeightStringLevelListItemContext::WeightStringLevelListItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Real_ulong_numberContext* MySQLParser::WeightStringLevelListItemContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WeightStringLevelListItemContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WeightStringLevelListItemContext::ASC_SYMBOL() {
  return getToken(MySQLParser::ASC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::WeightStringLevelListItemContext::DESC_SYMBOL() {
  return getToken(MySQLParser::DESC_SYMBOL, 0);
}


size_t MySQLParser::WeightStringLevelListItemContext::getRuleIndex() const {
  return MySQLParser::RuleWeightStringLevelListItem;
}

void MySQLParser::WeightStringLevelListItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWeightStringLevelListItem(this);
}

void MySQLParser::WeightStringLevelListItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWeightStringLevelListItem(this);
}

MySQLParser::WeightStringLevelListItemContext* MySQLParser::weightStringLevelListItem() {
  WeightStringLevelListItemContext *_localctx = _tracker.createInstance<WeightStringLevelListItemContext>(_ctx, getState());
  enterRule(_localctx, 708, MySQLParser::RuleWeightStringLevelListItem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6205);
    real_ulong_number();
    setState(6211);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ASC_SYMBOL:
      case MySQLParser::DESC_SYMBOL: {
        setState(6206);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6208);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::REVERSE_SYMBOL) {
          setState(6207);
          match(MySQLParser::REVERSE_SYMBOL);
        }
        break;
      }

      case MySQLParser::REVERSE_SYMBOL: {
        setState(6210);
        match(MySQLParser::REVERSE_SYMBOL);
        break;
      }

      case MySQLParser::COMMA_SYMBOL:
      case MySQLParser::CLOSE_PAR_SYMBOL: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DateTimeTtypeContext ------------------------------------------------------------------

MySQLParser::DateTimeTtypeContext::DateTimeTtypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DateTimeTtypeContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}


size_t MySQLParser::DateTimeTtypeContext::getRuleIndex() const {
  return MySQLParser::RuleDateTimeTtype;
}

void MySQLParser::DateTimeTtypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDateTimeTtype(this);
}

void MySQLParser::DateTimeTtypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDateTimeTtype(this);
}

MySQLParser::DateTimeTtypeContext* MySQLParser::dateTimeTtype() {
  DateTimeTtypeContext *_localctx = _tracker.createInstance<DateTimeTtypeContext>(_ctx, getState());
  enterRule(_localctx, 710, MySQLParser::RuleDateTimeTtype);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6213);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DATETIME_SYMBOL

    || _la == MySQLParser::DATE_SYMBOL || _la == MySQLParser::TIMESTAMP_SYMBOL

    || _la == MySQLParser::TIME_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TrimFunctionContext ------------------------------------------------------------------

MySQLParser::TrimFunctionContext::TrimFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::TRIM_SYMBOL() {
  return getToken(MySQLParser::TRIM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::TrimFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::TrimFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::LEADING_SYMBOL() {
  return getToken(MySQLParser::LEADING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::TRAILING_SYMBOL() {
  return getToken(MySQLParser::TRAILING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TrimFunctionContext::BOTH_SYMBOL() {
  return getToken(MySQLParser::BOTH_SYMBOL, 0);
}


size_t MySQLParser::TrimFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleTrimFunction;
}

void MySQLParser::TrimFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTrimFunction(this);
}

void MySQLParser::TrimFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTrimFunction(this);
}

MySQLParser::TrimFunctionContext* MySQLParser::trimFunction() {
  TrimFunctionContext *_localctx = _tracker.createInstance<TrimFunctionContext>(_ctx, getState());
  enterRule(_localctx, 712, MySQLParser::RuleTrimFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6215);
    match(MySQLParser::TRIM_SYMBOL);
    setState(6216);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6240);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 780, _ctx)) {
    case 1: {
      setState(6217);
      expr(0);
      setState(6220);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::FROM_SYMBOL) {
        setState(6218);
        match(MySQLParser::FROM_SYMBOL);
        setState(6219);
        expr(0);
      }
      break;
    }

    case 2: {
      setState(6222);
      match(MySQLParser::LEADING_SYMBOL);
      setState(6224);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 777, _ctx)) {
      case 1: {
        setState(6223);
        expr(0);
        break;
      }

      }
      setState(6226);
      match(MySQLParser::FROM_SYMBOL);
      setState(6227);
      expr(0);
      break;
    }

    case 3: {
      setState(6228);
      match(MySQLParser::TRAILING_SYMBOL);
      setState(6230);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 778, _ctx)) {
      case 1: {
        setState(6229);
        expr(0);
        break;
      }

      }
      setState(6232);
      match(MySQLParser::FROM_SYMBOL);
      setState(6233);
      expr(0);
      break;
    }

    case 4: {
      setState(6234);
      match(MySQLParser::BOTH_SYMBOL);
      setState(6236);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 779, _ctx)) {
      case 1: {
        setState(6235);
        expr(0);
        break;
      }

      }
      setState(6238);
      match(MySQLParser::FROM_SYMBOL);
      setState(6239);
      expr(0);
      break;
    }

    }
    setState(6242);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubstringFunctionContext ------------------------------------------------------------------

MySQLParser::SubstringFunctionContext::SubstringFunctionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::SUBSTRING_SYMBOL() {
  return getToken(MySQLParser::SUBSTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::SubstringFunctionContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::SubstringFunctionContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::SubstringFunctionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubstringFunctionContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}


size_t MySQLParser::SubstringFunctionContext::getRuleIndex() const {
  return MySQLParser::RuleSubstringFunction;
}

void MySQLParser::SubstringFunctionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubstringFunction(this);
}

void MySQLParser::SubstringFunctionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubstringFunction(this);
}

MySQLParser::SubstringFunctionContext* MySQLParser::substringFunction() {
  SubstringFunctionContext *_localctx = _tracker.createInstance<SubstringFunctionContext>(_ctx, getState());
  enterRule(_localctx, 714, MySQLParser::RuleSubstringFunction);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6244);
    match(MySQLParser::SUBSTRING_SYMBOL);
    setState(6245);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6246);
    expr(0);
    setState(6259);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::COMMA_SYMBOL: {
        setState(6247);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6248);
        expr(0);
        setState(6251);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::COMMA_SYMBOL) {
          setState(6249);
          match(MySQLParser::COMMA_SYMBOL);
          setState(6250);
          expr(0);
        }
        break;
      }

      case MySQLParser::FROM_SYMBOL: {
        setState(6253);
        match(MySQLParser::FROM_SYMBOL);
        setState(6254);
        expr(0);
        setState(6257);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::FOR_SYMBOL) {
          setState(6255);
          match(MySQLParser::FOR_SYMBOL);
          setState(6256);
          expr(0);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(6261);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionCallContext ------------------------------------------------------------------

MySQLParser::FunctionCallContext::FunctionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::FunctionCallContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::FunctionCallContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FunctionCallContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::UdfExprListContext* MySQLParser::FunctionCallContext::udfExprList() {
  return getRuleContext<MySQLParser::UdfExprListContext>(0);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FunctionCallContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::ExprListContext* MySQLParser::FunctionCallContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}


size_t MySQLParser::FunctionCallContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionCall;
}

void MySQLParser::FunctionCallContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionCall(this);
}

void MySQLParser::FunctionCallContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionCall(this);
}

MySQLParser::FunctionCallContext* MySQLParser::functionCall() {
  FunctionCallContext *_localctx = _tracker.createInstance<FunctionCallContext>(_ctx, getState());
  enterRule(_localctx, 716, MySQLParser::RuleFunctionCall);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6277);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 786, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6263);
      pureIdentifier();
      setState(6264);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6266);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 784, _ctx)) {
      case 1: {
        setState(6265);
        udfExprList();
        break;
      }

      }
      setState(6268);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6270);
      qualifiedIdentifier();
      setState(6271);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(6273);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 785, _ctx)) {
      case 1: {
        setState(6272);
        exprList();
        break;
      }

      }
      setState(6275);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfExprListContext ------------------------------------------------------------------

MySQLParser::UdfExprListContext::UdfExprListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UdfExprContext *> MySQLParser::UdfExprListContext::udfExpr() {
  return getRuleContexts<MySQLParser::UdfExprContext>();
}

MySQLParser::UdfExprContext* MySQLParser::UdfExprListContext::udfExpr(size_t i) {
  return getRuleContext<MySQLParser::UdfExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UdfExprListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UdfExprListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UdfExprListContext::getRuleIndex() const {
  return MySQLParser::RuleUdfExprList;
}

void MySQLParser::UdfExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfExprList(this);
}

void MySQLParser::UdfExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfExprList(this);
}

MySQLParser::UdfExprListContext* MySQLParser::udfExprList() {
  UdfExprListContext *_localctx = _tracker.createInstance<UdfExprListContext>(_ctx, getState());
  enterRule(_localctx, 718, MySQLParser::RuleUdfExprList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6279);
    udfExpr();
    setState(6284);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6280);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6281);
      udfExpr();
      setState(6286);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfExprContext ------------------------------------------------------------------

MySQLParser::UdfExprContext::UdfExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::UdfExprContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SelectAliasContext* MySQLParser::UdfExprContext::selectAlias() {
  return getRuleContext<MySQLParser::SelectAliasContext>(0);
}


size_t MySQLParser::UdfExprContext::getRuleIndex() const {
  return MySQLParser::RuleUdfExpr;
}

void MySQLParser::UdfExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfExpr(this);
}

void MySQLParser::UdfExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfExpr(this);
}

MySQLParser::UdfExprContext* MySQLParser::udfExpr() {
  UdfExprContext *_localctx = _tracker.createInstance<UdfExprContext>(_ctx, getState());
  enterRule(_localctx, 720, MySQLParser::RuleUdfExpr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6287);
    expr(0);
    setState(6289);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 788, _ctx)) {
    case 1: {
      setState(6288);
      selectAlias();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableContext ------------------------------------------------------------------

MySQLParser::VariableContext::VariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserVariableContext* MySQLParser::VariableContext::userVariable() {
  return getRuleContext<MySQLParser::UserVariableContext>(0);
}

tree::TerminalNode* MySQLParser::VariableContext::ASSIGN_OPERATOR() {
  return getToken(MySQLParser::ASSIGN_OPERATOR, 0);
}

MySQLParser::ExprContext* MySQLParser::VariableContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::SystemVariableContext* MySQLParser::VariableContext::systemVariable() {
  return getRuleContext<MySQLParser::SystemVariableContext>(0);
}


size_t MySQLParser::VariableContext::getRuleIndex() const {
  return MySQLParser::RuleVariable;
}

void MySQLParser::VariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariable(this);
}

void MySQLParser::VariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariable(this);
}

MySQLParser::VariableContext* MySQLParser::variable() {
  VariableContext *_localctx = _tracker.createInstance<VariableContext>(_ctx, getState());
  enterRule(_localctx, 722, MySQLParser::RuleVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6297);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SIGN_SYMBOL:
      case MySQLParser::AT_TEXT_SUFFIX: {
        enterOuterAlt(_localctx, 1);
        setState(6291);
        userVariable();
        setState(6294);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 789, _ctx)) {
        case 1: {
          setState(6292);
          match(MySQLParser::ASSIGN_OPERATOR);
          setState(6293);
          expr(0);
          break;
        }

        }
        break;
      }

      case MySQLParser::AT_AT_SIGN_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6296);
        systemVariable();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserVariableContext ------------------------------------------------------------------

MySQLParser::UserVariableContext::UserVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UserVariableContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::UserVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::UserVariableContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}


size_t MySQLParser::UserVariableContext::getRuleIndex() const {
  return MySQLParser::RuleUserVariable;
}

void MySQLParser::UserVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserVariable(this);
}

void MySQLParser::UserVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserVariable(this);
}

MySQLParser::UserVariableContext* MySQLParser::userVariable() {
  UserVariableContext *_localctx = _tracker.createInstance<UserVariableContext>(_ctx, getState());
  enterRule(_localctx, 724, MySQLParser::RuleUserVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6302);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SIGN_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6299);
        match(MySQLParser::AT_SIGN_SYMBOL);
        setState(6300);
        textOrIdentifier();
        break;
      }

      case MySQLParser::AT_TEXT_SUFFIX: {
        enterOuterAlt(_localctx, 2);
        setState(6301);
        match(MySQLParser::AT_TEXT_SUFFIX);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SystemVariableContext ------------------------------------------------------------------

MySQLParser::SystemVariableContext::SystemVariableContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SystemVariableContext::AT_AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_AT_SIGN_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::SystemVariableContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::VarIdentTypeContext* MySQLParser::SystemVariableContext::varIdentType() {
  return getRuleContext<MySQLParser::VarIdentTypeContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::SystemVariableContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::SystemVariableContext::getRuleIndex() const {
  return MySQLParser::RuleSystemVariable;
}

void MySQLParser::SystemVariableContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSystemVariable(this);
}

void MySQLParser::SystemVariableContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSystemVariable(this);
}

MySQLParser::SystemVariableContext* MySQLParser::systemVariable() {
  SystemVariableContext *_localctx = _tracker.createInstance<SystemVariableContext>(_ctx, getState());
  enterRule(_localctx, 726, MySQLParser::RuleSystemVariable);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6304);
    match(MySQLParser::AT_AT_SIGN_SYMBOL);
    setState(6306);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 792, _ctx)) {
    case 1: {
      setState(6305);
      varIdentType();
      break;
    }

    }
    setState(6308);
    textOrIdentifier();
    setState(6310);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 793, _ctx)) {
    case 1: {
      setState(6309);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InternalVariableNameContext ------------------------------------------------------------------

MySQLParser::InternalVariableNameContext::InternalVariableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::InternalVariableNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::LValueIdentifierContext* MySQLParser::InternalVariableNameContext::lValueIdentifier() {
  return getRuleContext<MySQLParser::LValueIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::InternalVariableNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::InternalVariableNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::InternalVariableNameContext::getRuleIndex() const {
  return MySQLParser::RuleInternalVariableName;
}

void MySQLParser::InternalVariableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInternalVariableName(this);
}

void MySQLParser::InternalVariableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInternalVariableName(this);
}

MySQLParser::InternalVariableNameContext* MySQLParser::internalVariableName() {
  InternalVariableNameContext *_localctx = _tracker.createInstance<InternalVariableNameContext>(_ctx, getState());
  enterRule(_localctx, 728, MySQLParser::RuleInternalVariableName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6326);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 797, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6322);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 796, _ctx)) {
      case 1: {
        setState(6312);

        if (!(serverVersion < 80017)) throw FailedPredicateException(this, "serverVersion < 80017");
        setState(6313);
        identifier();
        setState(6315);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DOT_SYMBOL) {
          setState(6314);
          dotIdentifier();
        }
        break;
      }

      case 2: {
        setState(6317);

        if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
        setState(6318);
        lValueIdentifier();
        setState(6320);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DOT_SYMBOL) {
          setState(6319);
          dotIdentifier();
        }
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6324);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(6325);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhenExpressionContext ------------------------------------------------------------------

MySQLParser::WhenExpressionContext::WhenExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WhenExpressionContext::WHEN_SYMBOL() {
  return getToken(MySQLParser::WHEN_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::WhenExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::WhenExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleWhenExpression;
}

void MySQLParser::WhenExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhenExpression(this);
}

void MySQLParser::WhenExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhenExpression(this);
}

MySQLParser::WhenExpressionContext* MySQLParser::whenExpression() {
  WhenExpressionContext *_localctx = _tracker.createInstance<WhenExpressionContext>(_ctx, getState());
  enterRule(_localctx, 730, MySQLParser::RuleWhenExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6328);
    match(MySQLParser::WHEN_SYMBOL);
    setState(6329);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThenExpressionContext ------------------------------------------------------------------

MySQLParser::ThenExpressionContext::ThenExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ThenExpressionContext::THEN_SYMBOL() {
  return getToken(MySQLParser::THEN_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ThenExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::ThenExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleThenExpression;
}

void MySQLParser::ThenExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThenExpression(this);
}

void MySQLParser::ThenExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThenExpression(this);
}

MySQLParser::ThenExpressionContext* MySQLParser::thenExpression() {
  ThenExpressionContext *_localctx = _tracker.createInstance<ThenExpressionContext>(_ctx, getState());
  enterRule(_localctx, 732, MySQLParser::RuleThenExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6331);
    match(MySQLParser::THEN_SYMBOL);
    setState(6332);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseExpressionContext ------------------------------------------------------------------

MySQLParser::ElseExpressionContext::ElseExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ElseExpressionContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ElseExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::ElseExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleElseExpression;
}

void MySQLParser::ElseExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseExpression(this);
}

void MySQLParser::ElseExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseExpression(this);
}

MySQLParser::ElseExpressionContext* MySQLParser::elseExpression() {
  ElseExpressionContext *_localctx = _tracker.createInstance<ElseExpressionContext>(_ctx, getState());
  enterRule(_localctx, 734, MySQLParser::RuleElseExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6334);
    match(MySQLParser::ELSE_SYMBOL);
    setState(6335);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CastTypeContext ------------------------------------------------------------------

MySQLParser::CastTypeContext::CastTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CastTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

MySQLParser::FieldLengthContext* MySQLParser::CastTypeContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

MySQLParser::CharsetWithOptBinaryContext* MySQLParser::CastTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLParser::CharsetWithOptBinaryContext>(0);
}

MySQLParser::NcharContext* MySQLParser::CastTypeContext::nchar() {
  return getRuleContext<MySQLParser::NcharContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::UNSIGNED_SYMBOL() {
  return getToken(MySQLParser::UNSIGNED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

MySQLParser::TypeDatetimePrecisionContext* MySQLParser::CastTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

MySQLParser::FloatOptionsContext* MySQLParser::CastTypeContext::floatOptions() {
  return getRuleContext<MySQLParser::FloatOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

MySQLParser::RealTypeContext* MySQLParser::CastTypeContext::realType() {
  return getRuleContext<MySQLParser::RealTypeContext>(0);
}

tree::TerminalNode* MySQLParser::CastTypeContext::FLOAT_SYMBOL() {
  return getToken(MySQLParser::FLOAT_SYMBOL, 0);
}

MySQLParser::StandardFloatOptionsContext* MySQLParser::CastTypeContext::standardFloatOptions() {
  return getRuleContext<MySQLParser::StandardFloatOptionsContext>(0);
}


size_t MySQLParser::CastTypeContext::getRuleIndex() const {
  return MySQLParser::RuleCastType;
}

void MySQLParser::CastTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCastType(this);
}

void MySQLParser::CastTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCastType(this);
}

MySQLParser::CastTypeContext* MySQLParser::castType() {
  CastTypeContext *_localctx = _tracker.createInstance<CastTypeContext>(_ctx, getState());
  enterRule(_localctx, 736, MySQLParser::RuleCastType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6382);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 808, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6337);
      match(MySQLParser::BINARY_SYMBOL);
      setState(6339);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 798, _ctx)) {
      case 1: {
        setState(6338);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6341);
      match(MySQLParser::CHAR_SYMBOL);
      setState(6343);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 799, _ctx)) {
      case 1: {
        setState(6342);
        fieldLength();
        break;
      }

      }
      setState(6346);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 800, _ctx)) {
      case 1: {
        setState(6345);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6348);
      nchar();
      setState(6350);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 801, _ctx)) {
      case 1: {
        setState(6349);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6352);
      match(MySQLParser::SIGNED_SYMBOL);
      setState(6354);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 802, _ctx)) {
      case 1: {
        setState(6353);
        match(MySQLParser::INT_SYMBOL);
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6356);
      match(MySQLParser::UNSIGNED_SYMBOL);
      setState(6358);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 803, _ctx)) {
      case 1: {
        setState(6357);
        match(MySQLParser::INT_SYMBOL);
        break;
      }

      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6360);
      match(MySQLParser::DATE_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6361);
      match(MySQLParser::TIME_SYMBOL);
      setState(6363);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 804, _ctx)) {
      case 1: {
        setState(6362);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6365);
      match(MySQLParser::DATETIME_SYMBOL);
      setState(6367);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 805, _ctx)) {
      case 1: {
        setState(6366);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6369);
      match(MySQLParser::DECIMAL_SYMBOL);
      setState(6371);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 806, _ctx)) {
      case 1: {
        setState(6370);
        floatOptions();
        break;
      }

      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6373);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(6374);
      match(MySQLParser::JSON_SYMBOL);
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6375);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(6376);
      realType();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6377);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(6378);
      match(MySQLParser::FLOAT_SYMBOL);
      setState(6380);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 807, _ctx)) {
      case 1: {
        setState(6379);
        standardFloatOptions();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprListContext ------------------------------------------------------------------

MySQLParser::ExprListContext::ExprListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ExprListContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ExprListContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ExprListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ExprListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ExprListContext::getRuleIndex() const {
  return MySQLParser::RuleExprList;
}

void MySQLParser::ExprListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprList(this);
}

void MySQLParser::ExprListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprList(this);
}

MySQLParser::ExprListContext* MySQLParser::exprList() {
  ExprListContext *_localctx = _tracker.createInstance<ExprListContext>(_ctx, getState());
  enterRule(_localctx, 738, MySQLParser::RuleExprList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6384);
    expr(0);
    setState(6389);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6385);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6386);
      expr(0);
      setState(6391);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetContext ------------------------------------------------------------------

MySQLParser::CharsetContext::CharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CharsetContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CharsetContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CharsetContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}


size_t MySQLParser::CharsetContext::getRuleIndex() const {
  return MySQLParser::RuleCharset;
}

void MySQLParser::CharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharset(this);
}

void MySQLParser::CharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharset(this);
}

MySQLParser::CharsetContext* MySQLParser::charset() {
  CharsetContext *_localctx = _tracker.createInstance<CharsetContext>(_ctx, getState());
  enterRule(_localctx, 740, MySQLParser::RuleCharset);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6395);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6392);
        match(MySQLParser::CHAR_SYMBOL);
        setState(6393);
        match(MySQLParser::SET_SYMBOL);
        break;
      }

      case MySQLParser::CHARSET_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6394);
        match(MySQLParser::CHARSET_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NotRuleContext ------------------------------------------------------------------

MySQLParser::NotRuleContext::NotRuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NotRuleContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NotRuleContext::NOT2_SYMBOL() {
  return getToken(MySQLParser::NOT2_SYMBOL, 0);
}


size_t MySQLParser::NotRuleContext::getRuleIndex() const {
  return MySQLParser::RuleNotRule;
}

void MySQLParser::NotRuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNotRule(this);
}

void MySQLParser::NotRuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNotRule(this);
}

MySQLParser::NotRuleContext* MySQLParser::notRule() {
  NotRuleContext *_localctx = _tracker.createInstance<NotRuleContext>(_ctx, getState());
  enterRule(_localctx, 742, MySQLParser::RuleNotRule);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6397);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Not2RuleContext ------------------------------------------------------------------

MySQLParser::Not2RuleContext::Not2RuleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Not2RuleContext::LOGICAL_NOT_OPERATOR() {
  return getToken(MySQLParser::LOGICAL_NOT_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::Not2RuleContext::NOT2_SYMBOL() {
  return getToken(MySQLParser::NOT2_SYMBOL, 0);
}


size_t MySQLParser::Not2RuleContext::getRuleIndex() const {
  return MySQLParser::RuleNot2Rule;
}

void MySQLParser::Not2RuleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNot2Rule(this);
}

void MySQLParser::Not2RuleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNot2Rule(this);
}

MySQLParser::Not2RuleContext* MySQLParser::not2Rule() {
  Not2RuleContext *_localctx = _tracker.createInstance<Not2RuleContext>(_ctx, getState());
  enterRule(_localctx, 744, MySQLParser::RuleNot2Rule);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6399);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NOT2_SYMBOL

    || _la == MySQLParser::LOGICAL_NOT_OPERATOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalContext ------------------------------------------------------------------

MySQLParser::IntervalContext::IntervalContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IntervalTimeStampContext* MySQLParser::IntervalContext::intervalTimeStamp() {
  return getRuleContext<MySQLParser::IntervalTimeStampContext>(0);
}

tree::TerminalNode* MySQLParser::IntervalContext::SECOND_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::MINUTE_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MINUTE_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::MINUTE_SECOND_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::HOUR_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::HOUR_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::HOUR_SECOND_SYMBOL() {
  return getToken(MySQLParser::HOUR_SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::HOUR_MINUTE_SYMBOL() {
  return getToken(MySQLParser::HOUR_MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::DAY_MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_SECOND_SYMBOL() {
  return getToken(MySQLParser::DAY_SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_MINUTE_SYMBOL() {
  return getToken(MySQLParser::DAY_MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::DAY_HOUR_SYMBOL() {
  return getToken(MySQLParser::DAY_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalContext::YEAR_MONTH_SYMBOL() {
  return getToken(MySQLParser::YEAR_MONTH_SYMBOL, 0);
}


size_t MySQLParser::IntervalContext::getRuleIndex() const {
  return MySQLParser::RuleInterval;
}

void MySQLParser::IntervalContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInterval(this);
}

void MySQLParser::IntervalContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInterval(this);
}

MySQLParser::IntervalContext* MySQLParser::interval() {
  IntervalContext *_localctx = _tracker.createInstance<IntervalContext>(_ctx, getState());
  enterRule(_localctx, 746, MySQLParser::RuleInterval);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6403);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DAY_SYMBOL:
      case MySQLParser::HOUR_SYMBOL:
      case MySQLParser::MICROSECOND_SYMBOL:
      case MySQLParser::MINUTE_SYMBOL:
      case MySQLParser::MONTH_SYMBOL:
      case MySQLParser::QUARTER_SYMBOL:
      case MySQLParser::SECOND_SYMBOL:
      case MySQLParser::WEEK_SYMBOL:
      case MySQLParser::YEAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6401);
        intervalTimeStamp();
        break;
      }

      case MySQLParser::DAY_HOUR_SYMBOL:
      case MySQLParser::DAY_MICROSECOND_SYMBOL:
      case MySQLParser::DAY_MINUTE_SYMBOL:
      case MySQLParser::DAY_SECOND_SYMBOL:
      case MySQLParser::HOUR_MICROSECOND_SYMBOL:
      case MySQLParser::HOUR_MINUTE_SYMBOL:
      case MySQLParser::HOUR_SECOND_SYMBOL:
      case MySQLParser::MINUTE_MICROSECOND_SYMBOL:
      case MySQLParser::MINUTE_SECOND_SYMBOL:
      case MySQLParser::SECOND_MICROSECOND_SYMBOL:
      case MySQLParser::YEAR_MONTH_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6402);
        _la = _input->LA(1);
        if (!(((((_la - 163) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 163)) & ((1ULL << (MySQLParser::DAY_HOUR_SYMBOL - 163))
          | (1ULL << (MySQLParser::DAY_MICROSECOND_SYMBOL - 163))
          | (1ULL << (MySQLParser::DAY_MINUTE_SYMBOL - 163))
          | (1ULL << (MySQLParser::DAY_SECOND_SYMBOL - 163)))) != 0) || ((((_la - 265) & ~ 0x3fULL) == 0) &&
          ((1ULL << (_la - 265)) & ((1ULL << (MySQLParser::HOUR_MICROSECOND_SYMBOL - 265))
          | (1ULL << (MySQLParser::HOUR_MINUTE_SYMBOL - 265))
          | (1ULL << (MySQLParser::HOUR_SECOND_SYMBOL - 265)))) != 0) || _la == MySQLParser::MINUTE_MICROSECOND_SYMBOL

        || _la == MySQLParser::MINUTE_SECOND_SYMBOL || _la == MySQLParser::SECOND_MICROSECOND_SYMBOL || _la == MySQLParser::YEAR_MONTH_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IntervalTimeStampContext ------------------------------------------------------------------

MySQLParser::IntervalTimeStampContext::IntervalTimeStampContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IntervalTimeStampContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}


size_t MySQLParser::IntervalTimeStampContext::getRuleIndex() const {
  return MySQLParser::RuleIntervalTimeStamp;
}

void MySQLParser::IntervalTimeStampContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIntervalTimeStamp(this);
}

void MySQLParser::IntervalTimeStampContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIntervalTimeStamp(this);
}

MySQLParser::IntervalTimeStampContext* MySQLParser::intervalTimeStamp() {
  IntervalTimeStampContext *_localctx = _tracker.createInstance<IntervalTimeStampContext>(_ctx, getState());
  enterRule(_localctx, 748, MySQLParser::RuleIntervalTimeStamp);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6405);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DAY_SYMBOL || _la == MySQLParser::HOUR_SYMBOL || ((((_la - 372) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 372)) & ((1ULL << (MySQLParser::MICROSECOND_SYMBOL - 372))
      | (1ULL << (MySQLParser::MINUTE_SYMBOL - 372))
      | (1ULL << (MySQLParser::MONTH_SYMBOL - 372)))) != 0) || _la == MySQLParser::QUARTER_SYMBOL

    || _la == MySQLParser::SECOND_SYMBOL || _la == MySQLParser::WEEK_SYMBOL

    || _la == MySQLParser::YEAR_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprListWithParenthesesContext ------------------------------------------------------------------

MySQLParser::ExprListWithParenthesesContext::ExprListWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ExprListWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprListContext* MySQLParser::ExprListWithParenthesesContext::exprList() {
  return getRuleContext<MySQLParser::ExprListContext>(0);
}

tree::TerminalNode* MySQLParser::ExprListWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::ExprListWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleExprListWithParentheses;
}

void MySQLParser::ExprListWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprListWithParentheses(this);
}

void MySQLParser::ExprListWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprListWithParentheses(this);
}

MySQLParser::ExprListWithParenthesesContext* MySQLParser::exprListWithParentheses() {
  ExprListWithParenthesesContext *_localctx = _tracker.createInstance<ExprListWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 750, MySQLParser::RuleExprListWithParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6407);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6408);
    exprList();
    setState(6409);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprWithParenthesesContext ------------------------------------------------------------------

MySQLParser::ExprWithParenthesesContext::ExprWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ExprWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ExprWithParenthesesContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::ExprWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::ExprWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleExprWithParentheses;
}

void MySQLParser::ExprWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterExprWithParentheses(this);
}

void MySQLParser::ExprWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitExprWithParentheses(this);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::exprWithParentheses() {
  ExprWithParenthesesContext *_localctx = _tracker.createInstance<ExprWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 752, MySQLParser::RuleExprWithParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6411);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6412);
    expr(0);
    setState(6413);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleExprWithParenthesesContext ------------------------------------------------------------------

MySQLParser::SimpleExprWithParenthesesContext::SimpleExprWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SimpleExprWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::SimpleExprContext* MySQLParser::SimpleExprWithParenthesesContext::simpleExpr() {
  return getRuleContext<MySQLParser::SimpleExprContext>(0);
}

tree::TerminalNode* MySQLParser::SimpleExprWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::SimpleExprWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleExprWithParentheses;
}

void MySQLParser::SimpleExprWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleExprWithParentheses(this);
}

void MySQLParser::SimpleExprWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleExprWithParentheses(this);
}

MySQLParser::SimpleExprWithParenthesesContext* MySQLParser::simpleExprWithParentheses() {
  SimpleExprWithParenthesesContext *_localctx = _tracker.createInstance<SimpleExprWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 754, MySQLParser::RuleSimpleExprWithParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6415);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6416);
    simpleExpr(0);
    setState(6417);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderListContext ------------------------------------------------------------------

MySQLParser::OrderListContext::OrderListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::OrderExpressionContext *> MySQLParser::OrderListContext::orderExpression() {
  return getRuleContexts<MySQLParser::OrderExpressionContext>();
}

MySQLParser::OrderExpressionContext* MySQLParser::OrderListContext::orderExpression(size_t i) {
  return getRuleContext<MySQLParser::OrderExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::OrderListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::OrderListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::OrderListContext::getRuleIndex() const {
  return MySQLParser::RuleOrderList;
}

void MySQLParser::OrderListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderList(this);
}

void MySQLParser::OrderListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderList(this);
}

MySQLParser::OrderListContext* MySQLParser::orderList() {
  OrderListContext *_localctx = _tracker.createInstance<OrderListContext>(_ctx, getState());
  enterRule(_localctx, 756, MySQLParser::RuleOrderList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6419);
    orderExpression();
    setState(6424);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 812, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6420);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6421);
        orderExpression(); 
      }
      setState(6426);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 812, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OrderExpressionContext ------------------------------------------------------------------

MySQLParser::OrderExpressionContext::OrderExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::OrderExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::DirectionContext* MySQLParser::OrderExpressionContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}


size_t MySQLParser::OrderExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleOrderExpression;
}

void MySQLParser::OrderExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOrderExpression(this);
}

void MySQLParser::OrderExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOrderExpression(this);
}

MySQLParser::OrderExpressionContext* MySQLParser::orderExpression() {
  OrderExpressionContext *_localctx = _tracker.createInstance<OrderExpressionContext>(_ctx, getState());
  enterRule(_localctx, 758, MySQLParser::RuleOrderExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6427);
    expr(0);
    setState(6429);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 813, _ctx)) {
    case 1: {
      setState(6428);
      direction();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupListContext ------------------------------------------------------------------

MySQLParser::GroupListContext::GroupListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::GroupingExpressionContext *> MySQLParser::GroupListContext::groupingExpression() {
  return getRuleContexts<MySQLParser::GroupingExpressionContext>();
}

MySQLParser::GroupingExpressionContext* MySQLParser::GroupListContext::groupingExpression(size_t i) {
  return getRuleContext<MySQLParser::GroupingExpressionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::GroupListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::GroupListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::GroupListContext::getRuleIndex() const {
  return MySQLParser::RuleGroupList;
}

void MySQLParser::GroupListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupList(this);
}

void MySQLParser::GroupListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupList(this);
}

MySQLParser::GroupListContext* MySQLParser::groupList() {
  GroupListContext *_localctx = _tracker.createInstance<GroupListContext>(_ctx, getState());
  enterRule(_localctx, 760, MySQLParser::RuleGroupList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6431);
    groupingExpression();
    setState(6436);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6432);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6433);
      groupingExpression();
      setState(6438);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GroupingExpressionContext ------------------------------------------------------------------

MySQLParser::GroupingExpressionContext::GroupingExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::GroupingExpressionContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::GroupingExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleGroupingExpression;
}

void MySQLParser::GroupingExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGroupingExpression(this);
}

void MySQLParser::GroupingExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGroupingExpression(this);
}

MySQLParser::GroupingExpressionContext* MySQLParser::groupingExpression() {
  GroupingExpressionContext *_localctx = _tracker.createInstance<GroupingExpressionContext>(_ctx, getState());
  enterRule(_localctx, 762, MySQLParser::RuleGroupingExpression);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6439);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ChannelContext ------------------------------------------------------------------

MySQLParser::ChannelContext::ChannelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ChannelContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ChannelContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::ChannelContext::textStringNoLinebreak() {
  return getRuleContext<MySQLParser::TextStringNoLinebreakContext>(0);
}


size_t MySQLParser::ChannelContext::getRuleIndex() const {
  return MySQLParser::RuleChannel;
}

void MySQLParser::ChannelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterChannel(this);
}

void MySQLParser::ChannelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitChannel(this);
}

MySQLParser::ChannelContext* MySQLParser::channel() {
  ChannelContext *_localctx = _tracker.createInstance<ChannelContext>(_ctx, getState());
  enterRule(_localctx, 764, MySQLParser::RuleChannel);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6441);

    if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
    setState(6442);
    match(MySQLParser::FOR_SYMBOL);
    setState(6443);
    match(MySQLParser::CHANNEL_SYMBOL);
    setState(6444);
    textStringNoLinebreak();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementContext ------------------------------------------------------------------

MySQLParser::CompoundStatementContext::CompoundStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SimpleStatementContext* MySQLParser::CompoundStatementContext::simpleStatement() {
  return getRuleContext<MySQLParser::SimpleStatementContext>(0);
}

MySQLParser::ReturnStatementContext* MySQLParser::CompoundStatementContext::returnStatement() {
  return getRuleContext<MySQLParser::ReturnStatementContext>(0);
}

MySQLParser::IfStatementContext* MySQLParser::CompoundStatementContext::ifStatement() {
  return getRuleContext<MySQLParser::IfStatementContext>(0);
}

MySQLParser::CaseStatementContext* MySQLParser::CompoundStatementContext::caseStatement() {
  return getRuleContext<MySQLParser::CaseStatementContext>(0);
}

MySQLParser::LabeledBlockContext* MySQLParser::CompoundStatementContext::labeledBlock() {
  return getRuleContext<MySQLParser::LabeledBlockContext>(0);
}

MySQLParser::UnlabeledBlockContext* MySQLParser::CompoundStatementContext::unlabeledBlock() {
  return getRuleContext<MySQLParser::UnlabeledBlockContext>(0);
}

MySQLParser::LabeledControlContext* MySQLParser::CompoundStatementContext::labeledControl() {
  return getRuleContext<MySQLParser::LabeledControlContext>(0);
}

MySQLParser::UnlabeledControlContext* MySQLParser::CompoundStatementContext::unlabeledControl() {
  return getRuleContext<MySQLParser::UnlabeledControlContext>(0);
}

MySQLParser::LeaveStatementContext* MySQLParser::CompoundStatementContext::leaveStatement() {
  return getRuleContext<MySQLParser::LeaveStatementContext>(0);
}

MySQLParser::IterateStatementContext* MySQLParser::CompoundStatementContext::iterateStatement() {
  return getRuleContext<MySQLParser::IterateStatementContext>(0);
}

MySQLParser::CursorOpenContext* MySQLParser::CompoundStatementContext::cursorOpen() {
  return getRuleContext<MySQLParser::CursorOpenContext>(0);
}

MySQLParser::CursorFetchContext* MySQLParser::CompoundStatementContext::cursorFetch() {
  return getRuleContext<MySQLParser::CursorFetchContext>(0);
}

MySQLParser::CursorCloseContext* MySQLParser::CompoundStatementContext::cursorClose() {
  return getRuleContext<MySQLParser::CursorCloseContext>(0);
}


size_t MySQLParser::CompoundStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCompoundStatement;
}

void MySQLParser::CompoundStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatement(this);
}

void MySQLParser::CompoundStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatement(this);
}

MySQLParser::CompoundStatementContext* MySQLParser::compoundStatement() {
  CompoundStatementContext *_localctx = _tracker.createInstance<CompoundStatementContext>(_ctx, getState());
  enterRule(_localctx, 766, MySQLParser::RuleCompoundStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6459);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 815, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6446);
      simpleStatement();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6447);
      returnStatement();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6448);
      ifStatement();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6449);
      caseStatement();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6450);
      labeledBlock();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6451);
      unlabeledBlock();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6452);
      labeledControl();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6453);
      unlabeledControl();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6454);
      leaveStatement();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6455);
      iterateStatement();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6456);
      cursorOpen();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6457);
      cursorFetch();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6458);
      cursorClose();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReturnStatementContext ------------------------------------------------------------------

MySQLParser::ReturnStatementContext::ReturnStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReturnStatementContext::RETURN_SYMBOL() {
  return getToken(MySQLParser::RETURN_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::ReturnStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::ReturnStatementContext::getRuleIndex() const {
  return MySQLParser::RuleReturnStatement;
}

void MySQLParser::ReturnStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReturnStatement(this);
}

void MySQLParser::ReturnStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReturnStatement(this);
}

MySQLParser::ReturnStatementContext* MySQLParser::returnStatement() {
  ReturnStatementContext *_localctx = _tracker.createInstance<ReturnStatementContext>(_ctx, getState());
  enterRule(_localctx, 768, MySQLParser::RuleReturnStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6461);
    match(MySQLParser::RETURN_SYMBOL);
    setState(6462);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfStatementContext ------------------------------------------------------------------

MySQLParser::IfStatementContext::IfStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::IfStatementContext::IF_SYMBOL() {
  return getTokens(MySQLParser::IF_SYMBOL);
}

tree::TerminalNode* MySQLParser::IfStatementContext::IF_SYMBOL(size_t i) {
  return getToken(MySQLParser::IF_SYMBOL, i);
}

MySQLParser::IfBodyContext* MySQLParser::IfStatementContext::ifBody() {
  return getRuleContext<MySQLParser::IfBodyContext>(0);
}

tree::TerminalNode* MySQLParser::IfStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::IfStatementContext::getRuleIndex() const {
  return MySQLParser::RuleIfStatement;
}

void MySQLParser::IfStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfStatement(this);
}

void MySQLParser::IfStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfStatement(this);
}

MySQLParser::IfStatementContext* MySQLParser::ifStatement() {
  IfStatementContext *_localctx = _tracker.createInstance<IfStatementContext>(_ctx, getState());
  enterRule(_localctx, 770, MySQLParser::RuleIfStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6464);
    match(MySQLParser::IF_SYMBOL);
    setState(6465);
    ifBody();
    setState(6466);
    match(MySQLParser::END_SYMBOL);
    setState(6467);
    match(MySQLParser::IF_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfBodyContext ------------------------------------------------------------------

MySQLParser::IfBodyContext::IfBodyContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ExprContext* MySQLParser::IfBodyContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

MySQLParser::ThenStatementContext* MySQLParser::IfBodyContext::thenStatement() {
  return getRuleContext<MySQLParser::ThenStatementContext>(0);
}

tree::TerminalNode* MySQLParser::IfBodyContext::ELSEIF_SYMBOL() {
  return getToken(MySQLParser::ELSEIF_SYMBOL, 0);
}

MySQLParser::IfBodyContext* MySQLParser::IfBodyContext::ifBody() {
  return getRuleContext<MySQLParser::IfBodyContext>(0);
}

tree::TerminalNode* MySQLParser::IfBodyContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::IfBodyContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::IfBodyContext::getRuleIndex() const {
  return MySQLParser::RuleIfBody;
}

void MySQLParser::IfBodyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfBody(this);
}

void MySQLParser::IfBodyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfBody(this);
}

MySQLParser::IfBodyContext* MySQLParser::ifBody() {
  IfBodyContext *_localctx = _tracker.createInstance<IfBodyContext>(_ctx, getState());
  enterRule(_localctx, 772, MySQLParser::RuleIfBody);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6469);
    expr(0);
    setState(6470);
    thenStatement();
    setState(6475);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ELSEIF_SYMBOL: {
        setState(6471);
        match(MySQLParser::ELSEIF_SYMBOL);
        setState(6472);
        ifBody();
        break;
      }

      case MySQLParser::ELSE_SYMBOL: {
        setState(6473);
        match(MySQLParser::ELSE_SYMBOL);
        setState(6474);
        compoundStatementList();
        break;
      }

      case MySQLParser::END_SYMBOL: {
        break;
      }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ThenStatementContext ------------------------------------------------------------------

MySQLParser::ThenStatementContext::ThenStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ThenStatementContext::THEN_SYMBOL() {
  return getToken(MySQLParser::THEN_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::ThenStatementContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::ThenStatementContext::getRuleIndex() const {
  return MySQLParser::RuleThenStatement;
}

void MySQLParser::ThenStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterThenStatement(this);
}

void MySQLParser::ThenStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitThenStatement(this);
}

MySQLParser::ThenStatementContext* MySQLParser::thenStatement() {
  ThenStatementContext *_localctx = _tracker.createInstance<ThenStatementContext>(_ctx, getState());
  enterRule(_localctx, 774, MySQLParser::RuleThenStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6477);
    match(MySQLParser::THEN_SYMBOL);
    setState(6478);
    compoundStatementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CompoundStatementListContext ------------------------------------------------------------------

MySQLParser::CompoundStatementListContext::CompoundStatementListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CompoundStatementContext *> MySQLParser::CompoundStatementListContext::compoundStatement() {
  return getRuleContexts<MySQLParser::CompoundStatementContext>();
}

MySQLParser::CompoundStatementContext* MySQLParser::CompoundStatementListContext::compoundStatement(size_t i) {
  return getRuleContext<MySQLParser::CompoundStatementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CompoundStatementListContext::SEMICOLON_SYMBOL() {
  return getTokens(MySQLParser::SEMICOLON_SYMBOL);
}

tree::TerminalNode* MySQLParser::CompoundStatementListContext::SEMICOLON_SYMBOL(size_t i) {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, i);
}


size_t MySQLParser::CompoundStatementListContext::getRuleIndex() const {
  return MySQLParser::RuleCompoundStatementList;
}

void MySQLParser::CompoundStatementListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCompoundStatementList(this);
}

void MySQLParser::CompoundStatementListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCompoundStatementList(this);
}

MySQLParser::CompoundStatementListContext* MySQLParser::compoundStatementList() {
  CompoundStatementListContext *_localctx = _tracker.createInstance<CompoundStatementListContext>(_ctx, getState());
  enterRule(_localctx, 776, MySQLParser::RuleCompoundStatementList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6483); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(6480);
              compoundStatement();
              setState(6481);
              match(MySQLParser::SEMICOLON_SYMBOL);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(6485); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 817, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseStatementContext ------------------------------------------------------------------

MySQLParser::CaseStatementContext::CaseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::CaseStatementContext::CASE_SYMBOL() {
  return getTokens(MySQLParser::CASE_SYMBOL);
}

tree::TerminalNode* MySQLParser::CaseStatementContext::CASE_SYMBOL(size_t i) {
  return getToken(MySQLParser::CASE_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::CaseStatementContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::CaseStatementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

std::vector<MySQLParser::WhenExpressionContext *> MySQLParser::CaseStatementContext::whenExpression() {
  return getRuleContexts<MySQLParser::WhenExpressionContext>();
}

MySQLParser::WhenExpressionContext* MySQLParser::CaseStatementContext::whenExpression(size_t i) {
  return getRuleContext<MySQLParser::WhenExpressionContext>(i);
}

std::vector<MySQLParser::ThenStatementContext *> MySQLParser::CaseStatementContext::thenStatement() {
  return getRuleContexts<MySQLParser::ThenStatementContext>();
}

MySQLParser::ThenStatementContext* MySQLParser::CaseStatementContext::thenStatement(size_t i) {
  return getRuleContext<MySQLParser::ThenStatementContext>(i);
}

MySQLParser::ElseStatementContext* MySQLParser::CaseStatementContext::elseStatement() {
  return getRuleContext<MySQLParser::ElseStatementContext>(0);
}


size_t MySQLParser::CaseStatementContext::getRuleIndex() const {
  return MySQLParser::RuleCaseStatement;
}

void MySQLParser::CaseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCaseStatement(this);
}

void MySQLParser::CaseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCaseStatement(this);
}

MySQLParser::CaseStatementContext* MySQLParser::caseStatement() {
  CaseStatementContext *_localctx = _tracker.createInstance<CaseStatementContext>(_ctx, getState());
  enterRule(_localctx, 778, MySQLParser::RuleCaseStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6487);
    match(MySQLParser::CASE_SYMBOL);
    setState(6489);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 818, _ctx)) {
    case 1: {
      setState(6488);
      expr(0);
      break;
    }

    }
    setState(6494); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(6491);
      whenExpression();
      setState(6492);
      thenStatement();
      setState(6496); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == MySQLParser::WHEN_SYMBOL);
    setState(6499);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ELSE_SYMBOL) {
      setState(6498);
      elseStatement();
    }
    setState(6501);
    match(MySQLParser::END_SYMBOL);
    setState(6502);
    match(MySQLParser::CASE_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseStatementContext ------------------------------------------------------------------

MySQLParser::ElseStatementContext::ElseStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ElseStatementContext::ELSE_SYMBOL() {
  return getToken(MySQLParser::ELSE_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::ElseStatementContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::ElseStatementContext::getRuleIndex() const {
  return MySQLParser::RuleElseStatement;
}

void MySQLParser::ElseStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterElseStatement(this);
}

void MySQLParser::ElseStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitElseStatement(this);
}

MySQLParser::ElseStatementContext* MySQLParser::elseStatement() {
  ElseStatementContext *_localctx = _tracker.createInstance<ElseStatementContext>(_ctx, getState());
  enterRule(_localctx, 780, MySQLParser::RuleElseStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6504);
    match(MySQLParser::ELSE_SYMBOL);
    setState(6505);
    compoundStatementList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledBlockContext ------------------------------------------------------------------

MySQLParser::LabeledBlockContext::LabeledBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelContext* MySQLParser::LabeledBlockContext::label() {
  return getRuleContext<MySQLParser::LabelContext>(0);
}

MySQLParser::BeginEndBlockContext* MySQLParser::LabeledBlockContext::beginEndBlock() {
  return getRuleContext<MySQLParser::BeginEndBlockContext>(0);
}

MySQLParser::LabelRefContext* MySQLParser::LabeledBlockContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::LabeledBlockContext::getRuleIndex() const {
  return MySQLParser::RuleLabeledBlock;
}

void MySQLParser::LabeledBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledBlock(this);
}

void MySQLParser::LabeledBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledBlock(this);
}

MySQLParser::LabeledBlockContext* MySQLParser::labeledBlock() {
  LabeledBlockContext *_localctx = _tracker.createInstance<LabeledBlockContext>(_ctx, getState());
  enterRule(_localctx, 782, MySQLParser::RuleLabeledBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6507);
    label();
    setState(6508);
    beginEndBlock();
    setState(6510);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 821, _ctx)) {
    case 1: {
      setState(6509);
      labelRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlabeledBlockContext ------------------------------------------------------------------

MySQLParser::UnlabeledBlockContext::UnlabeledBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::BeginEndBlockContext* MySQLParser::UnlabeledBlockContext::beginEndBlock() {
  return getRuleContext<MySQLParser::BeginEndBlockContext>(0);
}


size_t MySQLParser::UnlabeledBlockContext::getRuleIndex() const {
  return MySQLParser::RuleUnlabeledBlock;
}

void MySQLParser::UnlabeledBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlabeledBlock(this);
}

void MySQLParser::UnlabeledBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlabeledBlock(this);
}

MySQLParser::UnlabeledBlockContext* MySQLParser::unlabeledBlock() {
  UnlabeledBlockContext *_localctx = _tracker.createInstance<UnlabeledBlockContext>(_ctx, getState());
  enterRule(_localctx, 784, MySQLParser::RuleUnlabeledBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6512);
    beginEndBlock();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelContext ------------------------------------------------------------------

MySQLParser::LabelContext::LabelContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelIdentifierContext* MySQLParser::LabelContext::labelIdentifier() {
  return getRuleContext<MySQLParser::LabelIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::LabelContext::COLON_SYMBOL() {
  return getToken(MySQLParser::COLON_SYMBOL, 0);
}


size_t MySQLParser::LabelContext::getRuleIndex() const {
  return MySQLParser::RuleLabel;
}

void MySQLParser::LabelContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabel(this);
}

void MySQLParser::LabelContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabel(this);
}

MySQLParser::LabelContext* MySQLParser::label() {
  LabelContext *_localctx = _tracker.createInstance<LabelContext>(_ctx, getState());
  enterRule(_localctx, 786, MySQLParser::RuleLabel);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6514);
    labelIdentifier();
    setState(6515);
    match(MySQLParser::COLON_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BeginEndBlockContext ------------------------------------------------------------------

MySQLParser::BeginEndBlockContext::BeginEndBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::BeginEndBlockContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BeginEndBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

MySQLParser::SpDeclarationsContext* MySQLParser::BeginEndBlockContext::spDeclarations() {
  return getRuleContext<MySQLParser::SpDeclarationsContext>(0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::BeginEndBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}


size_t MySQLParser::BeginEndBlockContext::getRuleIndex() const {
  return MySQLParser::RuleBeginEndBlock;
}

void MySQLParser::BeginEndBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBeginEndBlock(this);
}

void MySQLParser::BeginEndBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBeginEndBlock(this);
}

MySQLParser::BeginEndBlockContext* MySQLParser::beginEndBlock() {
  BeginEndBlockContext *_localctx = _tracker.createInstance<BeginEndBlockContext>(_ctx, getState());
  enterRule(_localctx, 788, MySQLParser::RuleBeginEndBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6517);
    match(MySQLParser::BEGIN_SYMBOL);
    setState(6519);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 822, _ctx)) {
    case 1: {
      setState(6518);
      spDeclarations();
      break;
    }

    }
    setState(6522);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 823, _ctx)) {
    case 1: {
      setState(6521);
      compoundStatementList();
      break;
    }

    }
    setState(6524);
    match(MySQLParser::END_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabeledControlContext ------------------------------------------------------------------

MySQLParser::LabeledControlContext::LabeledControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelContext* MySQLParser::LabeledControlContext::label() {
  return getRuleContext<MySQLParser::LabelContext>(0);
}

MySQLParser::UnlabeledControlContext* MySQLParser::LabeledControlContext::unlabeledControl() {
  return getRuleContext<MySQLParser::UnlabeledControlContext>(0);
}

MySQLParser::LabelRefContext* MySQLParser::LabeledControlContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::LabeledControlContext::getRuleIndex() const {
  return MySQLParser::RuleLabeledControl;
}

void MySQLParser::LabeledControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabeledControl(this);
}

void MySQLParser::LabeledControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabeledControl(this);
}

MySQLParser::LabeledControlContext* MySQLParser::labeledControl() {
  LabeledControlContext *_localctx = _tracker.createInstance<LabeledControlContext>(_ctx, getState());
  enterRule(_localctx, 790, MySQLParser::RuleLabeledControl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6526);
    label();
    setState(6527);
    unlabeledControl();
    setState(6529);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 824, _ctx)) {
    case 1: {
      setState(6528);
      labelRef();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnlabeledControlContext ------------------------------------------------------------------

MySQLParser::UnlabeledControlContext::UnlabeledControlContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LoopBlockContext* MySQLParser::UnlabeledControlContext::loopBlock() {
  return getRuleContext<MySQLParser::LoopBlockContext>(0);
}

MySQLParser::WhileDoBlockContext* MySQLParser::UnlabeledControlContext::whileDoBlock() {
  return getRuleContext<MySQLParser::WhileDoBlockContext>(0);
}

MySQLParser::RepeatUntilBlockContext* MySQLParser::UnlabeledControlContext::repeatUntilBlock() {
  return getRuleContext<MySQLParser::RepeatUntilBlockContext>(0);
}


size_t MySQLParser::UnlabeledControlContext::getRuleIndex() const {
  return MySQLParser::RuleUnlabeledControl;
}

void MySQLParser::UnlabeledControlContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnlabeledControl(this);
}

void MySQLParser::UnlabeledControlContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnlabeledControl(this);
}

MySQLParser::UnlabeledControlContext* MySQLParser::unlabeledControl() {
  UnlabeledControlContext *_localctx = _tracker.createInstance<UnlabeledControlContext>(_ctx, getState());
  enterRule(_localctx, 792, MySQLParser::RuleUnlabeledControl);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6534);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::LOOP_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6531);
        loopBlock();
        break;
      }

      case MySQLParser::WHILE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6532);
        whileDoBlock();
        break;
      }

      case MySQLParser::REPEAT_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6533);
        repeatUntilBlock();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LoopBlockContext ------------------------------------------------------------------

MySQLParser::LoopBlockContext::LoopBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::LoopBlockContext::LOOP_SYMBOL() {
  return getTokens(MySQLParser::LOOP_SYMBOL);
}

tree::TerminalNode* MySQLParser::LoopBlockContext::LOOP_SYMBOL(size_t i) {
  return getToken(MySQLParser::LOOP_SYMBOL, i);
}

MySQLParser::CompoundStatementListContext* MySQLParser::LoopBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode* MySQLParser::LoopBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::LoopBlockContext::getRuleIndex() const {
  return MySQLParser::RuleLoopBlock;
}

void MySQLParser::LoopBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLoopBlock(this);
}

void MySQLParser::LoopBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLoopBlock(this);
}

MySQLParser::LoopBlockContext* MySQLParser::loopBlock() {
  LoopBlockContext *_localctx = _tracker.createInstance<LoopBlockContext>(_ctx, getState());
  enterRule(_localctx, 794, MySQLParser::RuleLoopBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6536);
    match(MySQLParser::LOOP_SYMBOL);
    setState(6537);
    compoundStatementList();
    setState(6538);
    match(MySQLParser::END_SYMBOL);
    setState(6539);
    match(MySQLParser::LOOP_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WhileDoBlockContext ------------------------------------------------------------------

MySQLParser::WhileDoBlockContext::WhileDoBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::WhileDoBlockContext::WHILE_SYMBOL() {
  return getTokens(MySQLParser::WHILE_SYMBOL);
}

tree::TerminalNode* MySQLParser::WhileDoBlockContext::WHILE_SYMBOL(size_t i) {
  return getToken(MySQLParser::WHILE_SYMBOL, i);
}

MySQLParser::ExprContext* MySQLParser::WhileDoBlockContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::WhileDoBlockContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

MySQLParser::CompoundStatementListContext* MySQLParser::WhileDoBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode* MySQLParser::WhileDoBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::WhileDoBlockContext::getRuleIndex() const {
  return MySQLParser::RuleWhileDoBlock;
}

void MySQLParser::WhileDoBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWhileDoBlock(this);
}

void MySQLParser::WhileDoBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWhileDoBlock(this);
}

MySQLParser::WhileDoBlockContext* MySQLParser::whileDoBlock() {
  WhileDoBlockContext *_localctx = _tracker.createInstance<WhileDoBlockContext>(_ctx, getState());
  enterRule(_localctx, 796, MySQLParser::RuleWhileDoBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6541);
    match(MySQLParser::WHILE_SYMBOL);
    setState(6542);
    expr(0);
    setState(6543);
    match(MySQLParser::DO_SYMBOL);
    setState(6544);
    compoundStatementList();
    setState(6545);
    match(MySQLParser::END_SYMBOL);
    setState(6546);
    match(MySQLParser::WHILE_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RepeatUntilBlockContext ------------------------------------------------------------------

MySQLParser::RepeatUntilBlockContext::RepeatUntilBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::RepeatUntilBlockContext::REPEAT_SYMBOL() {
  return getTokens(MySQLParser::REPEAT_SYMBOL);
}

tree::TerminalNode* MySQLParser::RepeatUntilBlockContext::REPEAT_SYMBOL(size_t i) {
  return getToken(MySQLParser::REPEAT_SYMBOL, i);
}

MySQLParser::CompoundStatementListContext* MySQLParser::RepeatUntilBlockContext::compoundStatementList() {
  return getRuleContext<MySQLParser::CompoundStatementListContext>(0);
}

tree::TerminalNode* MySQLParser::RepeatUntilBlockContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::RepeatUntilBlockContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::RepeatUntilBlockContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}


size_t MySQLParser::RepeatUntilBlockContext::getRuleIndex() const {
  return MySQLParser::RuleRepeatUntilBlock;
}

void MySQLParser::RepeatUntilBlockContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRepeatUntilBlock(this);
}

void MySQLParser::RepeatUntilBlockContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRepeatUntilBlock(this);
}

MySQLParser::RepeatUntilBlockContext* MySQLParser::repeatUntilBlock() {
  RepeatUntilBlockContext *_localctx = _tracker.createInstance<RepeatUntilBlockContext>(_ctx, getState());
  enterRule(_localctx, 798, MySQLParser::RuleRepeatUntilBlock);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6548);
    match(MySQLParser::REPEAT_SYMBOL);
    setState(6549);
    compoundStatementList();
    setState(6550);
    match(MySQLParser::UNTIL_SYMBOL);
    setState(6551);
    expr(0);
    setState(6552);
    match(MySQLParser::END_SYMBOL);
    setState(6553);
    match(MySQLParser::REPEAT_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpDeclarationsContext ------------------------------------------------------------------

MySQLParser::SpDeclarationsContext::SpDeclarationsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::SpDeclarationContext *> MySQLParser::SpDeclarationsContext::spDeclaration() {
  return getRuleContexts<MySQLParser::SpDeclarationContext>();
}

MySQLParser::SpDeclarationContext* MySQLParser::SpDeclarationsContext::spDeclaration(size_t i) {
  return getRuleContext<MySQLParser::SpDeclarationContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SpDeclarationsContext::SEMICOLON_SYMBOL() {
  return getTokens(MySQLParser::SEMICOLON_SYMBOL);
}

tree::TerminalNode* MySQLParser::SpDeclarationsContext::SEMICOLON_SYMBOL(size_t i) {
  return getToken(MySQLParser::SEMICOLON_SYMBOL, i);
}


size_t MySQLParser::SpDeclarationsContext::getRuleIndex() const {
  return MySQLParser::RuleSpDeclarations;
}

void MySQLParser::SpDeclarationsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpDeclarations(this);
}

void MySQLParser::SpDeclarationsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpDeclarations(this);
}

MySQLParser::SpDeclarationsContext* MySQLParser::spDeclarations() {
  SpDeclarationsContext *_localctx = _tracker.createInstance<SpDeclarationsContext>(_ctx, getState());
  enterRule(_localctx, 800, MySQLParser::RuleSpDeclarations);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6558); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(6555);
              spDeclaration();
              setState(6556);
              match(MySQLParser::SEMICOLON_SYMBOL);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(6560); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 826, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpDeclarationContext ------------------------------------------------------------------

MySQLParser::SpDeclarationContext::SpDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::VariableDeclarationContext* MySQLParser::SpDeclarationContext::variableDeclaration() {
  return getRuleContext<MySQLParser::VariableDeclarationContext>(0);
}

MySQLParser::ConditionDeclarationContext* MySQLParser::SpDeclarationContext::conditionDeclaration() {
  return getRuleContext<MySQLParser::ConditionDeclarationContext>(0);
}

MySQLParser::HandlerDeclarationContext* MySQLParser::SpDeclarationContext::handlerDeclaration() {
  return getRuleContext<MySQLParser::HandlerDeclarationContext>(0);
}

MySQLParser::CursorDeclarationContext* MySQLParser::SpDeclarationContext::cursorDeclaration() {
  return getRuleContext<MySQLParser::CursorDeclarationContext>(0);
}


size_t MySQLParser::SpDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleSpDeclaration;
}

void MySQLParser::SpDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpDeclaration(this);
}

void MySQLParser::SpDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpDeclaration(this);
}

MySQLParser::SpDeclarationContext* MySQLParser::spDeclaration() {
  SpDeclarationContext *_localctx = _tracker.createInstance<SpDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 802, MySQLParser::RuleSpDeclaration);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6566);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 827, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6562);
      variableDeclaration();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6563);
      conditionDeclaration();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6564);
      handlerDeclaration();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6565);
      cursorDeclaration();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VariableDeclarationContext ------------------------------------------------------------------

MySQLParser::VariableDeclarationContext::VariableDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VariableDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::VariableDeclarationContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::DataTypeContext* MySQLParser::VariableDeclarationContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

MySQLParser::CollateContext* MySQLParser::VariableDeclarationContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::VariableDeclarationContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::ExprContext* MySQLParser::VariableDeclarationContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}


size_t MySQLParser::VariableDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleVariableDeclaration;
}

void MySQLParser::VariableDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVariableDeclaration(this);
}

void MySQLParser::VariableDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVariableDeclaration(this);
}

MySQLParser::VariableDeclarationContext* MySQLParser::variableDeclaration() {
  VariableDeclarationContext *_localctx = _tracker.createInstance<VariableDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 804, MySQLParser::RuleVariableDeclaration);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6568);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6569);
    identifierList();
    setState(6570);
    dataType();
    setState(6572);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::COLLATE_SYMBOL) {
      setState(6571);
      collate();
    }
    setState(6576);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(6574);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(6575);
      expr(0);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionDeclarationContext ------------------------------------------------------------------

MySQLParser::ConditionDeclarationContext::ConditionDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConditionDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::ConditionDeclarationContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::ConditionDeclarationContext::CONDITION_SYMBOL() {
  return getToken(MySQLParser::CONDITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ConditionDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::SpConditionContext* MySQLParser::ConditionDeclarationContext::spCondition() {
  return getRuleContext<MySQLParser::SpConditionContext>(0);
}


size_t MySQLParser::ConditionDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleConditionDeclaration;
}

void MySQLParser::ConditionDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionDeclaration(this);
}

void MySQLParser::ConditionDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionDeclaration(this);
}

MySQLParser::ConditionDeclarationContext* MySQLParser::conditionDeclaration() {
  ConditionDeclarationContext *_localctx = _tracker.createInstance<ConditionDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 806, MySQLParser::RuleConditionDeclaration);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6578);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6579);
    identifier();
    setState(6580);
    match(MySQLParser::CONDITION_SYMBOL);
    setState(6581);
    match(MySQLParser::FOR_SYMBOL);
    setState(6582);
    spCondition();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpConditionContext ------------------------------------------------------------------

MySQLParser::SpConditionContext::SpConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Ulong_numberContext* MySQLParser::SpConditionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

MySQLParser::SqlstateContext* MySQLParser::SpConditionContext::sqlstate() {
  return getRuleContext<MySQLParser::SqlstateContext>(0);
}


size_t MySQLParser::SpConditionContext::getRuleIndex() const {
  return MySQLParser::RuleSpCondition;
}

void MySQLParser::SpConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpCondition(this);
}

void MySQLParser::SpConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpCondition(this);
}

MySQLParser::SpConditionContext* MySQLParser::spCondition() {
  SpConditionContext *_localctx = _tracker.createInstance<SpConditionContext>(_ctx, getState());
  enterRule(_localctx, 808, MySQLParser::RuleSpCondition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6586);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::HEX_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(6584);
        ulong_number();
        break;
      }

      case MySQLParser::SQLSTATE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6585);
        sqlstate();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SqlstateContext ------------------------------------------------------------------

MySQLParser::SqlstateContext::SqlstateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SqlstateContext::SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::SQLSTATE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::SqlstateContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::SqlstateContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}


size_t MySQLParser::SqlstateContext::getRuleIndex() const {
  return MySQLParser::RuleSqlstate;
}

void MySQLParser::SqlstateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSqlstate(this);
}

void MySQLParser::SqlstateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSqlstate(this);
}

MySQLParser::SqlstateContext* MySQLParser::sqlstate() {
  SqlstateContext *_localctx = _tracker.createInstance<SqlstateContext>(_ctx, getState());
  enterRule(_localctx, 810, MySQLParser::RuleSqlstate);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6588);
    match(MySQLParser::SQLSTATE_SYMBOL);
    setState(6590);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 831, _ctx)) {
    case 1: {
      setState(6589);
      match(MySQLParser::VALUE_SYMBOL);
      break;
    }

    }
    setState(6592);
    textLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerDeclarationContext ------------------------------------------------------------------

MySQLParser::HandlerDeclarationContext::HandlerDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

std::vector<MySQLParser::HandlerConditionContext *> MySQLParser::HandlerDeclarationContext::handlerCondition() {
  return getRuleContexts<MySQLParser::HandlerConditionContext>();
}

MySQLParser::HandlerConditionContext* MySQLParser::HandlerDeclarationContext::handlerCondition(size_t i) {
  return getRuleContext<MySQLParser::HandlerConditionContext>(i);
}

MySQLParser::CompoundStatementContext* MySQLParser::HandlerDeclarationContext::compoundStatement() {
  return getRuleContext<MySQLParser::CompoundStatementContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::CONTINUE_SYMBOL() {
  return getToken(MySQLParser::CONTINUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::EXIT_SYMBOL() {
  return getToken(MySQLParser::EXIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::UNDO_SYMBOL() {
  return getToken(MySQLParser::UNDO_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::HandlerDeclarationContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::HandlerDeclarationContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::HandlerDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerDeclaration;
}

void MySQLParser::HandlerDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerDeclaration(this);
}

void MySQLParser::HandlerDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerDeclaration(this);
}

MySQLParser::HandlerDeclarationContext* MySQLParser::handlerDeclaration() {
  HandlerDeclarationContext *_localctx = _tracker.createInstance<HandlerDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 812, MySQLParser::RuleHandlerDeclaration);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6594);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6595);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::CONTINUE_SYMBOL || _la == MySQLParser::EXIT_SYMBOL || _la == MySQLParser::UNDO_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(6596);
    match(MySQLParser::HANDLER_SYMBOL);
    setState(6597);
    match(MySQLParser::FOR_SYMBOL);
    setState(6598);
    handlerCondition();
    setState(6603);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 832, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(6599);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6600);
        handlerCondition(); 
      }
      setState(6605);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 832, _ctx);
    }
    setState(6606);
    compoundStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HandlerConditionContext ------------------------------------------------------------------

MySQLParser::HandlerConditionContext::HandlerConditionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SpConditionContext* MySQLParser::HandlerConditionContext::spCondition() {
  return getRuleContext<MySQLParser::SpConditionContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::HandlerConditionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerConditionContext::SQLWARNING_SYMBOL() {
  return getToken(MySQLParser::SQLWARNING_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::HandlerConditionContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode* MySQLParser::HandlerConditionContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::HandlerConditionContext::SQLEXCEPTION_SYMBOL() {
  return getToken(MySQLParser::SQLEXCEPTION_SYMBOL, 0);
}


size_t MySQLParser::HandlerConditionContext::getRuleIndex() const {
  return MySQLParser::RuleHandlerCondition;
}

void MySQLParser::HandlerConditionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterHandlerCondition(this);
}

void MySQLParser::HandlerConditionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitHandlerCondition(this);
}

MySQLParser::HandlerConditionContext* MySQLParser::handlerCondition() {
  HandlerConditionContext *_localctx = _tracker.createInstance<HandlerConditionContext>(_ctx, getState());
  enterRule(_localctx, 814, MySQLParser::RuleHandlerCondition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6615);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 833, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6608);
      spCondition();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6609);
      identifier();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6610);
      match(MySQLParser::SQLWARNING_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6611);
      notRule();
      setState(6612);
      match(MySQLParser::FOUND_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6614);
      match(MySQLParser::SQLEXCEPTION_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorDeclarationContext ------------------------------------------------------------------

MySQLParser::CursorDeclarationContext::CursorDeclarationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorDeclarationContext::DECLARE_SYMBOL() {
  return getToken(MySQLParser::DECLARE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorDeclarationContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CursorDeclarationContext::CURSOR_SYMBOL() {
  return getToken(MySQLParser::CURSOR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CursorDeclarationContext::FOR_SYMBOL() {
  return getToken(MySQLParser::FOR_SYMBOL, 0);
}

MySQLParser::SelectStatementContext* MySQLParser::CursorDeclarationContext::selectStatement() {
  return getRuleContext<MySQLParser::SelectStatementContext>(0);
}


size_t MySQLParser::CursorDeclarationContext::getRuleIndex() const {
  return MySQLParser::RuleCursorDeclaration;
}

void MySQLParser::CursorDeclarationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorDeclaration(this);
}

void MySQLParser::CursorDeclarationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorDeclaration(this);
}

MySQLParser::CursorDeclarationContext* MySQLParser::cursorDeclaration() {
  CursorDeclarationContext *_localctx = _tracker.createInstance<CursorDeclarationContext>(_ctx, getState());
  enterRule(_localctx, 816, MySQLParser::RuleCursorDeclaration);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6617);
    match(MySQLParser::DECLARE_SYMBOL);
    setState(6618);
    identifier();
    setState(6619);
    match(MySQLParser::CURSOR_SYMBOL);
    setState(6620);
    match(MySQLParser::FOR_SYMBOL);
    setState(6621);
    selectStatement();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IterateStatementContext ------------------------------------------------------------------

MySQLParser::IterateStatementContext::IterateStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IterateStatementContext::ITERATE_SYMBOL() {
  return getToken(MySQLParser::ITERATE_SYMBOL, 0);
}

MySQLParser::LabelRefContext* MySQLParser::IterateStatementContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::IterateStatementContext::getRuleIndex() const {
  return MySQLParser::RuleIterateStatement;
}

void MySQLParser::IterateStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIterateStatement(this);
}

void MySQLParser::IterateStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIterateStatement(this);
}

MySQLParser::IterateStatementContext* MySQLParser::iterateStatement() {
  IterateStatementContext *_localctx = _tracker.createInstance<IterateStatementContext>(_ctx, getState());
  enterRule(_localctx, 818, MySQLParser::RuleIterateStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6623);
    match(MySQLParser::ITERATE_SYMBOL);
    setState(6624);
    labelRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LeaveStatementContext ------------------------------------------------------------------

MySQLParser::LeaveStatementContext::LeaveStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LeaveStatementContext::LEAVE_SYMBOL() {
  return getToken(MySQLParser::LEAVE_SYMBOL, 0);
}

MySQLParser::LabelRefContext* MySQLParser::LeaveStatementContext::labelRef() {
  return getRuleContext<MySQLParser::LabelRefContext>(0);
}


size_t MySQLParser::LeaveStatementContext::getRuleIndex() const {
  return MySQLParser::RuleLeaveStatement;
}

void MySQLParser::LeaveStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLeaveStatement(this);
}

void MySQLParser::LeaveStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLeaveStatement(this);
}

MySQLParser::LeaveStatementContext* MySQLParser::leaveStatement() {
  LeaveStatementContext *_localctx = _tracker.createInstance<LeaveStatementContext>(_ctx, getState());
  enterRule(_localctx, 820, MySQLParser::RuleLeaveStatement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6626);
    match(MySQLParser::LEAVE_SYMBOL);
    setState(6627);
    labelRef();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GetDiagnosticsContext ------------------------------------------------------------------

MySQLParser::GetDiagnosticsContext::GetDiagnosticsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::GET_SYMBOL() {
  return getToken(MySQLParser::GET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

std::vector<MySQLParser::StatementInformationItemContext *> MySQLParser::GetDiagnosticsContext::statementInformationItem() {
  return getRuleContexts<MySQLParser::StatementInformationItemContext>();
}

MySQLParser::StatementInformationItemContext* MySQLParser::GetDiagnosticsContext::statementInformationItem(size_t i) {
  return getRuleContext<MySQLParser::StatementInformationItemContext>(i);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::CONDITION_SYMBOL() {
  return getToken(MySQLParser::CONDITION_SYMBOL, 0);
}

MySQLParser::SignalAllowedExprContext* MySQLParser::GetDiagnosticsContext::signalAllowedExpr() {
  return getRuleContext<MySQLParser::SignalAllowedExprContext>(0);
}

std::vector<MySQLParser::ConditionInformationItemContext *> MySQLParser::GetDiagnosticsContext::conditionInformationItem() {
  return getRuleContexts<MySQLParser::ConditionInformationItemContext>();
}

MySQLParser::ConditionInformationItemContext* MySQLParser::GetDiagnosticsContext::conditionInformationItem(size_t i) {
  return getRuleContext<MySQLParser::ConditionInformationItemContext>(i);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::GetDiagnosticsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::GetDiagnosticsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::GetDiagnosticsContext::getRuleIndex() const {
  return MySQLParser::RuleGetDiagnostics;
}

void MySQLParser::GetDiagnosticsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGetDiagnostics(this);
}

void MySQLParser::GetDiagnosticsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGetDiagnostics(this);
}

MySQLParser::GetDiagnosticsContext* MySQLParser::getDiagnostics() {
  GetDiagnosticsContext *_localctx = _tracker.createInstance<GetDiagnosticsContext>(_ctx, getState());
  enterRule(_localctx, 822, MySQLParser::RuleGetDiagnostics);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6629);
    match(MySQLParser::GET_SYMBOL);
    setState(6633);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 834, _ctx)) {
    case 1: {
      setState(6630);
      match(MySQLParser::CURRENT_SYMBOL);
      break;
    }

    case 2: {
      setState(6631);

      if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
      setState(6632);
      match(MySQLParser::STACKED_SYMBOL);
      break;
    }

    }
    setState(6635);
    match(MySQLParser::DIAGNOSTICS_SYMBOL);
    setState(6654);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 837, _ctx)) {
    case 1: {
      setState(6636);
      statementInformationItem();
      setState(6641);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6637);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6638);
        statementInformationItem();
        setState(6643);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    case 2: {
      setState(6644);
      match(MySQLParser::CONDITION_SYMBOL);
      setState(6645);
      signalAllowedExpr();
      setState(6646);
      conditionInformationItem();
      setState(6651);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6647);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6648);
        conditionInformationItem();
        setState(6653);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalAllowedExprContext ------------------------------------------------------------------

MySQLParser::SignalAllowedExprContext::SignalAllowedExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LiteralContext* MySQLParser::SignalAllowedExprContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

MySQLParser::VariableContext* MySQLParser::SignalAllowedExprContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::SignalAllowedExprContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::SignalAllowedExprContext::getRuleIndex() const {
  return MySQLParser::RuleSignalAllowedExpr;
}

void MySQLParser::SignalAllowedExprContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalAllowedExpr(this);
}

void MySQLParser::SignalAllowedExprContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalAllowedExpr(this);
}

MySQLParser::SignalAllowedExprContext* MySQLParser::signalAllowedExpr() {
  SignalAllowedExprContext *_localctx = _tracker.createInstance<SignalAllowedExprContext>(_ctx, getState());
  enterRule(_localctx, 824, MySQLParser::RuleSignalAllowedExpr);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6659);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 838, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6656);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6657);
      variable();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6658);
      qualifiedIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StatementInformationItemContext ------------------------------------------------------------------

MySQLParser::StatementInformationItemContext::StatementInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::StatementInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::StatementInformationItemContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StatementInformationItemContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

MySQLParser::VariableContext* MySQLParser::StatementInformationItemContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::StatementInformationItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::StatementInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleStatementInformationItem;
}

void MySQLParser::StatementInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStatementInformationItem(this);
}

void MySQLParser::StatementInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStatementInformationItem(this);
}

MySQLParser::StatementInformationItemContext* MySQLParser::statementInformationItem() {
  StatementInformationItemContext *_localctx = _tracker.createInstance<StatementInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 826, MySQLParser::RuleStatementInformationItem);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6663);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 839, _ctx)) {
    case 1: {
      setState(6661);
      variable();
      break;
    }

    case 2: {
      setState(6662);
      identifier();
      break;
    }

    }
    setState(6665);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(6666);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NUMBER_SYMBOL || _la == MySQLParser::ROW_COUNT_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConditionInformationItemContext ------------------------------------------------------------------

MySQLParser::ConditionInformationItemContext::ConditionInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConditionInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::VariableContext* MySQLParser::ConditionInformationItemContext::variable() {
  return getRuleContext<MySQLParser::VariableContext>(0);
}

MySQLParser::IdentifierContext* MySQLParser::ConditionInformationItemContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SignalInformationItemNameContext* MySQLParser::ConditionInformationItemContext::signalInformationItemName() {
  return getRuleContext<MySQLParser::SignalInformationItemNameContext>(0);
}

tree::TerminalNode* MySQLParser::ConditionInformationItemContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}


size_t MySQLParser::ConditionInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleConditionInformationItem;
}

void MySQLParser::ConditionInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConditionInformationItem(this);
}

void MySQLParser::ConditionInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConditionInformationItem(this);
}

MySQLParser::ConditionInformationItemContext* MySQLParser::conditionInformationItem() {
  ConditionInformationItemContext *_localctx = _tracker.createInstance<ConditionInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 828, MySQLParser::RuleConditionInformationItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6670);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 840, _ctx)) {
    case 1: {
      setState(6668);
      variable();
      break;
    }

    case 2: {
      setState(6669);
      identifier();
      break;
    }

    }
    setState(6672);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(6675);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CATALOG_NAME_SYMBOL:
      case MySQLParser::CLASS_ORIGIN_SYMBOL:
      case MySQLParser::COLUMN_NAME_SYMBOL:
      case MySQLParser::CONSTRAINT_CATALOG_SYMBOL:
      case MySQLParser::CONSTRAINT_NAME_SYMBOL:
      case MySQLParser::CONSTRAINT_SCHEMA_SYMBOL:
      case MySQLParser::CURSOR_NAME_SYMBOL:
      case MySQLParser::MESSAGE_TEXT_SYMBOL:
      case MySQLParser::MYSQL_ERRNO_SYMBOL:
      case MySQLParser::SCHEMA_NAME_SYMBOL:
      case MySQLParser::SUBCLASS_ORIGIN_SYMBOL:
      case MySQLParser::TABLE_NAME_SYMBOL: {
        setState(6673);
        signalInformationItemName();
        break;
      }

      case MySQLParser::RETURNED_SQLSTATE_SYMBOL: {
        setState(6674);
        match(MySQLParser::RETURNED_SQLSTATE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalInformationItemNameContext ------------------------------------------------------------------

MySQLParser::SignalInformationItemNameContext::SignalInformationItemNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemNameContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}


size_t MySQLParser::SignalInformationItemNameContext::getRuleIndex() const {
  return MySQLParser::RuleSignalInformationItemName;
}

void MySQLParser::SignalInformationItemNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalInformationItemName(this);
}

void MySQLParser::SignalInformationItemNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalInformationItemName(this);
}

MySQLParser::SignalInformationItemNameContext* MySQLParser::signalInformationItemName() {
  SignalInformationItemNameContext *_localctx = _tracker.createInstance<SignalInformationItemNameContext>(_ctx, getState());
  enterRule(_localctx, 830, MySQLParser::RuleSignalInformationItemName);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6677);
    _la = _input->LA(1);
    if (!(((((_la - 101) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 101)) & ((1ULL << (MySQLParser::CATALOG_NAME_SYMBOL - 101))
      | (1ULL << (MySQLParser::CLASS_ORIGIN_SYMBOL - 101))
      | (1ULL << (MySQLParser::COLUMN_NAME_SYMBOL - 101))
      | (1ULL << (MySQLParser::CONSTRAINT_CATALOG_SYMBOL - 101))
      | (1ULL << (MySQLParser::CONSTRAINT_NAME_SYMBOL - 101))
      | (1ULL << (MySQLParser::CONSTRAINT_SCHEMA_SYMBOL - 101))
      | (1ULL << (MySQLParser::CURSOR_NAME_SYMBOL - 101)))) != 0) || _la == MySQLParser::MESSAGE_TEXT_SYMBOL

    || _la == MySQLParser::MYSQL_ERRNO_SYMBOL || _la == MySQLParser::SCHEMA_NAME_SYMBOL

    || _la == MySQLParser::SUBCLASS_ORIGIN_SYMBOL || _la == MySQLParser::TABLE_NAME_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalStatementContext ------------------------------------------------------------------

MySQLParser::SignalStatementContext::SignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SignalStatementContext::SIGNAL_SYMBOL() {
  return getToken(MySQLParser::SIGNAL_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::SignalStatementContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::SqlstateContext* MySQLParser::SignalStatementContext::sqlstate() {
  return getRuleContext<MySQLParser::SqlstateContext>(0);
}

tree::TerminalNode* MySQLParser::SignalStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<MySQLParser::SignalInformationItemContext *> MySQLParser::SignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLParser::SignalInformationItemContext>();
}

MySQLParser::SignalInformationItemContext* MySQLParser::SignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLParser::SignalInformationItemContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::SignalStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::SignalStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::SignalStatementContext::getRuleIndex() const {
  return MySQLParser::RuleSignalStatement;
}

void MySQLParser::SignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalStatement(this);
}

void MySQLParser::SignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalStatement(this);
}

MySQLParser::SignalStatementContext* MySQLParser::signalStatement() {
  SignalStatementContext *_localctx = _tracker.createInstance<SignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 832, MySQLParser::RuleSignalStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6679);
    match(MySQLParser::SIGNAL_SYMBOL);
    setState(6682);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 842, _ctx)) {
    case 1: {
      setState(6680);
      identifier();
      break;
    }

    case 2: {
      setState(6681);
      sqlstate();
      break;
    }

    }
    setState(6693);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(6684);
      match(MySQLParser::SET_SYMBOL);
      setState(6685);
      signalInformationItem();
      setState(6690);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6686);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6687);
        signalInformationItem();
        setState(6692);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResignalStatementContext ------------------------------------------------------------------

MySQLParser::ResignalStatementContext::ResignalStatementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::RESIGNAL_SYMBOL() {
  return getToken(MySQLParser::RESIGNAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::SQLSTATE_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ResignalStatementContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

std::vector<MySQLParser::SignalInformationItemContext *> MySQLParser::ResignalStatementContext::signalInformationItem() {
  return getRuleContexts<MySQLParser::SignalInformationItemContext>();
}

MySQLParser::SignalInformationItemContext* MySQLParser::ResignalStatementContext::signalInformationItem(size_t i) {
  return getRuleContext<MySQLParser::SignalInformationItemContext>(i);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ResignalStatementContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ResignalStatementContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ResignalStatementContext::getRuleIndex() const {
  return MySQLParser::RuleResignalStatement;
}

void MySQLParser::ResignalStatementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResignalStatement(this);
}

void MySQLParser::ResignalStatementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResignalStatement(this);
}

MySQLParser::ResignalStatementContext* MySQLParser::resignalStatement() {
  ResignalStatementContext *_localctx = _tracker.createInstance<ResignalStatementContext>(_ctx, getState());
  enterRule(_localctx, 834, MySQLParser::RuleResignalStatement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6695);
    match(MySQLParser::RESIGNAL_SYMBOL);
    setState(6701);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SQLSTATE_SYMBOL) {
      setState(6696);
      match(MySQLParser::SQLSTATE_SYMBOL);
      setState(6698);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 845, _ctx)) {
      case 1: {
        setState(6697);
        match(MySQLParser::VALUE_SYMBOL);
        break;
      }

      }
      setState(6700);
      textOrIdentifier();
    }
    setState(6712);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::SET_SYMBOL) {
      setState(6703);
      match(MySQLParser::SET_SYMBOL);
      setState(6704);
      signalInformationItem();
      setState(6709);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(6705);
        match(MySQLParser::COMMA_SYMBOL);
        setState(6706);
        signalInformationItem();
        setState(6711);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignalInformationItemContext ------------------------------------------------------------------

MySQLParser::SignalInformationItemContext::SignalInformationItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SignalInformationItemNameContext* MySQLParser::SignalInformationItemContext::signalInformationItemName() {
  return getRuleContext<MySQLParser::SignalInformationItemNameContext>(0);
}

tree::TerminalNode* MySQLParser::SignalInformationItemContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::SignalAllowedExprContext* MySQLParser::SignalInformationItemContext::signalAllowedExpr() {
  return getRuleContext<MySQLParser::SignalAllowedExprContext>(0);
}


size_t MySQLParser::SignalInformationItemContext::getRuleIndex() const {
  return MySQLParser::RuleSignalInformationItem;
}

void MySQLParser::SignalInformationItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignalInformationItem(this);
}

void MySQLParser::SignalInformationItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignalInformationItem(this);
}

MySQLParser::SignalInformationItemContext* MySQLParser::signalInformationItem() {
  SignalInformationItemContext *_localctx = _tracker.createInstance<SignalInformationItemContext>(_ctx, getState());
  enterRule(_localctx, 836, MySQLParser::RuleSignalInformationItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6714);
    signalInformationItemName();
    setState(6715);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(6716);
    signalAllowedExpr();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorOpenContext ------------------------------------------------------------------

MySQLParser::CursorOpenContext::CursorOpenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorOpenContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorOpenContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::CursorOpenContext::getRuleIndex() const {
  return MySQLParser::RuleCursorOpen;
}

void MySQLParser::CursorOpenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorOpen(this);
}

void MySQLParser::CursorOpenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorOpen(this);
}

MySQLParser::CursorOpenContext* MySQLParser::cursorOpen() {
  CursorOpenContext *_localctx = _tracker.createInstance<CursorOpenContext>(_ctx, getState());
  enterRule(_localctx, 838, MySQLParser::RuleCursorOpen);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6718);
    match(MySQLParser::OPEN_SYMBOL);
    setState(6719);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorCloseContext ------------------------------------------------------------------

MySQLParser::CursorCloseContext::CursorCloseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorCloseContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorCloseContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::CursorCloseContext::getRuleIndex() const {
  return MySQLParser::RuleCursorClose;
}

void MySQLParser::CursorCloseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorClose(this);
}

void MySQLParser::CursorCloseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorClose(this);
}

MySQLParser::CursorCloseContext* MySQLParser::cursorClose() {
  CursorCloseContext *_localctx = _tracker.createInstance<CursorCloseContext>(_ctx, getState());
  enterRule(_localctx, 840, MySQLParser::RuleCursorClose);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6721);
    match(MySQLParser::CLOSE_SYMBOL);
    setState(6722);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CursorFetchContext ------------------------------------------------------------------

MySQLParser::CursorFetchContext::CursorFetchContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CursorFetchContext::FETCH_SYMBOL() {
  return getToken(MySQLParser::FETCH_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CursorFetchContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CursorFetchContext::INTO_SYMBOL() {
  return getToken(MySQLParser::INTO_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::CursorFetchContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::CursorFetchContext::FROM_SYMBOL() {
  return getToken(MySQLParser::FROM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CursorFetchContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}


size_t MySQLParser::CursorFetchContext::getRuleIndex() const {
  return MySQLParser::RuleCursorFetch;
}

void MySQLParser::CursorFetchContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCursorFetch(this);
}

void MySQLParser::CursorFetchContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCursorFetch(this);
}

MySQLParser::CursorFetchContext* MySQLParser::cursorFetch() {
  CursorFetchContext *_localctx = _tracker.createInstance<CursorFetchContext>(_ctx, getState());
  enterRule(_localctx, 842, MySQLParser::RuleCursorFetch);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6724);
    match(MySQLParser::FETCH_SYMBOL);
    setState(6729);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 850, _ctx)) {
    case 1: {
      setState(6726);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NEXT_SYMBOL) {
        setState(6725);
        match(MySQLParser::NEXT_SYMBOL);
      }
      setState(6728);
      match(MySQLParser::FROM_SYMBOL);
      break;
    }

    }
    setState(6731);
    identifier();
    setState(6732);
    match(MySQLParser::INTO_SYMBOL);
    setState(6733);
    identifierList();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ScheduleContext ------------------------------------------------------------------

MySQLParser::ScheduleContext::ScheduleContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ScheduleContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

std::vector<MySQLParser::ExprContext *> MySQLParser::ScheduleContext::expr() {
  return getRuleContexts<MySQLParser::ExprContext>();
}

MySQLParser::ExprContext* MySQLParser::ScheduleContext::expr(size_t i) {
  return getRuleContext<MySQLParser::ExprContext>(i);
}

tree::TerminalNode* MySQLParser::ScheduleContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

MySQLParser::IntervalContext* MySQLParser::ScheduleContext::interval() {
  return getRuleContext<MySQLParser::IntervalContext>(0);
}

tree::TerminalNode* MySQLParser::ScheduleContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ScheduleContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}


size_t MySQLParser::ScheduleContext::getRuleIndex() const {
  return MySQLParser::RuleSchedule;
}

void MySQLParser::ScheduleContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchedule(this);
}

void MySQLParser::ScheduleContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchedule(this);
}

MySQLParser::ScheduleContext* MySQLParser::schedule() {
  ScheduleContext *_localctx = _tracker.createInstance<ScheduleContext>(_ctx, getState());
  enterRule(_localctx, 844, MySQLParser::RuleSchedule);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6748);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::AT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6735);
        match(MySQLParser::AT_SYMBOL);
        setState(6736);
        expr(0);
        break;
      }

      case MySQLParser::EVERY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6737);
        match(MySQLParser::EVERY_SYMBOL);
        setState(6738);
        expr(0);
        setState(6739);
        interval();
        setState(6742);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::STARTS_SYMBOL) {
          setState(6740);
          match(MySQLParser::STARTS_SYMBOL);
          setState(6741);
          expr(0);
        }
        setState(6746);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::ENDS_SYMBOL) {
          setState(6744);
          match(MySQLParser::ENDS_SYMBOL);
          setState(6745);
          expr(0);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnDefinitionContext ------------------------------------------------------------------

MySQLParser::ColumnDefinitionContext::ColumnDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnNameContext* MySQLParser::ColumnDefinitionContext::columnName() {
  return getRuleContext<MySQLParser::ColumnNameContext>(0);
}

MySQLParser::FieldDefinitionContext* MySQLParser::ColumnDefinitionContext::fieldDefinition() {
  return getRuleContext<MySQLParser::FieldDefinitionContext>(0);
}

MySQLParser::CheckOrReferencesContext* MySQLParser::ColumnDefinitionContext::checkOrReferences() {
  return getRuleContext<MySQLParser::CheckOrReferencesContext>(0);
}


size_t MySQLParser::ColumnDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleColumnDefinition;
}

void MySQLParser::ColumnDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnDefinition(this);
}

void MySQLParser::ColumnDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnDefinition(this);
}

MySQLParser::ColumnDefinitionContext* MySQLParser::columnDefinition() {
  ColumnDefinitionContext *_localctx = _tracker.createInstance<ColumnDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 846, MySQLParser::RuleColumnDefinition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6750);
    columnName();
    setState(6751);
    fieldDefinition();
    setState(6753);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 854, _ctx)) {
    case 1: {
      setState(6752);
      checkOrReferences();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckOrReferencesContext ------------------------------------------------------------------

MySQLParser::CheckOrReferencesContext::CheckOrReferencesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CheckConstraintContext* MySQLParser::CheckOrReferencesContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

MySQLParser::ReferencesContext* MySQLParser::CheckOrReferencesContext::references() {
  return getRuleContext<MySQLParser::ReferencesContext>(0);
}


size_t MySQLParser::CheckOrReferencesContext::getRuleIndex() const {
  return MySQLParser::RuleCheckOrReferences;
}

void MySQLParser::CheckOrReferencesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckOrReferences(this);
}

void MySQLParser::CheckOrReferencesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckOrReferences(this);
}

MySQLParser::CheckOrReferencesContext* MySQLParser::checkOrReferences() {
  CheckOrReferencesContext *_localctx = _tracker.createInstance<CheckOrReferencesContext>(_ctx, getState());
  enterRule(_localctx, 848, MySQLParser::RuleCheckOrReferences);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6758);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 855, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6755);

      if (!(serverVersion < 80016)) throw FailedPredicateException(this, "serverVersion < 80016");
      setState(6756);
      checkConstraint();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6757);
      references();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CheckConstraintContext ------------------------------------------------------------------

MySQLParser::CheckConstraintContext::CheckConstraintContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CheckConstraintContext::CHECK_SYMBOL() {
  return getToken(MySQLParser::CHECK_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::CheckConstraintContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}


size_t MySQLParser::CheckConstraintContext::getRuleIndex() const {
  return MySQLParser::RuleCheckConstraint;
}

void MySQLParser::CheckConstraintContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCheckConstraint(this);
}

void MySQLParser::CheckConstraintContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCheckConstraint(this);
}

MySQLParser::CheckConstraintContext* MySQLParser::checkConstraint() {
  CheckConstraintContext *_localctx = _tracker.createInstance<CheckConstraintContext>(_ctx, getState());
  enterRule(_localctx, 850, MySQLParser::RuleCheckConstraint);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6760);
    match(MySQLParser::CHECK_SYMBOL);
    setState(6761);
    exprWithParentheses();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintEnforcementContext ------------------------------------------------------------------

MySQLParser::ConstraintEnforcementContext::ConstraintEnforcementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConstraintEnforcementContext::ENFORCED_SYMBOL() {
  return getToken(MySQLParser::ENFORCED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ConstraintEnforcementContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}


size_t MySQLParser::ConstraintEnforcementContext::getRuleIndex() const {
  return MySQLParser::RuleConstraintEnforcement;
}

void MySQLParser::ConstraintEnforcementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintEnforcement(this);
}

void MySQLParser::ConstraintEnforcementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintEnforcement(this);
}

MySQLParser::ConstraintEnforcementContext* MySQLParser::constraintEnforcement() {
  ConstraintEnforcementContext *_localctx = _tracker.createInstance<ConstraintEnforcementContext>(_ctx, getState());
  enterRule(_localctx, 852, MySQLParser::RuleConstraintEnforcement);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6764);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::NOT_SYMBOL) {
      setState(6763);
      match(MySQLParser::NOT_SYMBOL);
    }
    setState(6766);
    match(MySQLParser::ENFORCED_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableConstraintDefContext ------------------------------------------------------------------

MySQLParser::TableConstraintDefContext::TableConstraintDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyListVariantsContext* MySQLParser::TableConstraintDefContext::keyListVariants() {
  return getRuleContext<MySQLParser::KeyListVariantsContext>(0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IndexNameAndTypeContext* MySQLParser::TableConstraintDefContext::indexNameAndType() {
  return getRuleContext<MySQLParser::IndexNameAndTypeContext>(0);
}

std::vector<MySQLParser::IndexOptionContext *> MySQLParser::TableConstraintDefContext::indexOption() {
  return getRuleContexts<MySQLParser::IndexOptionContext>();
}

MySQLParser::IndexOptionContext* MySQLParser::TableConstraintDefContext::indexOption(size_t i) {
  return getRuleContext<MySQLParser::IndexOptionContext>(i);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::FULLTEXT_SYMBOL() {
  return getToken(MySQLParser::FULLTEXT_SYMBOL, 0);
}

MySQLParser::KeyOrIndexContext* MySQLParser::TableConstraintDefContext::keyOrIndex() {
  return getRuleContext<MySQLParser::KeyOrIndexContext>(0);
}

MySQLParser::IndexNameContext* MySQLParser::TableConstraintDefContext::indexName() {
  return getRuleContext<MySQLParser::IndexNameContext>(0);
}

std::vector<MySQLParser::FulltextIndexOptionContext *> MySQLParser::TableConstraintDefContext::fulltextIndexOption() {
  return getRuleContexts<MySQLParser::FulltextIndexOptionContext>();
}

MySQLParser::FulltextIndexOptionContext* MySQLParser::TableConstraintDefContext::fulltextIndexOption(size_t i) {
  return getRuleContext<MySQLParser::FulltextIndexOptionContext>(i);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::SPATIAL_SYMBOL() {
  return getToken(MySQLParser::SPATIAL_SYMBOL, 0);
}

std::vector<MySQLParser::SpatialIndexOptionContext *> MySQLParser::TableConstraintDefContext::spatialIndexOption() {
  return getRuleContexts<MySQLParser::SpatialIndexOptionContext>();
}

MySQLParser::SpatialIndexOptionContext* MySQLParser::TableConstraintDefContext::spatialIndexOption(size_t i) {
  return getRuleContext<MySQLParser::SpatialIndexOptionContext>(i);
}

MySQLParser::KeyListContext* MySQLParser::TableConstraintDefContext::keyList() {
  return getRuleContext<MySQLParser::KeyListContext>(0);
}

MySQLParser::ReferencesContext* MySQLParser::TableConstraintDefContext::references() {
  return getRuleContext<MySQLParser::ReferencesContext>(0);
}

MySQLParser::CheckConstraintContext* MySQLParser::TableConstraintDefContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

MySQLParser::ConstraintNameContext* MySQLParser::TableConstraintDefContext::constraintName() {
  return getRuleContext<MySQLParser::ConstraintNameContext>(0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::FOREIGN_SYMBOL() {
  return getToken(MySQLParser::FOREIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableConstraintDefContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::ConstraintEnforcementContext* MySQLParser::TableConstraintDefContext::constraintEnforcement() {
  return getRuleContext<MySQLParser::ConstraintEnforcementContext>(0);
}


size_t MySQLParser::TableConstraintDefContext::getRuleIndex() const {
  return MySQLParser::RuleTableConstraintDef;
}

void MySQLParser::TableConstraintDefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableConstraintDef(this);
}

void MySQLParser::TableConstraintDefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableConstraintDef(this);
}

MySQLParser::TableConstraintDefContext* MySQLParser::tableConstraintDef() {
  TableConstraintDefContext *_localctx = _tracker.createInstance<TableConstraintDefContext>(_ctx, getState());
  enterRule(_localctx, 854, MySQLParser::RuleTableConstraintDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    setState(6843);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INDEX_SYMBOL:
      case MySQLParser::KEY_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6768);
        dynamic_cast<TableConstraintDefContext *>(_localctx)->type = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::INDEX_SYMBOL

        || _la == MySQLParser::KEY_SYMBOL)) {
          dynamic_cast<TableConstraintDefContext *>(_localctx)->type = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(6770);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 857, _ctx)) {
        case 1: {
          setState(6769);
          indexNameAndType();
          break;
        }

        }
        setState(6772);
        keyListVariants();
        setState(6776);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 858, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6773);
            indexOption(); 
          }
          setState(6778);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 858, _ctx);
        }
        break;
      }

      case MySQLParser::FULLTEXT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6779);
        dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::FULLTEXT_SYMBOL);
        setState(6781);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 859, _ctx)) {
        case 1: {
          setState(6780);
          keyOrIndex();
          break;
        }

        }
        setState(6784);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 860, _ctx)) {
        case 1: {
          setState(6783);
          indexName();
          break;
        }

        }
        setState(6786);
        keyListVariants();
        setState(6790);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 861, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6787);
            fulltextIndexOption(); 
          }
          setState(6792);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 861, _ctx);
        }
        break;
      }

      case MySQLParser::SPATIAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6793);
        dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::SPATIAL_SYMBOL);
        setState(6795);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 862, _ctx)) {
        case 1: {
          setState(6794);
          keyOrIndex();
          break;
        }

        }
        setState(6798);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 863, _ctx)) {
        case 1: {
          setState(6797);
          indexName();
          break;
        }

        }
        setState(6800);
        keyListVariants();
        setState(6804);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 864, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6801);
            spatialIndexOption(); 
          }
          setState(6806);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 864, _ctx);
        }
        break;
      }

      case MySQLParser::CHECK_SYMBOL:
      case MySQLParser::CONSTRAINT_SYMBOL:
      case MySQLParser::FOREIGN_SYMBOL:
      case MySQLParser::PRIMARY_SYMBOL:
      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(6808);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::CONSTRAINT_SYMBOL) {
          setState(6807);
          constraintName();
        }
        setState(6841);
        _errHandler->sync(this);
        switch (_input->LA(1)) {
          case MySQLParser::PRIMARY_SYMBOL:
          case MySQLParser::UNIQUE_SYMBOL: {
            setState(6816);
            _errHandler->sync(this);
            switch (_input->LA(1)) {
              case MySQLParser::PRIMARY_SYMBOL: {
                setState(6810);
                dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::PRIMARY_SYMBOL);
                setState(6811);
                match(MySQLParser::KEY_SYMBOL);
                break;
              }

              case MySQLParser::UNIQUE_SYMBOL: {
                setState(6812);
                dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::UNIQUE_SYMBOL);
                setState(6814);
                _errHandler->sync(this);

                switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 866, _ctx)) {
                case 1: {
                  setState(6813);
                  keyOrIndex();
                  break;
                }

                }
                break;
              }

            default:
              throw NoViableAltException(this);
            }
            setState(6819);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 868, _ctx)) {
            case 1: {
              setState(6818);
              indexNameAndType();
              break;
            }

            }
            setState(6821);
            keyListVariants();
            setState(6825);
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 869, _ctx);
            while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
              if (alt == 1) {
                setState(6822);
                indexOption(); 
              }
              setState(6827);
              _errHandler->sync(this);
              alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 869, _ctx);
            }
            break;
          }

          case MySQLParser::FOREIGN_SYMBOL: {
            setState(6828);
            dynamic_cast<TableConstraintDefContext *>(_localctx)->type = match(MySQLParser::FOREIGN_SYMBOL);
            setState(6829);
            match(MySQLParser::KEY_SYMBOL);
            setState(6831);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 870, _ctx)) {
            case 1: {
              setState(6830);
              indexName();
              break;
            }

            }
            setState(6833);
            keyList();
            setState(6834);
            references();
            break;
          }

          case MySQLParser::CHECK_SYMBOL: {
            setState(6836);
            checkConstraint();
            setState(6839);
            _errHandler->sync(this);

            switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 871, _ctx)) {
            case 1: {
              setState(6837);

              if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
              setState(6838);
              constraintEnforcement();
              break;
            }

            }
            break;
          }

        default:
          throw NoViableAltException(this);
        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ConstraintNameContext ------------------------------------------------------------------

MySQLParser::ConstraintNameContext::ConstraintNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ConstraintNameContext::CONSTRAINT_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::ConstraintNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::ConstraintNameContext::getRuleIndex() const {
  return MySQLParser::RuleConstraintName;
}

void MySQLParser::ConstraintNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterConstraintName(this);
}

void MySQLParser::ConstraintNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitConstraintName(this);
}

MySQLParser::ConstraintNameContext* MySQLParser::constraintName() {
  ConstraintNameContext *_localctx = _tracker.createInstance<ConstraintNameContext>(_ctx, getState());
  enterRule(_localctx, 856, MySQLParser::RuleConstraintName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6845);
    match(MySQLParser::CONSTRAINT_SYMBOL);
    setState(6847);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 874, _ctx)) {
    case 1: {
      setState(6846);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldDefinitionContext ------------------------------------------------------------------

MySQLParser::FieldDefinitionContext::FieldDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext* MySQLParser::FieldDefinitionContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::FieldDefinitionContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

std::vector<MySQLParser::ColumnAttributeContext *> MySQLParser::FieldDefinitionContext::columnAttribute() {
  return getRuleContexts<MySQLParser::ColumnAttributeContext>();
}

MySQLParser::ColumnAttributeContext* MySQLParser::FieldDefinitionContext::columnAttribute(size_t i) {
  return getRuleContext<MySQLParser::ColumnAttributeContext>(i);
}

MySQLParser::CollateContext* MySQLParser::FieldDefinitionContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::GENERATED_SYMBOL() {
  return getToken(MySQLParser::GENERATED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::VIRTUAL_SYMBOL() {
  return getToken(MySQLParser::VIRTUAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldDefinitionContext::STORED_SYMBOL() {
  return getToken(MySQLParser::STORED_SYMBOL, 0);
}

std::vector<MySQLParser::GcolAttributeContext *> MySQLParser::FieldDefinitionContext::gcolAttribute() {
  return getRuleContexts<MySQLParser::GcolAttributeContext>();
}

MySQLParser::GcolAttributeContext* MySQLParser::FieldDefinitionContext::gcolAttribute(size_t i) {
  return getRuleContext<MySQLParser::GcolAttributeContext>(i);
}


size_t MySQLParser::FieldDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleFieldDefinition;
}

void MySQLParser::FieldDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldDefinition(this);
}

void MySQLParser::FieldDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldDefinition(this);
}

MySQLParser::FieldDefinitionContext* MySQLParser::fieldDefinition() {
  FieldDefinitionContext *_localctx = _tracker.createInstance<FieldDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 858, MySQLParser::RuleFieldDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(6849);
    dataType();
    setState(6885);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 882, _ctx)) {
    case 1: {
      setState(6853);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 875, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(6850);
          columnAttribute(); 
        }
        setState(6855);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 875, _ctx);
      }
      break;
    }

    case 2: {
      setState(6856);

      if (!(serverVersion >= 50707)) throw FailedPredicateException(this, "serverVersion >= 50707");
      setState(6858);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::COLLATE_SYMBOL) {
        setState(6857);
        collate();
      }
      setState(6862);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::GENERATED_SYMBOL) {
        setState(6860);
        match(MySQLParser::GENERATED_SYMBOL);
        setState(6861);
        match(MySQLParser::ALWAYS_SYMBOL);
      }
      setState(6864);
      match(MySQLParser::AS_SYMBOL);
      setState(6865);
      exprWithParentheses();
      setState(6867);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 878, _ctx)) {
      case 1: {
        setState(6866);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::STORED_SYMBOL || _la == MySQLParser::VIRTUAL_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      }
      setState(6883);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 881, _ctx)) {
      case 1: {
        setState(6869);

        if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
        setState(6873);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 879, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6870);
            gcolAttribute(); 
          }
          setState(6875);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 879, _ctx);
        }
        break;
      }

      case 2: {
        setState(6876);

        if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
        setState(6880);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 880, _ctx);
        while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
          if (alt == 1) {
            setState(6877);
            columnAttribute(); 
          }
          setState(6882);
          _errHandler->sync(this);
          alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 880, _ctx);
        }
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnAttributeContext ------------------------------------------------------------------

MySQLParser::ColumnAttributeContext::ColumnAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::NullLiteralContext* MySQLParser::ColumnAttributeContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::NOT_SYMBOL() {
  return getToken(MySQLParser::NOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

MySQLParser::SignedLiteralContext* MySQLParser::ColumnAttributeContext::signedLiteral() {
  return getRuleContext<MySQLParser::SignedLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::NOW_SYMBOL() {
  return getToken(MySQLParser::NOW_SYMBOL, 0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::ColumnAttributeContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::TimeFunctionParametersContext* MySQLParser::ColumnAttributeContext::timeFunctionParameters() {
  return getRuleContext<MySQLParser::TimeFunctionParametersContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::ON_SYMBOL() {
  return getToken(MySQLParser::ON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::ColumnAttributeContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::CollateContext* MySQLParser::ColumnAttributeContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}

MySQLParser::ColumnFormatContext* MySQLParser::ColumnAttributeContext::columnFormat() {
  return getRuleContext<MySQLParser::ColumnFormatContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

MySQLParser::StorageMediaContext* MySQLParser::ColumnAttributeContext::storageMedia() {
  return getRuleContext<MySQLParser::StorageMediaContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::ColumnAttributeContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::ColumnAttributeContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}

MySQLParser::CheckConstraintContext* MySQLParser::ColumnAttributeContext::checkConstraint() {
  return getRuleContext<MySQLParser::CheckConstraintContext>(0);
}

MySQLParser::ConstraintNameContext* MySQLParser::ColumnAttributeContext::constraintName() {
  return getRuleContext<MySQLParser::ConstraintNameContext>(0);
}

MySQLParser::ConstraintEnforcementContext* MySQLParser::ColumnAttributeContext::constraintEnforcement() {
  return getRuleContext<MySQLParser::ConstraintEnforcementContext>(0);
}


size_t MySQLParser::ColumnAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleColumnAttribute;
}

void MySQLParser::ColumnAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnAttribute(this);
}

void MySQLParser::ColumnAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnAttribute(this);
}

MySQLParser::ColumnAttributeContext* MySQLParser::columnAttribute() {
  ColumnAttributeContext *_localctx = _tracker.createInstance<ColumnAttributeContext>(_ctx, getState());
  enterRule(_localctx, 860, MySQLParser::RuleColumnAttribute);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6939);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 890, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(6888);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::NOT_SYMBOL) {
        setState(6887);
        match(MySQLParser::NOT_SYMBOL);
      }
      setState(6890);
      nullLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(6891);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(6892);
      match(MySQLParser::NOT_SYMBOL);
      setState(6893);
      match(MySQLParser::SECONDARY_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(6894);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::DEFAULT_SYMBOL);
      setState(6902);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 885, _ctx)) {
      case 1: {
        setState(6895);
        signedLiteral();
        break;
      }

      case 2: {
        setState(6896);
        match(MySQLParser::NOW_SYMBOL);
        setState(6898);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 884, _ctx)) {
        case 1: {
          setState(6897);
          timeFunctionParameters();
          break;
        }

        }
        break;
      }

      case 3: {
        setState(6900);

        if (!(serverVersion >= 80013)) throw FailedPredicateException(this, "serverVersion >= 80013");
        setState(6901);
        exprWithParentheses();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(6904);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::ON_SYMBOL);
      setState(6905);
      match(MySQLParser::UPDATE_SYMBOL);
      setState(6906);
      match(MySQLParser::NOW_SYMBOL);
      setState(6908);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 886, _ctx)) {
      case 1: {
        setState(6907);
        timeFunctionParameters();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(6910);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::AUTO_INCREMENT_SYMBOL);
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(6911);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::SERIAL_SYMBOL);
      setState(6912);
      match(MySQLParser::DEFAULT_SYMBOL);
      setState(6913);
      match(MySQLParser::VALUE_SYMBOL);
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(6915);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::PRIMARY_SYMBOL) {
        setState(6914);
        match(MySQLParser::PRIMARY_SYMBOL);
      }
      setState(6917);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::KEY_SYMBOL);
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(6918);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::UNIQUE_SYMBOL);
      setState(6920);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 888, _ctx)) {
      case 1: {
        setState(6919);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(6922);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::COMMENT_SYMBOL);
      setState(6923);
      textLiteral();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(6924);
      collate();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(6925);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::COLUMN_FORMAT_SYMBOL);
      setState(6926);
      columnFormat();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(6927);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::STORAGE_SYMBOL);
      setState(6928);
      storageMedia();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(6929);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(6930);
      dynamic_cast<ColumnAttributeContext *>(_localctx)->value = match(MySQLParser::SRID_SYMBOL);
      setState(6931);
      real_ulonglong_number();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(6932);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(6934);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::CONSTRAINT_SYMBOL) {
        setState(6933);
        constraintName();
      }
      setState(6936);
      checkConstraint();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(6937);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(6938);
      constraintEnforcement();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnFormatContext ------------------------------------------------------------------

MySQLParser::ColumnFormatContext::ColumnFormatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ColumnFormatContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnFormatContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ColumnFormatContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::ColumnFormatContext::getRuleIndex() const {
  return MySQLParser::RuleColumnFormat;
}

void MySQLParser::ColumnFormatContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnFormat(this);
}

void MySQLParser::ColumnFormatContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnFormat(this);
}

MySQLParser::ColumnFormatContext* MySQLParser::columnFormat() {
  ColumnFormatContext *_localctx = _tracker.createInstance<ColumnFormatContext>(_ctx, getState());
  enterRule(_localctx, 862, MySQLParser::RuleColumnFormat);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6941);
    _la = _input->LA(1);
    if (!(((((_la - 172) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 172)) & ((1ULL << (MySQLParser::DEFAULT_SYMBOL - 172))
      | (1ULL << (MySQLParser::DYNAMIC_SYMBOL - 172))
      | (1ULL << (MySQLParser::FIXED_SYMBOL - 172)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StorageMediaContext ------------------------------------------------------------------

MySQLParser::StorageMediaContext::StorageMediaContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::StorageMediaContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StorageMediaContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::StorageMediaContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::StorageMediaContext::getRuleIndex() const {
  return MySQLParser::RuleStorageMedia;
}

void MySQLParser::StorageMediaContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStorageMedia(this);
}

void MySQLParser::StorageMediaContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStorageMedia(this);
}

MySQLParser::StorageMediaContext* MySQLParser::storageMedia() {
  StorageMediaContext *_localctx = _tracker.createInstance<StorageMediaContext>(_ctx, getState());
  enterRule(_localctx, 864, MySQLParser::RuleStorageMedia);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6943);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::DEFAULT_SYMBOL

    || _la == MySQLParser::DISK_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- GcolAttributeContext ------------------------------------------------------------------

MySQLParser::GcolAttributeContext::GcolAttributeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::UNIQUE_SYMBOL() {
  return getToken(MySQLParser::UNIQUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::GcolAttributeContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::GcolAttributeContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode* MySQLParser::GcolAttributeContext::PRIMARY_SYMBOL() {
  return getToken(MySQLParser::PRIMARY_SYMBOL, 0);
}


size_t MySQLParser::GcolAttributeContext::getRuleIndex() const {
  return MySQLParser::RuleGcolAttribute;
}

void MySQLParser::GcolAttributeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterGcolAttribute(this);
}

void MySQLParser::GcolAttributeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitGcolAttribute(this);
}

MySQLParser::GcolAttributeContext* MySQLParser::gcolAttribute() {
  GcolAttributeContext *_localctx = _tracker.createInstance<GcolAttributeContext>(_ctx, getState());
  enterRule(_localctx, 866, MySQLParser::RuleGcolAttribute);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6959);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNIQUE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6945);
        match(MySQLParser::UNIQUE_SYMBOL);
        setState(6947);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 891, _ctx)) {
        case 1: {
          setState(6946);
          match(MySQLParser::KEY_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6949);
        match(MySQLParser::COMMENT_SYMBOL);
        setState(6950);
        textString();
        break;
      }

      case MySQLParser::NOT2_SYMBOL:
      case MySQLParser::NOT_SYMBOL:
      case MySQLParser::NULL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6952);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::NOT2_SYMBOL || _la == MySQLParser::NOT_SYMBOL) {
          setState(6951);
          notRule();
        }
        setState(6954);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case MySQLParser::KEY_SYMBOL:
      case MySQLParser::PRIMARY_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(6956);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::PRIMARY_SYMBOL) {
          setState(6955);
          match(MySQLParser::PRIMARY_SYMBOL);
        }
        setState(6958);
        match(MySQLParser::KEY_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReferencesContext ------------------------------------------------------------------

MySQLParser::ReferencesContext::ReferencesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReferencesContext::REFERENCES_SYMBOL() {
  return getToken(MySQLParser::REFERENCES_SYMBOL, 0);
}

MySQLParser::TableRefContext* MySQLParser::ReferencesContext::tableRef() {
  return getRuleContext<MySQLParser::TableRefContext>(0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::ReferencesContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::MATCH_SYMBOL() {
  return getToken(MySQLParser::MATCH_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ReferencesContext::ON_SYMBOL() {
  return getTokens(MySQLParser::ON_SYMBOL);
}

tree::TerminalNode* MySQLParser::ReferencesContext::ON_SYMBOL(size_t i) {
  return getToken(MySQLParser::ON_SYMBOL, i);
}

std::vector<MySQLParser::DeleteOptionContext *> MySQLParser::ReferencesContext::deleteOption() {
  return getRuleContexts<MySQLParser::DeleteOptionContext>();
}

MySQLParser::DeleteOptionContext* MySQLParser::ReferencesContext::deleteOption(size_t i) {
  return getRuleContext<MySQLParser::DeleteOptionContext>(i);
}

tree::TerminalNode* MySQLParser::ReferencesContext::UPDATE_SYMBOL() {
  return getToken(MySQLParser::UPDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::DELETE_SYMBOL() {
  return getToken(MySQLParser::DELETE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ReferencesContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}


size_t MySQLParser::ReferencesContext::getRuleIndex() const {
  return MySQLParser::RuleReferences;
}

void MySQLParser::ReferencesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReferences(this);
}

void MySQLParser::ReferencesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReferences(this);
}

MySQLParser::ReferencesContext* MySQLParser::references() {
  ReferencesContext *_localctx = _tracker.createInstance<ReferencesContext>(_ctx, getState());
  enterRule(_localctx, 868, MySQLParser::RuleReferences);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6961);
    match(MySQLParser::REFERENCES_SYMBOL);
    setState(6962);
    tableRef();
    setState(6964);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(6963);
      identifierListWithParentheses();
    }
    setState(6968);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::MATCH_SYMBOL) {
      setState(6966);
      match(MySQLParser::MATCH_SYMBOL);
      setState(6967);
      dynamic_cast<ReferencesContext *>(_localctx)->match = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FULL_SYMBOL || _la == MySQLParser::PARTIAL_SYMBOL || _la == MySQLParser::SIMPLE_SYMBOL)) {
        dynamic_cast<ReferencesContext *>(_localctx)->match = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
    }
    setState(6986);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 899, _ctx)) {
    case 1: {
      setState(6970);
      match(MySQLParser::ON_SYMBOL);
      setState(6971);
      dynamic_cast<ReferencesContext *>(_localctx)->option = match(MySQLParser::UPDATE_SYMBOL);
      setState(6972);
      deleteOption();
      setState(6976);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ON_SYMBOL) {
        setState(6973);
        match(MySQLParser::ON_SYMBOL);
        setState(6974);
        match(MySQLParser::DELETE_SYMBOL);
        setState(6975);
        deleteOption();
      }
      break;
    }

    case 2: {
      setState(6978);
      match(MySQLParser::ON_SYMBOL);
      setState(6979);
      dynamic_cast<ReferencesContext *>(_localctx)->option = match(MySQLParser::DELETE_SYMBOL);
      setState(6980);
      deleteOption();
      setState(6984);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ON_SYMBOL) {
        setState(6981);
        match(MySQLParser::ON_SYMBOL);
        setState(6982);
        match(MySQLParser::UPDATE_SYMBOL);
        setState(6983);
        deleteOption();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DeleteOptionContext ------------------------------------------------------------------

MySQLParser::DeleteOptionContext::DeleteOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::RESTRICT_SYMBOL() {
  return getToken(MySQLParser::RESTRICT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::CASCADE_SYMBOL() {
  return getToken(MySQLParser::CASCADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

MySQLParser::NullLiteralContext* MySQLParser::DeleteOptionContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DeleteOptionContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}


size_t MySQLParser::DeleteOptionContext::getRuleIndex() const {
  return MySQLParser::RuleDeleteOption;
}

void MySQLParser::DeleteOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDeleteOption(this);
}

void MySQLParser::DeleteOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDeleteOption(this);
}

MySQLParser::DeleteOptionContext* MySQLParser::deleteOption() {
  DeleteOptionContext *_localctx = _tracker.createInstance<DeleteOptionContext>(_ctx, getState());
  enterRule(_localctx, 870, MySQLParser::RuleDeleteOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(6993);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CASCADE_SYMBOL:
      case MySQLParser::RESTRICT_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(6988);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::CASCADE_SYMBOL || _la == MySQLParser::RESTRICT_SYMBOL)) {
        _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        break;
      }

      case MySQLParser::SET_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(6989);
        match(MySQLParser::SET_SYMBOL);
        setState(6990);
        nullLiteral();
        break;
      }

      case MySQLParser::NO_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(6991);
        match(MySQLParser::NO_SYMBOL);
        setState(6992);
        match(MySQLParser::ACTION_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListContext ------------------------------------------------------------------

MySQLParser::KeyListContext::KeyListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::KeyListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::KeyPartContext *> MySQLParser::KeyListContext::keyPart() {
  return getRuleContexts<MySQLParser::KeyPartContext>();
}

MySQLParser::KeyPartContext* MySQLParser::KeyListContext::keyPart(size_t i) {
  return getRuleContext<MySQLParser::KeyPartContext>(i);
}

tree::TerminalNode* MySQLParser::KeyListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyListContext::getRuleIndex() const {
  return MySQLParser::RuleKeyList;
}

void MySQLParser::KeyListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyList(this);
}

void MySQLParser::KeyListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyList(this);
}

MySQLParser::KeyListContext* MySQLParser::keyList() {
  KeyListContext *_localctx = _tracker.createInstance<KeyListContext>(_ctx, getState());
  enterRule(_localctx, 872, MySQLParser::RuleKeyList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(6995);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(6996);
    keyPart();
    setState(7001);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(6997);
      match(MySQLParser::COMMA_SYMBOL);
      setState(6998);
      keyPart();
      setState(7003);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7004);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartContext ------------------------------------------------------------------

MySQLParser::KeyPartContext::KeyPartContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::KeyPartContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldLengthContext* MySQLParser::KeyPartContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::DirectionContext* MySQLParser::KeyPartContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}


size_t MySQLParser::KeyPartContext::getRuleIndex() const {
  return MySQLParser::RuleKeyPart;
}

void MySQLParser::KeyPartContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPart(this);
}

void MySQLParser::KeyPartContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPart(this);
}

MySQLParser::KeyPartContext* MySQLParser::keyPart() {
  KeyPartContext *_localctx = _tracker.createInstance<KeyPartContext>(_ctx, getState());
  enterRule(_localctx, 874, MySQLParser::RuleKeyPart);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7006);
    identifier();
    setState(7008);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(7007);
      fieldLength();
    }
    setState(7011);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
      setState(7010);
      direction();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListWithExpressionContext ------------------------------------------------------------------

MySQLParser::KeyListWithExpressionContext::KeyListWithExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::KeyListWithExpressionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::KeyPartOrExpressionContext *> MySQLParser::KeyListWithExpressionContext::keyPartOrExpression() {
  return getRuleContexts<MySQLParser::KeyPartOrExpressionContext>();
}

MySQLParser::KeyPartOrExpressionContext* MySQLParser::KeyListWithExpressionContext::keyPartOrExpression(size_t i) {
  return getRuleContext<MySQLParser::KeyPartOrExpressionContext>(i);
}

tree::TerminalNode* MySQLParser::KeyListWithExpressionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::KeyListWithExpressionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::KeyListWithExpressionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::KeyListWithExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleKeyListWithExpression;
}

void MySQLParser::KeyListWithExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyListWithExpression(this);
}

void MySQLParser::KeyListWithExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyListWithExpression(this);
}

MySQLParser::KeyListWithExpressionContext* MySQLParser::keyListWithExpression() {
  KeyListWithExpressionContext *_localctx = _tracker.createInstance<KeyListWithExpressionContext>(_ctx, getState());
  enterRule(_localctx, 876, MySQLParser::RuleKeyListWithExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7013);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7014);
    keyPartOrExpression();
    setState(7019);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7015);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7016);
      keyPartOrExpression();
      setState(7021);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7022);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyPartOrExpressionContext ------------------------------------------------------------------

MySQLParser::KeyPartOrExpressionContext::KeyPartOrExpressionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyPartContext* MySQLParser::KeyPartOrExpressionContext::keyPart() {
  return getRuleContext<MySQLParser::KeyPartContext>(0);
}

MySQLParser::ExprWithParenthesesContext* MySQLParser::KeyPartOrExpressionContext::exprWithParentheses() {
  return getRuleContext<MySQLParser::ExprWithParenthesesContext>(0);
}

MySQLParser::DirectionContext* MySQLParser::KeyPartOrExpressionContext::direction() {
  return getRuleContext<MySQLParser::DirectionContext>(0);
}


size_t MySQLParser::KeyPartOrExpressionContext::getRuleIndex() const {
  return MySQLParser::RuleKeyPartOrExpression;
}

void MySQLParser::KeyPartOrExpressionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyPartOrExpression(this);
}

void MySQLParser::KeyPartOrExpressionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyPartOrExpression(this);
}

MySQLParser::KeyPartOrExpressionContext* MySQLParser::keyPartOrExpression() {
  KeyPartOrExpressionContext *_localctx = _tracker.createInstance<KeyPartOrExpressionContext>(_ctx, getState());
  enterRule(_localctx, 878, MySQLParser::RuleKeyPartOrExpression);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7029);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 906, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7024);
      keyPart();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7025);
      exprWithParentheses();
      setState(7027);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::ASC_SYMBOL || _la == MySQLParser::DESC_SYMBOL) {
        setState(7026);
        direction();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- KeyListVariantsContext ------------------------------------------------------------------

MySQLParser::KeyListVariantsContext::KeyListVariantsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::KeyListWithExpressionContext* MySQLParser::KeyListVariantsContext::keyListWithExpression() {
  return getRuleContext<MySQLParser::KeyListWithExpressionContext>(0);
}

MySQLParser::KeyListContext* MySQLParser::KeyListVariantsContext::keyList() {
  return getRuleContext<MySQLParser::KeyListContext>(0);
}


size_t MySQLParser::KeyListVariantsContext::getRuleIndex() const {
  return MySQLParser::RuleKeyListVariants;
}

void MySQLParser::KeyListVariantsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterKeyListVariants(this);
}

void MySQLParser::KeyListVariantsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitKeyListVariants(this);
}

MySQLParser::KeyListVariantsContext* MySQLParser::keyListVariants() {
  KeyListVariantsContext *_localctx = _tracker.createInstance<KeyListVariantsContext>(_ctx, getState());
  enterRule(_localctx, 880, MySQLParser::RuleKeyListVariants);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7035);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 907, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7031);

      if (!(serverVersion >= 80013)) throw FailedPredicateException(this, "serverVersion >= 80013");
      setState(7032);
      keyListWithExpression();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7033);

      if (!(serverVersion < 80013)) throw FailedPredicateException(this, "serverVersion < 80013");
      setState(7034);
      keyList();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeContext ------------------------------------------------------------------

MySQLParser::IndexTypeContext::IndexTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IndexTypeContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexTypeContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexTypeContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}


size_t MySQLParser::IndexTypeContext::getRuleIndex() const {
  return MySQLParser::RuleIndexType;
}

void MySQLParser::IndexTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexType(this);
}

void MySQLParser::IndexTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexType(this);
}

MySQLParser::IndexTypeContext* MySQLParser::indexType() {
  IndexTypeContext *_localctx = _tracker.createInstance<IndexTypeContext>(_ctx, getState());
  enterRule(_localctx, 882, MySQLParser::RuleIndexType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7037);
    dynamic_cast<IndexTypeContext *>(_localctx)->algorithm = _input->LT(1);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::BTREE_SYMBOL || _la == MySQLParser::HASH_SYMBOL || _la == MySQLParser::RTREE_SYMBOL)) {
      dynamic_cast<IndexTypeContext *>(_localctx)->algorithm = _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexOptionContext ------------------------------------------------------------------

MySQLParser::IndexOptionContext::IndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext* MySQLParser::IndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}

MySQLParser::IndexTypeClauseContext* MySQLParser::IndexOptionContext::indexTypeClause() {
  return getRuleContext<MySQLParser::IndexTypeClauseContext>(0);
}


size_t MySQLParser::IndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleIndexOption;
}

void MySQLParser::IndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexOption(this);
}

void MySQLParser::IndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexOption(this);
}

MySQLParser::IndexOptionContext* MySQLParser::indexOption() {
  IndexOptionContext *_localctx = _tracker.createInstance<IndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 884, MySQLParser::RuleIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7041);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 908, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7039);
      commonIndexOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7040);
      indexTypeClause();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CommonIndexOptionContext ------------------------------------------------------------------

MySQLParser::CommonIndexOptionContext::CommonIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CommonIndexOptionContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::CommonIndexOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CommonIndexOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CommonIndexOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::CommonIndexOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::VisibilityContext* MySQLParser::CommonIndexOptionContext::visibility() {
  return getRuleContext<MySQLParser::VisibilityContext>(0);
}


size_t MySQLParser::CommonIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCommonIndexOption;
}

void MySQLParser::CommonIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCommonIndexOption(this);
}

void MySQLParser::CommonIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCommonIndexOption(this);
}

MySQLParser::CommonIndexOptionContext* MySQLParser::commonIndexOption() {
  CommonIndexOptionContext *_localctx = _tracker.createInstance<CommonIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 886, MySQLParser::RuleCommonIndexOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7053);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 910, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7043);
      match(MySQLParser::KEY_BLOCK_SIZE_SYMBOL);
      setState(7045);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7044);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7047);
      ulong_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7048);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(7049);
      match(MySQLParser::COMMENT_SYMBOL);
      setState(7050);
      textLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7051);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(7052);
      visibility();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VisibilityContext ------------------------------------------------------------------

MySQLParser::VisibilityContext::VisibilityContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VisibilityContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VisibilityContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}


size_t MySQLParser::VisibilityContext::getRuleIndex() const {
  return MySQLParser::RuleVisibility;
}

void MySQLParser::VisibilityContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVisibility(this);
}

void MySQLParser::VisibilityContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVisibility(this);
}

MySQLParser::VisibilityContext* MySQLParser::visibility() {
  VisibilityContext *_localctx = _tracker.createInstance<VisibilityContext>(_ctx, getState());
  enterRule(_localctx, 888, MySQLParser::RuleVisibility);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7055);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::INVISIBLE_SYMBOL

    || _la == MySQLParser::VISIBLE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexTypeClauseContext ------------------------------------------------------------------

MySQLParser::IndexTypeClauseContext::IndexTypeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IndexTypeContext* MySQLParser::IndexTypeClauseContext::indexType() {
  return getRuleContext<MySQLParser::IndexTypeContext>(0);
}

tree::TerminalNode* MySQLParser::IndexTypeClauseContext::USING_SYMBOL() {
  return getToken(MySQLParser::USING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IndexTypeClauseContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}


size_t MySQLParser::IndexTypeClauseContext::getRuleIndex() const {
  return MySQLParser::RuleIndexTypeClause;
}

void MySQLParser::IndexTypeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexTypeClause(this);
}

void MySQLParser::IndexTypeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexTypeClause(this);
}

MySQLParser::IndexTypeClauseContext* MySQLParser::indexTypeClause() {
  IndexTypeClauseContext *_localctx = _tracker.createInstance<IndexTypeClauseContext>(_ctx, getState());
  enterRule(_localctx, 890, MySQLParser::RuleIndexTypeClause);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7057);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::TYPE_SYMBOL

    || _la == MySQLParser::USING_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7058);
    indexType();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FulltextIndexOptionContext ------------------------------------------------------------------

MySQLParser::FulltextIndexOptionContext::FulltextIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext* MySQLParser::FulltextIndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}

tree::TerminalNode* MySQLParser::FulltextIndexOptionContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FulltextIndexOptionContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::FulltextIndexOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::FulltextIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleFulltextIndexOption;
}

void MySQLParser::FulltextIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFulltextIndexOption(this);
}

void MySQLParser::FulltextIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFulltextIndexOption(this);
}

MySQLParser::FulltextIndexOptionContext* MySQLParser::fulltextIndexOption() {
  FulltextIndexOptionContext *_localctx = _tracker.createInstance<FulltextIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 892, MySQLParser::RuleFulltextIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7064);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 911, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7060);
      commonIndexOption();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7061);
      match(MySQLParser::WITH_SYMBOL);
      setState(7062);
      match(MySQLParser::PARSER_SYMBOL);
      setState(7063);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SpatialIndexOptionContext ------------------------------------------------------------------

MySQLParser::SpatialIndexOptionContext::SpatialIndexOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CommonIndexOptionContext* MySQLParser::SpatialIndexOptionContext::commonIndexOption() {
  return getRuleContext<MySQLParser::CommonIndexOptionContext>(0);
}


size_t MySQLParser::SpatialIndexOptionContext::getRuleIndex() const {
  return MySQLParser::RuleSpatialIndexOption;
}

void MySQLParser::SpatialIndexOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSpatialIndexOption(this);
}

void MySQLParser::SpatialIndexOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSpatialIndexOption(this);
}

MySQLParser::SpatialIndexOptionContext* MySQLParser::spatialIndexOption() {
  SpatialIndexOptionContext *_localctx = _tracker.createInstance<SpatialIndexOptionContext>(_ctx, getState());
  enterRule(_localctx, 894, MySQLParser::RuleSpatialIndexOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7066);
    commonIndexOption();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeDefinitionContext ------------------------------------------------------------------

MySQLParser::DataTypeDefinitionContext::DataTypeDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext* MySQLParser::DataTypeDefinitionContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeDefinitionContext::EOF() {
  return getToken(MySQLParser::EOF, 0);
}


size_t MySQLParser::DataTypeDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleDataTypeDefinition;
}

void MySQLParser::DataTypeDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataTypeDefinition(this);
}

void MySQLParser::DataTypeDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataTypeDefinition(this);
}

MySQLParser::DataTypeDefinitionContext* MySQLParser::dataTypeDefinition() {
  DataTypeDefinitionContext *_localctx = _tracker.createInstance<DataTypeDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 896, MySQLParser::RuleDataTypeDefinition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7068);
    dataType();
    setState(7069);
    match(MySQLParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DataTypeContext ------------------------------------------------------------------

MySQLParser::DataTypeContext::DataTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DataTypeContext::INT_SYMBOL() {
  return getToken(MySQLParser::INT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TINYINT_SYMBOL() {
  return getToken(MySQLParser::TINYINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::SMALLINT_SYMBOL() {
  return getToken(MySQLParser::SMALLINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MEDIUMINT_SYMBOL() {
  return getToken(MySQLParser::MEDIUMINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BIGINT_SYMBOL() {
  return getToken(MySQLParser::BIGINT_SYMBOL, 0);
}

MySQLParser::FieldLengthContext* MySQLParser::DataTypeContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::FieldOptionsContext* MySQLParser::DataTypeContext::fieldOptions() {
  return getRuleContext<MySQLParser::FieldOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DOUBLE_SYMBOL() {
  return getToken(MySQLParser::DOUBLE_SYMBOL, 0);
}

MySQLParser::PrecisionContext* MySQLParser::DataTypeContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::PRECISION_SYMBOL() {
  return getToken(MySQLParser::PRECISION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::FLOAT_SYMBOL() {
  return getToken(MySQLParser::FLOAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DECIMAL_SYMBOL() {
  return getToken(MySQLParser::DECIMAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NUMERIC_SYMBOL() {
  return getToken(MySQLParser::NUMERIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

MySQLParser::FloatOptionsContext* MySQLParser::DataTypeContext::floatOptions() {
  return getRuleContext<MySQLParser::FloatOptionsContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

MySQLParser::CharsetWithOptBinaryContext* MySQLParser::DataTypeContext::charsetWithOptBinary() {
  return getRuleContext<MySQLParser::CharsetWithOptBinaryContext>(0);
}

MySQLParser::NcharContext* MySQLParser::DataTypeContext::nchar() {
  return getRuleContext<MySQLParser::NcharContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::VARYING_SYMBOL() {
  return getToken(MySQLParser::VARYING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::VARCHAR_SYMBOL() {
  return getToken(MySQLParser::VARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::VARBINARY_SYMBOL() {
  return getToken(MySQLParser::VARBINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

MySQLParser::TypeDatetimePrecisionContext* MySQLParser::DataTypeContext::typeDatetimePrecision() {
  return getRuleContext<MySQLParser::TypeDatetimePrecisionContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TINYBLOB_SYMBOL() {
  return getToken(MySQLParser::TINYBLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::BLOB_SYMBOL() {
  return getToken(MySQLParser::BLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MEDIUMBLOB_SYMBOL() {
  return getToken(MySQLParser::MEDIUMBLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LONGBLOB_SYMBOL() {
  return getToken(MySQLParser::LONGBLOB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LONG_SYMBOL() {
  return getToken(MySQLParser::LONG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TINYTEXT_SYMBOL() {
  return getToken(MySQLParser::TINYTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MEDIUMTEXT_SYMBOL() {
  return getToken(MySQLParser::MEDIUMTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LONGTEXT_SYMBOL() {
  return getToken(MySQLParser::LONGTEXT_SYMBOL, 0);
}

MySQLParser::StringListContext* MySQLParser::DataTypeContext::stringList() {
  return getRuleContext<MySQLParser::StringListContext>(0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::SET_SYMBOL() {
  return getToken(MySQLParser::SET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DataTypeContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}


size_t MySQLParser::DataTypeContext::getRuleIndex() const {
  return MySQLParser::RuleDataType;
}

void MySQLParser::DataTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDataType(this);
}

void MySQLParser::DataTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDataType(this);
}

MySQLParser::DataTypeContext* MySQLParser::dataType() {
  DataTypeContext *_localctx = _tracker.createInstance<DataTypeContext>(_ctx, getState());
  enterRule(_localctx, 898, MySQLParser::RuleDataType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7218);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 945, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7071);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BIGINT_SYMBOL || _la == MySQLParser::INT_SYMBOL || _la == MySQLParser::MEDIUMINT_SYMBOL || _la == MySQLParser::SMALLINT_SYMBOL || _la == MySQLParser::TINYINT_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7073);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 912, _ctx)) {
      case 1: {
        setState(7072);
        fieldLength();
        break;
      }

      }
      setState(7076);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 913, _ctx)) {
      case 1: {
        setState(7075);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7083);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::REAL_SYMBOL: {
          setState(7078);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::REAL_SYMBOL);
          break;
        }

        case MySQLParser::DOUBLE_SYMBOL: {
          setState(7079);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DOUBLE_SYMBOL);
          setState(7081);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 914, _ctx)) {
          case 1: {
            setState(7080);
            match(MySQLParser::PRECISION_SYMBOL);
            break;
          }

          }
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(7086);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 916, _ctx)) {
      case 1: {
        setState(7085);
        precision();
        break;
      }

      }
      setState(7089);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 917, _ctx)) {
      case 1: {
        setState(7088);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7091);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DECIMAL_SYMBOL

      || _la == MySQLParser::FIXED_SYMBOL || _la == MySQLParser::FLOAT_SYMBOL || _la == MySQLParser::NUMERIC_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7093);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 918, _ctx)) {
      case 1: {
        setState(7092);
        floatOptions();
        break;
      }

      }
      setState(7096);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 919, _ctx)) {
      case 1: {
        setState(7095);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7098);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BIT_SYMBOL);
      setState(7100);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 920, _ctx)) {
      case 1: {
        setState(7099);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7102);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::BOOLEAN_SYMBOL

      || _la == MySQLParser::BOOL_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7103);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
      setState(7105);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 921, _ctx)) {
      case 1: {
        setState(7104);
        fieldLength();
        break;
      }

      }
      setState(7108);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 922, _ctx)) {
      case 1: {
        setState(7107);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7110);
      nchar();
      setState(7112);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 923, _ctx)) {
      case 1: {
        setState(7111);
        fieldLength();
        break;
      }

      }
      setState(7115);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 924, _ctx)) {
      case 1: {
        setState(7114);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7117);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BINARY_SYMBOL);
      setState(7119);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 925, _ctx)) {
      case 1: {
        setState(7118);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7124);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::CHAR_SYMBOL: {
          setState(7121);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
          setState(7122);
          match(MySQLParser::VARYING_SYMBOL);
          break;
        }

        case MySQLParser::VARCHAR_SYMBOL: {
          setState(7123);
          dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::VARCHAR_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(7126);
      fieldLength();
      setState(7128);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 927, _ctx)) {
      case 1: {
        setState(7127);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(7140);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 928, _ctx)) {
      case 1: {
        setState(7130);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
        setState(7131);
        match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

      case 2: {
        setState(7132);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NVARCHAR_SYMBOL);
        break;
      }

      case 3: {
        setState(7133);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
        setState(7134);
        match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

      case 4: {
        setState(7135);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
        setState(7136);
        match(MySQLParser::CHAR_SYMBOL);
        setState(7137);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      case 5: {
        setState(7138);
        dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
        setState(7139);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      }
      setState(7142);
      fieldLength();
      setState(7144);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 929, _ctx)) {
      case 1: {
        setState(7143);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(7146);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::VARBINARY_SYMBOL);
      setState(7147);
      fieldLength();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(7148);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::YEAR_SYMBOL);
      setState(7150);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 930, _ctx)) {
      case 1: {
        setState(7149);
        fieldLength();
        break;
      }

      }
      setState(7153);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 931, _ctx)) {
      case 1: {
        setState(7152);
        fieldOptions();
        break;
      }

      }
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(7155);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DATE_SYMBOL);
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(7156);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TIME_SYMBOL);
      setState(7158);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 932, _ctx)) {
      case 1: {
        setState(7157);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(7160);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TIMESTAMP_SYMBOL);
      setState(7162);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 933, _ctx)) {
      case 1: {
        setState(7161);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(7164);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::DATETIME_SYMBOL);
      setState(7166);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 934, _ctx)) {
      case 1: {
        setState(7165);
        typeDatetimePrecision();
        break;
      }

      }
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(7168);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TINYBLOB_SYMBOL);
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(7169);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::BLOB_SYMBOL);
      setState(7171);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 935, _ctx)) {
      case 1: {
        setState(7170);
        fieldLength();
        break;
      }

      }
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(7173);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LONGBLOB_SYMBOL

      || _la == MySQLParser::MEDIUMBLOB_SYMBOL)) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(7174);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONG_SYMBOL);
      setState(7175);
      match(MySQLParser::VARBINARY_SYMBOL);
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(7176);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONG_SYMBOL);
      setState(7180);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 936, _ctx)) {
      case 1: {
        setState(7177);
        match(MySQLParser::CHAR_SYMBOL);
        setState(7178);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      case 2: {
        setState(7179);
        match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

      }
      setState(7183);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 937, _ctx)) {
      case 1: {
        setState(7182);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(7185);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TINYTEXT_SYMBOL);
      setState(7187);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 938, _ctx)) {
      case 1: {
        setState(7186);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(7189);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::TEXT_SYMBOL);
      setState(7191);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 939, _ctx)) {
      case 1: {
        setState(7190);
        fieldLength();
        break;
      }

      }
      setState(7194);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 940, _ctx)) {
      case 1: {
        setState(7193);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(7196);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::MEDIUMTEXT_SYMBOL);
      setState(7198);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 941, _ctx)) {
      case 1: {
        setState(7197);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(7200);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::LONGTEXT_SYMBOL);
      setState(7202);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 942, _ctx)) {
      case 1: {
        setState(7201);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 26: {
      enterOuterAlt(_localctx, 26);
      setState(7204);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::ENUM_SYMBOL);
      setState(7205);
      stringList();
      setState(7207);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 943, _ctx)) {
      case 1: {
        setState(7206);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 27: {
      enterOuterAlt(_localctx, 27);
      setState(7209);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::SET_SYMBOL);
      setState(7210);
      stringList();
      setState(7212);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 944, _ctx)) {
      case 1: {
        setState(7211);
        charsetWithOptBinary();
        break;
      }

      }
      break;
    }

    case 28: {
      enterOuterAlt(_localctx, 28);
      setState(7214);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::SERIAL_SYMBOL);
      break;
    }

    case 29: {
      enterOuterAlt(_localctx, 29);
      setState(7215);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(7216);
      dynamic_cast<DataTypeContext *>(_localctx)->type = match(MySQLParser::JSON_SYMBOL);
      break;
    }

    case 30: {
      enterOuterAlt(_localctx, 30);
      setState(7217);
      dynamic_cast<DataTypeContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::GEOMETRYCOLLECTION_SYMBOL

      || _la == MySQLParser::GEOMETRY_SYMBOL || _la == MySQLParser::LINESTRING_SYMBOL || ((((_la - 385) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 385)) & ((1ULL << (MySQLParser::MULTILINESTRING_SYMBOL - 385))
        | (1ULL << (MySQLParser::MULTIPOINT_SYMBOL - 385))
        | (1ULL << (MySQLParser::MULTIPOLYGON_SYMBOL - 385))
        | (1ULL << (MySQLParser::POINT_SYMBOL - 385))
        | (1ULL << (MySQLParser::POLYGON_SYMBOL - 385)))) != 0))) {
        dynamic_cast<DataTypeContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NcharContext ------------------------------------------------------------------

MySQLParser::NcharContext::NcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NcharContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NcharContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NcharContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}


size_t MySQLParser::NcharContext::getRuleIndex() const {
  return MySQLParser::RuleNchar;
}

void MySQLParser::NcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNchar(this);
}

void MySQLParser::NcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNchar(this);
}

MySQLParser::NcharContext* MySQLParser::nchar() {
  NcharContext *_localctx = _tracker.createInstance<NcharContext>(_ctx, getState());
  enterRule(_localctx, 900, MySQLParser::RuleNchar);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7223);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::NCHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7220);
        dynamic_cast<NcharContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
        break;
      }

      case MySQLParser::NATIONAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7221);
        dynamic_cast<NcharContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
        setState(7222);
        match(MySQLParser::CHAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarcharContext ------------------------------------------------------------------

MySQLParser::VarcharContext::VarcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VarcharContext::VARYING_SYMBOL() {
  return getToken(MySQLParser::VARYING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarcharContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarcharContext::VARCHAR_SYMBOL() {
  return getToken(MySQLParser::VARCHAR_SYMBOL, 0);
}


size_t MySQLParser::VarcharContext::getRuleIndex() const {
  return MySQLParser::RuleVarchar;
}

void MySQLParser::VarcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarchar(this);
}

void MySQLParser::VarcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarchar(this);
}

MySQLParser::VarcharContext* MySQLParser::varchar() {
  VarcharContext *_localctx = _tracker.createInstance<VarcharContext>(_ctx, getState());
  enterRule(_localctx, 902, MySQLParser::RuleVarchar);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7228);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::CHAR_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7225);
        dynamic_cast<VarcharContext *>(_localctx)->type = match(MySQLParser::CHAR_SYMBOL);
        setState(7226);
        match(MySQLParser::VARYING_SYMBOL);
        break;
      }

      case MySQLParser::VARCHAR_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7227);
        dynamic_cast<VarcharContext *>(_localctx)->type = match(MySQLParser::VARCHAR_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NvarcharContext ------------------------------------------------------------------

MySQLParser::NvarcharContext::NvarcharContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NvarcharContext::VARCHAR_SYMBOL() {
  return getToken(MySQLParser::VARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::CHAR_SYMBOL() {
  return getToken(MySQLParser::CHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NvarcharContext::VARYING_SYMBOL() {
  return getToken(MySQLParser::VARYING_SYMBOL, 0);
}


size_t MySQLParser::NvarcharContext::getRuleIndex() const {
  return MySQLParser::RuleNvarchar;
}

void MySQLParser::NvarcharContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNvarchar(this);
}

void MySQLParser::NvarcharContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNvarchar(this);
}

MySQLParser::NvarcharContext* MySQLParser::nvarchar() {
  NvarcharContext *_localctx = _tracker.createInstance<NvarcharContext>(_ctx, getState());
  enterRule(_localctx, 904, MySQLParser::RuleNvarchar);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7240);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 948, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7230);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
      setState(7231);
      match(MySQLParser::VARCHAR_SYMBOL);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7232);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NVARCHAR_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7233);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
      setState(7234);
      match(MySQLParser::VARCHAR_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7235);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NATIONAL_SYMBOL);
      setState(7236);
      match(MySQLParser::CHAR_SYMBOL);
      setState(7237);
      match(MySQLParser::VARYING_SYMBOL);
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7238);
      dynamic_cast<NvarcharContext *>(_localctx)->type = match(MySQLParser::NCHAR_SYMBOL);
      setState(7239);
      match(MySQLParser::VARYING_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RealTypeContext ------------------------------------------------------------------

MySQLParser::RealTypeContext::RealTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RealTypeContext::REAL_SYMBOL() {
  return getToken(MySQLParser::REAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RealTypeContext::DOUBLE_SYMBOL() {
  return getToken(MySQLParser::DOUBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RealTypeContext::PRECISION_SYMBOL() {
  return getToken(MySQLParser::PRECISION_SYMBOL, 0);
}


size_t MySQLParser::RealTypeContext::getRuleIndex() const {
  return MySQLParser::RuleRealType;
}

void MySQLParser::RealTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRealType(this);
}

void MySQLParser::RealTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRealType(this);
}

MySQLParser::RealTypeContext* MySQLParser::realType() {
  RealTypeContext *_localctx = _tracker.createInstance<RealTypeContext>(_ctx, getState());
  enterRule(_localctx, 906, MySQLParser::RuleRealType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7247);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::REAL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7242);
        dynamic_cast<RealTypeContext *>(_localctx)->type = match(MySQLParser::REAL_SYMBOL);
        break;
      }

      case MySQLParser::DOUBLE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7243);
        dynamic_cast<RealTypeContext *>(_localctx)->type = match(MySQLParser::DOUBLE_SYMBOL);
        setState(7245);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 949, _ctx)) {
        case 1: {
          setState(7244);
          match(MySQLParser::PRECISION_SYMBOL);
          break;
        }

        }
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldLengthContext ------------------------------------------------------------------

MySQLParser::FieldLengthContext::FieldLengthContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FieldLengthContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldLengthContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::FieldLengthContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::FieldLengthContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}


size_t MySQLParser::FieldLengthContext::getRuleIndex() const {
  return MySQLParser::RuleFieldLength;
}

void MySQLParser::FieldLengthContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldLength(this);
}

void MySQLParser::FieldLengthContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldLength(this);
}

MySQLParser::FieldLengthContext* MySQLParser::fieldLength() {
  FieldLengthContext *_localctx = _tracker.createInstance<FieldLengthContext>(_ctx, getState());
  enterRule(_localctx, 908, MySQLParser::RuleFieldLength);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7249);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7252);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 951, _ctx)) {
    case 1: {
      setState(7250);
      real_ulonglong_number();
      break;
    }

    case 2: {
      setState(7251);
      match(MySQLParser::DECIMAL_NUMBER);
      break;
    }

    }
    setState(7254);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldOptionsContext ------------------------------------------------------------------

MySQLParser::FieldOptionsContext::FieldOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::SIGNED_SYMBOL() {
  return getTokens(MySQLParser::SIGNED_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOptionsContext::SIGNED_SYMBOL(size_t i) {
  return getToken(MySQLParser::SIGNED_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::UNSIGNED_SYMBOL() {
  return getTokens(MySQLParser::UNSIGNED_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOptionsContext::UNSIGNED_SYMBOL(size_t i) {
  return getToken(MySQLParser::UNSIGNED_SYMBOL, i);
}

std::vector<tree::TerminalNode *> MySQLParser::FieldOptionsContext::ZEROFILL_SYMBOL() {
  return getTokens(MySQLParser::ZEROFILL_SYMBOL);
}

tree::TerminalNode* MySQLParser::FieldOptionsContext::ZEROFILL_SYMBOL(size_t i) {
  return getToken(MySQLParser::ZEROFILL_SYMBOL, i);
}


size_t MySQLParser::FieldOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFieldOptions;
}

void MySQLParser::FieldOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldOptions(this);
}

void MySQLParser::FieldOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldOptions(this);
}

MySQLParser::FieldOptionsContext* MySQLParser::fieldOptions() {
  FieldOptionsContext *_localctx = _tracker.createInstance<FieldOptionsContext>(_ctx, getState());
  enterRule(_localctx, 910, MySQLParser::RuleFieldOptions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7257); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7256);
              _la = _input->LA(1);
              if (!(_la == MySQLParser::SIGNED_SYMBOL || _la == MySQLParser::UNSIGNED_SYMBOL

              || _la == MySQLParser::ZEROFILL_SYMBOL)) {
              _errHandler->recoverInline(this);
              }
              else {
                _errHandler->reportMatch(this);
                consume();
              }
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7259); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 952, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetWithOptBinaryContext ------------------------------------------------------------------

MySQLParser::CharsetWithOptBinaryContext::CharsetWithOptBinaryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::AsciiContext* MySQLParser::CharsetWithOptBinaryContext::ascii() {
  return getRuleContext<MySQLParser::AsciiContext>(0);
}

MySQLParser::UnicodeContext* MySQLParser::CharsetWithOptBinaryContext::unicode() {
  return getRuleContext<MySQLParser::UnicodeContext>(0);
}

tree::TerminalNode* MySQLParser::CharsetWithOptBinaryContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

MySQLParser::CharsetContext* MySQLParser::CharsetWithOptBinaryContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::CharsetWithOptBinaryContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::CharsetWithOptBinaryContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}


size_t MySQLParser::CharsetWithOptBinaryContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetWithOptBinary;
}

void MySQLParser::CharsetWithOptBinaryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetWithOptBinary(this);
}

void MySQLParser::CharsetWithOptBinaryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetWithOptBinary(this);
}

MySQLParser::CharsetWithOptBinaryContext* MySQLParser::charsetWithOptBinary() {
  CharsetWithOptBinaryContext *_localctx = _tracker.createInstance<CharsetWithOptBinaryContext>(_ctx, getState());
  enterRule(_localctx, 912, MySQLParser::RuleCharsetWithOptBinary);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7275);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 955, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7261);
      ascii();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7262);
      unicode();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7263);
      match(MySQLParser::BYTE_SYMBOL);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7264);
      charset();
      setState(7265);
      charsetName();
      setState(7267);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 953, _ctx)) {
      case 1: {
        setState(7266);
        match(MySQLParser::BINARY_SYMBOL);
        break;
      }

      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7269);
      match(MySQLParser::BINARY_SYMBOL);
      setState(7273);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 954, _ctx)) {
      case 1: {
        setState(7270);
        charset();
        setState(7271);
        charsetName();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AsciiContext ------------------------------------------------------------------

MySQLParser::AsciiContext::AsciiContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::AsciiContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AsciiContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}


size_t MySQLParser::AsciiContext::getRuleIndex() const {
  return MySQLParser::RuleAscii;
}

void MySQLParser::AsciiContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAscii(this);
}

void MySQLParser::AsciiContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAscii(this);
}

MySQLParser::AsciiContext* MySQLParser::ascii() {
  AsciiContext *_localctx = _tracker.createInstance<AsciiContext>(_ctx, getState());
  enterRule(_localctx, 914, MySQLParser::RuleAscii);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7283);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ASCII_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7277);
        match(MySQLParser::ASCII_SYMBOL);
        setState(7279);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 956, _ctx)) {
        case 1: {
          setState(7278);
          match(MySQLParser::BINARY_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::BINARY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7281);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7282);
        match(MySQLParser::ASCII_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UnicodeContext ------------------------------------------------------------------

MySQLParser::UnicodeContext::UnicodeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UnicodeContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UnicodeContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}


size_t MySQLParser::UnicodeContext::getRuleIndex() const {
  return MySQLParser::RuleUnicode;
}

void MySQLParser::UnicodeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUnicode(this);
}

void MySQLParser::UnicodeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUnicode(this);
}

MySQLParser::UnicodeContext* MySQLParser::unicode() {
  UnicodeContext *_localctx = _tracker.createInstance<UnicodeContext>(_ctx, getState());
  enterRule(_localctx, 916, MySQLParser::RuleUnicode);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7291);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::UNICODE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7285);
        match(MySQLParser::UNICODE_SYMBOL);
        setState(7287);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 958, _ctx)) {
        case 1: {
          setState(7286);
          match(MySQLParser::BINARY_SYMBOL);
          break;
        }

        }
        break;
      }

      case MySQLParser::BINARY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7289);
        match(MySQLParser::BINARY_SYMBOL);
        setState(7290);
        match(MySQLParser::UNICODE_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WsNumCodepointsContext ------------------------------------------------------------------

MySQLParser::WsNumCodepointsContext::WsNumCodepointsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::WsNumCodepointsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::WsNumCodepointsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::WsNumCodepointsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::WsNumCodepointsContext::getRuleIndex() const {
  return MySQLParser::RuleWsNumCodepoints;
}

void MySQLParser::WsNumCodepointsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWsNumCodepoints(this);
}

void MySQLParser::WsNumCodepointsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWsNumCodepoints(this);
}

MySQLParser::WsNumCodepointsContext* MySQLParser::wsNumCodepoints() {
  WsNumCodepointsContext *_localctx = _tracker.createInstance<WsNumCodepointsContext>(_ctx, getState());
  enterRule(_localctx, 918, MySQLParser::RuleWsNumCodepoints);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7293);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7294);
    real_ulong_number();
    setState(7295);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeDatetimePrecisionContext ------------------------------------------------------------------

MySQLParser::TypeDatetimePrecisionContext::TypeDatetimePrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TypeDatetimePrecisionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TypeDatetimePrecisionContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::TypeDatetimePrecisionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::TypeDatetimePrecisionContext::getRuleIndex() const {
  return MySQLParser::RuleTypeDatetimePrecision;
}

void MySQLParser::TypeDatetimePrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeDatetimePrecision(this);
}

void MySQLParser::TypeDatetimePrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeDatetimePrecision(this);
}

MySQLParser::TypeDatetimePrecisionContext* MySQLParser::typeDatetimePrecision() {
  TypeDatetimePrecisionContext *_localctx = _tracker.createInstance<TypeDatetimePrecisionContext>(_ctx, getState());
  enterRule(_localctx, 920, MySQLParser::RuleTypeDatetimePrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7297);

    if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
    setState(7298);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7299);
    match(MySQLParser::INT_NUMBER);
    setState(7300);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetNameContext ------------------------------------------------------------------

MySQLParser::CharsetNameContext::CharsetNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CharsetNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CharsetNameContext::BINARY_SYMBOL() {
  return getToken(MySQLParser::BINARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CharsetNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::CharsetNameContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetName;
}

void MySQLParser::CharsetNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetName(this);
}

void MySQLParser::CharsetNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetName(this);
}

MySQLParser::CharsetNameContext* MySQLParser::charsetName() {
  CharsetNameContext *_localctx = _tracker.createInstance<CharsetNameContext>(_ctx, getState());
  enterRule(_localctx, 922, MySQLParser::RuleCharsetName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7306);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 960, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7302);
      textOrIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7303);
      match(MySQLParser::BINARY_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7304);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(7305);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollationNameContext ------------------------------------------------------------------

MySQLParser::CollationNameContext::CollationNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CollationNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CollationNameContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::CollationNameContext::getRuleIndex() const {
  return MySQLParser::RuleCollationName;
}

void MySQLParser::CollationNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollationName(this);
}

void MySQLParser::CollationNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollationName(this);
}

MySQLParser::CollationNameContext* MySQLParser::collationName() {
  CollationNameContext *_localctx = _tracker.createInstance<CollationNameContext>(_ctx, getState());
  enterRule(_localctx, 924, MySQLParser::RuleCollationName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7311);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 961, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7308);
      textOrIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7309);

      if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
      setState(7310);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionsContext::CreateTableOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateTableOptionContext *> MySQLParser::CreateTableOptionsContext::createTableOption() {
  return getRuleContexts<MySQLParser::CreateTableOptionContext>();
}

MySQLParser::CreateTableOptionContext* MySQLParser::CreateTableOptionsContext::createTableOption(size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateTableOptionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateTableOptionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateTableOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOptions;
}

void MySQLParser::CreateTableOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptions(this);
}

void MySQLParser::CreateTableOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptions(this);
}

MySQLParser::CreateTableOptionsContext* MySQLParser::createTableOptions() {
  CreateTableOptionsContext *_localctx = _tracker.createInstance<CreateTableOptionsContext>(_ctx, getState());
  enterRule(_localctx, 926, MySQLParser::RuleCreateTableOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7313);
    createTableOption();
    setState(7320);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 963, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7315);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 962, _ctx)) {
        case 1: {
          setState(7314);
          match(MySQLParser::COMMA_SYMBOL);
          break;
        }

        }
        setState(7317);
        createTableOption(); 
      }
      setState(7322);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 963, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionsSpaceSeparatedContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionsSpaceSeparatedContext::CreateTableOptionsSpaceSeparatedContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateTableOptionContext *> MySQLParser::CreateTableOptionsSpaceSeparatedContext::createTableOption() {
  return getRuleContexts<MySQLParser::CreateTableOptionContext>();
}

MySQLParser::CreateTableOptionContext* MySQLParser::CreateTableOptionsSpaceSeparatedContext::createTableOption(size_t i) {
  return getRuleContext<MySQLParser::CreateTableOptionContext>(i);
}


size_t MySQLParser::CreateTableOptionsSpaceSeparatedContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOptionsSpaceSeparated;
}

void MySQLParser::CreateTableOptionsSpaceSeparatedContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOptionsSpaceSeparated(this);
}

void MySQLParser::CreateTableOptionsSpaceSeparatedContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOptionsSpaceSeparated(this);
}

MySQLParser::CreateTableOptionsSpaceSeparatedContext* MySQLParser::createTableOptionsSpaceSeparated() {
  CreateTableOptionsSpaceSeparatedContext *_localctx = _tracker.createInstance<CreateTableOptionsSpaceSeparatedContext>(_ctx, getState());
  enterRule(_localctx, 928, MySQLParser::RuleCreateTableOptionsSpaceSeparated);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7324); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7323);
              createTableOption();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7326); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 964, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateTableOptionContext ------------------------------------------------------------------

MySQLParser::CreateTableOptionContext::CreateTableOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::EngineRefContext* MySQLParser::CreateTableOptionContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CreateTableOptionContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::EqualContext* MySQLParser::CreateTableOptionContext::equal() {
  return getRuleContext<MySQLParser::EqualContext>(0);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::CreateTableOptionContext::ulonglong_number() {
  return getRuleContext<MySQLParser::Ulonglong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::CreateTableOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::CreateTableOptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::CreateTableOptionContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

MySQLParser::TernaryOptionContext* MySQLParser::CreateTableOptionContext::ternaryOption() {
  return getRuleContext<MySQLParser::TernaryOptionContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::TableRefListContext* MySQLParser::CreateTableOptionContext::tableRefList() {
  return getRuleContext<MySQLParser::TableRefListContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::UNION_SYMBOL() {
  return getToken(MySQLParser::UNION_SYMBOL, 0);
}

MySQLParser::DefaultCharsetContext* MySQLParser::CreateTableOptionContext::defaultCharset() {
  return getRuleContext<MySQLParser::DefaultCharsetContext>(0);
}

MySQLParser::DefaultCollationContext* MySQLParser::CreateTableOptionContext::defaultCollation() {
  return getRuleContext<MySQLParser::DefaultCollationContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::CreateTableOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateTableOptionContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}


size_t MySQLParser::CreateTableOptionContext::getRuleIndex() const {
  return MySQLParser::RuleCreateTableOption;
}

void MySQLParser::CreateTableOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateTableOption(this);
}

void MySQLParser::CreateTableOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateTableOption(this);
}

MySQLParser::CreateTableOptionContext* MySQLParser::createTableOption() {
  CreateTableOptionContext *_localctx = _tracker.createInstance<CreateTableOptionContext>(_ctx, getState());
  enterRule(_localctx, 930, MySQLParser::RuleCreateTableOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7458);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 989, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7328);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ENGINE_SYMBOL);
      setState(7330);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 965, _ctx)) {
      case 1: {
        setState(7329);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7332);
      engineRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7333);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(7334);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::SECONDARY_ENGINE_SYMBOL);
      setState(7336);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 966, _ctx)) {
      case 1: {
        setState(7335);
        equal();
        break;
      }

      }
      setState(7340);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 967, _ctx)) {
      case 1: {
        setState(7338);
        match(MySQLParser::NULL_SYMBOL);
        break;
      }

      case 2: {
        setState(7339);
        textOrIdentifier();
        break;
      }

      }
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(7342);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::MAX_ROWS_SYMBOL);
      setState(7344);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7343);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7346);
      ulonglong_number();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(7347);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::MIN_ROWS_SYMBOL);
      setState(7349);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7348);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7351);
      ulonglong_number();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(7352);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::AVG_ROW_LENGTH_SYMBOL);
      setState(7354);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7353);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7356);
      ulong_number();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(7357);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::PASSWORD_SYMBOL);
      setState(7359);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 971, _ctx)) {
      case 1: {
        setState(7358);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7361);
      textStringLiteral();
      break;
    }

    case 7: {
      enterOuterAlt(_localctx, 7);
      setState(7362);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
      setState(7364);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 972, _ctx)) {
      case 1: {
        setState(7363);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7366);
      textStringLiteral();
      break;
    }

    case 8: {
      enterOuterAlt(_localctx, 8);
      setState(7367);

      if (!(serverVersion >= 50708)) throw FailedPredicateException(this, "serverVersion >= 50708");
      setState(7368);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::COMPRESSION_SYMBOL);
      setState(7370);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 973, _ctx)) {
      case 1: {
        setState(7369);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7372);
      textString();
      break;
    }

    case 9: {
      enterOuterAlt(_localctx, 9);
      setState(7373);

      if (!(serverVersion >= 50711)) throw FailedPredicateException(this, "serverVersion >= 50711");
      setState(7374);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ENCRYPTION_SYMBOL);
      setState(7376);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 974, _ctx)) {
      case 1: {
        setState(7375);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7378);
      textString();
      break;
    }

    case 10: {
      enterOuterAlt(_localctx, 10);
      setState(7379);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::AUTO_INCREMENT_SYMBOL);
      setState(7381);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7380);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7383);
      ulonglong_number();
      break;
    }

    case 11: {
      enterOuterAlt(_localctx, 11);
      setState(7384);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::PACK_KEYS_SYMBOL);
      setState(7386);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7385);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7388);
      ternaryOption();
      break;
    }

    case 12: {
      enterOuterAlt(_localctx, 12);
      setState(7389);

      if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
      setState(7390);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 574) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 574)) & ((1ULL << (MySQLParser::STATS_AUTO_RECALC_SYMBOL - 574))
        | (1ULL << (MySQLParser::STATS_PERSISTENT_SYMBOL - 574))
        | (1ULL << (MySQLParser::STATS_SAMPLE_PAGES_SYMBOL - 574)))) != 0))) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7392);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7391);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7394);
      ternaryOption();
      break;
    }

    case 13: {
      enterOuterAlt(_localctx, 13);
      setState(7395);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CHECKSUM_SYMBOL || _la == MySQLParser::TABLE_CHECKSUM_SYMBOL)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7397);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7396);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7399);
      ulong_number();
      break;
    }

    case 14: {
      enterOuterAlt(_localctx, 14);
      setState(7400);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::DELAY_KEY_WRITE_SYMBOL);
      setState(7402);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7401);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7404);
      ulong_number();
      break;
    }

    case 15: {
      enterOuterAlt(_localctx, 15);
      setState(7405);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::ROW_FORMAT_SYMBOL);
      setState(7407);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7406);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7409);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->format = _input->LT(1);
      _la = _input->LA(1);
      if (!(((((_la - 125) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 125)) & ((1ULL << (MySQLParser::COMPACT_SYMBOL - 125))
        | (1ULL << (MySQLParser::COMPRESSED_SYMBOL - 125))
        | (1ULL << (MySQLParser::DEFAULT_SYMBOL - 125)))) != 0) || _la == MySQLParser::DYNAMIC_SYMBOL

      || _la == MySQLParser::FIXED_SYMBOL || _la == MySQLParser::REDUNDANT_SYMBOL)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->format = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 16: {
      enterOuterAlt(_localctx, 16);
      setState(7410);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::UNION_SYMBOL);
      setState(7412);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7411);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7414);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7415);
      tableRefList();
      setState(7416);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 17: {
      enterOuterAlt(_localctx, 17);
      setState(7418);
      defaultCharset();
      break;
    }

    case 18: {
      enterOuterAlt(_localctx, 18);
      setState(7419);
      defaultCollation();
      break;
    }

    case 19: {
      enterOuterAlt(_localctx, 19);
      setState(7420);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::INSERT_METHOD_SYMBOL);
      setState(7422);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7421);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7424);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->method = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::FIRST_SYMBOL || _la == MySQLParser::LAST_SYMBOL || _la == MySQLParser::NO_SYMBOL)) {
        dynamic_cast<CreateTableOptionContext *>(_localctx)->method = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 20: {
      enterOuterAlt(_localctx, 20);
      setState(7425);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::DATA_SYMBOL);
      setState(7426);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(7428);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 983, _ctx)) {
      case 1: {
        setState(7427);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7430);
      textString();
      break;
    }

    case 21: {
      enterOuterAlt(_localctx, 21);
      setState(7431);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::INDEX_SYMBOL);
      setState(7432);
      match(MySQLParser::DIRECTORY_SYMBOL);
      setState(7434);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 984, _ctx)) {
      case 1: {
        setState(7433);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7436);
      textString();
      break;
    }

    case 22: {
      enterOuterAlt(_localctx, 22);
      setState(7437);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::TABLESPACE_SYMBOL);
      setState(7443);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 986, _ctx)) {
      case 1: {
        setState(7438);

        if (!(serverVersion >= 50707)) throw FailedPredicateException(this, "serverVersion >= 50707");
        setState(7440);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 985, _ctx)) {
        case 1: {
          setState(7439);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        break;
      }

      case 2: {
        break;
      }

      }
      setState(7445);
      identifier();
      break;
    }

    case 23: {
      enterOuterAlt(_localctx, 23);
      setState(7446);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::STORAGE_SYMBOL);
      setState(7447);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::DISK_SYMBOL || _la == MySQLParser::MEMORY_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 24: {
      enterOuterAlt(_localctx, 24);
      setState(7448);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::CONNECTION_SYMBOL);
      setState(7450);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 987, _ctx)) {
      case 1: {
        setState(7449);
        match(MySQLParser::EQUAL_OPERATOR);
        break;
      }

      }
      setState(7452);
      textString();
      break;
    }

    case 25: {
      enterOuterAlt(_localctx, 25);
      setState(7453);
      dynamic_cast<CreateTableOptionContext *>(_localctx)->option = match(MySQLParser::KEY_BLOCK_SIZE_SYMBOL);
      setState(7455);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::EQUAL_OPERATOR) {
        setState(7454);
        match(MySQLParser::EQUAL_OPERATOR);
      }
      setState(7457);
      ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TernaryOptionContext ------------------------------------------------------------------

MySQLParser::TernaryOptionContext::TernaryOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Ulong_numberContext* MySQLParser::TernaryOptionContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::TernaryOptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::TernaryOptionContext::getRuleIndex() const {
  return MySQLParser::RuleTernaryOption;
}

void MySQLParser::TernaryOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTernaryOption(this);
}

void MySQLParser::TernaryOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTernaryOption(this);
}

MySQLParser::TernaryOptionContext* MySQLParser::ternaryOption() {
  TernaryOptionContext *_localctx = _tracker.createInstance<TernaryOptionContext>(_ctx, getState());
  enterRule(_localctx, 932, MySQLParser::RuleTernaryOption);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7462);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::INT_NUMBER:
      case MySQLParser::LONG_NUMBER:
      case MySQLParser::ULONGLONG_NUMBER:
      case MySQLParser::HEX_NUMBER:
      case MySQLParser::DECIMAL_NUMBER:
      case MySQLParser::FLOAT_NUMBER: {
        enterOuterAlt(_localctx, 1);
        setState(7460);
        ulong_number();
        break;
      }

      case MySQLParser::DEFAULT_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7461);
        match(MySQLParser::DEFAULT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCollationContext ------------------------------------------------------------------

MySQLParser::DefaultCollationContext::DefaultCollationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefaultCollationContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::CollationNameContext* MySQLParser::DefaultCollationContext::collationName() {
  return getRuleContext<MySQLParser::CollationNameContext>(0);
}

tree::TerminalNode* MySQLParser::DefaultCollationContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultCollationContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::DefaultCollationContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultCollation;
}

void MySQLParser::DefaultCollationContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCollation(this);
}

void MySQLParser::DefaultCollationContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCollation(this);
}

MySQLParser::DefaultCollationContext* MySQLParser::defaultCollation() {
  DefaultCollationContext *_localctx = _tracker.createInstance<DefaultCollationContext>(_ctx, getState());
  enterRule(_localctx, 934, MySQLParser::RuleDefaultCollation);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7465);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(7464);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(7467);
    match(MySQLParser::COLLATE_SYMBOL);
    setState(7469);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 992, _ctx)) {
    case 1: {
      setState(7468);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(7471);
    collationName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultEncryptionContext ------------------------------------------------------------------

MySQLParser::DefaultEncryptionContext::DefaultEncryptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefaultEncryptionContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::DefaultEncryptionContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::DefaultEncryptionContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultEncryptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::DefaultEncryptionContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultEncryption;
}

void MySQLParser::DefaultEncryptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultEncryption(this);
}

void MySQLParser::DefaultEncryptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultEncryption(this);
}

MySQLParser::DefaultEncryptionContext* MySQLParser::defaultEncryption() {
  DefaultEncryptionContext *_localctx = _tracker.createInstance<DefaultEncryptionContext>(_ctx, getState());
  enterRule(_localctx, 936, MySQLParser::RuleDefaultEncryption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7474);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(7473);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(7476);
    match(MySQLParser::ENCRYPTION_SYMBOL);
    setState(7478);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 994, _ctx)) {
    case 1: {
      setState(7477);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(7480);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCharsetContext ------------------------------------------------------------------

MySQLParser::DefaultCharsetContext::DefaultCharsetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CharsetContext* MySQLParser::DefaultCharsetContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::DefaultCharsetContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}

tree::TerminalNode* MySQLParser::DefaultCharsetContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefaultCharsetContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}


size_t MySQLParser::DefaultCharsetContext::getRuleIndex() const {
  return MySQLParser::RuleDefaultCharset;
}

void MySQLParser::DefaultCharsetContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefaultCharset(this);
}

void MySQLParser::DefaultCharsetContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefaultCharset(this);
}

MySQLParser::DefaultCharsetContext* MySQLParser::defaultCharset() {
  DefaultCharsetContext *_localctx = _tracker.createInstance<DefaultCharsetContext>(_ctx, getState());
  enterRule(_localctx, 938, MySQLParser::RuleDefaultCharset);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7483);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::DEFAULT_SYMBOL) {
      setState(7482);
      match(MySQLParser::DEFAULT_SYMBOL);
    }
    setState(7485);
    charset();
    setState(7487);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 996, _ctx)) {
    case 1: {
      setState(7486);
      match(MySQLParser::EQUAL_OPERATOR);
      break;
    }

    }
    setState(7489);
    charsetName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionClauseContext ------------------------------------------------------------------

MySQLParser::PartitionClauseContext::PartitionClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionClauseContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionClauseContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::PartitionTypeDefContext* MySQLParser::PartitionClauseContext::partitionTypeDef() {
  return getRuleContext<MySQLParser::PartitionTypeDefContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionClauseContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::PartitionClauseContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

MySQLParser::SubPartitionsContext* MySQLParser::PartitionClauseContext::subPartitions() {
  return getRuleContext<MySQLParser::SubPartitionsContext>(0);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::PartitionClauseContext::partitionDefinitions() {
  return getRuleContext<MySQLParser::PartitionDefinitionsContext>(0);
}


size_t MySQLParser::PartitionClauseContext::getRuleIndex() const {
  return MySQLParser::RulePartitionClause;
}

void MySQLParser::PartitionClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionClause(this);
}

void MySQLParser::PartitionClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionClause(this);
}

MySQLParser::PartitionClauseContext* MySQLParser::partitionClause() {
  PartitionClauseContext *_localctx = _tracker.createInstance<PartitionClauseContext>(_ctx, getState());
  enterRule(_localctx, 940, MySQLParser::RulePartitionClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7491);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(7492);
    match(MySQLParser::BY_SYMBOL);
    setState(7493);
    partitionTypeDef();
    setState(7496);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 997, _ctx)) {
    case 1: {
      setState(7494);
      match(MySQLParser::PARTITIONS_SYMBOL);
      setState(7495);
      real_ulong_number();
      break;
    }

    }
    setState(7499);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 998, _ctx)) {
    case 1: {
      setState(7498);
      subPartitions();
      break;
    }

    }
    setState(7502);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 999, _ctx)) {
    case 1: {
      setState(7501);
      partitionDefinitions();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionTypeDefContext ------------------------------------------------------------------

MySQLParser::PartitionTypeDefContext::PartitionTypeDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t MySQLParser::PartitionTypeDefContext::getRuleIndex() const {
  return MySQLParser::RulePartitionTypeDef;
}

void MySQLParser::PartitionTypeDefContext::copyFrom(PartitionTypeDefContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- PartitionDefRangeListContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::RANGE_SYMBOL() {
  return getToken(MySQLParser::RANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PartitionDefRangeListContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefRangeListContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::PartitionDefRangeListContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::PartitionDefRangeListContext::PartitionDefRangeListContext(PartitionTypeDefContext *ctx) { copyFrom(ctx); }

void MySQLParser::PartitionDefRangeListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefRangeList(this);
}
void MySQLParser::PartitionDefRangeListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefRangeList(this);
}
//----------------- PartitionDefKeyContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefKeyContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

MySQLParser::PartitionKeyAlgorithmContext* MySQLParser::PartitionDefKeyContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLParser::PartitionKeyAlgorithmContext>(0);
}

MySQLParser::IdentifierListContext* MySQLParser::PartitionDefKeyContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

MySQLParser::PartitionDefKeyContext::PartitionDefKeyContext(PartitionTypeDefContext *ctx) { copyFrom(ctx); }

void MySQLParser::PartitionDefKeyContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefKey(this);
}
void MySQLParser::PartitionDefKeyContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefKey(this);
}
//----------------- PartitionDefHashContext ------------------------------------------------------------------

tree::TerminalNode* MySQLParser::PartitionDefHashContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefHashContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::PartitionDefHashContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefHashContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefHashContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

MySQLParser::PartitionDefHashContext::PartitionDefHashContext(PartitionTypeDefContext *ctx) { copyFrom(ctx); }

void MySQLParser::PartitionDefHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefHash(this);
}
void MySQLParser::PartitionDefHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefHash(this);
}
MySQLParser::PartitionTypeDefContext* MySQLParser::partitionTypeDef() {
  PartitionTypeDefContext *_localctx = _tracker.createInstance<PartitionTypeDefContext>(_ctx, getState());
  enterRule(_localctx, 942, MySQLParser::RulePartitionTypeDef);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7537);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1006, _ctx)) {
    case 1: {
      _localctx = dynamic_cast<PartitionTypeDefContext *>(_tracker.createInstance<MySQLParser::PartitionDefKeyContext>(_localctx));
      enterOuterAlt(_localctx, 1);
      setState(7505);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LINEAR_SYMBOL) {
        setState(7504);
        match(MySQLParser::LINEAR_SYMBOL);
      }
      setState(7507);
      match(MySQLParser::KEY_SYMBOL);
      setState(7509);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1001, _ctx)) {
      case 1: {
        setState(7508);
        partitionKeyAlgorithm();
        break;
      }

      }
      setState(7511);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7513);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1002, _ctx)) {
      case 1: {
        setState(7512);
        identifierList();
        break;
      }

      }
      setState(7515);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 2: {
      _localctx = dynamic_cast<PartitionTypeDefContext *>(_tracker.createInstance<MySQLParser::PartitionDefHashContext>(_localctx));
      enterOuterAlt(_localctx, 2);
      setState(7517);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::LINEAR_SYMBOL) {
        setState(7516);
        match(MySQLParser::LINEAR_SYMBOL);
      }
      setState(7519);
      match(MySQLParser::HASH_SYMBOL);
      setState(7520);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7521);
      bitExpr(0);
      setState(7522);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    case 3: {
      _localctx = dynamic_cast<PartitionTypeDefContext *>(_tracker.createInstance<MySQLParser::PartitionDefRangeListContext>(_localctx));
      enterOuterAlt(_localctx, 3);
      setState(7524);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::LIST_SYMBOL || _la == MySQLParser::RANGE_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      setState(7535);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::OPEN_PAR_SYMBOL: {
          setState(7525);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(7526);
          bitExpr(0);
          setState(7527);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

        case MySQLParser::COLUMNS_SYMBOL: {
          setState(7529);
          match(MySQLParser::COLUMNS_SYMBOL);
          setState(7530);
          match(MySQLParser::OPEN_PAR_SYMBOL);
          setState(7532);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1004, _ctx)) {
          case 1: {
            setState(7531);
            identifierList();
            break;
          }

          }
          setState(7534);
          match(MySQLParser::CLOSE_PAR_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubPartitionsContext ------------------------------------------------------------------

MySQLParser::SubPartitionsContext::SubPartitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::BitExprContext* MySQLParser::SubPartitionsContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::KEY_SYMBOL() {
  return getToken(MySQLParser::KEY_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::SubPartitionsContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::LINEAR_SYMBOL() {
  return getToken(MySQLParser::LINEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SubPartitionsContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::SubPartitionsContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

MySQLParser::PartitionKeyAlgorithmContext* MySQLParser::SubPartitionsContext::partitionKeyAlgorithm() {
  return getRuleContext<MySQLParser::PartitionKeyAlgorithmContext>(0);
}


size_t MySQLParser::SubPartitionsContext::getRuleIndex() const {
  return MySQLParser::RuleSubPartitions;
}

void MySQLParser::SubPartitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubPartitions(this);
}

void MySQLParser::SubPartitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubPartitions(this);
}

MySQLParser::SubPartitionsContext* MySQLParser::subPartitions() {
  SubPartitionsContext *_localctx = _tracker.createInstance<SubPartitionsContext>(_ctx, getState());
  enterRule(_localctx, 944, MySQLParser::RuleSubPartitions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7539);
    match(MySQLParser::SUBPARTITION_SYMBOL);
    setState(7540);
    match(MySQLParser::BY_SYMBOL);
    setState(7542);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::LINEAR_SYMBOL) {
      setState(7541);
      match(MySQLParser::LINEAR_SYMBOL);
    }
    setState(7554);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::HASH_SYMBOL: {
        setState(7544);
        match(MySQLParser::HASH_SYMBOL);
        setState(7545);
        match(MySQLParser::OPEN_PAR_SYMBOL);
        setState(7546);
        bitExpr(0);
        setState(7547);
        match(MySQLParser::CLOSE_PAR_SYMBOL);
        break;
      }

      case MySQLParser::KEY_SYMBOL: {
        setState(7549);
        match(MySQLParser::KEY_SYMBOL);
        setState(7551);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1008, _ctx)) {
        case 1: {
          setState(7550);
          partitionKeyAlgorithm();
          break;
        }

        }
        setState(7553);
        identifierListWithParentheses();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    setState(7558);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1010, _ctx)) {
    case 1: {
      setState(7556);
      match(MySQLParser::SUBPARTITIONS_SYMBOL);
      setState(7557);
      real_ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionKeyAlgorithmContext ------------------------------------------------------------------

MySQLParser::PartitionKeyAlgorithmContext::PartitionKeyAlgorithmContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionKeyAlgorithmContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionKeyAlgorithmContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::PartitionKeyAlgorithmContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}


size_t MySQLParser::PartitionKeyAlgorithmContext::getRuleIndex() const {
  return MySQLParser::RulePartitionKeyAlgorithm;
}

void MySQLParser::PartitionKeyAlgorithmContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionKeyAlgorithm(this);
}

void MySQLParser::PartitionKeyAlgorithmContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionKeyAlgorithm(this);
}

MySQLParser::PartitionKeyAlgorithmContext* MySQLParser::partitionKeyAlgorithm() {
  PartitionKeyAlgorithmContext *_localctx = _tracker.createInstance<PartitionKeyAlgorithmContext>(_ctx, getState());
  enterRule(_localctx, 946, MySQLParser::RulePartitionKeyAlgorithm);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7560);

    if (!(serverVersion >= 50700)) throw FailedPredicateException(this, "serverVersion >= 50700");
    setState(7561);
    match(MySQLParser::ALGORITHM_SYMBOL);
    setState(7562);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7563);
    real_ulong_number();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionsContext ------------------------------------------------------------------

MySQLParser::PartitionDefinitionsContext::PartitionDefinitionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionDefinitionsContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::PartitionDefinitionContext *> MySQLParser::PartitionDefinitionsContext::partitionDefinition() {
  return getRuleContexts<MySQLParser::PartitionDefinitionContext>();
}

MySQLParser::PartitionDefinitionContext* MySQLParser::PartitionDefinitionsContext::partitionDefinition(size_t i) {
  return getRuleContext<MySQLParser::PartitionDefinitionContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionsContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionDefinitionsContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionsContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionDefinitionsContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDefinitions;
}

void MySQLParser::PartitionDefinitionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinitions(this);
}

void MySQLParser::PartitionDefinitionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinitions(this);
}

MySQLParser::PartitionDefinitionsContext* MySQLParser::partitionDefinitions() {
  PartitionDefinitionsContext *_localctx = _tracker.createInstance<PartitionDefinitionsContext>(_ctx, getState());
  enterRule(_localctx, 948, MySQLParser::RulePartitionDefinitions);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7565);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7566);
    partitionDefinition();
    setState(7571);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7567);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7568);
      partitionDefinition();
      setState(7573);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7574);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionDefinitionContext ------------------------------------------------------------------

MySQLParser::PartitionDefinitionContext::PartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::PartitionDefinitionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::VALUES_SYMBOL() {
  return getToken(MySQLParser::VALUES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

MySQLParser::PartitionValuesInContext* MySQLParser::PartitionDefinitionContext::partitionValuesIn() {
  return getRuleContext<MySQLParser::PartitionValuesInContext>(0);
}

std::vector<MySQLParser::PartitionOptionContext *> MySQLParser::PartitionDefinitionContext::partitionOption() {
  return getRuleContexts<MySQLParser::PartitionOptionContext>();
}

MySQLParser::PartitionOptionContext* MySQLParser::PartitionDefinitionContext::partitionOption(size_t i) {
  return getRuleContext<MySQLParser::PartitionOptionContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::SubpartitionDefinitionContext *> MySQLParser::PartitionDefinitionContext::subpartitionDefinition() {
  return getRuleContexts<MySQLParser::SubpartitionDefinitionContext>();
}

MySQLParser::SubpartitionDefinitionContext* MySQLParser::PartitionDefinitionContext::subpartitionDefinition(size_t i) {
  return getRuleContext<MySQLParser::SubpartitionDefinitionContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

MySQLParser::PartitionValueItemListParenContext* MySQLParser::PartitionDefinitionContext::partitionValueItemListParen() {
  return getRuleContext<MySQLParser::PartitionValueItemListParenContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::MAXVALUE_SYMBOL() {
  return getToken(MySQLParser::MAXVALUE_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionDefinitionContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionDefinitionContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionDefinitionContext::getRuleIndex() const {
  return MySQLParser::RulePartitionDefinition;
}

void MySQLParser::PartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionDefinition(this);
}

void MySQLParser::PartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionDefinition(this);
}

MySQLParser::PartitionDefinitionContext* MySQLParser::partitionDefinition() {
  PartitionDefinitionContext *_localctx = _tracker.createInstance<PartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 950, MySQLParser::RulePartitionDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7576);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(7577);
    identifier();
    setState(7588);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1013, _ctx)) {
    case 1: {
      setState(7578);
      match(MySQLParser::VALUES_SYMBOL);
      setState(7579);
      match(MySQLParser::LESS_SYMBOL);
      setState(7580);
      match(MySQLParser::THAN_SYMBOL);
      setState(7583);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::OPEN_PAR_SYMBOL: {
          setState(7581);
          partitionValueItemListParen();
          break;
        }

        case MySQLParser::MAXVALUE_SYMBOL: {
          setState(7582);
          match(MySQLParser::MAXVALUE_SYMBOL);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    case 2: {
      setState(7585);
      match(MySQLParser::VALUES_SYMBOL);
      setState(7586);
      match(MySQLParser::IN_SYMBOL);
      setState(7587);
      partitionValuesIn();
      break;
    }

    }
    setState(7593);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL

    || _la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INDEX_SYMBOL || ((((_la - 358) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 358)) & ((1ULL << (MySQLParser::MAX_ROWS_SYMBOL - 358))
      | (1ULL << (MySQLParser::MIN_ROWS_SYMBOL - 358))
      | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 358)))) != 0) || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::TABLESPACE_SYMBOL) {
      setState(7590);
      partitionOption();
      setState(7595);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7607);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == MySQLParser::OPEN_PAR_SYMBOL) {
      setState(7596);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7597);
      subpartitionDefinition();
      setState(7602);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(7598);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7599);
        subpartitionDefinition();
        setState(7604);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7605);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValuesInContext ------------------------------------------------------------------

MySQLParser::PartitionValuesInContext::PartitionValuesInContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::PartitionValueItemListParenContext *> MySQLParser::PartitionValuesInContext::partitionValueItemListParen() {
  return getRuleContexts<MySQLParser::PartitionValueItemListParenContext>();
}

MySQLParser::PartitionValueItemListParenContext* MySQLParser::PartitionValuesInContext::partitionValueItemListParen(size_t i) {
  return getRuleContext<MySQLParser::PartitionValueItemListParenContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionValuesInContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionValuesInContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionValuesInContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionValuesInContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionValuesInContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValuesIn;
}

void MySQLParser::PartitionValuesInContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValuesIn(this);
}

void MySQLParser::PartitionValuesInContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValuesIn(this);
}

MySQLParser::PartitionValuesInContext* MySQLParser::partitionValuesIn() {
  PartitionValuesInContext *_localctx = _tracker.createInstance<PartitionValuesInContext>(_ctx, getState());
  enterRule(_localctx, 952, MySQLParser::RulePartitionValuesIn);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7621);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1018, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7609);
      partitionValueItemListParen();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7610);
      match(MySQLParser::OPEN_PAR_SYMBOL);
      setState(7611);
      partitionValueItemListParen();
      setState(7616);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == MySQLParser::COMMA_SYMBOL) {
        setState(7612);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7613);
        partitionValueItemListParen();
        setState(7618);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
      setState(7619);
      match(MySQLParser::CLOSE_PAR_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionOptionContext ------------------------------------------------------------------

MySQLParser::PartitionOptionContext::PartitionOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::PartitionOptionContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::EngineRefContext* MySQLParser::PartitionOptionContext::engineRef() {
  return getRuleContext<MySQLParser::EngineRefContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::PartitionOptionContext::real_ulong_number() {
  return getRuleContext<MySQLParser::Real_ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

MySQLParser::TextLiteralContext* MySQLParser::PartitionOptionContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::INDEX_SYMBOL() {
  return getToken(MySQLParser::INDEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PartitionOptionContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}


size_t MySQLParser::PartitionOptionContext::getRuleIndex() const {
  return MySQLParser::RulePartitionOption;
}

void MySQLParser::PartitionOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionOption(this);
}

void MySQLParser::PartitionOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionOption(this);
}

MySQLParser::PartitionOptionContext* MySQLParser::partitionOption() {
  PartitionOptionContext *_localctx = _tracker.createInstance<PartitionOptionContext>(_ctx, getState());
  enterRule(_localctx, 954, MySQLParser::RulePartitionOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7657);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::TABLESPACE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7623);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::TABLESPACE_SYMBOL);
        setState(7625);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1019, _ctx)) {
        case 1: {
          setState(7624);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7627);
        identifier();
        break;
      }

      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7629);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::STORAGE_SYMBOL) {
          setState(7628);
          match(MySQLParser::STORAGE_SYMBOL);
        }
        setState(7631);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::ENGINE_SYMBOL);
        setState(7633);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1021, _ctx)) {
        case 1: {
          setState(7632);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7635);
        engineRef();
        break;
      }

      case MySQLParser::NODEGROUP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7636);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::NODEGROUP_SYMBOL);
        setState(7638);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(7637);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(7640);
        real_ulong_number();
        break;
      }

      case MySQLParser::MAX_ROWS_SYMBOL:
      case MySQLParser::MIN_ROWS_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(7641);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::MAX_ROWS_SYMBOL

        || _la == MySQLParser::MIN_ROWS_SYMBOL)) {
          dynamic_cast<PartitionOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7643);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::EQUAL_OPERATOR) {
          setState(7642);
          match(MySQLParser::EQUAL_OPERATOR);
        }
        setState(7645);
        real_ulong_number();
        break;
      }

      case MySQLParser::DATA_SYMBOL:
      case MySQLParser::INDEX_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(7646);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = _input->LT(1);
        _la = _input->LA(1);
        if (!(_la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::INDEX_SYMBOL)) {
          dynamic_cast<PartitionOptionContext *>(_localctx)->option = _errHandler->recoverInline(this);
        }
        else {
          _errHandler->reportMatch(this);
          consume();
        }
        setState(7647);
        match(MySQLParser::DIRECTORY_SYMBOL);
        setState(7649);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1024, _ctx)) {
        case 1: {
          setState(7648);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7651);
        textLiteral();
        break;
      }

      case MySQLParser::COMMENT_SYMBOL: {
        enterOuterAlt(_localctx, 6);
        setState(7652);
        dynamic_cast<PartitionOptionContext *>(_localctx)->option = match(MySQLParser::COMMENT_SYMBOL);
        setState(7654);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1025, _ctx)) {
        case 1: {
          setState(7653);
          match(MySQLParser::EQUAL_OPERATOR);
          break;
        }

        }
        setState(7656);
        textLiteral();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SubpartitionDefinitionContext ------------------------------------------------------------------

MySQLParser::SubpartitionDefinitionContext::SubpartitionDefinitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SubpartitionDefinitionContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::SubpartitionDefinitionContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

std::vector<MySQLParser::PartitionOptionContext *> MySQLParser::SubpartitionDefinitionContext::partitionOption() {
  return getRuleContexts<MySQLParser::PartitionOptionContext>();
}

MySQLParser::PartitionOptionContext* MySQLParser::SubpartitionDefinitionContext::partitionOption(size_t i) {
  return getRuleContext<MySQLParser::PartitionOptionContext>(i);
}


size_t MySQLParser::SubpartitionDefinitionContext::getRuleIndex() const {
  return MySQLParser::RuleSubpartitionDefinition;
}

void MySQLParser::SubpartitionDefinitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSubpartitionDefinition(this);
}

void MySQLParser::SubpartitionDefinitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSubpartitionDefinition(this);
}

MySQLParser::SubpartitionDefinitionContext* MySQLParser::subpartitionDefinition() {
  SubpartitionDefinitionContext *_localctx = _tracker.createInstance<SubpartitionDefinitionContext>(_ctx, getState());
  enterRule(_localctx, 956, MySQLParser::RuleSubpartitionDefinition);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7659);
    match(MySQLParser::SUBPARTITION_SYMBOL);
    setState(7660);
    textOrIdentifier();
    setState(7664);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMENT_SYMBOL

    || _la == MySQLParser::DATA_SYMBOL || _la == MySQLParser::ENGINE_SYMBOL || _la == MySQLParser::INDEX_SYMBOL || ((((_la - 358) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 358)) & ((1ULL << (MySQLParser::MAX_ROWS_SYMBOL - 358))
      | (1ULL << (MySQLParser::MIN_ROWS_SYMBOL - 358))
      | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 358)))) != 0) || _la == MySQLParser::STORAGE_SYMBOL

    || _la == MySQLParser::TABLESPACE_SYMBOL) {
      setState(7661);
      partitionOption();
      setState(7666);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValueItemListParenContext ------------------------------------------------------------------

MySQLParser::PartitionValueItemListParenContext::PartitionValueItemListParenContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PartitionValueItemListParenContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::PartitionValueItemContext *> MySQLParser::PartitionValueItemListParenContext::partitionValueItem() {
  return getRuleContexts<MySQLParser::PartitionValueItemContext>();
}

MySQLParser::PartitionValueItemContext* MySQLParser::PartitionValueItemListParenContext::partitionValueItem(size_t i) {
  return getRuleContext<MySQLParser::PartitionValueItemContext>(i);
}

tree::TerminalNode* MySQLParser::PartitionValueItemListParenContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PartitionValueItemListParenContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::PartitionValueItemListParenContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::PartitionValueItemListParenContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValueItemListParen;
}

void MySQLParser::PartitionValueItemListParenContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValueItemListParen(this);
}

void MySQLParser::PartitionValueItemListParenContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValueItemListParen(this);
}

MySQLParser::PartitionValueItemListParenContext* MySQLParser::partitionValueItemListParen() {
  PartitionValueItemListParenContext *_localctx = _tracker.createInstance<PartitionValueItemListParenContext>(_ctx, getState());
  enterRule(_localctx, 958, MySQLParser::RulePartitionValueItemListParen);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7667);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7668);
    partitionValueItem();
    setState(7673);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7669);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7670);
      partitionValueItem();
      setState(7675);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7676);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PartitionValueItemContext ------------------------------------------------------------------

MySQLParser::PartitionValueItemContext::PartitionValueItemContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::BitExprContext* MySQLParser::PartitionValueItemContext::bitExpr() {
  return getRuleContext<MySQLParser::BitExprContext>(0);
}

tree::TerminalNode* MySQLParser::PartitionValueItemContext::MAXVALUE_SYMBOL() {
  return getToken(MySQLParser::MAXVALUE_SYMBOL, 0);
}


size_t MySQLParser::PartitionValueItemContext::getRuleIndex() const {
  return MySQLParser::RulePartitionValueItem;
}

void MySQLParser::PartitionValueItemContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPartitionValueItem(this);
}

void MySQLParser::PartitionValueItemContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPartitionValueItem(this);
}

MySQLParser::PartitionValueItemContext* MySQLParser::partitionValueItem() {
  PartitionValueItemContext *_localctx = _tracker.createInstance<PartitionValueItemContext>(_ctx, getState());
  enterRule(_localctx, 960, MySQLParser::RulePartitionValueItem);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7680);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1029, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7678);
      bitExpr(0);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7679);
      match(MySQLParser::MAXVALUE_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefinerClauseContext ------------------------------------------------------------------

MySQLParser::DefinerClauseContext::DefinerClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DefinerClauseContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DefinerClauseContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::UserContext* MySQLParser::DefinerClauseContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}


size_t MySQLParser::DefinerClauseContext::getRuleIndex() const {
  return MySQLParser::RuleDefinerClause;
}

void MySQLParser::DefinerClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDefinerClause(this);
}

void MySQLParser::DefinerClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDefinerClause(this);
}

MySQLParser::DefinerClauseContext* MySQLParser::definerClause() {
  DefinerClauseContext *_localctx = _tracker.createInstance<DefinerClauseContext>(_ctx, getState());
  enterRule(_localctx, 962, MySQLParser::RuleDefinerClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7682);
    match(MySQLParser::DEFINER_SYMBOL);
    setState(7683);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7684);
    user();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfExistsContext ------------------------------------------------------------------

MySQLParser::IfExistsContext::IfExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IfExistsContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IfExistsContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}


size_t MySQLParser::IfExistsContext::getRuleIndex() const {
  return MySQLParser::RuleIfExists;
}

void MySQLParser::IfExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfExists(this);
}

void MySQLParser::IfExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfExists(this);
}

MySQLParser::IfExistsContext* MySQLParser::ifExists() {
  IfExistsContext *_localctx = _tracker.createInstance<IfExistsContext>(_ctx, getState());
  enterRule(_localctx, 964, MySQLParser::RuleIfExists);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7686);
    match(MySQLParser::IF_SYMBOL);
    setState(7687);
    match(MySQLParser::EXISTS_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfNotExistsContext ------------------------------------------------------------------

MySQLParser::IfNotExistsContext::IfNotExistsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IfNotExistsContext::IF_SYMBOL() {
  return getToken(MySQLParser::IF_SYMBOL, 0);
}

MySQLParser::NotRuleContext* MySQLParser::IfNotExistsContext::notRule() {
  return getRuleContext<MySQLParser::NotRuleContext>(0);
}

tree::TerminalNode* MySQLParser::IfNotExistsContext::EXISTS_SYMBOL() {
  return getToken(MySQLParser::EXISTS_SYMBOL, 0);
}


size_t MySQLParser::IfNotExistsContext::getRuleIndex() const {
  return MySQLParser::RuleIfNotExists;
}

void MySQLParser::IfNotExistsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIfNotExists(this);
}

void MySQLParser::IfNotExistsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIfNotExists(this);
}

MySQLParser::IfNotExistsContext* MySQLParser::ifNotExists() {
  IfNotExistsContext *_localctx = _tracker.createInstance<IfNotExistsContext>(_ctx, getState());
  enterRule(_localctx, 966, MySQLParser::RuleIfNotExists);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7689);
    match(MySQLParser::IF_SYMBOL);
    setState(7690);
    notRule();
    setState(7691);
    match(MySQLParser::EXISTS_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureParameterContext ------------------------------------------------------------------

MySQLParser::ProcedureParameterContext::ProcedureParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FunctionParameterContext* MySQLParser::ProcedureParameterContext::functionParameter() {
  return getRuleContext<MySQLParser::FunctionParameterContext>(0);
}

tree::TerminalNode* MySQLParser::ProcedureParameterContext::IN_SYMBOL() {
  return getToken(MySQLParser::IN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureParameterContext::OUT_SYMBOL() {
  return getToken(MySQLParser::OUT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ProcedureParameterContext::INOUT_SYMBOL() {
  return getToken(MySQLParser::INOUT_SYMBOL, 0);
}


size_t MySQLParser::ProcedureParameterContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureParameter;
}

void MySQLParser::ProcedureParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureParameter(this);
}

void MySQLParser::ProcedureParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureParameter(this);
}

MySQLParser::ProcedureParameterContext* MySQLParser::procedureParameter() {
  ProcedureParameterContext *_localctx = _tracker.createInstance<ProcedureParameterContext>(_ctx, getState());
  enterRule(_localctx, 968, MySQLParser::RuleProcedureParameter);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7694);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1030, _ctx)) {
    case 1: {
      setState(7693);
      dynamic_cast<ProcedureParameterContext *>(_localctx)->type = _input->LT(1);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::INOUT_SYMBOL

      || _la == MySQLParser::IN_SYMBOL || _la == MySQLParser::OUT_SYMBOL)) {
        dynamic_cast<ProcedureParameterContext *>(_localctx)->type = _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
    setState(7696);
    functionParameter();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionParameterContext ------------------------------------------------------------------

MySQLParser::FunctionParameterContext::FunctionParameterContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ParameterNameContext* MySQLParser::FunctionParameterContext::parameterName() {
  return getRuleContext<MySQLParser::ParameterNameContext>(0);
}

MySQLParser::TypeWithOptCollateContext* MySQLParser::FunctionParameterContext::typeWithOptCollate() {
  return getRuleContext<MySQLParser::TypeWithOptCollateContext>(0);
}


size_t MySQLParser::FunctionParameterContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionParameter;
}

void MySQLParser::FunctionParameterContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionParameter(this);
}

void MySQLParser::FunctionParameterContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionParameter(this);
}

MySQLParser::FunctionParameterContext* MySQLParser::functionParameter() {
  FunctionParameterContext *_localctx = _tracker.createInstance<FunctionParameterContext>(_ctx, getState());
  enterRule(_localctx, 970, MySQLParser::RuleFunctionParameter);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7698);
    parameterName();
    setState(7699);
    typeWithOptCollate();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CollateContext ------------------------------------------------------------------

MySQLParser::CollateContext::CollateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::CollateContext::COLLATE_SYMBOL() {
  return getToken(MySQLParser::COLLATE_SYMBOL, 0);
}

MySQLParser::CollationNameContext* MySQLParser::CollateContext::collationName() {
  return getRuleContext<MySQLParser::CollationNameContext>(0);
}


size_t MySQLParser::CollateContext::getRuleIndex() const {
  return MySQLParser::RuleCollate;
}

void MySQLParser::CollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCollate(this);
}

void MySQLParser::CollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCollate(this);
}

MySQLParser::CollateContext* MySQLParser::collate() {
  CollateContext *_localctx = _tracker.createInstance<CollateContext>(_ctx, getState());
  enterRule(_localctx, 972, MySQLParser::RuleCollate);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7701);
    match(MySQLParser::COLLATE_SYMBOL);
    setState(7702);
    collationName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TypeWithOptCollateContext ------------------------------------------------------------------

MySQLParser::TypeWithOptCollateContext::TypeWithOptCollateContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DataTypeContext* MySQLParser::TypeWithOptCollateContext::dataType() {
  return getRuleContext<MySQLParser::DataTypeContext>(0);
}

MySQLParser::CollateContext* MySQLParser::TypeWithOptCollateContext::collate() {
  return getRuleContext<MySQLParser::CollateContext>(0);
}


size_t MySQLParser::TypeWithOptCollateContext::getRuleIndex() const {
  return MySQLParser::RuleTypeWithOptCollate;
}

void MySQLParser::TypeWithOptCollateContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTypeWithOptCollate(this);
}

void MySQLParser::TypeWithOptCollateContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTypeWithOptCollate(this);
}

MySQLParser::TypeWithOptCollateContext* MySQLParser::typeWithOptCollate() {
  TypeWithOptCollateContext *_localctx = _tracker.createInstance<TypeWithOptCollateContext>(_ctx, getState());
  enterRule(_localctx, 974, MySQLParser::RuleTypeWithOptCollate);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7704);
    dataType();
    setState(7706);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1031, _ctx)) {
    case 1: {
      setState(7705);
      collate();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaIdentifierPairContext ------------------------------------------------------------------

MySQLParser::SchemaIdentifierPairContext::SchemaIdentifierPairContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SchemaIdentifierPairContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::SchemaRefContext *> MySQLParser::SchemaIdentifierPairContext::schemaRef() {
  return getRuleContexts<MySQLParser::SchemaRefContext>();
}

MySQLParser::SchemaRefContext* MySQLParser::SchemaIdentifierPairContext::schemaRef(size_t i) {
  return getRuleContext<MySQLParser::SchemaRefContext>(i);
}

tree::TerminalNode* MySQLParser::SchemaIdentifierPairContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SchemaIdentifierPairContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::SchemaIdentifierPairContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaIdentifierPair;
}

void MySQLParser::SchemaIdentifierPairContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaIdentifierPair(this);
}

void MySQLParser::SchemaIdentifierPairContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaIdentifierPair(this);
}

MySQLParser::SchemaIdentifierPairContext* MySQLParser::schemaIdentifierPair() {
  SchemaIdentifierPairContext *_localctx = _tracker.createInstance<SchemaIdentifierPairContext>(_ctx, getState());
  enterRule(_localctx, 976, MySQLParser::RuleSchemaIdentifierPair);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7708);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7709);
    schemaRef();
    setState(7710);
    match(MySQLParser::COMMA_SYMBOL);
    setState(7711);
    schemaRef();
    setState(7712);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewRefListContext ------------------------------------------------------------------

MySQLParser::ViewRefListContext::ViewRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::ViewRefContext *> MySQLParser::ViewRefListContext::viewRef() {
  return getRuleContexts<MySQLParser::ViewRefContext>();
}

MySQLParser::ViewRefContext* MySQLParser::ViewRefListContext::viewRef(size_t i) {
  return getRuleContext<MySQLParser::ViewRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::ViewRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ViewRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ViewRefListContext::getRuleIndex() const {
  return MySQLParser::RuleViewRefList;
}

void MySQLParser::ViewRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewRefList(this);
}

void MySQLParser::ViewRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewRefList(this);
}

MySQLParser::ViewRefListContext* MySQLParser::viewRefList() {
  ViewRefListContext *_localctx = _tracker.createInstance<ViewRefListContext>(_ctx, getState());
  enterRule(_localctx, 978, MySQLParser::RuleViewRefList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7714);
    viewRef();
    setState(7719);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7715);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7716);
      viewRef();
      setState(7721);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateListContext ------------------------------------------------------------------

MySQLParser::UpdateListContext::UpdateListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UpdateElementContext *> MySQLParser::UpdateListContext::updateElement() {
  return getRuleContexts<MySQLParser::UpdateElementContext>();
}

MySQLParser::UpdateElementContext* MySQLParser::UpdateListContext::updateElement(size_t i) {
  return getRuleContext<MySQLParser::UpdateElementContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UpdateListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UpdateListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UpdateListContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateList;
}

void MySQLParser::UpdateListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateList(this);
}

void MySQLParser::UpdateListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateList(this);
}

MySQLParser::UpdateListContext* MySQLParser::updateList() {
  UpdateListContext *_localctx = _tracker.createInstance<UpdateListContext>(_ctx, getState());
  enterRule(_localctx, 980, MySQLParser::RuleUpdateList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7722);
    updateElement();
    setState(7727);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7723);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7724);
      updateElement();
      setState(7729);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UpdateElementContext ------------------------------------------------------------------

MySQLParser::UpdateElementContext::UpdateElementContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnRefContext* MySQLParser::UpdateElementContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateElementContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

MySQLParser::ExprContext* MySQLParser::UpdateElementContext::expr() {
  return getRuleContext<MySQLParser::ExprContext>(0);
}

tree::TerminalNode* MySQLParser::UpdateElementContext::DEFAULT_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_SYMBOL, 0);
}


size_t MySQLParser::UpdateElementContext::getRuleIndex() const {
  return MySQLParser::RuleUpdateElement;
}

void MySQLParser::UpdateElementContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUpdateElement(this);
}

void MySQLParser::UpdateElementContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUpdateElement(this);
}

MySQLParser::UpdateElementContext* MySQLParser::updateElement() {
  UpdateElementContext *_localctx = _tracker.createInstance<UpdateElementContext>(_ctx, getState());
  enterRule(_localctx, 982, MySQLParser::RuleUpdateElement);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7730);
    columnRef();
    setState(7731);
    match(MySQLParser::EQUAL_OPERATOR);
    setState(7734);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1034, _ctx)) {
    case 1: {
      setState(7732);
      expr(0);
      break;
    }

    case 2: {
      setState(7733);
      match(MySQLParser::DEFAULT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CharsetClauseContext ------------------------------------------------------------------

MySQLParser::CharsetClauseContext::CharsetClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::CharsetContext* MySQLParser::CharsetClauseContext::charset() {
  return getRuleContext<MySQLParser::CharsetContext>(0);
}

MySQLParser::CharsetNameContext* MySQLParser::CharsetClauseContext::charsetName() {
  return getRuleContext<MySQLParser::CharsetNameContext>(0);
}


size_t MySQLParser::CharsetClauseContext::getRuleIndex() const {
  return MySQLParser::RuleCharsetClause;
}

void MySQLParser::CharsetClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCharsetClause(this);
}

void MySQLParser::CharsetClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCharsetClause(this);
}

MySQLParser::CharsetClauseContext* MySQLParser::charsetClause() {
  CharsetClauseContext *_localctx = _tracker.createInstance<CharsetClauseContext>(_ctx, getState());
  enterRule(_localctx, 984, MySQLParser::RuleCharsetClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7736);
    charset();
    setState(7737);
    charsetName();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldsClauseContext ------------------------------------------------------------------

MySQLParser::FieldsClauseContext::FieldsClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FieldsClauseContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

std::vector<MySQLParser::FieldTermContext *> MySQLParser::FieldsClauseContext::fieldTerm() {
  return getRuleContexts<MySQLParser::FieldTermContext>();
}

MySQLParser::FieldTermContext* MySQLParser::FieldsClauseContext::fieldTerm(size_t i) {
  return getRuleContext<MySQLParser::FieldTermContext>(i);
}


size_t MySQLParser::FieldsClauseContext::getRuleIndex() const {
  return MySQLParser::RuleFieldsClause;
}

void MySQLParser::FieldsClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldsClause(this);
}

void MySQLParser::FieldsClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldsClause(this);
}

MySQLParser::FieldsClauseContext* MySQLParser::fieldsClause() {
  FieldsClauseContext *_localctx = _tracker.createInstance<FieldsClauseContext>(_ctx, getState());
  enterRule(_localctx, 986, MySQLParser::RuleFieldsClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7739);
    match(MySQLParser::COLUMNS_SYMBOL);
    setState(7741); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7740);
              fieldTerm();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7743); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1035, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldTermContext ------------------------------------------------------------------

MySQLParser::FieldTermContext::FieldTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::FieldTermContext::TERMINATED_SYMBOL() {
  return getToken(MySQLParser::TERMINATED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::FieldTermContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::ENCLOSED_SYMBOL() {
  return getToken(MySQLParser::ENCLOSED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::OPTIONALLY_SYMBOL() {
  return getToken(MySQLParser::OPTIONALLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::FieldTermContext::ESCAPED_SYMBOL() {
  return getToken(MySQLParser::ESCAPED_SYMBOL, 0);
}


size_t MySQLParser::FieldTermContext::getRuleIndex() const {
  return MySQLParser::RuleFieldTerm;
}

void MySQLParser::FieldTermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldTerm(this);
}

void MySQLParser::FieldTermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldTerm(this);
}

MySQLParser::FieldTermContext* MySQLParser::fieldTerm() {
  FieldTermContext *_localctx = _tracker.createInstance<FieldTermContext>(_ctx, getState());
  enterRule(_localctx, 988, MySQLParser::RuleFieldTerm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7757);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::TERMINATED_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7745);
        match(MySQLParser::TERMINATED_SYMBOL);
        setState(7746);
        match(MySQLParser::BY_SYMBOL);
        setState(7747);
        textString();
        break;
      }

      case MySQLParser::ENCLOSED_SYMBOL:
      case MySQLParser::OPTIONALLY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7749);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::OPTIONALLY_SYMBOL) {
          setState(7748);
          match(MySQLParser::OPTIONALLY_SYMBOL);
        }
        setState(7751);
        match(MySQLParser::ENCLOSED_SYMBOL);
        setState(7752);
        match(MySQLParser::BY_SYMBOL);
        setState(7753);
        textString();
        break;
      }

      case MySQLParser::ESCAPED_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(7754);
        match(MySQLParser::ESCAPED_SYMBOL);
        setState(7755);
        match(MySQLParser::BY_SYMBOL);
        setState(7756);
        textString();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LinesClauseContext ------------------------------------------------------------------

MySQLParser::LinesClauseContext::LinesClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LinesClauseContext::LINES_SYMBOL() {
  return getToken(MySQLParser::LINES_SYMBOL, 0);
}

std::vector<MySQLParser::LineTermContext *> MySQLParser::LinesClauseContext::lineTerm() {
  return getRuleContexts<MySQLParser::LineTermContext>();
}

MySQLParser::LineTermContext* MySQLParser::LinesClauseContext::lineTerm(size_t i) {
  return getRuleContext<MySQLParser::LineTermContext>(i);
}


size_t MySQLParser::LinesClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLinesClause;
}

void MySQLParser::LinesClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLinesClause(this);
}

void MySQLParser::LinesClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLinesClause(this);
}

MySQLParser::LinesClauseContext* MySQLParser::linesClause() {
  LinesClauseContext *_localctx = _tracker.createInstance<LinesClauseContext>(_ctx, getState());
  enterRule(_localctx, 990, MySQLParser::RuleLinesClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7759);
    match(MySQLParser::LINES_SYMBOL);
    setState(7761); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(7760);
              lineTerm();
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(7763); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1038, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LineTermContext ------------------------------------------------------------------

MySQLParser::LineTermContext::LineTermContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LineTermContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::LineTermContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::LineTermContext::TERMINATED_SYMBOL() {
  return getToken(MySQLParser::TERMINATED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LineTermContext::STARTING_SYMBOL() {
  return getToken(MySQLParser::STARTING_SYMBOL, 0);
}


size_t MySQLParser::LineTermContext::getRuleIndex() const {
  return MySQLParser::RuleLineTerm;
}

void MySQLParser::LineTermContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLineTerm(this);
}

void MySQLParser::LineTermContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLineTerm(this);
}

MySQLParser::LineTermContext* MySQLParser::lineTerm() {
  LineTermContext *_localctx = _tracker.createInstance<LineTermContext>(_ctx, getState());
  enterRule(_localctx, 992, MySQLParser::RuleLineTerm);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7765);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::STARTING_SYMBOL

    || _la == MySQLParser::TERMINATED_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
    setState(7766);
    match(MySQLParser::BY_SYMBOL);
    setState(7767);
    textString();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserListContext ------------------------------------------------------------------

MySQLParser::UserListContext::UserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::UserContext *> MySQLParser::UserListContext::user() {
  return getRuleContexts<MySQLParser::UserContext>();
}

MySQLParser::UserContext* MySQLParser::UserListContext::user(size_t i) {
  return getRuleContext<MySQLParser::UserContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::UserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::UserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::UserListContext::getRuleIndex() const {
  return MySQLParser::RuleUserList;
}

void MySQLParser::UserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUserList(this);
}

void MySQLParser::UserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUserList(this);
}

MySQLParser::UserListContext* MySQLParser::userList() {
  UserListContext *_localctx = _tracker.createInstance<UserListContext>(_ctx, getState());
  enterRule(_localctx, 994, MySQLParser::RuleUserList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7769);
    user();
    setState(7774);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1039, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7770);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7771);
        user(); 
      }
      setState(7776);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1039, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserListContext ------------------------------------------------------------------

MySQLParser::CreateUserListContext::CreateUserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::CreateUserEntryContext *> MySQLParser::CreateUserListContext::createUserEntry() {
  return getRuleContexts<MySQLParser::CreateUserEntryContext>();
}

MySQLParser::CreateUserEntryContext* MySQLParser::CreateUserListContext::createUserEntry(size_t i) {
  return getRuleContext<MySQLParser::CreateUserEntryContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::CreateUserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::CreateUserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::CreateUserListContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserList;
}

void MySQLParser::CreateUserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserList(this);
}

void MySQLParser::CreateUserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserList(this);
}

MySQLParser::CreateUserListContext* MySQLParser::createUserList() {
  CreateUserListContext *_localctx = _tracker.createInstance<CreateUserListContext>(_ctx, getState());
  enterRule(_localctx, 996, MySQLParser::RuleCreateUserList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7777);
    createUserEntry();
    setState(7782);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1040, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7778);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7779);
        createUserEntry(); 
      }
      setState(7784);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1040, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserListContext ------------------------------------------------------------------

MySQLParser::AlterUserListContext::AlterUserListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::AlterUserEntryContext *> MySQLParser::AlterUserListContext::alterUserEntry() {
  return getRuleContexts<MySQLParser::AlterUserEntryContext>();
}

MySQLParser::AlterUserEntryContext* MySQLParser::AlterUserListContext::alterUserEntry(size_t i) {
  return getRuleContext<MySQLParser::AlterUserEntryContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::AlterUserListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::AlterUserListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::AlterUserListContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserList;
}

void MySQLParser::AlterUserListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserList(this);
}

void MySQLParser::AlterUserListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserList(this);
}

MySQLParser::AlterUserListContext* MySQLParser::alterUserList() {
  AlterUserListContext *_localctx = _tracker.createInstance<AlterUserListContext>(_ctx, getState());
  enterRule(_localctx, 998, MySQLParser::RuleAlterUserList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7785);
    alterUserEntry();
    setState(7790);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1041, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7786);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7787);
        alterUserEntry(); 
      }
      setState(7792);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1041, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CreateUserEntryContext ------------------------------------------------------------------

MySQLParser::CreateUserEntryContext::CreateUserEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserContext* MySQLParser::CreateUserEntryContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::CreateUserEntryContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::CreateUserEntryContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::CreateUserEntryContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::TextStringHashContext* MySQLParser::CreateUserEntryContext::textStringHash() {
  return getRuleContext<MySQLParser::TextStringHashContext>(0);
}


size_t MySQLParser::CreateUserEntryContext::getRuleIndex() const {
  return MySQLParser::RuleCreateUserEntry;
}

void MySQLParser::CreateUserEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterCreateUserEntry(this);
}

void MySQLParser::CreateUserEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitCreateUserEntry(this);
}

MySQLParser::CreateUserEntryContext* MySQLParser::createUserEntry() {
  CreateUserEntryContext *_localctx = _tracker.createInstance<CreateUserEntryContext>(_ctx, getState());
  enterRule(_localctx, 1000, MySQLParser::RuleCreateUserEntry);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7793);
    user();
    setState(7815);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1046, _ctx)) {
    case 1: {
      setState(7794);
      match(MySQLParser::IDENTIFIED_SYMBOL);
      setState(7813);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1045, _ctx)) {
      case 1: {
        setState(7795);
        match(MySQLParser::BY_SYMBOL);
        setState(7798);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1042, _ctx)) {
        case 1: {
          setState(7796);

          if (!(serverVersion < 80011)) throw FailedPredicateException(this, "serverVersion < 80011");
          setState(7797);
          match(MySQLParser::PASSWORD_SYMBOL);
          break;
        }

        }
        setState(7800);
        textString();
        break;
      }

      case 2: {
        setState(7801);

        if (!(serverVersion >= 50600)) throw FailedPredicateException(this, "serverVersion >= 50600");
        setState(7802);
        match(MySQLParser::WITH_SYMBOL);
        setState(7803);
        textOrIdentifier();
        setState(7811);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1044, _ctx)) {
        case 1: {
          setState(7809);
          _errHandler->sync(this);
          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1043, _ctx)) {
          case 1: {
            setState(7804);
            match(MySQLParser::AS_SYMBOL);
            setState(7805);
            textStringHash();
            break;
          }

          case 2: {
            setState(7806);

            if (!(serverVersion >= 50706)) throw FailedPredicateException(this, "serverVersion >= 50706");
            setState(7807);
            match(MySQLParser::BY_SYMBOL);
            setState(7808);
            textString();
            break;
          }

          }
          break;
        }

        }
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- AlterUserEntryContext ------------------------------------------------------------------

MySQLParser::AlterUserEntryContext::AlterUserEntryContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::UserContext* MySQLParser::AlterUserEntryContext::user() {
  return getRuleContext<MySQLParser::UserContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::BY_SYMBOL() {
  return getToken(MySQLParser::BY_SYMBOL, 0);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::AlterUserEntryContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::AlterUserEntryContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::WITH_SYMBOL() {
  return getToken(MySQLParser::WITH_SYMBOL, 0);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::AlterUserEntryContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}

MySQLParser::DiscardOldPasswordContext* MySQLParser::AlterUserEntryContext::discardOldPassword() {
  return getRuleContext<MySQLParser::DiscardOldPasswordContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::AlterUserEntryContext::retainCurrentPassword() {
  return getRuleContext<MySQLParser::RetainCurrentPasswordContext>(0);
}

tree::TerminalNode* MySQLParser::AlterUserEntryContext::AS_SYMBOL() {
  return getToken(MySQLParser::AS_SYMBOL, 0);
}

MySQLParser::TextStringHashContext* MySQLParser::AlterUserEntryContext::textStringHash() {
  return getRuleContext<MySQLParser::TextStringHashContext>(0);
}


size_t MySQLParser::AlterUserEntryContext::getRuleIndex() const {
  return MySQLParser::RuleAlterUserEntry;
}

void MySQLParser::AlterUserEntryContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterAlterUserEntry(this);
}

void MySQLParser::AlterUserEntryContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitAlterUserEntry(this);
}

MySQLParser::AlterUserEntryContext* MySQLParser::alterUserEntry() {
  AlterUserEntryContext *_localctx = _tracker.createInstance<AlterUserEntryContext>(_ctx, getState());
  enterRule(_localctx, 1002, MySQLParser::RuleAlterUserEntry);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7817);
    user();
    setState(7846);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1054, _ctx)) {
    case 1: {
      setState(7818);
      match(MySQLParser::IDENTIFIED_SYMBOL);
      setState(7841);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1052, _ctx)) {
      case 1: {
        setState(7821);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::WITH_SYMBOL) {
          setState(7819);
          match(MySQLParser::WITH_SYMBOL);
          setState(7820);
          textOrIdentifier();
        }
        setState(7823);
        match(MySQLParser::BY_SYMBOL);
        setState(7824);
        textString();
        setState(7827);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1048, _ctx)) {
        case 1: {
          setState(7825);
          match(MySQLParser::REPLACE_SYMBOL);
          setState(7826);
          textString();
          break;
        }

        }
        setState(7830);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1049, _ctx)) {
        case 1: {
          setState(7829);
          retainCurrentPassword();
          break;
        }

        }
        break;
      }

      case 2: {
        setState(7832);
        match(MySQLParser::WITH_SYMBOL);
        setState(7833);
        textOrIdentifier();
        setState(7839);
        _errHandler->sync(this);

        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1051, _ctx)) {
        case 1: {
          setState(7834);
          match(MySQLParser::AS_SYMBOL);
          setState(7835);
          textStringHash();
          setState(7837);
          _errHandler->sync(this);

          switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1050, _ctx)) {
          case 1: {
            setState(7836);
            retainCurrentPassword();
            break;
          }

          }
          break;
        }

        }
        break;
      }

      }
      break;
    }

    case 2: {
      setState(7844);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1053, _ctx)) {
      case 1: {
        setState(7843);
        discardOldPassword();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RetainCurrentPasswordContext ------------------------------------------------------------------

MySQLParser::RetainCurrentPasswordContext::RetainCurrentPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RetainCurrentPasswordContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RetainCurrentPasswordContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RetainCurrentPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}


size_t MySQLParser::RetainCurrentPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleRetainCurrentPassword;
}

void MySQLParser::RetainCurrentPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRetainCurrentPassword(this);
}

void MySQLParser::RetainCurrentPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRetainCurrentPassword(this);
}

MySQLParser::RetainCurrentPasswordContext* MySQLParser::retainCurrentPassword() {
  RetainCurrentPasswordContext *_localctx = _tracker.createInstance<RetainCurrentPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1004, MySQLParser::RuleRetainCurrentPassword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7848);
    match(MySQLParser::RETAIN_SYMBOL);
    setState(7849);
    match(MySQLParser::CURRENT_SYMBOL);
    setState(7850);
    match(MySQLParser::PASSWORD_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DiscardOldPasswordContext ------------------------------------------------------------------

MySQLParser::DiscardOldPasswordContext::DiscardOldPasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DiscardOldPasswordContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DiscardOldPasswordContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::DiscardOldPasswordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}


size_t MySQLParser::DiscardOldPasswordContext::getRuleIndex() const {
  return MySQLParser::RuleDiscardOldPassword;
}

void MySQLParser::DiscardOldPasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDiscardOldPassword(this);
}

void MySQLParser::DiscardOldPasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDiscardOldPassword(this);
}

MySQLParser::DiscardOldPasswordContext* MySQLParser::discardOldPassword() {
  DiscardOldPasswordContext *_localctx = _tracker.createInstance<DiscardOldPasswordContext>(_ctx, getState());
  enterRule(_localctx, 1006, MySQLParser::RuleDiscardOldPassword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7852);
    match(MySQLParser::DISCARD_SYMBOL);
    setState(7853);
    match(MySQLParser::OLD_SYMBOL);
    setState(7854);
    match(MySQLParser::PASSWORD_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ReplacePasswordContext ------------------------------------------------------------------

MySQLParser::ReplacePasswordContext::ReplacePasswordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ReplacePasswordContext::REPLACE_SYMBOL() {
  return getToken(MySQLParser::REPLACE_SYMBOL, 0);
}

MySQLParser::TextStringContext* MySQLParser::ReplacePasswordContext::textString() {
  return getRuleContext<MySQLParser::TextStringContext>(0);
}


size_t MySQLParser::ReplacePasswordContext::getRuleIndex() const {
  return MySQLParser::RuleReplacePassword;
}

void MySQLParser::ReplacePasswordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReplacePassword(this);
}

void MySQLParser::ReplacePasswordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReplacePassword(this);
}

MySQLParser::ReplacePasswordContext* MySQLParser::replacePassword() {
  ReplacePasswordContext *_localctx = _tracker.createInstance<ReplacePasswordContext>(_ctx, getState());
  enterRule(_localctx, 1008, MySQLParser::RuleReplacePassword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7856);
    match(MySQLParser::REPLACE_SYMBOL);
    setState(7857);
    textString();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UserContext ------------------------------------------------------------------

MySQLParser::UserContext::UserContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextOrIdentifierContext *> MySQLParser::UserContext::textOrIdentifier() {
  return getRuleContexts<MySQLParser::TextOrIdentifierContext>();
}

MySQLParser::TextOrIdentifierContext* MySQLParser::UserContext::textOrIdentifier(size_t i) {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(i);
}

tree::TerminalNode* MySQLParser::UserContext::AT_SIGN_SYMBOL() {
  return getToken(MySQLParser::AT_SIGN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::UserContext::AT_TEXT_SUFFIX() {
  return getToken(MySQLParser::AT_TEXT_SUFFIX, 0);
}

tree::TerminalNode* MySQLParser::UserContext::CURRENT_USER_SYMBOL() {
  return getToken(MySQLParser::CURRENT_USER_SYMBOL, 0);
}

MySQLParser::ParenthesesContext* MySQLParser::UserContext::parentheses() {
  return getRuleContext<MySQLParser::ParenthesesContext>(0);
}


size_t MySQLParser::UserContext::getRuleIndex() const {
  return MySQLParser::RuleUser;
}

void MySQLParser::UserContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUser(this);
}

void MySQLParser::UserContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUser(this);
}

MySQLParser::UserContext* MySQLParser::user() {
  UserContext *_localctx = _tracker.createInstance<UserContext>(_ctx, getState());
  enterRule(_localctx, 1010, MySQLParser::RuleUser);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7869);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1057, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7859);
      textOrIdentifier();
      setState(7863);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1055, _ctx)) {
      case 1: {
        setState(7860);
        match(MySQLParser::AT_SIGN_SYMBOL);
        setState(7861);
        textOrIdentifier();
        break;
      }

      case 2: {
        setState(7862);
        match(MySQLParser::AT_TEXT_SUFFIX);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7865);
      match(MySQLParser::CURRENT_USER_SYMBOL);
      setState(7867);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1056, _ctx)) {
      case 1: {
        setState(7866);
        parentheses();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LikeClauseContext ------------------------------------------------------------------

MySQLParser::LikeClauseContext::LikeClauseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::LikeClauseContext::LIKE_SYMBOL() {
  return getToken(MySQLParser::LIKE_SYMBOL, 0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::LikeClauseContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::LikeClauseContext::getRuleIndex() const {
  return MySQLParser::RuleLikeClause;
}

void MySQLParser::LikeClauseContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikeClause(this);
}

void MySQLParser::LikeClauseContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikeClause(this);
}

MySQLParser::LikeClauseContext* MySQLParser::likeClause() {
  LikeClauseContext *_localctx = _tracker.createInstance<LikeClauseContext>(_ctx, getState());
  enterRule(_localctx, 1012, MySQLParser::RuleLikeClause);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7871);
    match(MySQLParser::LIKE_SYMBOL);
    setState(7872);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LikeOrWhereContext ------------------------------------------------------------------

MySQLParser::LikeOrWhereContext::LikeOrWhereContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LikeClauseContext* MySQLParser::LikeOrWhereContext::likeClause() {
  return getRuleContext<MySQLParser::LikeClauseContext>(0);
}

MySQLParser::WhereClauseContext* MySQLParser::LikeOrWhereContext::whereClause() {
  return getRuleContext<MySQLParser::WhereClauseContext>(0);
}


size_t MySQLParser::LikeOrWhereContext::getRuleIndex() const {
  return MySQLParser::RuleLikeOrWhere;
}

void MySQLParser::LikeOrWhereContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLikeOrWhere(this);
}

void MySQLParser::LikeOrWhereContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLikeOrWhere(this);
}

MySQLParser::LikeOrWhereContext* MySQLParser::likeOrWhere() {
  LikeOrWhereContext *_localctx = _tracker.createInstance<LikeOrWhereContext>(_ctx, getState());
  enterRule(_localctx, 1014, MySQLParser::RuleLikeOrWhere);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7876);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::LIKE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(7874);
        likeClause();
        break;
      }

      case MySQLParser::WHERE_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(7875);
        whereClause();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OnlineOptionContext ------------------------------------------------------------------

MySQLParser::OnlineOptionContext::OnlineOptionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OnlineOptionContext::ONLINE_SYMBOL() {
  return getToken(MySQLParser::ONLINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OnlineOptionContext::OFFLINE_SYMBOL() {
  return getToken(MySQLParser::OFFLINE_SYMBOL, 0);
}


size_t MySQLParser::OnlineOptionContext::getRuleIndex() const {
  return MySQLParser::RuleOnlineOption;
}

void MySQLParser::OnlineOptionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOnlineOption(this);
}

void MySQLParser::OnlineOptionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOnlineOption(this);
}

MySQLParser::OnlineOptionContext* MySQLParser::onlineOption() {
  OnlineOptionContext *_localctx = _tracker.createInstance<OnlineOptionContext>(_ctx, getState());
  enterRule(_localctx, 1016, MySQLParser::RuleOnlineOption);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7878);

    if (!(serverVersion < 50600)) throw FailedPredicateException(this, "serverVersion < 50600");
    setState(7879);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::OFFLINE_SYMBOL

    || _la == MySQLParser::ONLINE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NoWriteToBinLogContext ------------------------------------------------------------------

MySQLParser::NoWriteToBinLogContext::NoWriteToBinLogContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NoWriteToBinLogContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NoWriteToBinLogContext::NO_WRITE_TO_BINLOG_SYMBOL() {
  return getToken(MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL, 0);
}


size_t MySQLParser::NoWriteToBinLogContext::getRuleIndex() const {
  return MySQLParser::RuleNoWriteToBinLog;
}

void MySQLParser::NoWriteToBinLogContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNoWriteToBinLog(this);
}

void MySQLParser::NoWriteToBinLogContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNoWriteToBinLog(this);
}

MySQLParser::NoWriteToBinLogContext* MySQLParser::noWriteToBinLog() {
  NoWriteToBinLogContext *_localctx = _tracker.createInstance<NoWriteToBinLogContext>(_ctx, getState());
  enterRule(_localctx, 1018, MySQLParser::RuleNoWriteToBinLog);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7881);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::NO_WRITE_TO_BINLOG_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UsePartitionContext ------------------------------------------------------------------

MySQLParser::UsePartitionContext::UsePartitionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::UsePartitionContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::UsePartitionContext::identifierListWithParentheses() {
  return getRuleContext<MySQLParser::IdentifierListWithParenthesesContext>(0);
}


size_t MySQLParser::UsePartitionContext::getRuleIndex() const {
  return MySQLParser::RuleUsePartition;
}

void MySQLParser::UsePartitionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUsePartition(this);
}

void MySQLParser::UsePartitionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUsePartition(this);
}

MySQLParser::UsePartitionContext* MySQLParser::usePartition() {
  UsePartitionContext *_localctx = _tracker.createInstance<UsePartitionContext>(_ctx, getState());
  enterRule(_localctx, 1020, MySQLParser::RuleUsePartition);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7883);

    if (!(serverVersion >= 50602)) throw FailedPredicateException(this, "serverVersion >= 50602");
    setState(7884);
    match(MySQLParser::PARTITION_SYMBOL);
    setState(7885);
    identifierListWithParentheses();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FieldIdentifierContext ------------------------------------------------------------------

MySQLParser::FieldIdentifierContext::FieldIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::DotIdentifierContext* MySQLParser::FieldIdentifierContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FieldIdentifierContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::FieldIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleFieldIdentifier;
}

void MySQLParser::FieldIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFieldIdentifier(this);
}

void MySQLParser::FieldIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFieldIdentifier(this);
}

MySQLParser::FieldIdentifierContext* MySQLParser::fieldIdentifier() {
  FieldIdentifierContext *_localctx = _tracker.createInstance<FieldIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1022, MySQLParser::RuleFieldIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7892);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1060, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7887);
      dotIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7888);
      qualifiedIdentifier();
      setState(7890);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1059, _ctx)) {
      case 1: {
        setState(7889);
        dotIdentifier();
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnNameContext ------------------------------------------------------------------

MySQLParser::ColumnNameContext::ColumnNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ColumnNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::FieldIdentifierContext* MySQLParser::ColumnNameContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}


size_t MySQLParser::ColumnNameContext::getRuleIndex() const {
  return MySQLParser::RuleColumnName;
}

void MySQLParser::ColumnNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnName(this);
}

void MySQLParser::ColumnNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnName(this);
}

MySQLParser::ColumnNameContext* MySQLParser::columnName() {
  ColumnNameContext *_localctx = _tracker.createInstance<ColumnNameContext>(_ctx, getState());
  enterRule(_localctx, 1024, MySQLParser::RuleColumnName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7898);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1061, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7894);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(7895);
      identifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7896);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(7897);
      fieldIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnInternalRefContext ------------------------------------------------------------------

MySQLParser::ColumnInternalRefContext::ColumnInternalRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ColumnInternalRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::ColumnInternalRefContext::getRuleIndex() const {
  return MySQLParser::RuleColumnInternalRef;
}

void MySQLParser::ColumnInternalRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnInternalRef(this);
}

void MySQLParser::ColumnInternalRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnInternalRef(this);
}

MySQLParser::ColumnInternalRefContext* MySQLParser::columnInternalRef() {
  ColumnInternalRefContext *_localctx = _tracker.createInstance<ColumnInternalRefContext>(_ctx, getState());
  enterRule(_localctx, 1026, MySQLParser::RuleColumnInternalRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7900);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnInternalRefListContext ------------------------------------------------------------------

MySQLParser::ColumnInternalRefListContext::ColumnInternalRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ColumnInternalRefListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::ColumnInternalRefContext *> MySQLParser::ColumnInternalRefListContext::columnInternalRef() {
  return getRuleContexts<MySQLParser::ColumnInternalRefContext>();
}

MySQLParser::ColumnInternalRefContext* MySQLParser::ColumnInternalRefListContext::columnInternalRef(size_t i) {
  return getRuleContext<MySQLParser::ColumnInternalRefContext>(i);
}

tree::TerminalNode* MySQLParser::ColumnInternalRefListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::ColumnInternalRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::ColumnInternalRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::ColumnInternalRefListContext::getRuleIndex() const {
  return MySQLParser::RuleColumnInternalRefList;
}

void MySQLParser::ColumnInternalRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnInternalRefList(this);
}

void MySQLParser::ColumnInternalRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnInternalRefList(this);
}

MySQLParser::ColumnInternalRefListContext* MySQLParser::columnInternalRefList() {
  ColumnInternalRefListContext *_localctx = _tracker.createInstance<ColumnInternalRefListContext>(_ctx, getState());
  enterRule(_localctx, 1028, MySQLParser::RuleColumnInternalRefList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7902);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(7903);
    columnInternalRef();
    setState(7908);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(7904);
      match(MySQLParser::COMMA_SYMBOL);
      setState(7905);
      columnInternalRef();
      setState(7910);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(7911);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ColumnRefContext ------------------------------------------------------------------

MySQLParser::ColumnRefContext::ColumnRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldIdentifierContext* MySQLParser::ColumnRefContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}


size_t MySQLParser::ColumnRefContext::getRuleIndex() const {
  return MySQLParser::RuleColumnRef;
}

void MySQLParser::ColumnRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterColumnRef(this);
}

void MySQLParser::ColumnRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitColumnRef(this);
}

MySQLParser::ColumnRefContext* MySQLParser::columnRef() {
  ColumnRefContext *_localctx = _tracker.createInstance<ColumnRefContext>(_ctx, getState());
  enterRule(_localctx, 1030, MySQLParser::RuleColumnRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7913);
    fieldIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- InsertIdentifierContext ------------------------------------------------------------------

MySQLParser::InsertIdentifierContext::InsertIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::ColumnRefContext* MySQLParser::InsertIdentifierContext::columnRef() {
  return getRuleContext<MySQLParser::ColumnRefContext>(0);
}

MySQLParser::TableWildContext* MySQLParser::InsertIdentifierContext::tableWild() {
  return getRuleContext<MySQLParser::TableWildContext>(0);
}


size_t MySQLParser::InsertIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleInsertIdentifier;
}

void MySQLParser::InsertIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterInsertIdentifier(this);
}

void MySQLParser::InsertIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitInsertIdentifier(this);
}

MySQLParser::InsertIdentifierContext* MySQLParser::insertIdentifier() {
  InsertIdentifierContext *_localctx = _tracker.createInstance<InsertIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1032, MySQLParser::RuleInsertIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7917);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1063, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7915);
      columnRef();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7916);
      tableWild();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexNameContext ------------------------------------------------------------------

MySQLParser::IndexNameContext::IndexNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::IndexNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::IndexNameContext::getRuleIndex() const {
  return MySQLParser::RuleIndexName;
}

void MySQLParser::IndexNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexName(this);
}

void MySQLParser::IndexNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexName(this);
}

MySQLParser::IndexNameContext* MySQLParser::indexName() {
  IndexNameContext *_localctx = _tracker.createInstance<IndexNameContext>(_ctx, getState());
  enterRule(_localctx, 1034, MySQLParser::RuleIndexName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7919);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IndexRefContext ------------------------------------------------------------------

MySQLParser::IndexRefContext::IndexRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldIdentifierContext* MySQLParser::IndexRefContext::fieldIdentifier() {
  return getRuleContext<MySQLParser::FieldIdentifierContext>(0);
}


size_t MySQLParser::IndexRefContext::getRuleIndex() const {
  return MySQLParser::RuleIndexRef;
}

void MySQLParser::IndexRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIndexRef(this);
}

void MySQLParser::IndexRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIndexRef(this);
}

MySQLParser::IndexRefContext* MySQLParser::indexRef() {
  IndexRefContext *_localctx = _tracker.createInstance<IndexRefContext>(_ctx, getState());
  enterRule(_localctx, 1036, MySQLParser::RuleIndexRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7921);
    fieldIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableWildContext ------------------------------------------------------------------

MySQLParser::TableWildContext::TableWildContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::TableWildContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext* MySQLParser::TableWildContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableWildContext::DOT_SYMBOL() {
  return getTokens(MySQLParser::DOT_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableWildContext::DOT_SYMBOL(size_t i) {
  return getToken(MySQLParser::DOT_SYMBOL, i);
}

tree::TerminalNode* MySQLParser::TableWildContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}


size_t MySQLParser::TableWildContext::getRuleIndex() const {
  return MySQLParser::RuleTableWild;
}

void MySQLParser::TableWildContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableWild(this);
}

void MySQLParser::TableWildContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableWild(this);
}

MySQLParser::TableWildContext* MySQLParser::tableWild() {
  TableWildContext *_localctx = _tracker.createInstance<TableWildContext>(_ctx, getState());
  enterRule(_localctx, 1038, MySQLParser::RuleTableWild);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7923);
    identifier();
    setState(7924);
    match(MySQLParser::DOT_SYMBOL);
    setState(7928);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1064, _ctx)) {
    case 1: {
      setState(7925);
      identifier();
      setState(7926);
      match(MySQLParser::DOT_SYMBOL);
      break;
    }

    }
    setState(7930);
    match(MySQLParser::MULT_OPERATOR);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaNameContext ------------------------------------------------------------------

MySQLParser::SchemaNameContext::SchemaNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SchemaNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::SchemaNameContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaName;
}

void MySQLParser::SchemaNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaName(this);
}

void MySQLParser::SchemaNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaName(this);
}

MySQLParser::SchemaNameContext* MySQLParser::schemaName() {
  SchemaNameContext *_localctx = _tracker.createInstance<SchemaNameContext>(_ctx, getState());
  enterRule(_localctx, 1040, MySQLParser::RuleSchemaName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7932);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SchemaRefContext ------------------------------------------------------------------

MySQLParser::SchemaRefContext::SchemaRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SchemaRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::SchemaRefContext::getRuleIndex() const {
  return MySQLParser::RuleSchemaRef;
}

void MySQLParser::SchemaRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSchemaRef(this);
}

void MySQLParser::SchemaRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSchemaRef(this);
}

MySQLParser::SchemaRefContext* MySQLParser::schemaRef() {
  SchemaRefContext *_localctx = _tracker.createInstance<SchemaRefContext>(_ctx, getState());
  enterRule(_localctx, 1042, MySQLParser::RuleSchemaRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7934);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureNameContext ------------------------------------------------------------------

MySQLParser::ProcedureNameContext::ProcedureNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ProcedureNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::ProcedureNameContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureName;
}

void MySQLParser::ProcedureNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureName(this);
}

void MySQLParser::ProcedureNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureName(this);
}

MySQLParser::ProcedureNameContext* MySQLParser::procedureName() {
  ProcedureNameContext *_localctx = _tracker.createInstance<ProcedureNameContext>(_ctx, getState());
  enterRule(_localctx, 1044, MySQLParser::RuleProcedureName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7936);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ProcedureRefContext ------------------------------------------------------------------

MySQLParser::ProcedureRefContext::ProcedureRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ProcedureRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::ProcedureRefContext::getRuleIndex() const {
  return MySQLParser::RuleProcedureRef;
}

void MySQLParser::ProcedureRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterProcedureRef(this);
}

void MySQLParser::ProcedureRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitProcedureRef(this);
}

MySQLParser::ProcedureRefContext* MySQLParser::procedureRef() {
  ProcedureRefContext *_localctx = _tracker.createInstance<ProcedureRefContext>(_ctx, getState());
  enterRule(_localctx, 1046, MySQLParser::RuleProcedureRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7938);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionNameContext ------------------------------------------------------------------

MySQLParser::FunctionNameContext::FunctionNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FunctionNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::FunctionNameContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionName;
}

void MySQLParser::FunctionNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionName(this);
}

void MySQLParser::FunctionNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionName(this);
}

MySQLParser::FunctionNameContext* MySQLParser::functionName() {
  FunctionNameContext *_localctx = _tracker.createInstance<FunctionNameContext>(_ctx, getState());
  enterRule(_localctx, 1048, MySQLParser::RuleFunctionName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7940);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FunctionRefContext ------------------------------------------------------------------

MySQLParser::FunctionRefContext::FunctionRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::FunctionRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::FunctionRefContext::getRuleIndex() const {
  return MySQLParser::RuleFunctionRef;
}

void MySQLParser::FunctionRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFunctionRef(this);
}

void MySQLParser::FunctionRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFunctionRef(this);
}

MySQLParser::FunctionRefContext* MySQLParser::functionRef() {
  FunctionRefContext *_localctx = _tracker.createInstance<FunctionRefContext>(_ctx, getState());
  enterRule(_localctx, 1050, MySQLParser::RuleFunctionRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7942);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerNameContext ------------------------------------------------------------------

MySQLParser::TriggerNameContext::TriggerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TriggerNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::TriggerNameContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerName;
}

void MySQLParser::TriggerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerName(this);
}

void MySQLParser::TriggerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerName(this);
}

MySQLParser::TriggerNameContext* MySQLParser::triggerName() {
  TriggerNameContext *_localctx = _tracker.createInstance<TriggerNameContext>(_ctx, getState());
  enterRule(_localctx, 1052, MySQLParser::RuleTriggerName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7944);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TriggerRefContext ------------------------------------------------------------------

MySQLParser::TriggerRefContext::TriggerRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TriggerRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::TriggerRefContext::getRuleIndex() const {
  return MySQLParser::RuleTriggerRef;
}

void MySQLParser::TriggerRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTriggerRef(this);
}

void MySQLParser::TriggerRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTriggerRef(this);
}

MySQLParser::TriggerRefContext* MySQLParser::triggerRef() {
  TriggerRefContext *_localctx = _tracker.createInstance<TriggerRefContext>(_ctx, getState());
  enterRule(_localctx, 1054, MySQLParser::RuleTriggerRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7946);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewNameContext ------------------------------------------------------------------

MySQLParser::ViewNameContext::ViewNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ViewNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::ViewNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::ViewNameContext::getRuleIndex() const {
  return MySQLParser::RuleViewName;
}

void MySQLParser::ViewNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewName(this);
}

void MySQLParser::ViewNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewName(this);
}

MySQLParser::ViewNameContext* MySQLParser::viewName() {
  ViewNameContext *_localctx = _tracker.createInstance<ViewNameContext>(_ctx, getState());
  enterRule(_localctx, 1056, MySQLParser::RuleViewName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7950);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1065, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7948);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7949);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ViewRefContext ------------------------------------------------------------------

MySQLParser::ViewRefContext::ViewRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::ViewRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::ViewRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::ViewRefContext::getRuleIndex() const {
  return MySQLParser::RuleViewRef;
}

void MySQLParser::ViewRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterViewRef(this);
}

void MySQLParser::ViewRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitViewRef(this);
}

MySQLParser::ViewRefContext* MySQLParser::viewRef() {
  ViewRefContext *_localctx = _tracker.createInstance<ViewRefContext>(_ctx, getState());
  enterRule(_localctx, 1058, MySQLParser::RuleViewRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7954);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1066, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7952);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7953);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceNameContext ------------------------------------------------------------------

MySQLParser::TablespaceNameContext::TablespaceNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TablespaceNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::TablespaceNameContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceName;
}

void MySQLParser::TablespaceNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceName(this);
}

void MySQLParser::TablespaceNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceName(this);
}

MySQLParser::TablespaceNameContext* MySQLParser::tablespaceName() {
  TablespaceNameContext *_localctx = _tracker.createInstance<TablespaceNameContext>(_ctx, getState());
  enterRule(_localctx, 1060, MySQLParser::RuleTablespaceName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7956);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TablespaceRefContext ------------------------------------------------------------------

MySQLParser::TablespaceRefContext::TablespaceRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TablespaceRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::TablespaceRefContext::getRuleIndex() const {
  return MySQLParser::RuleTablespaceRef;
}

void MySQLParser::TablespaceRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTablespaceRef(this);
}

void MySQLParser::TablespaceRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTablespaceRef(this);
}

MySQLParser::TablespaceRefContext* MySQLParser::tablespaceRef() {
  TablespaceRefContext *_localctx = _tracker.createInstance<TablespaceRefContext>(_ctx, getState());
  enterRule(_localctx, 1062, MySQLParser::RuleTablespaceRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7958);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupNameContext ------------------------------------------------------------------

MySQLParser::LogfileGroupNameContext::LogfileGroupNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::LogfileGroupNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::LogfileGroupNameContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupName;
}

void MySQLParser::LogfileGroupNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupName(this);
}

void MySQLParser::LogfileGroupNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupName(this);
}

MySQLParser::LogfileGroupNameContext* MySQLParser::logfileGroupName() {
  LogfileGroupNameContext *_localctx = _tracker.createInstance<LogfileGroupNameContext>(_ctx, getState());
  enterRule(_localctx, 1064, MySQLParser::RuleLogfileGroupName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7960);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogfileGroupRefContext ------------------------------------------------------------------

MySQLParser::LogfileGroupRefContext::LogfileGroupRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::LogfileGroupRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::LogfileGroupRefContext::getRuleIndex() const {
  return MySQLParser::RuleLogfileGroupRef;
}

void MySQLParser::LogfileGroupRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLogfileGroupRef(this);
}

void MySQLParser::LogfileGroupRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLogfileGroupRef(this);
}

MySQLParser::LogfileGroupRefContext* MySQLParser::logfileGroupRef() {
  LogfileGroupRefContext *_localctx = _tracker.createInstance<LogfileGroupRefContext>(_ctx, getState());
  enterRule(_localctx, 1066, MySQLParser::RuleLogfileGroupRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7962);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventNameContext ------------------------------------------------------------------

MySQLParser::EventNameContext::EventNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::EventNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::EventNameContext::getRuleIndex() const {
  return MySQLParser::RuleEventName;
}

void MySQLParser::EventNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventName(this);
}

void MySQLParser::EventNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventName(this);
}

MySQLParser::EventNameContext* MySQLParser::eventName() {
  EventNameContext *_localctx = _tracker.createInstance<EventNameContext>(_ctx, getState());
  enterRule(_localctx, 1068, MySQLParser::RuleEventName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7964);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventRefContext ------------------------------------------------------------------

MySQLParser::EventRefContext::EventRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::EventRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}


size_t MySQLParser::EventRefContext::getRuleIndex() const {
  return MySQLParser::RuleEventRef;
}

void MySQLParser::EventRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEventRef(this);
}

void MySQLParser::EventRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEventRef(this);
}

MySQLParser::EventRefContext* MySQLParser::eventRef() {
  EventRefContext *_localctx = _tracker.createInstance<EventRefContext>(_ctx, getState());
  enterRule(_localctx, 1070, MySQLParser::RuleEventRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7966);
    qualifiedIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- UdfNameContext ------------------------------------------------------------------

MySQLParser::UdfNameContext::UdfNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::UdfNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::UdfNameContext::getRuleIndex() const {
  return MySQLParser::RuleUdfName;
}

void MySQLParser::UdfNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUdfName(this);
}

void MySQLParser::UdfNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUdfName(this);
}

MySQLParser::UdfNameContext* MySQLParser::udfName() {
  UdfNameContext *_localctx = _tracker.createInstance<UdfNameContext>(_ctx, getState());
  enterRule(_localctx, 1072, MySQLParser::RuleUdfName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7968);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerNameContext ------------------------------------------------------------------

MySQLParser::ServerNameContext::ServerNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ServerNameContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::ServerNameContext::getRuleIndex() const {
  return MySQLParser::RuleServerName;
}

void MySQLParser::ServerNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerName(this);
}

void MySQLParser::ServerNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerName(this);
}

MySQLParser::ServerNameContext* MySQLParser::serverName() {
  ServerNameContext *_localctx = _tracker.createInstance<ServerNameContext>(_ctx, getState());
  enterRule(_localctx, 1074, MySQLParser::RuleServerName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7970);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ServerRefContext ------------------------------------------------------------------

MySQLParser::ServerRefContext::ServerRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::ServerRefContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::ServerRefContext::getRuleIndex() const {
  return MySQLParser::RuleServerRef;
}

void MySQLParser::ServerRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterServerRef(this);
}

void MySQLParser::ServerRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitServerRef(this);
}

MySQLParser::ServerRefContext* MySQLParser::serverRef() {
  ServerRefContext *_localctx = _tracker.createInstance<ServerRefContext>(_ctx, getState());
  enterRule(_localctx, 1076, MySQLParser::RuleServerRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7972);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EngineRefContext ------------------------------------------------------------------

MySQLParser::EngineRefContext::EngineRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextOrIdentifierContext* MySQLParser::EngineRefContext::textOrIdentifier() {
  return getRuleContext<MySQLParser::TextOrIdentifierContext>(0);
}


size_t MySQLParser::EngineRefContext::getRuleIndex() const {
  return MySQLParser::RuleEngineRef;
}

void MySQLParser::EngineRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEngineRef(this);
}

void MySQLParser::EngineRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEngineRef(this);
}

MySQLParser::EngineRefContext* MySQLParser::engineRef() {
  EngineRefContext *_localctx = _tracker.createInstance<EngineRefContext>(_ctx, getState());
  enterRule(_localctx, 1078, MySQLParser::RuleEngineRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7974);
    textOrIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableNameContext ------------------------------------------------------------------

MySQLParser::TableNameContext::TableNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TableNameContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::TableNameContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::TableNameContext::getRuleIndex() const {
  return MySQLParser::RuleTableName;
}

void MySQLParser::TableNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableName(this);
}

void MySQLParser::TableNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableName(this);
}

MySQLParser::TableNameContext* MySQLParser::tableName() {
  TableNameContext *_localctx = _tracker.createInstance<TableNameContext>(_ctx, getState());
  enterRule(_localctx, 1080, MySQLParser::RuleTableName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7978);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1067, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7976);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7977);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FilterTableRefContext ------------------------------------------------------------------

MySQLParser::FilterTableRefContext::FilterTableRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::SchemaRefContext* MySQLParser::FilterTableRefContext::schemaRef() {
  return getRuleContext<MySQLParser::SchemaRefContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::FilterTableRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::FilterTableRefContext::getRuleIndex() const {
  return MySQLParser::RuleFilterTableRef;
}

void MySQLParser::FilterTableRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFilterTableRef(this);
}

void MySQLParser::FilterTableRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFilterTableRef(this);
}

MySQLParser::FilterTableRefContext* MySQLParser::filterTableRef() {
  FilterTableRefContext *_localctx = _tracker.createInstance<FilterTableRefContext>(_ctx, getState());
  enterRule(_localctx, 1082, MySQLParser::RuleFilterTableRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7980);
    schemaRef();
    setState(7981);
    dotIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefWithWildcardContext ------------------------------------------------------------------

MySQLParser::TableRefWithWildcardContext::TableRefWithWildcardContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::TableRefWithWildcardContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

tree::TerminalNode* MySQLParser::TableRefWithWildcardContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TableRefWithWildcardContext::MULT_OPERATOR() {
  return getToken(MySQLParser::MULT_OPERATOR, 0);
}

MySQLParser::DotIdentifierContext* MySQLParser::TableRefWithWildcardContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::TableRefWithWildcardContext::getRuleIndex() const {
  return MySQLParser::RuleTableRefWithWildcard;
}

void MySQLParser::TableRefWithWildcardContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRefWithWildcard(this);
}

void MySQLParser::TableRefWithWildcardContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRefWithWildcard(this);
}

MySQLParser::TableRefWithWildcardContext* MySQLParser::tableRefWithWildcard() {
  TableRefWithWildcardContext *_localctx = _tracker.createInstance<TableRefWithWildcardContext>(_ctx, getState());
  enterRule(_localctx, 1084, MySQLParser::RuleTableRefWithWildcard);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(7983);
    identifier();
    setState(7991);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1069, _ctx)) {
    case 1: {
      setState(7984);
      match(MySQLParser::DOT_SYMBOL);
      setState(7985);
      match(MySQLParser::MULT_OPERATOR);
      break;
    }

    case 2: {
      setState(7986);
      dotIdentifier();
      setState(7989);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1068, _ctx)) {
      case 1: {
        setState(7987);
        match(MySQLParser::DOT_SYMBOL);
        setState(7988);
        match(MySQLParser::MULT_OPERATOR);
        break;
      }

      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefContext ------------------------------------------------------------------

MySQLParser::TableRefContext::TableRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::TableRefContext::qualifiedIdentifier() {
  return getRuleContext<MySQLParser::QualifiedIdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::TableRefContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::TableRefContext::getRuleIndex() const {
  return MySQLParser::RuleTableRef;
}

void MySQLParser::TableRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRef(this);
}

void MySQLParser::TableRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRef(this);
}

MySQLParser::TableRefContext* MySQLParser::tableRef() {
  TableRefContext *_localctx = _tracker.createInstance<TableRefContext>(_ctx, getState());
  enterRule(_localctx, 1086, MySQLParser::RuleTableRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(7995);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1070, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(7993);
      qualifiedIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(7994);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableRefListContext ------------------------------------------------------------------

MySQLParser::TableRefListContext::TableRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableRefContext *> MySQLParser::TableRefListContext::tableRef() {
  return getRuleContexts<MySQLParser::TableRefContext>();
}

MySQLParser::TableRefContext* MySQLParser::TableRefListContext::tableRef(size_t i) {
  return getRuleContext<MySQLParser::TableRefContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableRefListContext::getRuleIndex() const {
  return MySQLParser::RuleTableRefList;
}

void MySQLParser::TableRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableRefList(this);
}

void MySQLParser::TableRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableRefList(this);
}

MySQLParser::TableRefListContext* MySQLParser::tableRefList() {
  TableRefListContext *_localctx = _tracker.createInstance<TableRefListContext>(_ctx, getState());
  enterRule(_localctx, 1088, MySQLParser::RuleTableRefList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(7997);
    tableRef();
    setState(8002);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1071, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(7998);
        match(MySQLParser::COMMA_SYMBOL);
        setState(7999);
        tableRef(); 
      }
      setState(8004);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1071, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TableAliasRefListContext ------------------------------------------------------------------

MySQLParser::TableAliasRefListContext::TableAliasRefListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TableRefWithWildcardContext *> MySQLParser::TableAliasRefListContext::tableRefWithWildcard() {
  return getRuleContexts<MySQLParser::TableRefWithWildcardContext>();
}

MySQLParser::TableRefWithWildcardContext* MySQLParser::TableAliasRefListContext::tableRefWithWildcard(size_t i) {
  return getRuleContext<MySQLParser::TableRefWithWildcardContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TableAliasRefListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TableAliasRefListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TableAliasRefListContext::getRuleIndex() const {
  return MySQLParser::RuleTableAliasRefList;
}

void MySQLParser::TableAliasRefListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTableAliasRefList(this);
}

void MySQLParser::TableAliasRefListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTableAliasRefList(this);
}

MySQLParser::TableAliasRefListContext* MySQLParser::tableAliasRefList() {
  TableAliasRefListContext *_localctx = _tracker.createInstance<TableAliasRefListContext>(_ctx, getState());
  enterRule(_localctx, 1090, MySQLParser::RuleTableAliasRefList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8005);
    tableRefWithWildcard();
    setState(8010);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1072, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8006);
        match(MySQLParser::COMMA_SYMBOL);
        setState(8007);
        tableRefWithWildcard(); 
      }
      setState(8012);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1072, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParameterNameContext ------------------------------------------------------------------

MySQLParser::ParameterNameContext::ParameterNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ParameterNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::ParameterNameContext::getRuleIndex() const {
  return MySQLParser::RuleParameterName;
}

void MySQLParser::ParameterNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParameterName(this);
}

void MySQLParser::ParameterNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParameterName(this);
}

MySQLParser::ParameterNameContext* MySQLParser::parameterName() {
  ParameterNameContext *_localctx = _tracker.createInstance<ParameterNameContext>(_ctx, getState());
  enterRule(_localctx, 1092, MySQLParser::RuleParameterName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8013);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelIdentifierContext ------------------------------------------------------------------

MySQLParser::LabelIdentifierContext::LabelIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::LabelIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::LabelKeywordContext* MySQLParser::LabelIdentifierContext::labelKeyword() {
  return getRuleContext<MySQLParser::LabelKeywordContext>(0);
}


size_t MySQLParser::LabelIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleLabelIdentifier;
}

void MySQLParser::LabelIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelIdentifier(this);
}

void MySQLParser::LabelIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelIdentifier(this);
}

MySQLParser::LabelIdentifierContext* MySQLParser::labelIdentifier() {
  LabelIdentifierContext *_localctx = _tracker.createInstance<LabelIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1094, MySQLParser::RuleLabelIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8017);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1073, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8015);
      pureIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8016);
      labelKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelRefContext ------------------------------------------------------------------

MySQLParser::LabelRefContext::LabelRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelIdentifierContext* MySQLParser::LabelRefContext::labelIdentifier() {
  return getRuleContext<MySQLParser::LabelIdentifierContext>(0);
}


size_t MySQLParser::LabelRefContext::getRuleIndex() const {
  return MySQLParser::RuleLabelRef;
}

void MySQLParser::LabelRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelRef(this);
}

void MySQLParser::LabelRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelRef(this);
}

MySQLParser::LabelRefContext* MySQLParser::labelRef() {
  LabelRefContext *_localctx = _tracker.createInstance<LabelRefContext>(_ctx, getState());
  enterRule(_localctx, 1096, MySQLParser::RuleLabelRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8019);
    labelIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleIdentifierContext ------------------------------------------------------------------

MySQLParser::RoleIdentifierContext::RoleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::RoleIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::RoleKeywordContext* MySQLParser::RoleIdentifierContext::roleKeyword() {
  return getRuleContext<MySQLParser::RoleKeywordContext>(0);
}


size_t MySQLParser::RoleIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleRoleIdentifier;
}

void MySQLParser::RoleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleIdentifier(this);
}

void MySQLParser::RoleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleIdentifier(this);
}

MySQLParser::RoleIdentifierContext* MySQLParser::roleIdentifier() {
  RoleIdentifierContext *_localctx = _tracker.createInstance<RoleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1098, MySQLParser::RuleRoleIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8023);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1074, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8021);
      pureIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8022);
      roleKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleRefContext ------------------------------------------------------------------

MySQLParser::RoleRefContext::RoleRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierContext* MySQLParser::RoleRefContext::roleIdentifier() {
  return getRuleContext<MySQLParser::RoleIdentifierContext>(0);
}


size_t MySQLParser::RoleRefContext::getRuleIndex() const {
  return MySQLParser::RuleRoleRef;
}

void MySQLParser::RoleRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleRef(this);
}

void MySQLParser::RoleRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleRef(this);
}

MySQLParser::RoleRefContext* MySQLParser::roleRef() {
  RoleRefContext *_localctx = _tracker.createInstance<RoleRefContext>(_ctx, getState());
  enterRule(_localctx, 1100, MySQLParser::RuleRoleRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8025);
    roleIdentifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PluginRefContext ------------------------------------------------------------------

MySQLParser::PluginRefContext::PluginRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::PluginRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::PluginRefContext::getRuleIndex() const {
  return MySQLParser::RulePluginRef;
}

void MySQLParser::PluginRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPluginRef(this);
}

void MySQLParser::PluginRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPluginRef(this);
}

MySQLParser::PluginRefContext* MySQLParser::pluginRef() {
  PluginRefContext *_localctx = _tracker.createInstance<PluginRefContext>(_ctx, getState());
  enterRule(_localctx, 1102, MySQLParser::RulePluginRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8027);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ComponentRefContext ------------------------------------------------------------------

MySQLParser::ComponentRefContext::ComponentRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext* MySQLParser::ComponentRefContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::ComponentRefContext::getRuleIndex() const {
  return MySQLParser::RuleComponentRef;
}

void MySQLParser::ComponentRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterComponentRef(this);
}

void MySQLParser::ComponentRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitComponentRef(this);
}

MySQLParser::ComponentRefContext* MySQLParser::componentRef() {
  ComponentRefContext *_localctx = _tracker.createInstance<ComponentRefContext>(_ctx, getState());
  enterRule(_localctx, 1104, MySQLParser::RuleComponentRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8029);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ResourceGroupRefContext ------------------------------------------------------------------

MySQLParser::ResourceGroupRefContext::ResourceGroupRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::ResourceGroupRefContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::ResourceGroupRefContext::getRuleIndex() const {
  return MySQLParser::RuleResourceGroupRef;
}

void MySQLParser::ResourceGroupRefContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterResourceGroupRef(this);
}

void MySQLParser::ResourceGroupRefContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitResourceGroupRef(this);
}

MySQLParser::ResourceGroupRefContext* MySQLParser::resourceGroupRef() {
  ResourceGroupRefContext *_localctx = _tracker.createInstance<ResourceGroupRefContext>(_ctx, getState());
  enterRule(_localctx, 1106, MySQLParser::RuleResourceGroupRef);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8031);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- WindowNameContext ------------------------------------------------------------------

MySQLParser::WindowNameContext::WindowNameContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::WindowNameContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::WindowNameContext::getRuleIndex() const {
  return MySQLParser::RuleWindowName;
}

void MySQLParser::WindowNameContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterWindowName(this);
}

void MySQLParser::WindowNameContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitWindowName(this);
}

MySQLParser::WindowNameContext* MySQLParser::windowName() {
  WindowNameContext *_localctx = _tracker.createInstance<WindowNameContext>(_ctx, getState());
  enterRule(_localctx, 1108, MySQLParser::RuleWindowName);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8033);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PureIdentifierContext ------------------------------------------------------------------

MySQLParser::PureIdentifierContext::PureIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PureIdentifierContext::IDENTIFIER() {
  return getToken(MySQLParser::IDENTIFIER, 0);
}

tree::TerminalNode* MySQLParser::PureIdentifierContext::BACK_TICK_QUOTED_ID() {
  return getToken(MySQLParser::BACK_TICK_QUOTED_ID, 0);
}

tree::TerminalNode* MySQLParser::PureIdentifierContext::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLParser::DOUBLE_QUOTED_TEXT, 0);
}


size_t MySQLParser::PureIdentifierContext::getRuleIndex() const {
  return MySQLParser::RulePureIdentifier;
}

void MySQLParser::PureIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPureIdentifier(this);
}

void MySQLParser::PureIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPureIdentifier(this);
}

MySQLParser::PureIdentifierContext* MySQLParser::pureIdentifier() {
  PureIdentifierContext *_localctx = _tracker.createInstance<PureIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1110, MySQLParser::RulePureIdentifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8038);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1075, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8035);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::IDENTIFIER

      || _la == MySQLParser::BACK_TICK_QUOTED_ID)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8036);

      if (!(isSqlModeActive(AnsiQuotes))) throw FailedPredicateException(this, "isSqlModeActive(AnsiQuotes)");
      setState(8037);
      match(MySQLParser::DOUBLE_QUOTED_TEXT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierContext ------------------------------------------------------------------

MySQLParser::IdentifierContext::IdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::IdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::IdentifierKeywordContext* MySQLParser::IdentifierContext::identifierKeyword() {
  return getRuleContext<MySQLParser::IdentifierKeywordContext>(0);
}


size_t MySQLParser::IdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifier;
}

void MySQLParser::IdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifier(this);
}

void MySQLParser::IdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifier(this);
}

MySQLParser::IdentifierContext* MySQLParser::identifier() {
  IdentifierContext *_localctx = _tracker.createInstance<IdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1112, MySQLParser::RuleIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8042);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1076, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8040);
      pureIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8041);
      identifierKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListContext ------------------------------------------------------------------

MySQLParser::IdentifierListContext::IdentifierListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::IdentifierContext *> MySQLParser::IdentifierListContext::identifier() {
  return getRuleContexts<MySQLParser::IdentifierContext>();
}

MySQLParser::IdentifierContext* MySQLParser::IdentifierListContext::identifier(size_t i) {
  return getRuleContext<MySQLParser::IdentifierContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::IdentifierListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::IdentifierListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::IdentifierListContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierList;
}

void MySQLParser::IdentifierListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierList(this);
}

void MySQLParser::IdentifierListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierList(this);
}

MySQLParser::IdentifierListContext* MySQLParser::identifierList() {
  IdentifierListContext *_localctx = _tracker.createInstance<IdentifierListContext>(_ctx, getState());
  enterRule(_localctx, 1114, MySQLParser::RuleIdentifierList);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8044);
    identifier();
    setState(8049);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1077, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8045);
        match(MySQLParser::COMMA_SYMBOL);
        setState(8046);
        identifier(); 
      }
      setState(8051);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1077, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierListWithParenthesesContext ------------------------------------------------------------------

MySQLParser::IdentifierListWithParenthesesContext::IdentifierListWithParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IdentifierListWithParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

MySQLParser::IdentifierListContext* MySQLParser::IdentifierListWithParenthesesContext::identifierList() {
  return getRuleContext<MySQLParser::IdentifierListContext>(0);
}

tree::TerminalNode* MySQLParser::IdentifierListWithParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::IdentifierListWithParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierListWithParentheses;
}

void MySQLParser::IdentifierListWithParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierListWithParentheses(this);
}

void MySQLParser::IdentifierListWithParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierListWithParentheses(this);
}

MySQLParser::IdentifierListWithParenthesesContext* MySQLParser::identifierListWithParentheses() {
  IdentifierListWithParenthesesContext *_localctx = _tracker.createInstance<IdentifierListWithParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 1116, MySQLParser::RuleIdentifierListWithParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8052);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8053);
    identifierList();
    setState(8054);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QualifiedIdentifierContext ------------------------------------------------------------------

MySQLParser::QualifiedIdentifierContext::QualifiedIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::QualifiedIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

MySQLParser::DotIdentifierContext* MySQLParser::QualifiedIdentifierContext::dotIdentifier() {
  return getRuleContext<MySQLParser::DotIdentifierContext>(0);
}


size_t MySQLParser::QualifiedIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleQualifiedIdentifier;
}

void MySQLParser::QualifiedIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterQualifiedIdentifier(this);
}

void MySQLParser::QualifiedIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitQualifiedIdentifier(this);
}

MySQLParser::QualifiedIdentifierContext* MySQLParser::qualifiedIdentifier() {
  QualifiedIdentifierContext *_localctx = _tracker.createInstance<QualifiedIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1118, MySQLParser::RuleQualifiedIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8056);
    identifier();
    setState(8058);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1078, _ctx)) {
    case 1: {
      setState(8057);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SimpleIdentifierContext ------------------------------------------------------------------

MySQLParser::SimpleIdentifierContext::SimpleIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierContext* MySQLParser::SimpleIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}

std::vector<MySQLParser::DotIdentifierContext *> MySQLParser::SimpleIdentifierContext::dotIdentifier() {
  return getRuleContexts<MySQLParser::DotIdentifierContext>();
}

MySQLParser::DotIdentifierContext* MySQLParser::SimpleIdentifierContext::dotIdentifier(size_t i) {
  return getRuleContext<MySQLParser::DotIdentifierContext>(i);
}


size_t MySQLParser::SimpleIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleSimpleIdentifier;
}

void MySQLParser::SimpleIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSimpleIdentifier(this);
}

void MySQLParser::SimpleIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSimpleIdentifier(this);
}

MySQLParser::SimpleIdentifierContext* MySQLParser::simpleIdentifier() {
  SimpleIdentifierContext *_localctx = _tracker.createInstance<SimpleIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1120, MySQLParser::RuleSimpleIdentifier);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8071);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1081, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8060);
      identifier();
      setState(8065);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::DOT_SYMBOL) {
        setState(8061);
        dotIdentifier();
        setState(8063);
        _errHandler->sync(this);

        _la = _input->LA(1);
        if (_la == MySQLParser::DOT_SYMBOL) {
          setState(8062);
          dotIdentifier();
        }
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8067);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(8068);
      dotIdentifier();
      setState(8069);
      dotIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DotIdentifierContext ------------------------------------------------------------------

MySQLParser::DotIdentifierContext::DotIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::DotIdentifierContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

MySQLParser::IdentifierContext* MySQLParser::DotIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::DotIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleDotIdentifier;
}

void MySQLParser::DotIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterDotIdentifier(this);
}

void MySQLParser::DotIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitDotIdentifier(this);
}

MySQLParser::DotIdentifierContext* MySQLParser::dotIdentifier() {
  DotIdentifierContext *_localctx = _tracker.createInstance<DotIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1122, MySQLParser::RuleDotIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8073);
    match(MySQLParser::DOT_SYMBOL);
    setState(8074);
    identifier();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ulong_numberContext ------------------------------------------------------------------

MySQLParser::Ulong_numberContext::Ulong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulong_numberContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}


size_t MySQLParser::Ulong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleUlong_number;
}

void MySQLParser::Ulong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUlong_number(this);
}

void MySQLParser::Ulong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUlong_number(this);
}

MySQLParser::Ulong_numberContext* MySQLParser::ulong_number() {
  Ulong_numberContext *_localctx = _tracker.createInstance<Ulong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1124, MySQLParser::RuleUlong_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8076);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::INT_NUMBER)
      | (1ULL << MySQLParser::LONG_NUMBER)
      | (1ULL << MySQLParser::ULONGLONG_NUMBER)
      | (1ULL << MySQLParser::HEX_NUMBER)
      | (1ULL << MySQLParser::DECIMAL_NUMBER)
      | (1ULL << MySQLParser::FLOAT_NUMBER))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_ulong_numberContext ------------------------------------------------------------------

MySQLParser::Real_ulong_numberContext::Real_ulong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}


size_t MySQLParser::Real_ulong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleReal_ulong_number;
}

void MySQLParser::Real_ulong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReal_ulong_number(this);
}

void MySQLParser::Real_ulong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReal_ulong_number(this);
}

MySQLParser::Real_ulong_numberContext* MySQLParser::real_ulong_number() {
  Real_ulong_numberContext *_localctx = _tracker.createInstance<Real_ulong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1126, MySQLParser::RuleReal_ulong_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8078);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::INT_NUMBER)
      | (1ULL << MySQLParser::LONG_NUMBER)
      | (1ULL << MySQLParser::ULONGLONG_NUMBER)
      | (1ULL << MySQLParser::HEX_NUMBER))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Ulonglong_numberContext ------------------------------------------------------------------

MySQLParser::Ulonglong_numberContext::Ulonglong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Ulonglong_numberContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}


size_t MySQLParser::Ulonglong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleUlonglong_number;
}

void MySQLParser::Ulonglong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterUlonglong_number(this);
}

void MySQLParser::Ulonglong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitUlonglong_number(this);
}

MySQLParser::Ulonglong_numberContext* MySQLParser::ulonglong_number() {
  Ulonglong_numberContext *_localctx = _tracker.createInstance<Ulonglong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1128, MySQLParser::RuleUlonglong_number);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8080);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::INT_NUMBER)
      | (1ULL << MySQLParser::LONG_NUMBER)
      | (1ULL << MySQLParser::ULONGLONG_NUMBER)
      | (1ULL << MySQLParser::DECIMAL_NUMBER)
      | (1ULL << MySQLParser::FLOAT_NUMBER))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Real_ulonglong_numberContext ------------------------------------------------------------------

MySQLParser::Real_ulonglong_numberContext::Real_ulonglong_numberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::Real_ulonglong_numberContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulonglong_numberContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulonglong_numberContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::Real_ulonglong_numberContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}


size_t MySQLParser::Real_ulonglong_numberContext::getRuleIndex() const {
  return MySQLParser::RuleReal_ulonglong_number;
}

void MySQLParser::Real_ulonglong_numberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterReal_ulonglong_number(this);
}

void MySQLParser::Real_ulonglong_numberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitReal_ulonglong_number(this);
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::real_ulonglong_number() {
  Real_ulonglong_numberContext *_localctx = _tracker.createInstance<Real_ulonglong_numberContext>(_ctx, getState());
  enterRule(_localctx, 1130, MySQLParser::RuleReal_ulonglong_number);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8087);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1082, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8082);
      match(MySQLParser::INT_NUMBER);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8083);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(8084);
      match(MySQLParser::HEX_NUMBER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8085);
      match(MySQLParser::ULONGLONG_NUMBER);
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8086);
      match(MySQLParser::LONG_NUMBER);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LiteralContext ------------------------------------------------------------------

MySQLParser::LiteralContext::LiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextLiteralContext* MySQLParser::LiteralContext::textLiteral() {
  return getRuleContext<MySQLParser::TextLiteralContext>(0);
}

MySQLParser::NumLiteralContext* MySQLParser::LiteralContext::numLiteral() {
  return getRuleContext<MySQLParser::NumLiteralContext>(0);
}

MySQLParser::TemporalLiteralContext* MySQLParser::LiteralContext::temporalLiteral() {
  return getRuleContext<MySQLParser::TemporalLiteralContext>(0);
}

MySQLParser::NullLiteralContext* MySQLParser::LiteralContext::nullLiteral() {
  return getRuleContext<MySQLParser::NullLiteralContext>(0);
}

MySQLParser::BoolLiteralContext* MySQLParser::LiteralContext::boolLiteral() {
  return getRuleContext<MySQLParser::BoolLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::LiteralContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LiteralContext::BIN_NUMBER() {
  return getToken(MySQLParser::BIN_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::LiteralContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLParser::UNDERSCORE_CHARSET, 0);
}


size_t MySQLParser::LiteralContext::getRuleIndex() const {
  return MySQLParser::RuleLiteral;
}

void MySQLParser::LiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLiteral(this);
}

void MySQLParser::LiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLiteral(this);
}

MySQLParser::LiteralContext* MySQLParser::literal() {
  LiteralContext *_localctx = _tracker.createInstance<LiteralContext>(_ctx, getState());
  enterRule(_localctx, 1132, MySQLParser::RuleLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8098);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1084, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8089);
      textLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8090);
      numLiteral();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8091);
      temporalLiteral();
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8092);
      nullLiteral();
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8093);
      boolLiteral();
      break;
    }

    case 6: {
      enterOuterAlt(_localctx, 6);
      setState(8095);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == MySQLParser::UNDERSCORE_CHARSET) {
        setState(8094);
        match(MySQLParser::UNDERSCORE_CHARSET);
      }
      setState(8097);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::HEX_NUMBER

      || _la == MySQLParser::BIN_NUMBER)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SignedLiteralContext ------------------------------------------------------------------

MySQLParser::SignedLiteralContext::SignedLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LiteralContext* MySQLParser::SignedLiteralContext::literal() {
  return getRuleContext<MySQLParser::LiteralContext>(0);
}

tree::TerminalNode* MySQLParser::SignedLiteralContext::PLUS_OPERATOR() {
  return getToken(MySQLParser::PLUS_OPERATOR, 0);
}

MySQLParser::Ulong_numberContext* MySQLParser::SignedLiteralContext::ulong_number() {
  return getRuleContext<MySQLParser::Ulong_numberContext>(0);
}

tree::TerminalNode* MySQLParser::SignedLiteralContext::MINUS_OPERATOR() {
  return getToken(MySQLParser::MINUS_OPERATOR, 0);
}


size_t MySQLParser::SignedLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleSignedLiteral;
}

void MySQLParser::SignedLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSignedLiteral(this);
}

void MySQLParser::SignedLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSignedLiteral(this);
}

MySQLParser::SignedLiteralContext* MySQLParser::signedLiteral() {
  SignedLiteralContext *_localctx = _tracker.createInstance<SignedLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1134, MySQLParser::RuleSignedLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8105);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1085, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8100);
      literal();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8101);
      match(MySQLParser::PLUS_OPERATOR);
      setState(8102);
      ulong_number();
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8103);
      match(MySQLParser::MINUS_OPERATOR);
      setState(8104);
      ulong_number();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StringListContext ------------------------------------------------------------------

MySQLParser::StringListContext::StringListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::StringListContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<MySQLParser::TextStringContext *> MySQLParser::StringListContext::textString() {
  return getRuleContexts<MySQLParser::TextStringContext>();
}

MySQLParser::TextStringContext* MySQLParser::StringListContext::textString(size_t i) {
  return getRuleContext<MySQLParser::TextStringContext>(i);
}

tree::TerminalNode* MySQLParser::StringListContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::StringListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::StringListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::StringListContext::getRuleIndex() const {
  return MySQLParser::RuleStringList;
}

void MySQLParser::StringListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStringList(this);
}

void MySQLParser::StringListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStringList(this);
}

MySQLParser::StringListContext* MySQLParser::stringList() {
  StringListContext *_localctx = _tracker.createInstance<StringListContext>(_ctx, getState());
  enterRule(_localctx, 1136, MySQLParser::RuleStringList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8107);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8108);
    textString();
    setState(8113);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8109);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8110);
      textString();
      setState(8115);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(8116);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringLiteralContext ------------------------------------------------------------------

MySQLParser::TextStringLiteralContext::TextStringLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TextStringLiteralContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

tree::TerminalNode* MySQLParser::TextStringLiteralContext::DOUBLE_QUOTED_TEXT() {
  return getToken(MySQLParser::DOUBLE_QUOTED_TEXT, 0);
}


size_t MySQLParser::TextStringLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringLiteral;
}

void MySQLParser::TextStringLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringLiteral(this);
}

void MySQLParser::TextStringLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringLiteral(this);
}

MySQLParser::TextStringLiteralContext* MySQLParser::textStringLiteral() {
  TextStringLiteralContext *_localctx = _tracker.createInstance<TextStringLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1138, MySQLParser::RuleTextStringLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8121);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1087, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8118);
      dynamic_cast<TextStringLiteralContext *>(_localctx)->value = match(MySQLParser::SINGLE_QUOTED_TEXT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8119);

      if (!(!isSqlModeActive(AnsiQuotes))) throw FailedPredicateException(this, "!isSqlModeActive(AnsiQuotes)");
      setState(8120);
      dynamic_cast<TextStringLiteralContext *>(_localctx)->value = match(MySQLParser::DOUBLE_QUOTED_TEXT);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringContext ------------------------------------------------------------------

MySQLParser::TextStringContext::TextStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextStringContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::TextStringContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::TextStringContext::BIN_NUMBER() {
  return getToken(MySQLParser::BIN_NUMBER, 0);
}


size_t MySQLParser::TextStringContext::getRuleIndex() const {
  return MySQLParser::RuleTextString;
}

void MySQLParser::TextStringContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextString(this);
}

void MySQLParser::TextStringContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextString(this);
}

MySQLParser::TextStringContext* MySQLParser::textString() {
  TextStringContext *_localctx = _tracker.createInstance<TextStringContext>(_ctx, getState());
  enterRule(_localctx, 1140, MySQLParser::RuleTextString);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8126);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1088, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8123);
      textStringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8124);
      match(MySQLParser::HEX_NUMBER);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8125);
      match(MySQLParser::BIN_NUMBER);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringHashContext ------------------------------------------------------------------

MySQLParser::TextStringHashContext::TextStringHashContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextStringHashContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}

tree::TerminalNode* MySQLParser::TextStringHashContext::HEX_NUMBER() {
  return getToken(MySQLParser::HEX_NUMBER, 0);
}


size_t MySQLParser::TextStringHashContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringHash;
}

void MySQLParser::TextStringHashContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringHash(this);
}

void MySQLParser::TextStringHashContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringHash(this);
}

MySQLParser::TextStringHashContext* MySQLParser::textStringHash() {
  TextStringHashContext *_localctx = _tracker.createInstance<TextStringHashContext>(_ctx, getState());
  enterRule(_localctx, 1142, MySQLParser::RuleTextStringHash);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8131);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1089, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8128);
      textStringLiteral();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8129);

      if (!(serverVersion >= 80017)) throw FailedPredicateException(this, "serverVersion >= 80017");
      setState(8130);
      match(MySQLParser::HEX_NUMBER);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextLiteralContext ------------------------------------------------------------------

MySQLParser::TextLiteralContext::TextLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringLiteralContext *> MySQLParser::TextLiteralContext::textStringLiteral() {
  return getRuleContexts<MySQLParser::TextStringLiteralContext>();
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextLiteralContext::textStringLiteral(size_t i) {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(i);
}

tree::TerminalNode* MySQLParser::TextLiteralContext::NCHAR_TEXT() {
  return getToken(MySQLParser::NCHAR_TEXT, 0);
}

tree::TerminalNode* MySQLParser::TextLiteralContext::UNDERSCORE_CHARSET() {
  return getToken(MySQLParser::UNDERSCORE_CHARSET, 0);
}


size_t MySQLParser::TextLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTextLiteral;
}

void MySQLParser::TextLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextLiteral(this);
}

void MySQLParser::TextLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextLiteral(this);
}

MySQLParser::TextLiteralContext* MySQLParser::textLiteral() {
  TextLiteralContext *_localctx = _tracker.createInstance<TextLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1144, MySQLParser::RuleTextLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(8138);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1091, _ctx)) {
    case 1: {
      setState(8134);
      _errHandler->sync(this);

      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1090, _ctx)) {
      case 1: {
        setState(8133);
        match(MySQLParser::UNDERSCORE_CHARSET);
        break;
      }

      }
      setState(8136);
      textStringLiteral();
      break;
    }

    case 2: {
      setState(8137);
      match(MySQLParser::NCHAR_TEXT);
      break;
    }

    }
    setState(8143);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1092, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(8140);
        textStringLiteral(); 
      }
      setState(8145);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1092, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringNoLinebreakContext ------------------------------------------------------------------

MySQLParser::TextStringNoLinebreakContext::TextStringNoLinebreakContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextStringNoLinebreakContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::TextStringNoLinebreakContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringNoLinebreak;
}

void MySQLParser::TextStringNoLinebreakContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringNoLinebreak(this);
}

void MySQLParser::TextStringNoLinebreakContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringNoLinebreak(this);
}

MySQLParser::TextStringNoLinebreakContext* MySQLParser::textStringNoLinebreak() {
  TextStringNoLinebreakContext *_localctx = _tracker.createInstance<TextStringNoLinebreakContext>(_ctx, getState());
  enterRule(_localctx, 1146, MySQLParser::RuleTextStringNoLinebreak);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8146);
    textStringLiteral();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextStringLiteralListContext ------------------------------------------------------------------

MySQLParser::TextStringLiteralListContext::TextStringLiteralListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<MySQLParser::TextStringLiteralContext *> MySQLParser::TextStringLiteralListContext::textStringLiteral() {
  return getRuleContexts<MySQLParser::TextStringLiteralContext>();
}

MySQLParser::TextStringLiteralContext* MySQLParser::TextStringLiteralListContext::textStringLiteral(size_t i) {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(i);
}

std::vector<tree::TerminalNode *> MySQLParser::TextStringLiteralListContext::COMMA_SYMBOL() {
  return getTokens(MySQLParser::COMMA_SYMBOL);
}

tree::TerminalNode* MySQLParser::TextStringLiteralListContext::COMMA_SYMBOL(size_t i) {
  return getToken(MySQLParser::COMMA_SYMBOL, i);
}


size_t MySQLParser::TextStringLiteralListContext::getRuleIndex() const {
  return MySQLParser::RuleTextStringLiteralList;
}

void MySQLParser::TextStringLiteralListContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextStringLiteralList(this);
}

void MySQLParser::TextStringLiteralListContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextStringLiteralList(this);
}

MySQLParser::TextStringLiteralListContext* MySQLParser::textStringLiteralList() {
  TextStringLiteralListContext *_localctx = _tracker.createInstance<TextStringLiteralListContext>(_ctx, getState());
  enterRule(_localctx, 1148, MySQLParser::RuleTextStringLiteralList);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8148);
    textStringLiteral();
    setState(8153);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == MySQLParser::COMMA_SYMBOL) {
      setState(8149);
      match(MySQLParser::COMMA_SYMBOL);
      setState(8150);
      textStringLiteral();
      setState(8155);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NumLiteralContext ------------------------------------------------------------------

MySQLParser::NumLiteralContext::NumLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NumLiteralContext::INT_NUMBER() {
  return getToken(MySQLParser::INT_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::LONG_NUMBER() {
  return getToken(MySQLParser::LONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::ULONGLONG_NUMBER() {
  return getToken(MySQLParser::ULONGLONG_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::DECIMAL_NUMBER() {
  return getToken(MySQLParser::DECIMAL_NUMBER, 0);
}

tree::TerminalNode* MySQLParser::NumLiteralContext::FLOAT_NUMBER() {
  return getToken(MySQLParser::FLOAT_NUMBER, 0);
}


size_t MySQLParser::NumLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNumLiteral;
}

void MySQLParser::NumLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNumLiteral(this);
}

void MySQLParser::NumLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNumLiteral(this);
}

MySQLParser::NumLiteralContext* MySQLParser::numLiteral() {
  NumLiteralContext *_localctx = _tracker.createInstance<NumLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1150, MySQLParser::RuleNumLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8156);
    _la = _input->LA(1);
    if (!((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & ((1ULL << MySQLParser::INT_NUMBER)
      | (1ULL << MySQLParser::LONG_NUMBER)
      | (1ULL << MySQLParser::ULONGLONG_NUMBER)
      | (1ULL << MySQLParser::DECIMAL_NUMBER)
      | (1ULL << MySQLParser::FLOAT_NUMBER))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- BoolLiteralContext ------------------------------------------------------------------

MySQLParser::BoolLiteralContext::BoolLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::BoolLiteralContext::TRUE_SYMBOL() {
  return getToken(MySQLParser::TRUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::BoolLiteralContext::FALSE_SYMBOL() {
  return getToken(MySQLParser::FALSE_SYMBOL, 0);
}


size_t MySQLParser::BoolLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleBoolLiteral;
}

void MySQLParser::BoolLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterBoolLiteral(this);
}

void MySQLParser::BoolLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitBoolLiteral(this);
}

MySQLParser::BoolLiteralContext* MySQLParser::boolLiteral() {
  BoolLiteralContext *_localctx = _tracker.createInstance<BoolLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1152, MySQLParser::RuleBoolLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8158);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::FALSE_SYMBOL || _la == MySQLParser::TRUE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NullLiteralContext ------------------------------------------------------------------

MySQLParser::NullLiteralContext::NullLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::NullLiteralContext::NULL_SYMBOL() {
  return getToken(MySQLParser::NULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::NullLiteralContext::NULL2_SYMBOL() {
  return getToken(MySQLParser::NULL2_SYMBOL, 0);
}


size_t MySQLParser::NullLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleNullLiteral;
}

void MySQLParser::NullLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterNullLiteral(this);
}

void MySQLParser::NullLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitNullLiteral(this);
}

MySQLParser::NullLiteralContext* MySQLParser::nullLiteral() {
  NullLiteralContext *_localctx = _tracker.createInstance<NullLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1154, MySQLParser::RuleNullLiteral);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8160);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::NULL2_SYMBOL || _la == MySQLParser::NULL_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TemporalLiteralContext ------------------------------------------------------------------

MySQLParser::TemporalLiteralContext::TemporalLiteralContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::TemporalLiteralContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}


size_t MySQLParser::TemporalLiteralContext::getRuleIndex() const {
  return MySQLParser::RuleTemporalLiteral;
}

void MySQLParser::TemporalLiteralContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTemporalLiteral(this);
}

void MySQLParser::TemporalLiteralContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTemporalLiteral(this);
}

MySQLParser::TemporalLiteralContext* MySQLParser::temporalLiteral() {
  TemporalLiteralContext *_localctx = _tracker.createInstance<TemporalLiteralContext>(_ctx, getState());
  enterRule(_localctx, 1156, MySQLParser::RuleTemporalLiteral);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8168);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::DATE_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8162);
        match(MySQLParser::DATE_SYMBOL);
        setState(8163);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      case MySQLParser::TIME_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8164);
        match(MySQLParser::TIME_SYMBOL);
        setState(8165);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

      case MySQLParser::TIMESTAMP_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8166);
        match(MySQLParser::TIMESTAMP_SYMBOL);
        setState(8167);
        match(MySQLParser::SINGLE_QUOTED_TEXT);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FloatOptionsContext ------------------------------------------------------------------

MySQLParser::FloatOptionsContext::FloatOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::FieldLengthContext* MySQLParser::FloatOptionsContext::fieldLength() {
  return getRuleContext<MySQLParser::FieldLengthContext>(0);
}

MySQLParser::PrecisionContext* MySQLParser::FloatOptionsContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}


size_t MySQLParser::FloatOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleFloatOptions;
}

void MySQLParser::FloatOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterFloatOptions(this);
}

void MySQLParser::FloatOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitFloatOptions(this);
}

MySQLParser::FloatOptionsContext* MySQLParser::floatOptions() {
  FloatOptionsContext *_localctx = _tracker.createInstance<FloatOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1158, MySQLParser::RuleFloatOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8172);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1095, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8170);
      fieldLength();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8171);
      precision();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- StandardFloatOptionsContext ------------------------------------------------------------------

MySQLParser::StandardFloatOptionsContext::StandardFloatOptionsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PrecisionContext* MySQLParser::StandardFloatOptionsContext::precision() {
  return getRuleContext<MySQLParser::PrecisionContext>(0);
}


size_t MySQLParser::StandardFloatOptionsContext::getRuleIndex() const {
  return MySQLParser::RuleStandardFloatOptions;
}

void MySQLParser::StandardFloatOptionsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterStandardFloatOptions(this);
}

void MySQLParser::StandardFloatOptionsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitStandardFloatOptions(this);
}

MySQLParser::StandardFloatOptionsContext* MySQLParser::standardFloatOptions() {
  StandardFloatOptionsContext *_localctx = _tracker.createInstance<StandardFloatOptionsContext>(_ctx, getState());
  enterRule(_localctx, 1160, MySQLParser::RuleStandardFloatOptions);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8174);
    precision();
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PrecisionContext ------------------------------------------------------------------

MySQLParser::PrecisionContext::PrecisionContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::PrecisionContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

std::vector<tree::TerminalNode *> MySQLParser::PrecisionContext::INT_NUMBER() {
  return getTokens(MySQLParser::INT_NUMBER);
}

tree::TerminalNode* MySQLParser::PrecisionContext::INT_NUMBER(size_t i) {
  return getToken(MySQLParser::INT_NUMBER, i);
}

tree::TerminalNode* MySQLParser::PrecisionContext::COMMA_SYMBOL() {
  return getToken(MySQLParser::COMMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::PrecisionContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::PrecisionContext::getRuleIndex() const {
  return MySQLParser::RulePrecision;
}

void MySQLParser::PrecisionContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterPrecision(this);
}

void MySQLParser::PrecisionContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitPrecision(this);
}

MySQLParser::PrecisionContext* MySQLParser::precision() {
  PrecisionContext *_localctx = _tracker.createInstance<PrecisionContext>(_ctx, getState());
  enterRule(_localctx, 1162, MySQLParser::RulePrecision);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8176);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8177);
    match(MySQLParser::INT_NUMBER);
    setState(8178);
    match(MySQLParser::COMMA_SYMBOL);
    setState(8179);
    match(MySQLParser::INT_NUMBER);
    setState(8180);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- TextOrIdentifierContext ------------------------------------------------------------------

MySQLParser::TextOrIdentifierContext::TextOrIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::TextOrIdentifierContext::SINGLE_QUOTED_TEXT() {
  return getToken(MySQLParser::SINGLE_QUOTED_TEXT, 0);
}

MySQLParser::IdentifierContext* MySQLParser::TextOrIdentifierContext::identifier() {
  return getRuleContext<MySQLParser::IdentifierContext>(0);
}


size_t MySQLParser::TextOrIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleTextOrIdentifier;
}

void MySQLParser::TextOrIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterTextOrIdentifier(this);
}

void MySQLParser::TextOrIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitTextOrIdentifier(this);
}

MySQLParser::TextOrIdentifierContext* MySQLParser::textOrIdentifier() {
  TextOrIdentifierContext *_localctx = _tracker.createInstance<TextOrIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1164, MySQLParser::RuleTextOrIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8184);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1096, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8182);
      match(MySQLParser::SINGLE_QUOTED_TEXT);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8183);
      identifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LValueIdentifierContext ------------------------------------------------------------------

MySQLParser::LValueIdentifierContext::LValueIdentifierContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::PureIdentifierContext* MySQLParser::LValueIdentifierContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}

MySQLParser::LValueKeywordContext* MySQLParser::LValueIdentifierContext::lValueKeyword() {
  return getRuleContext<MySQLParser::LValueKeywordContext>(0);
}


size_t MySQLParser::LValueIdentifierContext::getRuleIndex() const {
  return MySQLParser::RuleLValueIdentifier;
}

void MySQLParser::LValueIdentifierContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLValueIdentifier(this);
}

void MySQLParser::LValueIdentifierContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLValueIdentifier(this);
}

MySQLParser::LValueIdentifierContext* MySQLParser::lValueIdentifier() {
  LValueIdentifierContext *_localctx = _tracker.createInstance<LValueIdentifierContext>(_ctx, getState());
  enterRule(_localctx, 1166, MySQLParser::RuleLValueIdentifier);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8188);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1097, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8186);
      pureIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8187);
      lValueKeyword();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleIdentifierOrTextContext ------------------------------------------------------------------

MySQLParser::RoleIdentifierOrTextContext::RoleIdentifierOrTextContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleIdentifierContext* MySQLParser::RoleIdentifierOrTextContext::roleIdentifier() {
  return getRuleContext<MySQLParser::RoleIdentifierContext>(0);
}

MySQLParser::TextStringLiteralContext* MySQLParser::RoleIdentifierOrTextContext::textStringLiteral() {
  return getRuleContext<MySQLParser::TextStringLiteralContext>(0);
}


size_t MySQLParser::RoleIdentifierOrTextContext::getRuleIndex() const {
  return MySQLParser::RuleRoleIdentifierOrText;
}

void MySQLParser::RoleIdentifierOrTextContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleIdentifierOrText(this);
}

void MySQLParser::RoleIdentifierOrTextContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleIdentifierOrText(this);
}

MySQLParser::RoleIdentifierOrTextContext* MySQLParser::roleIdentifierOrText() {
  RoleIdentifierOrTextContext *_localctx = _tracker.createInstance<RoleIdentifierOrTextContext>(_ctx, getState());
  enterRule(_localctx, 1168, MySQLParser::RuleRoleIdentifierOrText);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8192);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1098, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8190);
      roleIdentifier();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8191);
      textStringLiteral();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SizeNumberContext ------------------------------------------------------------------

MySQLParser::SizeNumberContext::SizeNumberContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::Real_ulonglong_numberContext* MySQLParser::SizeNumberContext::real_ulonglong_number() {
  return getRuleContext<MySQLParser::Real_ulonglong_numberContext>(0);
}

MySQLParser::PureIdentifierContext* MySQLParser::SizeNumberContext::pureIdentifier() {
  return getRuleContext<MySQLParser::PureIdentifierContext>(0);
}


size_t MySQLParser::SizeNumberContext::getRuleIndex() const {
  return MySQLParser::RuleSizeNumber;
}

void MySQLParser::SizeNumberContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSizeNumber(this);
}

void MySQLParser::SizeNumberContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSizeNumber(this);
}

MySQLParser::SizeNumberContext* MySQLParser::sizeNumber() {
  SizeNumberContext *_localctx = _tracker.createInstance<SizeNumberContext>(_ctx, getState());
  enterRule(_localctx, 1170, MySQLParser::RuleSizeNumber);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8196);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1099, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8194);
      real_ulonglong_number();
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8195);
      pureIdentifier();
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenthesesContext ------------------------------------------------------------------

MySQLParser::ParenthesesContext::ParenthesesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::ParenthesesContext::OPEN_PAR_SYMBOL() {
  return getToken(MySQLParser::OPEN_PAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::ParenthesesContext::CLOSE_PAR_SYMBOL() {
  return getToken(MySQLParser::CLOSE_PAR_SYMBOL, 0);
}


size_t MySQLParser::ParenthesesContext::getRuleIndex() const {
  return MySQLParser::RuleParentheses;
}

void MySQLParser::ParenthesesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterParentheses(this);
}

void MySQLParser::ParenthesesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitParentheses(this);
}

MySQLParser::ParenthesesContext* MySQLParser::parentheses() {
  ParenthesesContext *_localctx = _tracker.createInstance<ParenthesesContext>(_ctx, getState());
  enterRule(_localctx, 1172, MySQLParser::RuleParentheses);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8198);
    match(MySQLParser::OPEN_PAR_SYMBOL);
    setState(8199);
    match(MySQLParser::CLOSE_PAR_SYMBOL);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EqualContext ------------------------------------------------------------------

MySQLParser::EqualContext::EqualContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::EqualContext::EQUAL_OPERATOR() {
  return getToken(MySQLParser::EQUAL_OPERATOR, 0);
}

tree::TerminalNode* MySQLParser::EqualContext::ASSIGN_OPERATOR() {
  return getToken(MySQLParser::ASSIGN_OPERATOR, 0);
}


size_t MySQLParser::EqualContext::getRuleIndex() const {
  return MySQLParser::RuleEqual;
}

void MySQLParser::EqualContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterEqual(this);
}

void MySQLParser::EqualContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitEqual(this);
}

MySQLParser::EqualContext* MySQLParser::equal() {
  EqualContext *_localctx = _tracker.createInstance<EqualContext>(_ctx, getState());
  enterRule(_localctx, 1174, MySQLParser::RuleEqual);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8201);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EQUAL_OPERATOR

    || _la == MySQLParser::ASSIGN_OPERATOR)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionTypeContext ------------------------------------------------------------------

MySQLParser::OptionTypeContext::OptionTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::OptionTypeContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::OptionTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}


size_t MySQLParser::OptionTypeContext::getRuleIndex() const {
  return MySQLParser::RuleOptionType;
}

void MySQLParser::OptionTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterOptionType(this);
}

void MySQLParser::OptionTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitOptionType(this);
}

MySQLParser::OptionTypeContext* MySQLParser::optionType() {
  OptionTypeContext *_localctx = _tracker.createInstance<OptionTypeContext>(_ctx, getState());
  enterRule(_localctx, 1176, MySQLParser::RuleOptionType);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8203);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL || _la == MySQLParser::PERSIST_SYMBOL

    || _la == MySQLParser::PERSIST_ONLY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- VarIdentTypeContext ------------------------------------------------------------------

MySQLParser::VarIdentTypeContext::VarIdentTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::VarIdentTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}


size_t MySQLParser::VarIdentTypeContext::getRuleIndex() const {
  return MySQLParser::RuleVarIdentType;
}

void MySQLParser::VarIdentTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterVarIdentType(this);
}

void MySQLParser::VarIdentTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitVarIdentType(this);
}

MySQLParser::VarIdentTypeContext* MySQLParser::varIdentType() {
  VarIdentTypeContext *_localctx = _tracker.createInstance<VarIdentTypeContext>(_ctx, getState());
  enterRule(_localctx, 1178, MySQLParser::RuleVarIdentType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8211);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::GLOBAL_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8205);
        match(MySQLParser::GLOBAL_SYMBOL);
        setState(8206);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::LOCAL_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8207);
        match(MySQLParser::LOCAL_SYMBOL);
        setState(8208);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::SESSION_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8209);
        match(MySQLParser::SESSION_SYMBOL);
        setState(8210);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SetVarIdentTypeContext ------------------------------------------------------------------

MySQLParser::SetVarIdentTypeContext::SetVarIdentTypeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::DOT_SYMBOL() {
  return getToken(MySQLParser::DOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::SetVarIdentTypeContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}


size_t MySQLParser::SetVarIdentTypeContext::getRuleIndex() const {
  return MySQLParser::RuleSetVarIdentType;
}

void MySQLParser::SetVarIdentTypeContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterSetVarIdentType(this);
}

void MySQLParser::SetVarIdentTypeContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitSetVarIdentType(this);
}

MySQLParser::SetVarIdentTypeContext* MySQLParser::setVarIdentType() {
  SetVarIdentTypeContext *_localctx = _tracker.createInstance<SetVarIdentTypeContext>(_ctx, getState());
  enterRule(_localctx, 1180, MySQLParser::RuleSetVarIdentType);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8223);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::PERSIST_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8213);
        match(MySQLParser::PERSIST_SYMBOL);
        setState(8214);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::PERSIST_ONLY_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8215);
        match(MySQLParser::PERSIST_ONLY_SYMBOL);
        setState(8216);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::GLOBAL_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8217);
        match(MySQLParser::GLOBAL_SYMBOL);
        setState(8218);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::LOCAL_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(8219);
        match(MySQLParser::LOCAL_SYMBOL);
        setState(8220);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

      case MySQLParser::SESSION_SYMBOL: {
        enterOuterAlt(_localctx, 5);
        setState(8221);
        match(MySQLParser::SESSION_SYMBOL);
        setState(8222);
        match(MySQLParser::DOT_SYMBOL);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordContext::IdentifierKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::LabelKeywordContext* MySQLParser::IdentifierKeywordContext::labelKeyword() {
  return getRuleContext<MySQLParser::LabelKeywordContext>(0);
}

MySQLParser::RoleOrIdentifierKeywordContext* MySQLParser::IdentifierKeywordContext::roleOrIdentifierKeyword() {
  return getRuleContext<MySQLParser::RoleOrIdentifierKeywordContext>(0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}

MySQLParser::IdentifierKeywordsUnambiguousContext* MySQLParser::IdentifierKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext* MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous1RolesAndLabels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext* MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous2Labels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext* MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous3Roles() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous3RolesContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext* MySQLParser::IdentifierKeywordContext::identifierKeywordsAmbiguous4SystemVariables() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext>(0);
}


size_t MySQLParser::IdentifierKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeyword;
}

void MySQLParser::IdentifierKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeyword(this);
}

void MySQLParser::IdentifierKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeyword(this);
}

MySQLParser::IdentifierKeywordContext* MySQLParser::identifierKeyword() {
  IdentifierKeywordContext *_localctx = _tracker.createInstance<IdentifierKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1182, MySQLParser::RuleIdentifierKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8242);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1104, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8225);

      if (!(serverVersion < 80017)) throw FailedPredicateException(this, "serverVersion < 80017");
      setState(8233);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1102, _ctx)) {
      case 1: {
        setState(8226);
        labelKeyword();
        break;
      }

      case 2: {
        setState(8227);
        roleOrIdentifierKeyword();
        break;
      }

      case 3: {
        setState(8228);
        match(MySQLParser::EXECUTE_SYMBOL);
        break;
      }

      case 4: {
        setState(8229);

        if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
        setState(8230);
        match(MySQLParser::SHUTDOWN_SYMBOL);
        break;
      }

      case 5: {
        setState(8231);

        if (!(serverVersion >= 80011)) throw FailedPredicateException(this, "serverVersion >= 80011");
        setState(8232);
        match(MySQLParser::RESTART_SYMBOL);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8240);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::ACCOUNT_SYMBOL:
        case MySQLParser::ACTION_SYMBOL:
        case MySQLParser::ADDDATE_SYMBOL:
        case MySQLParser::AFTER_SYMBOL:
        case MySQLParser::AGAINST_SYMBOL:
        case MySQLParser::AGGREGATE_SYMBOL:
        case MySQLParser::ALGORITHM_SYMBOL:
        case MySQLParser::ALWAYS_SYMBOL:
        case MySQLParser::ANY_SYMBOL:
        case MySQLParser::AT_SYMBOL:
        case MySQLParser::AUTOEXTEND_SIZE_SYMBOL:
        case MySQLParser::AUTO_INCREMENT_SYMBOL:
        case MySQLParser::AVG_ROW_LENGTH_SYMBOL:
        case MySQLParser::AVG_SYMBOL:
        case MySQLParser::BACKUP_SYMBOL:
        case MySQLParser::BINLOG_SYMBOL:
        case MySQLParser::BIT_SYMBOL:
        case MySQLParser::BLOCK_SYMBOL:
        case MySQLParser::BOOLEAN_SYMBOL:
        case MySQLParser::BOOL_SYMBOL:
        case MySQLParser::BTREE_SYMBOL:
        case MySQLParser::CASCADED_SYMBOL:
        case MySQLParser::CATALOG_NAME_SYMBOL:
        case MySQLParser::CHAIN_SYMBOL:
        case MySQLParser::CHANGED_SYMBOL:
        case MySQLParser::CHANNEL_SYMBOL:
        case MySQLParser::CIPHER_SYMBOL:
        case MySQLParser::CLASS_ORIGIN_SYMBOL:
        case MySQLParser::CLIENT_SYMBOL:
        case MySQLParser::CLOSE_SYMBOL:
        case MySQLParser::COALESCE_SYMBOL:
        case MySQLParser::CODE_SYMBOL:
        case MySQLParser::COLLATION_SYMBOL:
        case MySQLParser::COLUMNS_SYMBOL:
        case MySQLParser::COLUMN_NAME_SYMBOL:
        case MySQLParser::COLUMN_FORMAT_SYMBOL:
        case MySQLParser::COMMITTED_SYMBOL:
        case MySQLParser::COMPACT_SYMBOL:
        case MySQLParser::COMPLETION_SYMBOL:
        case MySQLParser::COMPRESSED_SYMBOL:
        case MySQLParser::COMPRESSION_SYMBOL:
        case MySQLParser::CONCURRENT_SYMBOL:
        case MySQLParser::CONNECTION_SYMBOL:
        case MySQLParser::CONSISTENT_SYMBOL:
        case MySQLParser::CONSTRAINT_CATALOG_SYMBOL:
        case MySQLParser::CONSTRAINT_NAME_SYMBOL:
        case MySQLParser::CONSTRAINT_SCHEMA_SYMBOL:
        case MySQLParser::CONTEXT_SYMBOL:
        case MySQLParser::CPU_SYMBOL:
        case MySQLParser::CURRENT_SYMBOL:
        case MySQLParser::CURSOR_NAME_SYMBOL:
        case MySQLParser::DATAFILE_SYMBOL:
        case MySQLParser::DATA_SYMBOL:
        case MySQLParser::DATETIME_SYMBOL:
        case MySQLParser::DATE_SYMBOL:
        case MySQLParser::DAY_SYMBOL:
        case MySQLParser::DEFAULT_AUTH_SYMBOL:
        case MySQLParser::DEFINER_SYMBOL:
        case MySQLParser::DELAY_KEY_WRITE_SYMBOL:
        case MySQLParser::DIAGNOSTICS_SYMBOL:
        case MySQLParser::DIRECTORY_SYMBOL:
        case MySQLParser::DISABLE_SYMBOL:
        case MySQLParser::DISCARD_SYMBOL:
        case MySQLParser::DISK_SYMBOL:
        case MySQLParser::DUMPFILE_SYMBOL:
        case MySQLParser::DUPLICATE_SYMBOL:
        case MySQLParser::DYNAMIC_SYMBOL:
        case MySQLParser::ENABLE_SYMBOL:
        case MySQLParser::ENCRYPTION_SYMBOL:
        case MySQLParser::ENDS_SYMBOL:
        case MySQLParser::ENGINES_SYMBOL:
        case MySQLParser::ENGINE_SYMBOL:
        case MySQLParser::ENUM_SYMBOL:
        case MySQLParser::ERROR_SYMBOL:
        case MySQLParser::ERRORS_SYMBOL:
        case MySQLParser::ESCAPE_SYMBOL:
        case MySQLParser::EVENTS_SYMBOL:
        case MySQLParser::EVERY_SYMBOL:
        case MySQLParser::EXCHANGE_SYMBOL:
        case MySQLParser::EXPANSION_SYMBOL:
        case MySQLParser::EXPIRE_SYMBOL:
        case MySQLParser::EXPORT_SYMBOL:
        case MySQLParser::EXTENDED_SYMBOL:
        case MySQLParser::EXTENT_SIZE_SYMBOL:
        case MySQLParser::FAST_SYMBOL:
        case MySQLParser::FAULTS_SYMBOL:
        case MySQLParser::FILE_BLOCK_SIZE_SYMBOL:
        case MySQLParser::FILTER_SYMBOL:
        case MySQLParser::FIRST_SYMBOL:
        case MySQLParser::FIXED_SYMBOL:
        case MySQLParser::FORMAT_SYMBOL:
        case MySQLParser::FOUND_SYMBOL:
        case MySQLParser::FULL_SYMBOL:
        case MySQLParser::GENERAL_SYMBOL:
        case MySQLParser::GROUP_REPLICATION_SYMBOL:
        case MySQLParser::GEOMETRYCOLLECTION_SYMBOL:
        case MySQLParser::GEOMETRY_SYMBOL:
        case MySQLParser::GET_FORMAT_SYMBOL:
        case MySQLParser::GRANTS_SYMBOL:
        case MySQLParser::HASH_SYMBOL:
        case MySQLParser::HOST_SYMBOL:
        case MySQLParser::HOSTS_SYMBOL:
        case MySQLParser::HOUR_SYMBOL:
        case MySQLParser::IDENTIFIED_SYMBOL:
        case MySQLParser::IGNORE_SERVER_IDS_SYMBOL:
        case MySQLParser::INDEXES_SYMBOL:
        case MySQLParser::INITIAL_SIZE_SYMBOL:
        case MySQLParser::INSERT_METHOD_SYMBOL:
        case MySQLParser::INSTANCE_SYMBOL:
        case MySQLParser::INVOKER_SYMBOL:
        case MySQLParser::IO_SYMBOL:
        case MySQLParser::IPC_SYMBOL:
        case MySQLParser::ISOLATION_SYMBOL:
        case MySQLParser::ISSUER_SYMBOL:
        case MySQLParser::JSON_SYMBOL:
        case MySQLParser::KEY_BLOCK_SIZE_SYMBOL:
        case MySQLParser::LAST_SYMBOL:
        case MySQLParser::LEAVES_SYMBOL:
        case MySQLParser::LESS_SYMBOL:
        case MySQLParser::LEVEL_SYMBOL:
        case MySQLParser::LINESTRING_SYMBOL:
        case MySQLParser::LIST_SYMBOL:
        case MySQLParser::LOCKS_SYMBOL:
        case MySQLParser::LOGFILE_SYMBOL:
        case MySQLParser::LOGS_SYMBOL:
        case MySQLParser::MASTER_AUTO_POSITION_SYMBOL:
        case MySQLParser::MASTER_CONNECT_RETRY_SYMBOL:
        case MySQLParser::MASTER_DELAY_SYMBOL:
        case MySQLParser::MASTER_HOST_SYMBOL:
        case MySQLParser::MASTER_LOG_FILE_SYMBOL:
        case MySQLParser::MASTER_LOG_POS_SYMBOL:
        case MySQLParser::MASTER_PASSWORD_SYMBOL:
        case MySQLParser::MASTER_PORT_SYMBOL:
        case MySQLParser::MASTER_RETRY_COUNT_SYMBOL:
        case MySQLParser::MASTER_SERVER_ID_SYMBOL:
        case MySQLParser::MASTER_SSL_CAPATH_SYMBOL:
        case MySQLParser::MASTER_SSL_CA_SYMBOL:
        case MySQLParser::MASTER_SSL_CERT_SYMBOL:
        case MySQLParser::MASTER_SSL_CIPHER_SYMBOL:
        case MySQLParser::MASTER_SSL_CRL_SYMBOL:
        case MySQLParser::MASTER_SSL_CRLPATH_SYMBOL:
        case MySQLParser::MASTER_SSL_KEY_SYMBOL:
        case MySQLParser::MASTER_SSL_SYMBOL:
        case MySQLParser::MASTER_SYMBOL:
        case MySQLParser::MASTER_TLS_VERSION_SYMBOL:
        case MySQLParser::MASTER_USER_SYMBOL:
        case MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL:
        case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_ROWS_SYMBOL:
        case MySQLParser::MAX_SIZE_SYMBOL:
        case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL:
        case MySQLParser::MEDIUM_SYMBOL:
        case MySQLParser::MEMORY_SYMBOL:
        case MySQLParser::MERGE_SYMBOL:
        case MySQLParser::MESSAGE_TEXT_SYMBOL:
        case MySQLParser::MICROSECOND_SYMBOL:
        case MySQLParser::MIGRATE_SYMBOL:
        case MySQLParser::MINUTE_SYMBOL:
        case MySQLParser::MIN_ROWS_SYMBOL:
        case MySQLParser::MODE_SYMBOL:
        case MySQLParser::MODIFY_SYMBOL:
        case MySQLParser::MONTH_SYMBOL:
        case MySQLParser::MULTILINESTRING_SYMBOL:
        case MySQLParser::MULTIPOINT_SYMBOL:
        case MySQLParser::MULTIPOLYGON_SYMBOL:
        case MySQLParser::MUTEX_SYMBOL:
        case MySQLParser::MYSQL_ERRNO_SYMBOL:
        case MySQLParser::NAMES_SYMBOL:
        case MySQLParser::NAME_SYMBOL:
        case MySQLParser::NATIONAL_SYMBOL:
        case MySQLParser::NCHAR_SYMBOL:
        case MySQLParser::NDBCLUSTER_SYMBOL:
        case MySQLParser::NEVER_SYMBOL:
        case MySQLParser::NEW_SYMBOL:
        case MySQLParser::NEXT_SYMBOL:
        case MySQLParser::NODEGROUP_SYMBOL:
        case MySQLParser::NO_WAIT_SYMBOL:
        case MySQLParser::NUMBER_SYMBOL:
        case MySQLParser::NVARCHAR_SYMBOL:
        case MySQLParser::OFFSET_SYMBOL:
        case MySQLParser::ONE_SYMBOL:
        case MySQLParser::ONLY_SYMBOL:
        case MySQLParser::OPEN_SYMBOL:
        case MySQLParser::OPTIONS_SYMBOL:
        case MySQLParser::OWNER_SYMBOL:
        case MySQLParser::PACK_KEYS_SYMBOL:
        case MySQLParser::PAGE_SYMBOL:
        case MySQLParser::PARSER_SYMBOL:
        case MySQLParser::PARTIAL_SYMBOL:
        case MySQLParser::PARTITIONING_SYMBOL:
        case MySQLParser::PARTITIONS_SYMBOL:
        case MySQLParser::PASSWORD_SYMBOL:
        case MySQLParser::PHASE_SYMBOL:
        case MySQLParser::PLUGINS_SYMBOL:
        case MySQLParser::PLUGIN_DIR_SYMBOL:
        case MySQLParser::PLUGIN_SYMBOL:
        case MySQLParser::POINT_SYMBOL:
        case MySQLParser::POLYGON_SYMBOL:
        case MySQLParser::PORT_SYMBOL:
        case MySQLParser::PRESERVE_SYMBOL:
        case MySQLParser::PREV_SYMBOL:
        case MySQLParser::PRIVILEGES_SYMBOL:
        case MySQLParser::PROCESSLIST_SYMBOL:
        case MySQLParser::PROFILE_SYMBOL:
        case MySQLParser::PROFILES_SYMBOL:
        case MySQLParser::QUARTER_SYMBOL:
        case MySQLParser::QUERY_SYMBOL:
        case MySQLParser::QUICK_SYMBOL:
        case MySQLParser::READ_ONLY_SYMBOL:
        case MySQLParser::REBUILD_SYMBOL:
        case MySQLParser::RECOVER_SYMBOL:
        case MySQLParser::REDO_BUFFER_SIZE_SYMBOL:
        case MySQLParser::REDUNDANT_SYMBOL:
        case MySQLParser::RELAY_SYMBOL:
        case MySQLParser::RELAYLOG_SYMBOL:
        case MySQLParser::RELAY_LOG_FILE_SYMBOL:
        case MySQLParser::RELAY_LOG_POS_SYMBOL:
        case MySQLParser::RELAY_THREAD_SYMBOL:
        case MySQLParser::REMOVE_SYMBOL:
        case MySQLParser::REORGANIZE_SYMBOL:
        case MySQLParser::REPEATABLE_SYMBOL:
        case MySQLParser::REPLICATE_DO_DB_SYMBOL:
        case MySQLParser::REPLICATE_IGNORE_DB_SYMBOL:
        case MySQLParser::REPLICATE_DO_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_REWRITE_DB_SYMBOL:
        case MySQLParser::RESTORE_SYMBOL:
        case MySQLParser::RESUME_SYMBOL:
        case MySQLParser::RETURNED_SQLSTATE_SYMBOL:
        case MySQLParser::RETURNS_SYMBOL:
        case MySQLParser::REVERSE_SYMBOL:
        case MySQLParser::ROLLUP_SYMBOL:
        case MySQLParser::ROTATE_SYMBOL:
        case MySQLParser::ROUTINE_SYMBOL:
        case MySQLParser::ROW_COUNT_SYMBOL:
        case MySQLParser::ROW_FORMAT_SYMBOL:
        case MySQLParser::RTREE_SYMBOL:
        case MySQLParser::SCHEDULE_SYMBOL:
        case MySQLParser::SCHEMA_NAME_SYMBOL:
        case MySQLParser::SECOND_SYMBOL:
        case MySQLParser::SECURITY_SYMBOL:
        case MySQLParser::SERIALIZABLE_SYMBOL:
        case MySQLParser::SERIAL_SYMBOL:
        case MySQLParser::SERVER_SYMBOL:
        case MySQLParser::SHARE_SYMBOL:
        case MySQLParser::SIMPLE_SYMBOL:
        case MySQLParser::SLOW_SYMBOL:
        case MySQLParser::SNAPSHOT_SYMBOL:
        case MySQLParser::SOCKET_SYMBOL:
        case MySQLParser::SONAME_SYMBOL:
        case MySQLParser::SOUNDS_SYMBOL:
        case MySQLParser::SOURCE_SYMBOL:
        case MySQLParser::SQL_AFTER_GTIDS_SYMBOL:
        case MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL:
        case MySQLParser::SQL_BEFORE_GTIDS_SYMBOL:
        case MySQLParser::SQL_BUFFER_RESULT_SYMBOL:
        case MySQLParser::SQL_NO_CACHE_SYMBOL:
        case MySQLParser::SQL_THREAD_SYMBOL:
        case MySQLParser::STACKED_SYMBOL:
        case MySQLParser::STARTS_SYMBOL:
        case MySQLParser::STATS_AUTO_RECALC_SYMBOL:
        case MySQLParser::STATS_PERSISTENT_SYMBOL:
        case MySQLParser::STATS_SAMPLE_PAGES_SYMBOL:
        case MySQLParser::STATUS_SYMBOL:
        case MySQLParser::STORAGE_SYMBOL:
        case MySQLParser::STRING_SYMBOL:
        case MySQLParser::SUBCLASS_ORIGIN_SYMBOL:
        case MySQLParser::SUBDATE_SYMBOL:
        case MySQLParser::SUBJECT_SYMBOL:
        case MySQLParser::SUBPARTITIONS_SYMBOL:
        case MySQLParser::SUBPARTITION_SYMBOL:
        case MySQLParser::SUSPEND_SYMBOL:
        case MySQLParser::SWAPS_SYMBOL:
        case MySQLParser::SWITCHES_SYMBOL:
        case MySQLParser::TABLES_SYMBOL:
        case MySQLParser::TABLESPACE_SYMBOL:
        case MySQLParser::TABLE_CHECKSUM_SYMBOL:
        case MySQLParser::TABLE_NAME_SYMBOL:
        case MySQLParser::TEMPORARY_SYMBOL:
        case MySQLParser::TEMPTABLE_SYMBOL:
        case MySQLParser::TEXT_SYMBOL:
        case MySQLParser::THAN_SYMBOL:
        case MySQLParser::TIMESTAMP_SYMBOL:
        case MySQLParser::TIMESTAMP_ADD_SYMBOL:
        case MySQLParser::TIMESTAMP_DIFF_SYMBOL:
        case MySQLParser::TIME_SYMBOL:
        case MySQLParser::TRANSACTION_SYMBOL:
        case MySQLParser::TRIGGERS_SYMBOL:
        case MySQLParser::TYPES_SYMBOL:
        case MySQLParser::TYPE_SYMBOL:
        case MySQLParser::UNCOMMITTED_SYMBOL:
        case MySQLParser::UNDEFINED_SYMBOL:
        case MySQLParser::UNDOFILE_SYMBOL:
        case MySQLParser::UNDO_BUFFER_SIZE_SYMBOL:
        case MySQLParser::UNKNOWN_SYMBOL:
        case MySQLParser::UNTIL_SYMBOL:
        case MySQLParser::UPGRADE_SYMBOL:
        case MySQLParser::USER_RESOURCES_SYMBOL:
        case MySQLParser::USER_SYMBOL:
        case MySQLParser::USE_FRM_SYMBOL:
        case MySQLParser::VALIDATION_SYMBOL:
        case MySQLParser::VALUE_SYMBOL:
        case MySQLParser::VARIABLES_SYMBOL:
        case MySQLParser::VIEW_SYMBOL:
        case MySQLParser::WAIT_SYMBOL:
        case MySQLParser::WARNINGS_SYMBOL:
        case MySQLParser::WEEK_SYMBOL:
        case MySQLParser::WEIGHT_STRING_SYMBOL:
        case MySQLParser::WITHOUT_SYMBOL:
        case MySQLParser::WORK_SYMBOL:
        case MySQLParser::WRAPPER_SYMBOL:
        case MySQLParser::X509_SYMBOL:
        case MySQLParser::XID_SYMBOL:
        case MySQLParser::XML_SYMBOL:
        case MySQLParser::YEAR_SYMBOL:
        case MySQLParser::ROLE_SYMBOL:
        case MySQLParser::ADMIN_SYMBOL:
        case MySQLParser::INVISIBLE_SYMBOL:
        case MySQLParser::VISIBLE_SYMBOL:
        case MySQLParser::COMPONENT_SYMBOL:
        case MySQLParser::SKIP_SYMBOL:
        case MySQLParser::LOCKED_SYMBOL:
        case MySQLParser::NOWAIT_SYMBOL:
        case MySQLParser::HISTOGRAM_SYMBOL:
        case MySQLParser::BUCKETS_SYMBOL:
        case MySQLParser::EXCLUDE_SYMBOL:
        case MySQLParser::FOLLOWING_SYMBOL:
        case MySQLParser::NULLS_SYMBOL:
        case MySQLParser::OTHERS_SYMBOL:
        case MySQLParser::PRECEDING_SYMBOL:
        case MySQLParser::RESPECT_SYMBOL:
        case MySQLParser::TIES_SYMBOL:
        case MySQLParser::UNBOUNDED_SYMBOL:
        case MySQLParser::NESTED_SYMBOL:
        case MySQLParser::ORDINALITY_SYMBOL:
        case MySQLParser::PATH_SYMBOL:
        case MySQLParser::HISTORY_SYMBOL:
        case MySQLParser::REUSE_SYMBOL:
        case MySQLParser::SRID_SYMBOL:
        case MySQLParser::THREAD_PRIORITY_SYMBOL:
        case MySQLParser::VCPU_SYMBOL:
        case MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL:
        case MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL:
        case MySQLParser::DEFINITION_SYMBOL:
        case MySQLParser::DESCRIPTION_SYMBOL:
        case MySQLParser::ORGANIZATION_SYMBOL:
        case MySQLParser::REFERENCE_SYMBOL:
        case MySQLParser::OPTIONAL_SYMBOL:
        case MySQLParser::SECONDARY_SYMBOL:
        case MySQLParser::SECONDARY_ENGINE_SYMBOL:
        case MySQLParser::SECONDARY_LOAD_SYMBOL:
        case MySQLParser::SECONDARY_UNLOAD_SYMBOL:
        case MySQLParser::ACTIVE_SYMBOL:
        case MySQLParser::INACTIVE_SYMBOL:
        case MySQLParser::RETAIN_SYMBOL:
        case MySQLParser::OLD_SYMBOL:
        case MySQLParser::NETWORK_NAMESPACE_SYMBOL:
        case MySQLParser::ENFORCED_SYMBOL:
        case MySQLParser::OJ_SYMBOL: {
          setState(8235);
          identifierKeywordsUnambiguous();
          break;
        }

        case MySQLParser::EXECUTE_SYMBOL:
        case MySQLParser::SHUTDOWN_SYMBOL:
        case MySQLParser::RESTART_SYMBOL: {
          setState(8236);
          identifierKeywordsAmbiguous1RolesAndLabels();
          break;
        }

        case MySQLParser::ASCII_SYMBOL:
        case MySQLParser::BEGIN_SYMBOL:
        case MySQLParser::BYTE_SYMBOL:
        case MySQLParser::CACHE_SYMBOL:
        case MySQLParser::CHARSET_SYMBOL:
        case MySQLParser::CHECKSUM_SYMBOL:
        case MySQLParser::COMMENT_SYMBOL:
        case MySQLParser::COMMIT_SYMBOL:
        case MySQLParser::CONTAINS_SYMBOL:
        case MySQLParser::DEALLOCATE_SYMBOL:
        case MySQLParser::DO_SYMBOL:
        case MySQLParser::END_SYMBOL:
        case MySQLParser::FLUSH_SYMBOL:
        case MySQLParser::FOLLOWS_SYMBOL:
        case MySQLParser::HANDLER_SYMBOL:
        case MySQLParser::HELP_SYMBOL:
        case MySQLParser::IMPORT_SYMBOL:
        case MySQLParser::INSTALL_SYMBOL:
        case MySQLParser::LANGUAGE_SYMBOL:
        case MySQLParser::NO_SYMBOL:
        case MySQLParser::PRECEDES_SYMBOL:
        case MySQLParser::PREPARE_SYMBOL:
        case MySQLParser::REPAIR_SYMBOL:
        case MySQLParser::RESET_SYMBOL:
        case MySQLParser::ROLLBACK_SYMBOL:
        case MySQLParser::SAVEPOINT_SYMBOL:
        case MySQLParser::SIGNED_SYMBOL:
        case MySQLParser::SLAVE_SYMBOL:
        case MySQLParser::START_SYMBOL:
        case MySQLParser::STOP_SYMBOL:
        case MySQLParser::TRUNCATE_SYMBOL:
        case MySQLParser::UNICODE_SYMBOL:
        case MySQLParser::UNINSTALL_SYMBOL:
        case MySQLParser::XA_SYMBOL:
        case MySQLParser::CLONE_SYMBOL: {
          setState(8237);
          identifierKeywordsAmbiguous2Labels();
          break;
        }

        case MySQLParser::EVENT_SYMBOL:
        case MySQLParser::FILE_SYMBOL:
        case MySQLParser::NONE_SYMBOL:
        case MySQLParser::PROCESS_SYMBOL:
        case MySQLParser::PROXY_SYMBOL:
        case MySQLParser::RELOAD_SYMBOL:
        case MySQLParser::REPLICATION_SYMBOL:
        case MySQLParser::SUPER_SYMBOL:
        case MySQLParser::RESOURCE_SYMBOL: {
          setState(8238);
          identifierKeywordsAmbiguous3Roles();
          break;
        }

        case MySQLParser::GLOBAL_SYMBOL:
        case MySQLParser::LOCAL_SYMBOL:
        case MySQLParser::SESSION_SYMBOL:
        case MySQLParser::PERSIST_SYMBOL:
        case MySQLParser::PERSIST_ONLY_SYMBOL: {
          setState(8239);
          identifierKeywordsAmbiguous4SystemVariables();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous1RolesAndLabelsContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::IdentifierKeywordsAmbiguous1RolesAndLabelsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::EXECUTE_SYMBOL() {
  return getToken(MySQLParser::EXECUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::RESTART_SYMBOL() {
  return getToken(MySQLParser::RESTART_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}


size_t MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous1RolesAndLabels;
}

void MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous1RolesAndLabels(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous1RolesAndLabels(this);
}

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext* MySQLParser::identifierKeywordsAmbiguous1RolesAndLabels() {
  IdentifierKeywordsAmbiguous1RolesAndLabelsContext *_localctx = _tracker.createInstance<IdentifierKeywordsAmbiguous1RolesAndLabelsContext>(_ctx, getState());
  enterRule(_localctx, 1184, MySQLParser::RuleIdentifierKeywordsAmbiguous1RolesAndLabels);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8244);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EXECUTE_SYMBOL || _la == MySQLParser::SHUTDOWN_SYMBOL || _la == MySQLParser::RESTART_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous2LabelsContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::IdentifierKeywordsAmbiguous2LabelsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}


size_t MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous2Labels;
}

void MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous2Labels(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous2Labels(this);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext* MySQLParser::identifierKeywordsAmbiguous2Labels() {
  IdentifierKeywordsAmbiguous2LabelsContext *_localctx = _tracker.createInstance<IdentifierKeywordsAmbiguous2LabelsContext>(_ctx, getState());
  enterRule(_localctx, 1186, MySQLParser::RuleIdentifierKeywordsAmbiguous2Labels);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8246);
    _la = _input->LA(1);
    if (!(((((_la - 67) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 67)) & ((1ULL << (MySQLParser::ASCII_SYMBOL - 67))
      | (1ULL << (MySQLParser::BEGIN_SYMBOL - 67))
      | (1ULL << (MySQLParser::BYTE_SYMBOL - 67))
      | (1ULL << (MySQLParser::CACHE_SYMBOL - 67))
      | (1ULL << (MySQLParser::CHARSET_SYMBOL - 67))
      | (1ULL << (MySQLParser::CHECKSUM_SYMBOL - 67))
      | (1ULL << (MySQLParser::COMMENT_SYMBOL - 67))
      | (1ULL << (MySQLParser::COMMIT_SYMBOL - 67)))) != 0) || ((((_la - 137) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 137)) & ((1ULL << (MySQLParser::CONTAINS_SYMBOL - 137))
      | (1ULL << (MySQLParser::DEALLOCATE_SYMBOL - 137))
      | (1ULL << (MySQLParser::DO_SYMBOL - 137)))) != 0) || ((((_la - 202) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 202)) & ((1ULL << (MySQLParser::END_SYMBOL - 202))
      | (1ULL << (MySQLParser::FLUSH_SYMBOL - 202))
      | (1ULL << (MySQLParser::FOLLOWS_SYMBOL - 202))
      | (1ULL << (MySQLParser::HANDLER_SYMBOL - 202))
      | (1ULL << (MySQLParser::HELP_SYMBOL - 202)))) != 0) || ((((_la - 273) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 273)) & ((1ULL << (MySQLParser::IMPORT_SYMBOL - 273))
      | (1ULL << (MySQLParser::INSTALL_SYMBOL - 273))
      | (1ULL << (MySQLParser::LANGUAGE_SYMBOL - 273)))) != 0) || ((((_la - 406) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 406)) & ((1ULL << (MySQLParser::NO_SYMBOL - 406))
      | (1ULL << (MySQLParser::PRECEDES_SYMBOL - 406))
      | (1ULL << (MySQLParser::PREPARE_SYMBOL - 406)))) != 0) || ((((_la - 489) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 489)) & ((1ULL << (MySQLParser::REPAIR_SYMBOL - 489))
      | (1ULL << (MySQLParser::RESET_SYMBOL - 489))
      | (1ULL << (MySQLParser::ROLLBACK_SYMBOL - 489))
      | (1ULL << (MySQLParser::SAVEPOINT_SYMBOL - 489))
      | (1ULL << (MySQLParser::SIGNED_SYMBOL - 489))
      | (1ULL << (MySQLParser::SLAVE_SYMBOL - 489)))) != 0) || ((((_la - 573) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 573)) & ((1ULL << (MySQLParser::START_SYMBOL - 573))
      | (1ULL << (MySQLParser::STOP_SYMBOL - 573))
      | (1ULL << (MySQLParser::TRUNCATE_SYMBOL - 573))
      | (1ULL << (MySQLParser::UNICODE_SYMBOL - 573)))) != 0) || _la == MySQLParser::UNINSTALL_SYMBOL

    || _la == MySQLParser::XA_SYMBOL || _la == MySQLParser::CLONE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LabelKeywordContext ------------------------------------------------------------------

MySQLParser::LabelKeywordContext::LabelKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleOrLabelKeywordContext* MySQLParser::LabelKeywordContext::roleOrLabelKeyword() {
  return getRuleContext<MySQLParser::RoleOrLabelKeywordContext>(0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::LabelKeywordContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

MySQLParser::IdentifierKeywordsUnambiguousContext* MySQLParser::LabelKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext* MySQLParser::LabelKeywordContext::identifierKeywordsAmbiguous3Roles() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous3RolesContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext* MySQLParser::LabelKeywordContext::identifierKeywordsAmbiguous4SystemVariables() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext>(0);
}


size_t MySQLParser::LabelKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleLabelKeyword;
}

void MySQLParser::LabelKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLabelKeyword(this);
}

void MySQLParser::LabelKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLabelKeyword(this);
}

MySQLParser::LabelKeywordContext* MySQLParser::labelKeyword() {
  LabelKeywordContext *_localctx = _tracker.createInstance<LabelKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1188, MySQLParser::RuleLabelKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8266);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1107, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8248);

      if (!(serverVersion < 80017)) throw FailedPredicateException(this, "serverVersion < 80017");
      setState(8259);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1105, _ctx)) {
      case 1: {
        setState(8249);
        roleOrLabelKeyword();
        break;
      }

      case 2: {
        setState(8250);
        match(MySQLParser::EVENT_SYMBOL);
        break;
      }

      case 3: {
        setState(8251);
        match(MySQLParser::FILE_SYMBOL);
        break;
      }

      case 4: {
        setState(8252);
        match(MySQLParser::NONE_SYMBOL);
        break;
      }

      case 5: {
        setState(8253);
        match(MySQLParser::PROCESS_SYMBOL);
        break;
      }

      case 6: {
        setState(8254);
        match(MySQLParser::PROXY_SYMBOL);
        break;
      }

      case 7: {
        setState(8255);
        match(MySQLParser::RELOAD_SYMBOL);
        break;
      }

      case 8: {
        setState(8256);
        match(MySQLParser::REPLICATION_SYMBOL);
        break;
      }

      case 9: {
        setState(8257);
        match(MySQLParser::RESOURCE_SYMBOL);
        break;
      }

      case 10: {
        setState(8258);
        match(MySQLParser::SUPER_SYMBOL);
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8264);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::ACCOUNT_SYMBOL:
        case MySQLParser::ACTION_SYMBOL:
        case MySQLParser::ADDDATE_SYMBOL:
        case MySQLParser::AFTER_SYMBOL:
        case MySQLParser::AGAINST_SYMBOL:
        case MySQLParser::AGGREGATE_SYMBOL:
        case MySQLParser::ALGORITHM_SYMBOL:
        case MySQLParser::ALWAYS_SYMBOL:
        case MySQLParser::ANY_SYMBOL:
        case MySQLParser::AT_SYMBOL:
        case MySQLParser::AUTOEXTEND_SIZE_SYMBOL:
        case MySQLParser::AUTO_INCREMENT_SYMBOL:
        case MySQLParser::AVG_ROW_LENGTH_SYMBOL:
        case MySQLParser::AVG_SYMBOL:
        case MySQLParser::BACKUP_SYMBOL:
        case MySQLParser::BINLOG_SYMBOL:
        case MySQLParser::BIT_SYMBOL:
        case MySQLParser::BLOCK_SYMBOL:
        case MySQLParser::BOOLEAN_SYMBOL:
        case MySQLParser::BOOL_SYMBOL:
        case MySQLParser::BTREE_SYMBOL:
        case MySQLParser::CASCADED_SYMBOL:
        case MySQLParser::CATALOG_NAME_SYMBOL:
        case MySQLParser::CHAIN_SYMBOL:
        case MySQLParser::CHANGED_SYMBOL:
        case MySQLParser::CHANNEL_SYMBOL:
        case MySQLParser::CIPHER_SYMBOL:
        case MySQLParser::CLASS_ORIGIN_SYMBOL:
        case MySQLParser::CLIENT_SYMBOL:
        case MySQLParser::CLOSE_SYMBOL:
        case MySQLParser::COALESCE_SYMBOL:
        case MySQLParser::CODE_SYMBOL:
        case MySQLParser::COLLATION_SYMBOL:
        case MySQLParser::COLUMNS_SYMBOL:
        case MySQLParser::COLUMN_NAME_SYMBOL:
        case MySQLParser::COLUMN_FORMAT_SYMBOL:
        case MySQLParser::COMMITTED_SYMBOL:
        case MySQLParser::COMPACT_SYMBOL:
        case MySQLParser::COMPLETION_SYMBOL:
        case MySQLParser::COMPRESSED_SYMBOL:
        case MySQLParser::COMPRESSION_SYMBOL:
        case MySQLParser::CONCURRENT_SYMBOL:
        case MySQLParser::CONNECTION_SYMBOL:
        case MySQLParser::CONSISTENT_SYMBOL:
        case MySQLParser::CONSTRAINT_CATALOG_SYMBOL:
        case MySQLParser::CONSTRAINT_NAME_SYMBOL:
        case MySQLParser::CONSTRAINT_SCHEMA_SYMBOL:
        case MySQLParser::CONTEXT_SYMBOL:
        case MySQLParser::CPU_SYMBOL:
        case MySQLParser::CURRENT_SYMBOL:
        case MySQLParser::CURSOR_NAME_SYMBOL:
        case MySQLParser::DATAFILE_SYMBOL:
        case MySQLParser::DATA_SYMBOL:
        case MySQLParser::DATETIME_SYMBOL:
        case MySQLParser::DATE_SYMBOL:
        case MySQLParser::DAY_SYMBOL:
        case MySQLParser::DEFAULT_AUTH_SYMBOL:
        case MySQLParser::DEFINER_SYMBOL:
        case MySQLParser::DELAY_KEY_WRITE_SYMBOL:
        case MySQLParser::DIAGNOSTICS_SYMBOL:
        case MySQLParser::DIRECTORY_SYMBOL:
        case MySQLParser::DISABLE_SYMBOL:
        case MySQLParser::DISCARD_SYMBOL:
        case MySQLParser::DISK_SYMBOL:
        case MySQLParser::DUMPFILE_SYMBOL:
        case MySQLParser::DUPLICATE_SYMBOL:
        case MySQLParser::DYNAMIC_SYMBOL:
        case MySQLParser::ENABLE_SYMBOL:
        case MySQLParser::ENCRYPTION_SYMBOL:
        case MySQLParser::ENDS_SYMBOL:
        case MySQLParser::ENGINES_SYMBOL:
        case MySQLParser::ENGINE_SYMBOL:
        case MySQLParser::ENUM_SYMBOL:
        case MySQLParser::ERROR_SYMBOL:
        case MySQLParser::ERRORS_SYMBOL:
        case MySQLParser::ESCAPE_SYMBOL:
        case MySQLParser::EVENTS_SYMBOL:
        case MySQLParser::EVERY_SYMBOL:
        case MySQLParser::EXCHANGE_SYMBOL:
        case MySQLParser::EXPANSION_SYMBOL:
        case MySQLParser::EXPIRE_SYMBOL:
        case MySQLParser::EXPORT_SYMBOL:
        case MySQLParser::EXTENDED_SYMBOL:
        case MySQLParser::EXTENT_SIZE_SYMBOL:
        case MySQLParser::FAST_SYMBOL:
        case MySQLParser::FAULTS_SYMBOL:
        case MySQLParser::FILE_BLOCK_SIZE_SYMBOL:
        case MySQLParser::FILTER_SYMBOL:
        case MySQLParser::FIRST_SYMBOL:
        case MySQLParser::FIXED_SYMBOL:
        case MySQLParser::FORMAT_SYMBOL:
        case MySQLParser::FOUND_SYMBOL:
        case MySQLParser::FULL_SYMBOL:
        case MySQLParser::GENERAL_SYMBOL:
        case MySQLParser::GROUP_REPLICATION_SYMBOL:
        case MySQLParser::GEOMETRYCOLLECTION_SYMBOL:
        case MySQLParser::GEOMETRY_SYMBOL:
        case MySQLParser::GET_FORMAT_SYMBOL:
        case MySQLParser::GRANTS_SYMBOL:
        case MySQLParser::HASH_SYMBOL:
        case MySQLParser::HOST_SYMBOL:
        case MySQLParser::HOSTS_SYMBOL:
        case MySQLParser::HOUR_SYMBOL:
        case MySQLParser::IDENTIFIED_SYMBOL:
        case MySQLParser::IGNORE_SERVER_IDS_SYMBOL:
        case MySQLParser::INDEXES_SYMBOL:
        case MySQLParser::INITIAL_SIZE_SYMBOL:
        case MySQLParser::INSERT_METHOD_SYMBOL:
        case MySQLParser::INSTANCE_SYMBOL:
        case MySQLParser::INVOKER_SYMBOL:
        case MySQLParser::IO_SYMBOL:
        case MySQLParser::IPC_SYMBOL:
        case MySQLParser::ISOLATION_SYMBOL:
        case MySQLParser::ISSUER_SYMBOL:
        case MySQLParser::JSON_SYMBOL:
        case MySQLParser::KEY_BLOCK_SIZE_SYMBOL:
        case MySQLParser::LAST_SYMBOL:
        case MySQLParser::LEAVES_SYMBOL:
        case MySQLParser::LESS_SYMBOL:
        case MySQLParser::LEVEL_SYMBOL:
        case MySQLParser::LINESTRING_SYMBOL:
        case MySQLParser::LIST_SYMBOL:
        case MySQLParser::LOCKS_SYMBOL:
        case MySQLParser::LOGFILE_SYMBOL:
        case MySQLParser::LOGS_SYMBOL:
        case MySQLParser::MASTER_AUTO_POSITION_SYMBOL:
        case MySQLParser::MASTER_CONNECT_RETRY_SYMBOL:
        case MySQLParser::MASTER_DELAY_SYMBOL:
        case MySQLParser::MASTER_HOST_SYMBOL:
        case MySQLParser::MASTER_LOG_FILE_SYMBOL:
        case MySQLParser::MASTER_LOG_POS_SYMBOL:
        case MySQLParser::MASTER_PASSWORD_SYMBOL:
        case MySQLParser::MASTER_PORT_SYMBOL:
        case MySQLParser::MASTER_RETRY_COUNT_SYMBOL:
        case MySQLParser::MASTER_SERVER_ID_SYMBOL:
        case MySQLParser::MASTER_SSL_CAPATH_SYMBOL:
        case MySQLParser::MASTER_SSL_CA_SYMBOL:
        case MySQLParser::MASTER_SSL_CERT_SYMBOL:
        case MySQLParser::MASTER_SSL_CIPHER_SYMBOL:
        case MySQLParser::MASTER_SSL_CRL_SYMBOL:
        case MySQLParser::MASTER_SSL_CRLPATH_SYMBOL:
        case MySQLParser::MASTER_SSL_KEY_SYMBOL:
        case MySQLParser::MASTER_SSL_SYMBOL:
        case MySQLParser::MASTER_SYMBOL:
        case MySQLParser::MASTER_TLS_VERSION_SYMBOL:
        case MySQLParser::MASTER_USER_SYMBOL:
        case MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL:
        case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_ROWS_SYMBOL:
        case MySQLParser::MAX_SIZE_SYMBOL:
        case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL:
        case MySQLParser::MEDIUM_SYMBOL:
        case MySQLParser::MEMORY_SYMBOL:
        case MySQLParser::MERGE_SYMBOL:
        case MySQLParser::MESSAGE_TEXT_SYMBOL:
        case MySQLParser::MICROSECOND_SYMBOL:
        case MySQLParser::MIGRATE_SYMBOL:
        case MySQLParser::MINUTE_SYMBOL:
        case MySQLParser::MIN_ROWS_SYMBOL:
        case MySQLParser::MODE_SYMBOL:
        case MySQLParser::MODIFY_SYMBOL:
        case MySQLParser::MONTH_SYMBOL:
        case MySQLParser::MULTILINESTRING_SYMBOL:
        case MySQLParser::MULTIPOINT_SYMBOL:
        case MySQLParser::MULTIPOLYGON_SYMBOL:
        case MySQLParser::MUTEX_SYMBOL:
        case MySQLParser::MYSQL_ERRNO_SYMBOL:
        case MySQLParser::NAMES_SYMBOL:
        case MySQLParser::NAME_SYMBOL:
        case MySQLParser::NATIONAL_SYMBOL:
        case MySQLParser::NCHAR_SYMBOL:
        case MySQLParser::NDBCLUSTER_SYMBOL:
        case MySQLParser::NEVER_SYMBOL:
        case MySQLParser::NEW_SYMBOL:
        case MySQLParser::NEXT_SYMBOL:
        case MySQLParser::NODEGROUP_SYMBOL:
        case MySQLParser::NO_WAIT_SYMBOL:
        case MySQLParser::NUMBER_SYMBOL:
        case MySQLParser::NVARCHAR_SYMBOL:
        case MySQLParser::OFFSET_SYMBOL:
        case MySQLParser::ONE_SYMBOL:
        case MySQLParser::ONLY_SYMBOL:
        case MySQLParser::OPEN_SYMBOL:
        case MySQLParser::OPTIONS_SYMBOL:
        case MySQLParser::OWNER_SYMBOL:
        case MySQLParser::PACK_KEYS_SYMBOL:
        case MySQLParser::PAGE_SYMBOL:
        case MySQLParser::PARSER_SYMBOL:
        case MySQLParser::PARTIAL_SYMBOL:
        case MySQLParser::PARTITIONING_SYMBOL:
        case MySQLParser::PARTITIONS_SYMBOL:
        case MySQLParser::PASSWORD_SYMBOL:
        case MySQLParser::PHASE_SYMBOL:
        case MySQLParser::PLUGINS_SYMBOL:
        case MySQLParser::PLUGIN_DIR_SYMBOL:
        case MySQLParser::PLUGIN_SYMBOL:
        case MySQLParser::POINT_SYMBOL:
        case MySQLParser::POLYGON_SYMBOL:
        case MySQLParser::PORT_SYMBOL:
        case MySQLParser::PRESERVE_SYMBOL:
        case MySQLParser::PREV_SYMBOL:
        case MySQLParser::PRIVILEGES_SYMBOL:
        case MySQLParser::PROCESSLIST_SYMBOL:
        case MySQLParser::PROFILE_SYMBOL:
        case MySQLParser::PROFILES_SYMBOL:
        case MySQLParser::QUARTER_SYMBOL:
        case MySQLParser::QUERY_SYMBOL:
        case MySQLParser::QUICK_SYMBOL:
        case MySQLParser::READ_ONLY_SYMBOL:
        case MySQLParser::REBUILD_SYMBOL:
        case MySQLParser::RECOVER_SYMBOL:
        case MySQLParser::REDO_BUFFER_SIZE_SYMBOL:
        case MySQLParser::REDUNDANT_SYMBOL:
        case MySQLParser::RELAY_SYMBOL:
        case MySQLParser::RELAYLOG_SYMBOL:
        case MySQLParser::RELAY_LOG_FILE_SYMBOL:
        case MySQLParser::RELAY_LOG_POS_SYMBOL:
        case MySQLParser::RELAY_THREAD_SYMBOL:
        case MySQLParser::REMOVE_SYMBOL:
        case MySQLParser::REORGANIZE_SYMBOL:
        case MySQLParser::REPEATABLE_SYMBOL:
        case MySQLParser::REPLICATE_DO_DB_SYMBOL:
        case MySQLParser::REPLICATE_IGNORE_DB_SYMBOL:
        case MySQLParser::REPLICATE_DO_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_REWRITE_DB_SYMBOL:
        case MySQLParser::RESTORE_SYMBOL:
        case MySQLParser::RESUME_SYMBOL:
        case MySQLParser::RETURNED_SQLSTATE_SYMBOL:
        case MySQLParser::RETURNS_SYMBOL:
        case MySQLParser::REVERSE_SYMBOL:
        case MySQLParser::ROLLUP_SYMBOL:
        case MySQLParser::ROTATE_SYMBOL:
        case MySQLParser::ROUTINE_SYMBOL:
        case MySQLParser::ROW_COUNT_SYMBOL:
        case MySQLParser::ROW_FORMAT_SYMBOL:
        case MySQLParser::RTREE_SYMBOL:
        case MySQLParser::SCHEDULE_SYMBOL:
        case MySQLParser::SCHEMA_NAME_SYMBOL:
        case MySQLParser::SECOND_SYMBOL:
        case MySQLParser::SECURITY_SYMBOL:
        case MySQLParser::SERIALIZABLE_SYMBOL:
        case MySQLParser::SERIAL_SYMBOL:
        case MySQLParser::SERVER_SYMBOL:
        case MySQLParser::SHARE_SYMBOL:
        case MySQLParser::SIMPLE_SYMBOL:
        case MySQLParser::SLOW_SYMBOL:
        case MySQLParser::SNAPSHOT_SYMBOL:
        case MySQLParser::SOCKET_SYMBOL:
        case MySQLParser::SONAME_SYMBOL:
        case MySQLParser::SOUNDS_SYMBOL:
        case MySQLParser::SOURCE_SYMBOL:
        case MySQLParser::SQL_AFTER_GTIDS_SYMBOL:
        case MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL:
        case MySQLParser::SQL_BEFORE_GTIDS_SYMBOL:
        case MySQLParser::SQL_BUFFER_RESULT_SYMBOL:
        case MySQLParser::SQL_NO_CACHE_SYMBOL:
        case MySQLParser::SQL_THREAD_SYMBOL:
        case MySQLParser::STACKED_SYMBOL:
        case MySQLParser::STARTS_SYMBOL:
        case MySQLParser::STATS_AUTO_RECALC_SYMBOL:
        case MySQLParser::STATS_PERSISTENT_SYMBOL:
        case MySQLParser::STATS_SAMPLE_PAGES_SYMBOL:
        case MySQLParser::STATUS_SYMBOL:
        case MySQLParser::STORAGE_SYMBOL:
        case MySQLParser::STRING_SYMBOL:
        case MySQLParser::SUBCLASS_ORIGIN_SYMBOL:
        case MySQLParser::SUBDATE_SYMBOL:
        case MySQLParser::SUBJECT_SYMBOL:
        case MySQLParser::SUBPARTITIONS_SYMBOL:
        case MySQLParser::SUBPARTITION_SYMBOL:
        case MySQLParser::SUSPEND_SYMBOL:
        case MySQLParser::SWAPS_SYMBOL:
        case MySQLParser::SWITCHES_SYMBOL:
        case MySQLParser::TABLES_SYMBOL:
        case MySQLParser::TABLESPACE_SYMBOL:
        case MySQLParser::TABLE_CHECKSUM_SYMBOL:
        case MySQLParser::TABLE_NAME_SYMBOL:
        case MySQLParser::TEMPORARY_SYMBOL:
        case MySQLParser::TEMPTABLE_SYMBOL:
        case MySQLParser::TEXT_SYMBOL:
        case MySQLParser::THAN_SYMBOL:
        case MySQLParser::TIMESTAMP_SYMBOL:
        case MySQLParser::TIMESTAMP_ADD_SYMBOL:
        case MySQLParser::TIMESTAMP_DIFF_SYMBOL:
        case MySQLParser::TIME_SYMBOL:
        case MySQLParser::TRANSACTION_SYMBOL:
        case MySQLParser::TRIGGERS_SYMBOL:
        case MySQLParser::TYPES_SYMBOL:
        case MySQLParser::TYPE_SYMBOL:
        case MySQLParser::UNCOMMITTED_SYMBOL:
        case MySQLParser::UNDEFINED_SYMBOL:
        case MySQLParser::UNDOFILE_SYMBOL:
        case MySQLParser::UNDO_BUFFER_SIZE_SYMBOL:
        case MySQLParser::UNKNOWN_SYMBOL:
        case MySQLParser::UNTIL_SYMBOL:
        case MySQLParser::UPGRADE_SYMBOL:
        case MySQLParser::USER_RESOURCES_SYMBOL:
        case MySQLParser::USER_SYMBOL:
        case MySQLParser::USE_FRM_SYMBOL:
        case MySQLParser::VALIDATION_SYMBOL:
        case MySQLParser::VALUE_SYMBOL:
        case MySQLParser::VARIABLES_SYMBOL:
        case MySQLParser::VIEW_SYMBOL:
        case MySQLParser::WAIT_SYMBOL:
        case MySQLParser::WARNINGS_SYMBOL:
        case MySQLParser::WEEK_SYMBOL:
        case MySQLParser::WEIGHT_STRING_SYMBOL:
        case MySQLParser::WITHOUT_SYMBOL:
        case MySQLParser::WORK_SYMBOL:
        case MySQLParser::WRAPPER_SYMBOL:
        case MySQLParser::X509_SYMBOL:
        case MySQLParser::XID_SYMBOL:
        case MySQLParser::XML_SYMBOL:
        case MySQLParser::YEAR_SYMBOL:
        case MySQLParser::ROLE_SYMBOL:
        case MySQLParser::ADMIN_SYMBOL:
        case MySQLParser::INVISIBLE_SYMBOL:
        case MySQLParser::VISIBLE_SYMBOL:
        case MySQLParser::COMPONENT_SYMBOL:
        case MySQLParser::SKIP_SYMBOL:
        case MySQLParser::LOCKED_SYMBOL:
        case MySQLParser::NOWAIT_SYMBOL:
        case MySQLParser::HISTOGRAM_SYMBOL:
        case MySQLParser::BUCKETS_SYMBOL:
        case MySQLParser::EXCLUDE_SYMBOL:
        case MySQLParser::FOLLOWING_SYMBOL:
        case MySQLParser::NULLS_SYMBOL:
        case MySQLParser::OTHERS_SYMBOL:
        case MySQLParser::PRECEDING_SYMBOL:
        case MySQLParser::RESPECT_SYMBOL:
        case MySQLParser::TIES_SYMBOL:
        case MySQLParser::UNBOUNDED_SYMBOL:
        case MySQLParser::NESTED_SYMBOL:
        case MySQLParser::ORDINALITY_SYMBOL:
        case MySQLParser::PATH_SYMBOL:
        case MySQLParser::HISTORY_SYMBOL:
        case MySQLParser::REUSE_SYMBOL:
        case MySQLParser::SRID_SYMBOL:
        case MySQLParser::THREAD_PRIORITY_SYMBOL:
        case MySQLParser::VCPU_SYMBOL:
        case MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL:
        case MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL:
        case MySQLParser::DEFINITION_SYMBOL:
        case MySQLParser::DESCRIPTION_SYMBOL:
        case MySQLParser::ORGANIZATION_SYMBOL:
        case MySQLParser::REFERENCE_SYMBOL:
        case MySQLParser::OPTIONAL_SYMBOL:
        case MySQLParser::SECONDARY_SYMBOL:
        case MySQLParser::SECONDARY_ENGINE_SYMBOL:
        case MySQLParser::SECONDARY_LOAD_SYMBOL:
        case MySQLParser::SECONDARY_UNLOAD_SYMBOL:
        case MySQLParser::ACTIVE_SYMBOL:
        case MySQLParser::INACTIVE_SYMBOL:
        case MySQLParser::RETAIN_SYMBOL:
        case MySQLParser::OLD_SYMBOL:
        case MySQLParser::NETWORK_NAMESPACE_SYMBOL:
        case MySQLParser::ENFORCED_SYMBOL:
        case MySQLParser::OJ_SYMBOL: {
          setState(8261);
          identifierKeywordsUnambiguous();
          break;
        }

        case MySQLParser::EVENT_SYMBOL:
        case MySQLParser::FILE_SYMBOL:
        case MySQLParser::NONE_SYMBOL:
        case MySQLParser::PROCESS_SYMBOL:
        case MySQLParser::PROXY_SYMBOL:
        case MySQLParser::RELOAD_SYMBOL:
        case MySQLParser::REPLICATION_SYMBOL:
        case MySQLParser::SUPER_SYMBOL:
        case MySQLParser::RESOURCE_SYMBOL: {
          setState(8262);
          identifierKeywordsAmbiguous3Roles();
          break;
        }

        case MySQLParser::GLOBAL_SYMBOL:
        case MySQLParser::LOCAL_SYMBOL:
        case MySQLParser::SESSION_SYMBOL:
        case MySQLParser::PERSIST_SYMBOL:
        case MySQLParser::PERSIST_ONLY_SYMBOL: {
          setState(8263);
          identifierKeywordsAmbiguous4SystemVariables();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous3RolesContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::IdentifierKeywordsAmbiguous3RolesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::EVENT_SYMBOL() {
  return getToken(MySQLParser::EVENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::FILE_SYMBOL() {
  return getToken(MySQLParser::FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::NONE_SYMBOL() {
  return getToken(MySQLParser::NONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::PROCESS_SYMBOL() {
  return getToken(MySQLParser::PROCESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::PROXY_SYMBOL() {
  return getToken(MySQLParser::PROXY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::RELOAD_SYMBOL() {
  return getToken(MySQLParser::RELOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::REPLICATION_SYMBOL() {
  return getToken(MySQLParser::REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::RESOURCE_SYMBOL() {
  return getToken(MySQLParser::RESOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}


size_t MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous3Roles;
}

void MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous3Roles(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous3RolesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous3Roles(this);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext* MySQLParser::identifierKeywordsAmbiguous3Roles() {
  IdentifierKeywordsAmbiguous3RolesContext *_localctx = _tracker.createInstance<IdentifierKeywordsAmbiguous3RolesContext>(_ctx, getState());
  enterRule(_localctx, 1190, MySQLParser::RuleIdentifierKeywordsAmbiguous3Roles);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8268);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::EVENT_SYMBOL

    || _la == MySQLParser::FILE_SYMBOL || ((((_la - 402) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 402)) & ((1ULL << (MySQLParser::NONE_SYMBOL - 402))
      | (1ULL << (MySQLParser::PROCESS_SYMBOL - 402))
      | (1ULL << (MySQLParser::PROXY_SYMBOL - 402)))) != 0) || _la == MySQLParser::RELOAD_SYMBOL

    || _la == MySQLParser::REPLICATION_SYMBOL || _la == MySQLParser::SUPER_SYMBOL || _la == MySQLParser::RESOURCE_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsUnambiguousContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordsUnambiguousContext::IdentifierKeywordsUnambiguousContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DEFINITION_SYMBOL() {
  return getToken(MySQLParser::DEFINITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ENFORCED_SYMBOL() {
  return getToken(MySQLParser::ENFORCED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EXCHANGE_SYMBOL() {
  return getToken(MySQLParser::EXCHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EXPIRE_SYMBOL() {
  return getToken(MySQLParser::EXPIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::GET_MASTER_PUBLIC_KEY_SYMBOL() {
  return getToken(MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LOCKS_SYMBOL() {
  return getToken(MySQLParser::LOCKS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NETWORK_NAMESPACE_SYMBOL() {
  return getToken(MySQLParser::NETWORK_NAMESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SERVER_ID_SYMBOL() {
  return getToken(MySQLParser::MASTER_SERVER_ID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NDBCLUSTER_SYMBOL() {
  return getToken(MySQLParser::NDBCLUSTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NEW_SYMBOL() {
  return getToken(MySQLParser::NEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OJ_SYMBOL() {
  return getToken(MySQLParser::OJ_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::READ_ONLY_SYMBOL() {
  return getToken(MySQLParser::READ_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REFERENCE_SYMBOL() {
  return getToken(MySQLParser::REFERENCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RESTORE_SYMBOL() {
  return getToken(MySQLParser::RESTORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TIMESTAMP_ADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TIMESTAMP_DIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_DIFF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TYPES_SYMBOL() {
  return getToken(MySQLParser::TYPES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::VALIDATION_SYMBOL() {
  return getToken(MySQLParser::VALIDATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::WITHOUT_SYMBOL() {
  return getToken(MySQLParser::WITHOUT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsUnambiguousContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}


size_t MySQLParser::IdentifierKeywordsUnambiguousContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsUnambiguous;
}

void MySQLParser::IdentifierKeywordsUnambiguousContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsUnambiguous(this);
}

void MySQLParser::IdentifierKeywordsUnambiguousContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsUnambiguous(this);
}

MySQLParser::IdentifierKeywordsUnambiguousContext* MySQLParser::identifierKeywordsUnambiguous() {
  IdentifierKeywordsUnambiguousContext *_localctx = _tracker.createInstance<IdentifierKeywordsUnambiguousContext>(_ctx, getState());
  enterRule(_localctx, 1192, MySQLParser::RuleIdentifierKeywordsUnambiguous);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8270);
    _la = _input->LA(1);
    if (!(((((_la - 50) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 50)) & ((1ULL << (MySQLParser::ACCOUNT_SYMBOL - 50))
      | (1ULL << (MySQLParser::ACTION_SYMBOL - 50))
      | (1ULL << (MySQLParser::ADDDATE_SYMBOL - 50))
      | (1ULL << (MySQLParser::AFTER_SYMBOL - 50))
      | (1ULL << (MySQLParser::AGAINST_SYMBOL - 50))
      | (1ULL << (MySQLParser::AGGREGATE_SYMBOL - 50))
      | (1ULL << (MySQLParser::ALGORITHM_SYMBOL - 50))
      | (1ULL << (MySQLParser::ALWAYS_SYMBOL - 50))
      | (1ULL << (MySQLParser::ANY_SYMBOL - 50))
      | (1ULL << (MySQLParser::AT_SYMBOL - 50))
      | (1ULL << (MySQLParser::AUTOEXTEND_SIZE_SYMBOL - 50))
      | (1ULL << (MySQLParser::AUTO_INCREMENT_SYMBOL - 50))
      | (1ULL << (MySQLParser::AVG_ROW_LENGTH_SYMBOL - 50))
      | (1ULL << (MySQLParser::AVG_SYMBOL - 50))
      | (1ULL << (MySQLParser::BACKUP_SYMBOL - 50))
      | (1ULL << (MySQLParser::BINLOG_SYMBOL - 50))
      | (1ULL << (MySQLParser::BIT_SYMBOL - 50))
      | (1ULL << (MySQLParser::BLOCK_SYMBOL - 50))
      | (1ULL << (MySQLParser::BOOLEAN_SYMBOL - 50))
      | (1ULL << (MySQLParser::BOOL_SYMBOL - 50))
      | (1ULL << (MySQLParser::BTREE_SYMBOL - 50))
      | (1ULL << (MySQLParser::CASCADED_SYMBOL - 50))
      | (1ULL << (MySQLParser::CATALOG_NAME_SYMBOL - 50))
      | (1ULL << (MySQLParser::CHAIN_SYMBOL - 50))
      | (1ULL << (MySQLParser::CHANGED_SYMBOL - 50))
      | (1ULL << (MySQLParser::CHANNEL_SYMBOL - 50))
      | (1ULL << (MySQLParser::CIPHER_SYMBOL - 50))
      | (1ULL << (MySQLParser::CLASS_ORIGIN_SYMBOL - 50))
      | (1ULL << (MySQLParser::CLIENT_SYMBOL - 50))
      | (1ULL << (MySQLParser::CLOSE_SYMBOL - 50)))) != 0) || ((((_la - 114) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 114)) & ((1ULL << (MySQLParser::COALESCE_SYMBOL - 114))
      | (1ULL << (MySQLParser::CODE_SYMBOL - 114))
      | (1ULL << (MySQLParser::COLLATION_SYMBOL - 114))
      | (1ULL << (MySQLParser::COLUMNS_SYMBOL - 114))
      | (1ULL << (MySQLParser::COLUMN_NAME_SYMBOL - 114))
      | (1ULL << (MySQLParser::COLUMN_FORMAT_SYMBOL - 114))
      | (1ULL << (MySQLParser::COMMITTED_SYMBOL - 114))
      | (1ULL << (MySQLParser::COMPACT_SYMBOL - 114))
      | (1ULL << (MySQLParser::COMPLETION_SYMBOL - 114))
      | (1ULL << (MySQLParser::COMPRESSED_SYMBOL - 114))
      | (1ULL << (MySQLParser::COMPRESSION_SYMBOL - 114))
      | (1ULL << (MySQLParser::CONCURRENT_SYMBOL - 114))
      | (1ULL << (MySQLParser::CONNECTION_SYMBOL - 114))
      | (1ULL << (MySQLParser::CONSISTENT_SYMBOL - 114))
      | (1ULL << (MySQLParser::CONSTRAINT_CATALOG_SYMBOL - 114))
      | (1ULL << (MySQLParser::CONSTRAINT_NAME_SYMBOL - 114))
      | (1ULL << (MySQLParser::CONSTRAINT_SCHEMA_SYMBOL - 114))
      | (1ULL << (MySQLParser::CONTEXT_SYMBOL - 114))
      | (1ULL << (MySQLParser::CPU_SYMBOL - 114))
      | (1ULL << (MySQLParser::CURRENT_SYMBOL - 114))
      | (1ULL << (MySQLParser::CURSOR_NAME_SYMBOL - 114))
      | (1ULL << (MySQLParser::DATAFILE_SYMBOL - 114))
      | (1ULL << (MySQLParser::DATA_SYMBOL - 114))
      | (1ULL << (MySQLParser::DATETIME_SYMBOL - 114))
      | (1ULL << (MySQLParser::DATE_SYMBOL - 114))
      | (1ULL << (MySQLParser::DAY_SYMBOL - 114))
      | (1ULL << (MySQLParser::DEFAULT_AUTH_SYMBOL - 114))
      | (1ULL << (MySQLParser::DEFINER_SYMBOL - 114))
      | (1ULL << (MySQLParser::DELAY_KEY_WRITE_SYMBOL - 114)))) != 0) || ((((_la - 182) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 182)) & ((1ULL << (MySQLParser::DIAGNOSTICS_SYMBOL - 182))
      | (1ULL << (MySQLParser::DIRECTORY_SYMBOL - 182))
      | (1ULL << (MySQLParser::DISABLE_SYMBOL - 182))
      | (1ULL << (MySQLParser::DISCARD_SYMBOL - 182))
      | (1ULL << (MySQLParser::DISK_SYMBOL - 182))
      | (1ULL << (MySQLParser::DUMPFILE_SYMBOL - 182))
      | (1ULL << (MySQLParser::DUPLICATE_SYMBOL - 182))
      | (1ULL << (MySQLParser::DYNAMIC_SYMBOL - 182))
      | (1ULL << (MySQLParser::ENABLE_SYMBOL - 182))
      | (1ULL << (MySQLParser::ENCRYPTION_SYMBOL - 182))
      | (1ULL << (MySQLParser::ENDS_SYMBOL - 182))
      | (1ULL << (MySQLParser::ENGINES_SYMBOL - 182))
      | (1ULL << (MySQLParser::ENGINE_SYMBOL - 182))
      | (1ULL << (MySQLParser::ENUM_SYMBOL - 182))
      | (1ULL << (MySQLParser::ERROR_SYMBOL - 182))
      | (1ULL << (MySQLParser::ERRORS_SYMBOL - 182))
      | (1ULL << (MySQLParser::ESCAPE_SYMBOL - 182))
      | (1ULL << (MySQLParser::EVENTS_SYMBOL - 182))
      | (1ULL << (MySQLParser::EVERY_SYMBOL - 182))
      | (1ULL << (MySQLParser::EXCHANGE_SYMBOL - 182))
      | (1ULL << (MySQLParser::EXPANSION_SYMBOL - 182))
      | (1ULL << (MySQLParser::EXPIRE_SYMBOL - 182))
      | (1ULL << (MySQLParser::EXPORT_SYMBOL - 182))
      | (1ULL << (MySQLParser::EXTENDED_SYMBOL - 182))
      | (1ULL << (MySQLParser::EXTENT_SIZE_SYMBOL - 182))
      | (1ULL << (MySQLParser::FAST_SYMBOL - 182))
      | (1ULL << (MySQLParser::FAULTS_SYMBOL - 182))
      | (1ULL << (MySQLParser::FILE_BLOCK_SIZE_SYMBOL - 182))
      | (1ULL << (MySQLParser::FILTER_SYMBOL - 182))
      | (1ULL << (MySQLParser::FIRST_SYMBOL - 182))
      | (1ULL << (MySQLParser::FIXED_SYMBOL - 182))
      | (1ULL << (MySQLParser::FORMAT_SYMBOL - 182))
      | (1ULL << (MySQLParser::FOUND_SYMBOL - 182))
      | (1ULL << (MySQLParser::FULL_SYMBOL - 182)))) != 0) || ((((_la - 247) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 247)) & ((1ULL << (MySQLParser::GENERAL_SYMBOL - 247))
      | (1ULL << (MySQLParser::GROUP_REPLICATION_SYMBOL - 247))
      | (1ULL << (MySQLParser::GEOMETRYCOLLECTION_SYMBOL - 247))
      | (1ULL << (MySQLParser::GEOMETRY_SYMBOL - 247))
      | (1ULL << (MySQLParser::GET_FORMAT_SYMBOL - 247))
      | (1ULL << (MySQLParser::GRANTS_SYMBOL - 247))
      | (1ULL << (MySQLParser::HASH_SYMBOL - 247))
      | (1ULL << (MySQLParser::HOST_SYMBOL - 247))
      | (1ULL << (MySQLParser::HOSTS_SYMBOL - 247))
      | (1ULL << (MySQLParser::HOUR_SYMBOL - 247))
      | (1ULL << (MySQLParser::IDENTIFIED_SYMBOL - 247))
      | (1ULL << (MySQLParser::IGNORE_SERVER_IDS_SYMBOL - 247))
      | (1ULL << (MySQLParser::INDEXES_SYMBOL - 247))
      | (1ULL << (MySQLParser::INITIAL_SIZE_SYMBOL - 247))
      | (1ULL << (MySQLParser::INSERT_METHOD_SYMBOL - 247))
      | (1ULL << (MySQLParser::INSTANCE_SYMBOL - 247))
      | (1ULL << (MySQLParser::INVOKER_SYMBOL - 247))
      | (1ULL << (MySQLParser::IO_SYMBOL - 247))
      | (1ULL << (MySQLParser::IPC_SYMBOL - 247))
      | (1ULL << (MySQLParser::ISOLATION_SYMBOL - 247))
      | (1ULL << (MySQLParser::ISSUER_SYMBOL - 247))
      | (1ULL << (MySQLParser::JSON_SYMBOL - 247))
      | (1ULL << (MySQLParser::KEY_BLOCK_SIZE_SYMBOL - 247))
      | (1ULL << (MySQLParser::LAST_SYMBOL - 247))
      | (1ULL << (MySQLParser::LEAVES_SYMBOL - 247))
      | (1ULL << (MySQLParser::LESS_SYMBOL - 247)))) != 0) || ((((_la - 311) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 311)) & ((1ULL << (MySQLParser::LEVEL_SYMBOL - 311))
      | (1ULL << (MySQLParser::LINESTRING_SYMBOL - 311))
      | (1ULL << (MySQLParser::LIST_SYMBOL - 311))
      | (1ULL << (MySQLParser::LOCKS_SYMBOL - 311))
      | (1ULL << (MySQLParser::LOGFILE_SYMBOL - 311))
      | (1ULL << (MySQLParser::LOGS_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_AUTO_POSITION_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_CONNECT_RETRY_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_DELAY_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_HOST_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_LOG_FILE_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_LOG_POS_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_PASSWORD_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_PORT_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_RETRY_COUNT_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SERVER_ID_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_CAPATH_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_CA_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_CERT_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_CIPHER_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_CRL_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_CRLPATH_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_KEY_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SSL_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_TLS_VERSION_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_USER_SYMBOL - 311))
      | (1ULL << (MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL - 311))
      | (1ULL << (MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL - 311))
      | (1ULL << (MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL - 311))
      | (1ULL << (MySQLParser::MAX_ROWS_SYMBOL - 311))
      | (1ULL << (MySQLParser::MAX_SIZE_SYMBOL - 311))
      | (1ULL << (MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL - 311))
      | (1ULL << (MySQLParser::MAX_USER_CONNECTIONS_SYMBOL - 311))
      | (1ULL << (MySQLParser::MEDIUM_SYMBOL - 311))
      | (1ULL << (MySQLParser::MEMORY_SYMBOL - 311))
      | (1ULL << (MySQLParser::MERGE_SYMBOL - 311))
      | (1ULL << (MySQLParser::MESSAGE_TEXT_SYMBOL - 311))
      | (1ULL << (MySQLParser::MICROSECOND_SYMBOL - 311))
      | (1ULL << (MySQLParser::MIGRATE_SYMBOL - 311)))) != 0) || ((((_la - 377) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 377)) & ((1ULL << (MySQLParser::MINUTE_SYMBOL - 377))
      | (1ULL << (MySQLParser::MIN_ROWS_SYMBOL - 377))
      | (1ULL << (MySQLParser::MODE_SYMBOL - 377))
      | (1ULL << (MySQLParser::MODIFY_SYMBOL - 377))
      | (1ULL << (MySQLParser::MONTH_SYMBOL - 377))
      | (1ULL << (MySQLParser::MULTILINESTRING_SYMBOL - 377))
      | (1ULL << (MySQLParser::MULTIPOINT_SYMBOL - 377))
      | (1ULL << (MySQLParser::MULTIPOLYGON_SYMBOL - 377))
      | (1ULL << (MySQLParser::MUTEX_SYMBOL - 377))
      | (1ULL << (MySQLParser::MYSQL_ERRNO_SYMBOL - 377))
      | (1ULL << (MySQLParser::NAMES_SYMBOL - 377))
      | (1ULL << (MySQLParser::NAME_SYMBOL - 377))
      | (1ULL << (MySQLParser::NATIONAL_SYMBOL - 377))
      | (1ULL << (MySQLParser::NCHAR_SYMBOL - 377))
      | (1ULL << (MySQLParser::NDBCLUSTER_SYMBOL - 377))
      | (1ULL << (MySQLParser::NEVER_SYMBOL - 377))
      | (1ULL << (MySQLParser::NEW_SYMBOL - 377))
      | (1ULL << (MySQLParser::NEXT_SYMBOL - 377))
      | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 377))
      | (1ULL << (MySQLParser::NO_WAIT_SYMBOL - 377))
      | (1ULL << (MySQLParser::NUMBER_SYMBOL - 377))
      | (1ULL << (MySQLParser::NVARCHAR_SYMBOL - 377))
      | (1ULL << (MySQLParser::OFFSET_SYMBOL - 377))
      | (1ULL << (MySQLParser::ONE_SYMBOL - 377))
      | (1ULL << (MySQLParser::ONLY_SYMBOL - 377))
      | (1ULL << (MySQLParser::OPEN_SYMBOL - 377))
      | (1ULL << (MySQLParser::OPTIONS_SYMBOL - 377))
      | (1ULL << (MySQLParser::OWNER_SYMBOL - 377))
      | (1ULL << (MySQLParser::PACK_KEYS_SYMBOL - 377))
      | (1ULL << (MySQLParser::PAGE_SYMBOL - 377))
      | (1ULL << (MySQLParser::PARSER_SYMBOL - 377))
      | (1ULL << (MySQLParser::PARTIAL_SYMBOL - 377))
      | (1ULL << (MySQLParser::PARTITIONING_SYMBOL - 377))
      | (1ULL << (MySQLParser::PARTITIONS_SYMBOL - 377))
      | (1ULL << (MySQLParser::PASSWORD_SYMBOL - 377)))) != 0) || ((((_la - 441) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 441)) & ((1ULL << (MySQLParser::PHASE_SYMBOL - 441))
      | (1ULL << (MySQLParser::PLUGINS_SYMBOL - 441))
      | (1ULL << (MySQLParser::PLUGIN_DIR_SYMBOL - 441))
      | (1ULL << (MySQLParser::PLUGIN_SYMBOL - 441))
      | (1ULL << (MySQLParser::POINT_SYMBOL - 441))
      | (1ULL << (MySQLParser::POLYGON_SYMBOL - 441))
      | (1ULL << (MySQLParser::PORT_SYMBOL - 441))
      | (1ULL << (MySQLParser::PRESERVE_SYMBOL - 441))
      | (1ULL << (MySQLParser::PREV_SYMBOL - 441))
      | (1ULL << (MySQLParser::PRIVILEGES_SYMBOL - 441))
      | (1ULL << (MySQLParser::PROCESSLIST_SYMBOL - 441))
      | (1ULL << (MySQLParser::PROFILE_SYMBOL - 441))
      | (1ULL << (MySQLParser::PROFILES_SYMBOL - 441))
      | (1ULL << (MySQLParser::QUARTER_SYMBOL - 441))
      | (1ULL << (MySQLParser::QUERY_SYMBOL - 441))
      | (1ULL << (MySQLParser::QUICK_SYMBOL - 441))
      | (1ULL << (MySQLParser::READ_ONLY_SYMBOL - 441))
      | (1ULL << (MySQLParser::REBUILD_SYMBOL - 441))
      | (1ULL << (MySQLParser::RECOVER_SYMBOL - 441))
      | (1ULL << (MySQLParser::REDO_BUFFER_SIZE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REDUNDANT_SYMBOL - 441))
      | (1ULL << (MySQLParser::RELAY_SYMBOL - 441))
      | (1ULL << (MySQLParser::RELAYLOG_SYMBOL - 441))
      | (1ULL << (MySQLParser::RELAY_LOG_FILE_SYMBOL - 441))
      | (1ULL << (MySQLParser::RELAY_LOG_POS_SYMBOL - 441))
      | (1ULL << (MySQLParser::RELAY_THREAD_SYMBOL - 441))
      | (1ULL << (MySQLParser::REMOVE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REORGANIZE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPEATABLE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPLICATE_DO_DB_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPLICATE_IGNORE_DB_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPLICATE_DO_TABLE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL - 441))
      | (1ULL << (MySQLParser::REPLICATE_REWRITE_DB_SYMBOL - 441))
      | (1ULL << (MySQLParser::RESTORE_SYMBOL - 441)))) != 0) || ((((_la - 506) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 506)) & ((1ULL << (MySQLParser::RESUME_SYMBOL - 506))
      | (1ULL << (MySQLParser::RETURNED_SQLSTATE_SYMBOL - 506))
      | (1ULL << (MySQLParser::RETURNS_SYMBOL - 506))
      | (1ULL << (MySQLParser::REVERSE_SYMBOL - 506))
      | (1ULL << (MySQLParser::ROLLUP_SYMBOL - 506))
      | (1ULL << (MySQLParser::ROTATE_SYMBOL - 506))
      | (1ULL << (MySQLParser::ROUTINE_SYMBOL - 506))
      | (1ULL << (MySQLParser::ROW_COUNT_SYMBOL - 506))
      | (1ULL << (MySQLParser::ROW_FORMAT_SYMBOL - 506))
      | (1ULL << (MySQLParser::RTREE_SYMBOL - 506))
      | (1ULL << (MySQLParser::SCHEDULE_SYMBOL - 506))
      | (1ULL << (MySQLParser::SCHEMA_NAME_SYMBOL - 506))
      | (1ULL << (MySQLParser::SECOND_SYMBOL - 506))
      | (1ULL << (MySQLParser::SECURITY_SYMBOL - 506))
      | (1ULL << (MySQLParser::SERIALIZABLE_SYMBOL - 506))
      | (1ULL << (MySQLParser::SERIAL_SYMBOL - 506))
      | (1ULL << (MySQLParser::SERVER_SYMBOL - 506))
      | (1ULL << (MySQLParser::SHARE_SYMBOL - 506))
      | (1ULL << (MySQLParser::SIMPLE_SYMBOL - 506))
      | (1ULL << (MySQLParser::SLOW_SYMBOL - 506))
      | (1ULL << (MySQLParser::SNAPSHOT_SYMBOL - 506))
      | (1ULL << (MySQLParser::SOCKET_SYMBOL - 506))
      | (1ULL << (MySQLParser::SONAME_SYMBOL - 506))
      | (1ULL << (MySQLParser::SOUNDS_SYMBOL - 506))
      | (1ULL << (MySQLParser::SOURCE_SYMBOL - 506))
      | (1ULL << (MySQLParser::SQL_AFTER_GTIDS_SYMBOL - 506))
      | (1ULL << (MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL - 506))
      | (1ULL << (MySQLParser::SQL_BEFORE_GTIDS_SYMBOL - 506))
      | (1ULL << (MySQLParser::SQL_BUFFER_RESULT_SYMBOL - 506))
      | (1ULL << (MySQLParser::SQL_NO_CACHE_SYMBOL - 506))
      | (1ULL << (MySQLParser::SQL_THREAD_SYMBOL - 506)))) != 0) || ((((_la - 570) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 570)) & ((1ULL << (MySQLParser::STACKED_SYMBOL - 570))
      | (1ULL << (MySQLParser::STARTS_SYMBOL - 570))
      | (1ULL << (MySQLParser::STATS_AUTO_RECALC_SYMBOL - 570))
      | (1ULL << (MySQLParser::STATS_PERSISTENT_SYMBOL - 570))
      | (1ULL << (MySQLParser::STATS_SAMPLE_PAGES_SYMBOL - 570))
      | (1ULL << (MySQLParser::STATUS_SYMBOL - 570))
      | (1ULL << (MySQLParser::STORAGE_SYMBOL - 570))
      | (1ULL << (MySQLParser::STRING_SYMBOL - 570))
      | (1ULL << (MySQLParser::SUBCLASS_ORIGIN_SYMBOL - 570))
      | (1ULL << (MySQLParser::SUBDATE_SYMBOL - 570))
      | (1ULL << (MySQLParser::SUBJECT_SYMBOL - 570))
      | (1ULL << (MySQLParser::SUBPARTITIONS_SYMBOL - 570))
      | (1ULL << (MySQLParser::SUBPARTITION_SYMBOL - 570))
      | (1ULL << (MySQLParser::SUSPEND_SYMBOL - 570))
      | (1ULL << (MySQLParser::SWAPS_SYMBOL - 570))
      | (1ULL << (MySQLParser::SWITCHES_SYMBOL - 570))
      | (1ULL << (MySQLParser::TABLES_SYMBOL - 570))
      | (1ULL << (MySQLParser::TABLESPACE_SYMBOL - 570))
      | (1ULL << (MySQLParser::TABLE_CHECKSUM_SYMBOL - 570))
      | (1ULL << (MySQLParser::TABLE_NAME_SYMBOL - 570))
      | (1ULL << (MySQLParser::TEMPORARY_SYMBOL - 570))
      | (1ULL << (MySQLParser::TEMPTABLE_SYMBOL - 570))
      | (1ULL << (MySQLParser::TEXT_SYMBOL - 570))
      | (1ULL << (MySQLParser::THAN_SYMBOL - 570))
      | (1ULL << (MySQLParser::TIMESTAMP_SYMBOL - 570))
      | (1ULL << (MySQLParser::TIMESTAMP_ADD_SYMBOL - 570))
      | (1ULL << (MySQLParser::TIMESTAMP_DIFF_SYMBOL - 570))
      | (1ULL << (MySQLParser::TIME_SYMBOL - 570))
      | (1ULL << (MySQLParser::TRANSACTION_SYMBOL - 570))
      | (1ULL << (MySQLParser::TRIGGERS_SYMBOL - 570))
      | (1ULL << (MySQLParser::TYPES_SYMBOL - 570))
      | (1ULL << (MySQLParser::TYPE_SYMBOL - 570))
      | (1ULL << (MySQLParser::UNCOMMITTED_SYMBOL - 570))
      | (1ULL << (MySQLParser::UNDEFINED_SYMBOL - 570))
      | (1ULL << (MySQLParser::UNDOFILE_SYMBOL - 570)))) != 0) || ((((_la - 634) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 634)) & ((1ULL << (MySQLParser::UNDO_BUFFER_SIZE_SYMBOL - 634))
      | (1ULL << (MySQLParser::UNKNOWN_SYMBOL - 634))
      | (1ULL << (MySQLParser::UNTIL_SYMBOL - 634))
      | (1ULL << (MySQLParser::UPGRADE_SYMBOL - 634))
      | (1ULL << (MySQLParser::USER_RESOURCES_SYMBOL - 634))
      | (1ULL << (MySQLParser::USER_SYMBOL - 634))
      | (1ULL << (MySQLParser::USE_FRM_SYMBOL - 634))
      | (1ULL << (MySQLParser::VALIDATION_SYMBOL - 634))
      | (1ULL << (MySQLParser::VALUE_SYMBOL - 634))
      | (1ULL << (MySQLParser::VARIABLES_SYMBOL - 634))
      | (1ULL << (MySQLParser::VIEW_SYMBOL - 634))
      | (1ULL << (MySQLParser::WAIT_SYMBOL - 634))
      | (1ULL << (MySQLParser::WARNINGS_SYMBOL - 634))
      | (1ULL << (MySQLParser::WEEK_SYMBOL - 634))
      | (1ULL << (MySQLParser::WEIGHT_STRING_SYMBOL - 634))
      | (1ULL << (MySQLParser::WITHOUT_SYMBOL - 634))
      | (1ULL << (MySQLParser::WORK_SYMBOL - 634))
      | (1ULL << (MySQLParser::WRAPPER_SYMBOL - 634))
      | (1ULL << (MySQLParser::X509_SYMBOL - 634))
      | (1ULL << (MySQLParser::XID_SYMBOL - 634))
      | (1ULL << (MySQLParser::XML_SYMBOL - 634))
      | (1ULL << (MySQLParser::YEAR_SYMBOL - 634))
      | (1ULL << (MySQLParser::ROLE_SYMBOL - 634))
      | (1ULL << (MySQLParser::ADMIN_SYMBOL - 634))
      | (1ULL << (MySQLParser::INVISIBLE_SYMBOL - 634))
      | (1ULL << (MySQLParser::VISIBLE_SYMBOL - 634))
      | (1ULL << (MySQLParser::COMPONENT_SYMBOL - 634)))) != 0) || ((((_la - 700) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 700)) & ((1ULL << (MySQLParser::SKIP_SYMBOL - 700))
      | (1ULL << (MySQLParser::LOCKED_SYMBOL - 700))
      | (1ULL << (MySQLParser::NOWAIT_SYMBOL - 700))
      | (1ULL << (MySQLParser::HISTOGRAM_SYMBOL - 700))
      | (1ULL << (MySQLParser::BUCKETS_SYMBOL - 700))
      | (1ULL << (MySQLParser::EXCLUDE_SYMBOL - 700))
      | (1ULL << (MySQLParser::FOLLOWING_SYMBOL - 700))
      | (1ULL << (MySQLParser::NULLS_SYMBOL - 700))
      | (1ULL << (MySQLParser::OTHERS_SYMBOL - 700))
      | (1ULL << (MySQLParser::PRECEDING_SYMBOL - 700))
      | (1ULL << (MySQLParser::RESPECT_SYMBOL - 700))
      | (1ULL << (MySQLParser::TIES_SYMBOL - 700))
      | (1ULL << (MySQLParser::UNBOUNDED_SYMBOL - 700))
      | (1ULL << (MySQLParser::NESTED_SYMBOL - 700))
      | (1ULL << (MySQLParser::ORDINALITY_SYMBOL - 700))
      | (1ULL << (MySQLParser::PATH_SYMBOL - 700))
      | (1ULL << (MySQLParser::HISTORY_SYMBOL - 700))
      | (1ULL << (MySQLParser::REUSE_SYMBOL - 700))
      | (1ULL << (MySQLParser::SRID_SYMBOL - 700))
      | (1ULL << (MySQLParser::THREAD_PRIORITY_SYMBOL - 700))
      | (1ULL << (MySQLParser::VCPU_SYMBOL - 700))
      | (1ULL << (MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL - 700))
      | (1ULL << (MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL - 700))
      | (1ULL << (MySQLParser::DEFINITION_SYMBOL - 700))
      | (1ULL << (MySQLParser::DESCRIPTION_SYMBOL - 700))
      | (1ULL << (MySQLParser::ORGANIZATION_SYMBOL - 700))
      | (1ULL << (MySQLParser::REFERENCE_SYMBOL - 700))
      | (1ULL << (MySQLParser::OPTIONAL_SYMBOL - 700))
      | (1ULL << (MySQLParser::SECONDARY_SYMBOL - 700))
      | (1ULL << (MySQLParser::SECONDARY_ENGINE_SYMBOL - 700))
      | (1ULL << (MySQLParser::SECONDARY_LOAD_SYMBOL - 700))
      | (1ULL << (MySQLParser::SECONDARY_UNLOAD_SYMBOL - 700))
      | (1ULL << (MySQLParser::ACTIVE_SYMBOL - 700))
      | (1ULL << (MySQLParser::INACTIVE_SYMBOL - 700))
      | (1ULL << (MySQLParser::RETAIN_SYMBOL - 700))
      | (1ULL << (MySQLParser::OLD_SYMBOL - 700))
      | (1ULL << (MySQLParser::NETWORK_NAMESPACE_SYMBOL - 700))
      | (1ULL << (MySQLParser::ENFORCED_SYMBOL - 700))
      | (1ULL << (MySQLParser::OJ_SYMBOL - 700)))) != 0))) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleKeywordContext ------------------------------------------------------------------

MySQLParser::RoleKeywordContext::RoleKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::RoleOrLabelKeywordContext* MySQLParser::RoleKeywordContext::roleOrLabelKeyword() {
  return getRuleContext<MySQLParser::RoleOrLabelKeywordContext>(0);
}

MySQLParser::RoleOrIdentifierKeywordContext* MySQLParser::RoleKeywordContext::roleOrIdentifierKeyword() {
  return getRuleContext<MySQLParser::RoleOrIdentifierKeywordContext>(0);
}

MySQLParser::IdentifierKeywordsUnambiguousContext* MySQLParser::RoleKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext* MySQLParser::RoleKeywordContext::identifierKeywordsAmbiguous2Labels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext* MySQLParser::RoleKeywordContext::identifierKeywordsAmbiguous4SystemVariables() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext>(0);
}


size_t MySQLParser::RoleKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleKeyword;
}

void MySQLParser::RoleKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleKeyword(this);
}

void MySQLParser::RoleKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleKeyword(this);
}

MySQLParser::RoleKeywordContext* MySQLParser::roleKeyword() {
  RoleKeywordContext *_localctx = _tracker.createInstance<RoleKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1194, MySQLParser::RuleRoleKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8282);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1110, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8272);

      if (!(serverVersion < 80017)) throw FailedPredicateException(this, "serverVersion < 80017");
      setState(8275);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1108, _ctx)) {
      case 1: {
        setState(8273);
        roleOrLabelKeyword();
        break;
      }

      case 2: {
        setState(8274);
        roleOrIdentifierKeyword();
        break;
      }

      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8280);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case MySQLParser::ACCOUNT_SYMBOL:
        case MySQLParser::ACTION_SYMBOL:
        case MySQLParser::ADDDATE_SYMBOL:
        case MySQLParser::AFTER_SYMBOL:
        case MySQLParser::AGAINST_SYMBOL:
        case MySQLParser::AGGREGATE_SYMBOL:
        case MySQLParser::ALGORITHM_SYMBOL:
        case MySQLParser::ALWAYS_SYMBOL:
        case MySQLParser::ANY_SYMBOL:
        case MySQLParser::AT_SYMBOL:
        case MySQLParser::AUTOEXTEND_SIZE_SYMBOL:
        case MySQLParser::AUTO_INCREMENT_SYMBOL:
        case MySQLParser::AVG_ROW_LENGTH_SYMBOL:
        case MySQLParser::AVG_SYMBOL:
        case MySQLParser::BACKUP_SYMBOL:
        case MySQLParser::BINLOG_SYMBOL:
        case MySQLParser::BIT_SYMBOL:
        case MySQLParser::BLOCK_SYMBOL:
        case MySQLParser::BOOLEAN_SYMBOL:
        case MySQLParser::BOOL_SYMBOL:
        case MySQLParser::BTREE_SYMBOL:
        case MySQLParser::CASCADED_SYMBOL:
        case MySQLParser::CATALOG_NAME_SYMBOL:
        case MySQLParser::CHAIN_SYMBOL:
        case MySQLParser::CHANGED_SYMBOL:
        case MySQLParser::CHANNEL_SYMBOL:
        case MySQLParser::CIPHER_SYMBOL:
        case MySQLParser::CLASS_ORIGIN_SYMBOL:
        case MySQLParser::CLIENT_SYMBOL:
        case MySQLParser::CLOSE_SYMBOL:
        case MySQLParser::COALESCE_SYMBOL:
        case MySQLParser::CODE_SYMBOL:
        case MySQLParser::COLLATION_SYMBOL:
        case MySQLParser::COLUMNS_SYMBOL:
        case MySQLParser::COLUMN_NAME_SYMBOL:
        case MySQLParser::COLUMN_FORMAT_SYMBOL:
        case MySQLParser::COMMITTED_SYMBOL:
        case MySQLParser::COMPACT_SYMBOL:
        case MySQLParser::COMPLETION_SYMBOL:
        case MySQLParser::COMPRESSED_SYMBOL:
        case MySQLParser::COMPRESSION_SYMBOL:
        case MySQLParser::CONCURRENT_SYMBOL:
        case MySQLParser::CONNECTION_SYMBOL:
        case MySQLParser::CONSISTENT_SYMBOL:
        case MySQLParser::CONSTRAINT_CATALOG_SYMBOL:
        case MySQLParser::CONSTRAINT_NAME_SYMBOL:
        case MySQLParser::CONSTRAINT_SCHEMA_SYMBOL:
        case MySQLParser::CONTEXT_SYMBOL:
        case MySQLParser::CPU_SYMBOL:
        case MySQLParser::CURRENT_SYMBOL:
        case MySQLParser::CURSOR_NAME_SYMBOL:
        case MySQLParser::DATAFILE_SYMBOL:
        case MySQLParser::DATA_SYMBOL:
        case MySQLParser::DATETIME_SYMBOL:
        case MySQLParser::DATE_SYMBOL:
        case MySQLParser::DAY_SYMBOL:
        case MySQLParser::DEFAULT_AUTH_SYMBOL:
        case MySQLParser::DEFINER_SYMBOL:
        case MySQLParser::DELAY_KEY_WRITE_SYMBOL:
        case MySQLParser::DIAGNOSTICS_SYMBOL:
        case MySQLParser::DIRECTORY_SYMBOL:
        case MySQLParser::DISABLE_SYMBOL:
        case MySQLParser::DISCARD_SYMBOL:
        case MySQLParser::DISK_SYMBOL:
        case MySQLParser::DUMPFILE_SYMBOL:
        case MySQLParser::DUPLICATE_SYMBOL:
        case MySQLParser::DYNAMIC_SYMBOL:
        case MySQLParser::ENABLE_SYMBOL:
        case MySQLParser::ENCRYPTION_SYMBOL:
        case MySQLParser::ENDS_SYMBOL:
        case MySQLParser::ENGINES_SYMBOL:
        case MySQLParser::ENGINE_SYMBOL:
        case MySQLParser::ENUM_SYMBOL:
        case MySQLParser::ERROR_SYMBOL:
        case MySQLParser::ERRORS_SYMBOL:
        case MySQLParser::ESCAPE_SYMBOL:
        case MySQLParser::EVENTS_SYMBOL:
        case MySQLParser::EVERY_SYMBOL:
        case MySQLParser::EXCHANGE_SYMBOL:
        case MySQLParser::EXPANSION_SYMBOL:
        case MySQLParser::EXPIRE_SYMBOL:
        case MySQLParser::EXPORT_SYMBOL:
        case MySQLParser::EXTENDED_SYMBOL:
        case MySQLParser::EXTENT_SIZE_SYMBOL:
        case MySQLParser::FAST_SYMBOL:
        case MySQLParser::FAULTS_SYMBOL:
        case MySQLParser::FILE_BLOCK_SIZE_SYMBOL:
        case MySQLParser::FILTER_SYMBOL:
        case MySQLParser::FIRST_SYMBOL:
        case MySQLParser::FIXED_SYMBOL:
        case MySQLParser::FORMAT_SYMBOL:
        case MySQLParser::FOUND_SYMBOL:
        case MySQLParser::FULL_SYMBOL:
        case MySQLParser::GENERAL_SYMBOL:
        case MySQLParser::GROUP_REPLICATION_SYMBOL:
        case MySQLParser::GEOMETRYCOLLECTION_SYMBOL:
        case MySQLParser::GEOMETRY_SYMBOL:
        case MySQLParser::GET_FORMAT_SYMBOL:
        case MySQLParser::GRANTS_SYMBOL:
        case MySQLParser::HASH_SYMBOL:
        case MySQLParser::HOST_SYMBOL:
        case MySQLParser::HOSTS_SYMBOL:
        case MySQLParser::HOUR_SYMBOL:
        case MySQLParser::IDENTIFIED_SYMBOL:
        case MySQLParser::IGNORE_SERVER_IDS_SYMBOL:
        case MySQLParser::INDEXES_SYMBOL:
        case MySQLParser::INITIAL_SIZE_SYMBOL:
        case MySQLParser::INSERT_METHOD_SYMBOL:
        case MySQLParser::INSTANCE_SYMBOL:
        case MySQLParser::INVOKER_SYMBOL:
        case MySQLParser::IO_SYMBOL:
        case MySQLParser::IPC_SYMBOL:
        case MySQLParser::ISOLATION_SYMBOL:
        case MySQLParser::ISSUER_SYMBOL:
        case MySQLParser::JSON_SYMBOL:
        case MySQLParser::KEY_BLOCK_SIZE_SYMBOL:
        case MySQLParser::LAST_SYMBOL:
        case MySQLParser::LEAVES_SYMBOL:
        case MySQLParser::LESS_SYMBOL:
        case MySQLParser::LEVEL_SYMBOL:
        case MySQLParser::LINESTRING_SYMBOL:
        case MySQLParser::LIST_SYMBOL:
        case MySQLParser::LOCKS_SYMBOL:
        case MySQLParser::LOGFILE_SYMBOL:
        case MySQLParser::LOGS_SYMBOL:
        case MySQLParser::MASTER_AUTO_POSITION_SYMBOL:
        case MySQLParser::MASTER_CONNECT_RETRY_SYMBOL:
        case MySQLParser::MASTER_DELAY_SYMBOL:
        case MySQLParser::MASTER_HOST_SYMBOL:
        case MySQLParser::MASTER_LOG_FILE_SYMBOL:
        case MySQLParser::MASTER_LOG_POS_SYMBOL:
        case MySQLParser::MASTER_PASSWORD_SYMBOL:
        case MySQLParser::MASTER_PORT_SYMBOL:
        case MySQLParser::MASTER_RETRY_COUNT_SYMBOL:
        case MySQLParser::MASTER_SERVER_ID_SYMBOL:
        case MySQLParser::MASTER_SSL_CAPATH_SYMBOL:
        case MySQLParser::MASTER_SSL_CA_SYMBOL:
        case MySQLParser::MASTER_SSL_CERT_SYMBOL:
        case MySQLParser::MASTER_SSL_CIPHER_SYMBOL:
        case MySQLParser::MASTER_SSL_CRL_SYMBOL:
        case MySQLParser::MASTER_SSL_CRLPATH_SYMBOL:
        case MySQLParser::MASTER_SSL_KEY_SYMBOL:
        case MySQLParser::MASTER_SSL_SYMBOL:
        case MySQLParser::MASTER_SYMBOL:
        case MySQLParser::MASTER_TLS_VERSION_SYMBOL:
        case MySQLParser::MASTER_USER_SYMBOL:
        case MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL:
        case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_ROWS_SYMBOL:
        case MySQLParser::MAX_SIZE_SYMBOL:
        case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL:
        case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL:
        case MySQLParser::MEDIUM_SYMBOL:
        case MySQLParser::MEMORY_SYMBOL:
        case MySQLParser::MERGE_SYMBOL:
        case MySQLParser::MESSAGE_TEXT_SYMBOL:
        case MySQLParser::MICROSECOND_SYMBOL:
        case MySQLParser::MIGRATE_SYMBOL:
        case MySQLParser::MINUTE_SYMBOL:
        case MySQLParser::MIN_ROWS_SYMBOL:
        case MySQLParser::MODE_SYMBOL:
        case MySQLParser::MODIFY_SYMBOL:
        case MySQLParser::MONTH_SYMBOL:
        case MySQLParser::MULTILINESTRING_SYMBOL:
        case MySQLParser::MULTIPOINT_SYMBOL:
        case MySQLParser::MULTIPOLYGON_SYMBOL:
        case MySQLParser::MUTEX_SYMBOL:
        case MySQLParser::MYSQL_ERRNO_SYMBOL:
        case MySQLParser::NAMES_SYMBOL:
        case MySQLParser::NAME_SYMBOL:
        case MySQLParser::NATIONAL_SYMBOL:
        case MySQLParser::NCHAR_SYMBOL:
        case MySQLParser::NDBCLUSTER_SYMBOL:
        case MySQLParser::NEVER_SYMBOL:
        case MySQLParser::NEW_SYMBOL:
        case MySQLParser::NEXT_SYMBOL:
        case MySQLParser::NODEGROUP_SYMBOL:
        case MySQLParser::NO_WAIT_SYMBOL:
        case MySQLParser::NUMBER_SYMBOL:
        case MySQLParser::NVARCHAR_SYMBOL:
        case MySQLParser::OFFSET_SYMBOL:
        case MySQLParser::ONE_SYMBOL:
        case MySQLParser::ONLY_SYMBOL:
        case MySQLParser::OPEN_SYMBOL:
        case MySQLParser::OPTIONS_SYMBOL:
        case MySQLParser::OWNER_SYMBOL:
        case MySQLParser::PACK_KEYS_SYMBOL:
        case MySQLParser::PAGE_SYMBOL:
        case MySQLParser::PARSER_SYMBOL:
        case MySQLParser::PARTIAL_SYMBOL:
        case MySQLParser::PARTITIONING_SYMBOL:
        case MySQLParser::PARTITIONS_SYMBOL:
        case MySQLParser::PASSWORD_SYMBOL:
        case MySQLParser::PHASE_SYMBOL:
        case MySQLParser::PLUGINS_SYMBOL:
        case MySQLParser::PLUGIN_DIR_SYMBOL:
        case MySQLParser::PLUGIN_SYMBOL:
        case MySQLParser::POINT_SYMBOL:
        case MySQLParser::POLYGON_SYMBOL:
        case MySQLParser::PORT_SYMBOL:
        case MySQLParser::PRESERVE_SYMBOL:
        case MySQLParser::PREV_SYMBOL:
        case MySQLParser::PRIVILEGES_SYMBOL:
        case MySQLParser::PROCESSLIST_SYMBOL:
        case MySQLParser::PROFILE_SYMBOL:
        case MySQLParser::PROFILES_SYMBOL:
        case MySQLParser::QUARTER_SYMBOL:
        case MySQLParser::QUERY_SYMBOL:
        case MySQLParser::QUICK_SYMBOL:
        case MySQLParser::READ_ONLY_SYMBOL:
        case MySQLParser::REBUILD_SYMBOL:
        case MySQLParser::RECOVER_SYMBOL:
        case MySQLParser::REDO_BUFFER_SIZE_SYMBOL:
        case MySQLParser::REDUNDANT_SYMBOL:
        case MySQLParser::RELAY_SYMBOL:
        case MySQLParser::RELAYLOG_SYMBOL:
        case MySQLParser::RELAY_LOG_FILE_SYMBOL:
        case MySQLParser::RELAY_LOG_POS_SYMBOL:
        case MySQLParser::RELAY_THREAD_SYMBOL:
        case MySQLParser::REMOVE_SYMBOL:
        case MySQLParser::REORGANIZE_SYMBOL:
        case MySQLParser::REPEATABLE_SYMBOL:
        case MySQLParser::REPLICATE_DO_DB_SYMBOL:
        case MySQLParser::REPLICATE_IGNORE_DB_SYMBOL:
        case MySQLParser::REPLICATE_DO_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL:
        case MySQLParser::REPLICATE_REWRITE_DB_SYMBOL:
        case MySQLParser::RESTORE_SYMBOL:
        case MySQLParser::RESUME_SYMBOL:
        case MySQLParser::RETURNED_SQLSTATE_SYMBOL:
        case MySQLParser::RETURNS_SYMBOL:
        case MySQLParser::REVERSE_SYMBOL:
        case MySQLParser::ROLLUP_SYMBOL:
        case MySQLParser::ROTATE_SYMBOL:
        case MySQLParser::ROUTINE_SYMBOL:
        case MySQLParser::ROW_COUNT_SYMBOL:
        case MySQLParser::ROW_FORMAT_SYMBOL:
        case MySQLParser::RTREE_SYMBOL:
        case MySQLParser::SCHEDULE_SYMBOL:
        case MySQLParser::SCHEMA_NAME_SYMBOL:
        case MySQLParser::SECOND_SYMBOL:
        case MySQLParser::SECURITY_SYMBOL:
        case MySQLParser::SERIALIZABLE_SYMBOL:
        case MySQLParser::SERIAL_SYMBOL:
        case MySQLParser::SERVER_SYMBOL:
        case MySQLParser::SHARE_SYMBOL:
        case MySQLParser::SIMPLE_SYMBOL:
        case MySQLParser::SLOW_SYMBOL:
        case MySQLParser::SNAPSHOT_SYMBOL:
        case MySQLParser::SOCKET_SYMBOL:
        case MySQLParser::SONAME_SYMBOL:
        case MySQLParser::SOUNDS_SYMBOL:
        case MySQLParser::SOURCE_SYMBOL:
        case MySQLParser::SQL_AFTER_GTIDS_SYMBOL:
        case MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL:
        case MySQLParser::SQL_BEFORE_GTIDS_SYMBOL:
        case MySQLParser::SQL_BUFFER_RESULT_SYMBOL:
        case MySQLParser::SQL_NO_CACHE_SYMBOL:
        case MySQLParser::SQL_THREAD_SYMBOL:
        case MySQLParser::STACKED_SYMBOL:
        case MySQLParser::STARTS_SYMBOL:
        case MySQLParser::STATS_AUTO_RECALC_SYMBOL:
        case MySQLParser::STATS_PERSISTENT_SYMBOL:
        case MySQLParser::STATS_SAMPLE_PAGES_SYMBOL:
        case MySQLParser::STATUS_SYMBOL:
        case MySQLParser::STORAGE_SYMBOL:
        case MySQLParser::STRING_SYMBOL:
        case MySQLParser::SUBCLASS_ORIGIN_SYMBOL:
        case MySQLParser::SUBDATE_SYMBOL:
        case MySQLParser::SUBJECT_SYMBOL:
        case MySQLParser::SUBPARTITIONS_SYMBOL:
        case MySQLParser::SUBPARTITION_SYMBOL:
        case MySQLParser::SUSPEND_SYMBOL:
        case MySQLParser::SWAPS_SYMBOL:
        case MySQLParser::SWITCHES_SYMBOL:
        case MySQLParser::TABLES_SYMBOL:
        case MySQLParser::TABLESPACE_SYMBOL:
        case MySQLParser::TABLE_CHECKSUM_SYMBOL:
        case MySQLParser::TABLE_NAME_SYMBOL:
        case MySQLParser::TEMPORARY_SYMBOL:
        case MySQLParser::TEMPTABLE_SYMBOL:
        case MySQLParser::TEXT_SYMBOL:
        case MySQLParser::THAN_SYMBOL:
        case MySQLParser::TIMESTAMP_SYMBOL:
        case MySQLParser::TIMESTAMP_ADD_SYMBOL:
        case MySQLParser::TIMESTAMP_DIFF_SYMBOL:
        case MySQLParser::TIME_SYMBOL:
        case MySQLParser::TRANSACTION_SYMBOL:
        case MySQLParser::TRIGGERS_SYMBOL:
        case MySQLParser::TYPES_SYMBOL:
        case MySQLParser::TYPE_SYMBOL:
        case MySQLParser::UNCOMMITTED_SYMBOL:
        case MySQLParser::UNDEFINED_SYMBOL:
        case MySQLParser::UNDOFILE_SYMBOL:
        case MySQLParser::UNDO_BUFFER_SIZE_SYMBOL:
        case MySQLParser::UNKNOWN_SYMBOL:
        case MySQLParser::UNTIL_SYMBOL:
        case MySQLParser::UPGRADE_SYMBOL:
        case MySQLParser::USER_RESOURCES_SYMBOL:
        case MySQLParser::USER_SYMBOL:
        case MySQLParser::USE_FRM_SYMBOL:
        case MySQLParser::VALIDATION_SYMBOL:
        case MySQLParser::VALUE_SYMBOL:
        case MySQLParser::VARIABLES_SYMBOL:
        case MySQLParser::VIEW_SYMBOL:
        case MySQLParser::WAIT_SYMBOL:
        case MySQLParser::WARNINGS_SYMBOL:
        case MySQLParser::WEEK_SYMBOL:
        case MySQLParser::WEIGHT_STRING_SYMBOL:
        case MySQLParser::WITHOUT_SYMBOL:
        case MySQLParser::WORK_SYMBOL:
        case MySQLParser::WRAPPER_SYMBOL:
        case MySQLParser::X509_SYMBOL:
        case MySQLParser::XID_SYMBOL:
        case MySQLParser::XML_SYMBOL:
        case MySQLParser::YEAR_SYMBOL:
        case MySQLParser::ROLE_SYMBOL:
        case MySQLParser::ADMIN_SYMBOL:
        case MySQLParser::INVISIBLE_SYMBOL:
        case MySQLParser::VISIBLE_SYMBOL:
        case MySQLParser::COMPONENT_SYMBOL:
        case MySQLParser::SKIP_SYMBOL:
        case MySQLParser::LOCKED_SYMBOL:
        case MySQLParser::NOWAIT_SYMBOL:
        case MySQLParser::HISTOGRAM_SYMBOL:
        case MySQLParser::BUCKETS_SYMBOL:
        case MySQLParser::EXCLUDE_SYMBOL:
        case MySQLParser::FOLLOWING_SYMBOL:
        case MySQLParser::NULLS_SYMBOL:
        case MySQLParser::OTHERS_SYMBOL:
        case MySQLParser::PRECEDING_SYMBOL:
        case MySQLParser::RESPECT_SYMBOL:
        case MySQLParser::TIES_SYMBOL:
        case MySQLParser::UNBOUNDED_SYMBOL:
        case MySQLParser::NESTED_SYMBOL:
        case MySQLParser::ORDINALITY_SYMBOL:
        case MySQLParser::PATH_SYMBOL:
        case MySQLParser::HISTORY_SYMBOL:
        case MySQLParser::REUSE_SYMBOL:
        case MySQLParser::SRID_SYMBOL:
        case MySQLParser::THREAD_PRIORITY_SYMBOL:
        case MySQLParser::VCPU_SYMBOL:
        case MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL:
        case MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL:
        case MySQLParser::DEFINITION_SYMBOL:
        case MySQLParser::DESCRIPTION_SYMBOL:
        case MySQLParser::ORGANIZATION_SYMBOL:
        case MySQLParser::REFERENCE_SYMBOL:
        case MySQLParser::OPTIONAL_SYMBOL:
        case MySQLParser::SECONDARY_SYMBOL:
        case MySQLParser::SECONDARY_ENGINE_SYMBOL:
        case MySQLParser::SECONDARY_LOAD_SYMBOL:
        case MySQLParser::SECONDARY_UNLOAD_SYMBOL:
        case MySQLParser::ACTIVE_SYMBOL:
        case MySQLParser::INACTIVE_SYMBOL:
        case MySQLParser::RETAIN_SYMBOL:
        case MySQLParser::OLD_SYMBOL:
        case MySQLParser::NETWORK_NAMESPACE_SYMBOL:
        case MySQLParser::ENFORCED_SYMBOL:
        case MySQLParser::OJ_SYMBOL: {
          setState(8277);
          identifierKeywordsUnambiguous();
          break;
        }

        case MySQLParser::ASCII_SYMBOL:
        case MySQLParser::BEGIN_SYMBOL:
        case MySQLParser::BYTE_SYMBOL:
        case MySQLParser::CACHE_SYMBOL:
        case MySQLParser::CHARSET_SYMBOL:
        case MySQLParser::CHECKSUM_SYMBOL:
        case MySQLParser::COMMENT_SYMBOL:
        case MySQLParser::COMMIT_SYMBOL:
        case MySQLParser::CONTAINS_SYMBOL:
        case MySQLParser::DEALLOCATE_SYMBOL:
        case MySQLParser::DO_SYMBOL:
        case MySQLParser::END_SYMBOL:
        case MySQLParser::FLUSH_SYMBOL:
        case MySQLParser::FOLLOWS_SYMBOL:
        case MySQLParser::HANDLER_SYMBOL:
        case MySQLParser::HELP_SYMBOL:
        case MySQLParser::IMPORT_SYMBOL:
        case MySQLParser::INSTALL_SYMBOL:
        case MySQLParser::LANGUAGE_SYMBOL:
        case MySQLParser::NO_SYMBOL:
        case MySQLParser::PRECEDES_SYMBOL:
        case MySQLParser::PREPARE_SYMBOL:
        case MySQLParser::REPAIR_SYMBOL:
        case MySQLParser::RESET_SYMBOL:
        case MySQLParser::ROLLBACK_SYMBOL:
        case MySQLParser::SAVEPOINT_SYMBOL:
        case MySQLParser::SIGNED_SYMBOL:
        case MySQLParser::SLAVE_SYMBOL:
        case MySQLParser::START_SYMBOL:
        case MySQLParser::STOP_SYMBOL:
        case MySQLParser::TRUNCATE_SYMBOL:
        case MySQLParser::UNICODE_SYMBOL:
        case MySQLParser::UNINSTALL_SYMBOL:
        case MySQLParser::XA_SYMBOL:
        case MySQLParser::CLONE_SYMBOL: {
          setState(8278);
          identifierKeywordsAmbiguous2Labels();
          break;
        }

        case MySQLParser::GLOBAL_SYMBOL:
        case MySQLParser::LOCAL_SYMBOL:
        case MySQLParser::SESSION_SYMBOL:
        case MySQLParser::PERSIST_SYMBOL:
        case MySQLParser::PERSIST_ONLY_SYMBOL: {
          setState(8279);
          identifierKeywordsAmbiguous4SystemVariables();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LValueKeywordContext ------------------------------------------------------------------

MySQLParser::LValueKeywordContext::LValueKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

MySQLParser::IdentifierKeywordsUnambiguousContext* MySQLParser::LValueKeywordContext::identifierKeywordsUnambiguous() {
  return getRuleContext<MySQLParser::IdentifierKeywordsUnambiguousContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext* MySQLParser::LValueKeywordContext::identifierKeywordsAmbiguous1RolesAndLabels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous1RolesAndLabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext* MySQLParser::LValueKeywordContext::identifierKeywordsAmbiguous2Labels() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous2LabelsContext>(0);
}

MySQLParser::IdentifierKeywordsAmbiguous3RolesContext* MySQLParser::LValueKeywordContext::identifierKeywordsAmbiguous3Roles() {
  return getRuleContext<MySQLParser::IdentifierKeywordsAmbiguous3RolesContext>(0);
}


size_t MySQLParser::LValueKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleLValueKeyword;
}

void MySQLParser::LValueKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterLValueKeyword(this);
}

void MySQLParser::LValueKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitLValueKeyword(this);
}

MySQLParser::LValueKeywordContext* MySQLParser::lValueKeyword() {
  LValueKeywordContext *_localctx = _tracker.createInstance<LValueKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1196, MySQLParser::RuleLValueKeyword);

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8288);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case MySQLParser::ACCOUNT_SYMBOL:
      case MySQLParser::ACTION_SYMBOL:
      case MySQLParser::ADDDATE_SYMBOL:
      case MySQLParser::AFTER_SYMBOL:
      case MySQLParser::AGAINST_SYMBOL:
      case MySQLParser::AGGREGATE_SYMBOL:
      case MySQLParser::ALGORITHM_SYMBOL:
      case MySQLParser::ALWAYS_SYMBOL:
      case MySQLParser::ANY_SYMBOL:
      case MySQLParser::AT_SYMBOL:
      case MySQLParser::AUTOEXTEND_SIZE_SYMBOL:
      case MySQLParser::AUTO_INCREMENT_SYMBOL:
      case MySQLParser::AVG_ROW_LENGTH_SYMBOL:
      case MySQLParser::AVG_SYMBOL:
      case MySQLParser::BACKUP_SYMBOL:
      case MySQLParser::BINLOG_SYMBOL:
      case MySQLParser::BIT_SYMBOL:
      case MySQLParser::BLOCK_SYMBOL:
      case MySQLParser::BOOLEAN_SYMBOL:
      case MySQLParser::BOOL_SYMBOL:
      case MySQLParser::BTREE_SYMBOL:
      case MySQLParser::CASCADED_SYMBOL:
      case MySQLParser::CATALOG_NAME_SYMBOL:
      case MySQLParser::CHAIN_SYMBOL:
      case MySQLParser::CHANGED_SYMBOL:
      case MySQLParser::CHANNEL_SYMBOL:
      case MySQLParser::CIPHER_SYMBOL:
      case MySQLParser::CLASS_ORIGIN_SYMBOL:
      case MySQLParser::CLIENT_SYMBOL:
      case MySQLParser::CLOSE_SYMBOL:
      case MySQLParser::COALESCE_SYMBOL:
      case MySQLParser::CODE_SYMBOL:
      case MySQLParser::COLLATION_SYMBOL:
      case MySQLParser::COLUMNS_SYMBOL:
      case MySQLParser::COLUMN_NAME_SYMBOL:
      case MySQLParser::COLUMN_FORMAT_SYMBOL:
      case MySQLParser::COMMITTED_SYMBOL:
      case MySQLParser::COMPACT_SYMBOL:
      case MySQLParser::COMPLETION_SYMBOL:
      case MySQLParser::COMPRESSED_SYMBOL:
      case MySQLParser::COMPRESSION_SYMBOL:
      case MySQLParser::CONCURRENT_SYMBOL:
      case MySQLParser::CONNECTION_SYMBOL:
      case MySQLParser::CONSISTENT_SYMBOL:
      case MySQLParser::CONSTRAINT_CATALOG_SYMBOL:
      case MySQLParser::CONSTRAINT_NAME_SYMBOL:
      case MySQLParser::CONSTRAINT_SCHEMA_SYMBOL:
      case MySQLParser::CONTEXT_SYMBOL:
      case MySQLParser::CPU_SYMBOL:
      case MySQLParser::CURRENT_SYMBOL:
      case MySQLParser::CURSOR_NAME_SYMBOL:
      case MySQLParser::DATAFILE_SYMBOL:
      case MySQLParser::DATA_SYMBOL:
      case MySQLParser::DATETIME_SYMBOL:
      case MySQLParser::DATE_SYMBOL:
      case MySQLParser::DAY_SYMBOL:
      case MySQLParser::DEFAULT_AUTH_SYMBOL:
      case MySQLParser::DEFINER_SYMBOL:
      case MySQLParser::DELAY_KEY_WRITE_SYMBOL:
      case MySQLParser::DIAGNOSTICS_SYMBOL:
      case MySQLParser::DIRECTORY_SYMBOL:
      case MySQLParser::DISABLE_SYMBOL:
      case MySQLParser::DISCARD_SYMBOL:
      case MySQLParser::DISK_SYMBOL:
      case MySQLParser::DUMPFILE_SYMBOL:
      case MySQLParser::DUPLICATE_SYMBOL:
      case MySQLParser::DYNAMIC_SYMBOL:
      case MySQLParser::ENABLE_SYMBOL:
      case MySQLParser::ENCRYPTION_SYMBOL:
      case MySQLParser::ENDS_SYMBOL:
      case MySQLParser::ENGINES_SYMBOL:
      case MySQLParser::ENGINE_SYMBOL:
      case MySQLParser::ENUM_SYMBOL:
      case MySQLParser::ERROR_SYMBOL:
      case MySQLParser::ERRORS_SYMBOL:
      case MySQLParser::ESCAPE_SYMBOL:
      case MySQLParser::EVENTS_SYMBOL:
      case MySQLParser::EVERY_SYMBOL:
      case MySQLParser::EXCHANGE_SYMBOL:
      case MySQLParser::EXPANSION_SYMBOL:
      case MySQLParser::EXPIRE_SYMBOL:
      case MySQLParser::EXPORT_SYMBOL:
      case MySQLParser::EXTENDED_SYMBOL:
      case MySQLParser::EXTENT_SIZE_SYMBOL:
      case MySQLParser::FAST_SYMBOL:
      case MySQLParser::FAULTS_SYMBOL:
      case MySQLParser::FILE_BLOCK_SIZE_SYMBOL:
      case MySQLParser::FILTER_SYMBOL:
      case MySQLParser::FIRST_SYMBOL:
      case MySQLParser::FIXED_SYMBOL:
      case MySQLParser::FORMAT_SYMBOL:
      case MySQLParser::FOUND_SYMBOL:
      case MySQLParser::FULL_SYMBOL:
      case MySQLParser::GENERAL_SYMBOL:
      case MySQLParser::GROUP_REPLICATION_SYMBOL:
      case MySQLParser::GEOMETRYCOLLECTION_SYMBOL:
      case MySQLParser::GEOMETRY_SYMBOL:
      case MySQLParser::GET_FORMAT_SYMBOL:
      case MySQLParser::GRANTS_SYMBOL:
      case MySQLParser::HASH_SYMBOL:
      case MySQLParser::HOST_SYMBOL:
      case MySQLParser::HOSTS_SYMBOL:
      case MySQLParser::HOUR_SYMBOL:
      case MySQLParser::IDENTIFIED_SYMBOL:
      case MySQLParser::IGNORE_SERVER_IDS_SYMBOL:
      case MySQLParser::INDEXES_SYMBOL:
      case MySQLParser::INITIAL_SIZE_SYMBOL:
      case MySQLParser::INSERT_METHOD_SYMBOL:
      case MySQLParser::INSTANCE_SYMBOL:
      case MySQLParser::INVOKER_SYMBOL:
      case MySQLParser::IO_SYMBOL:
      case MySQLParser::IPC_SYMBOL:
      case MySQLParser::ISOLATION_SYMBOL:
      case MySQLParser::ISSUER_SYMBOL:
      case MySQLParser::JSON_SYMBOL:
      case MySQLParser::KEY_BLOCK_SIZE_SYMBOL:
      case MySQLParser::LAST_SYMBOL:
      case MySQLParser::LEAVES_SYMBOL:
      case MySQLParser::LESS_SYMBOL:
      case MySQLParser::LEVEL_SYMBOL:
      case MySQLParser::LINESTRING_SYMBOL:
      case MySQLParser::LIST_SYMBOL:
      case MySQLParser::LOCKS_SYMBOL:
      case MySQLParser::LOGFILE_SYMBOL:
      case MySQLParser::LOGS_SYMBOL:
      case MySQLParser::MASTER_AUTO_POSITION_SYMBOL:
      case MySQLParser::MASTER_CONNECT_RETRY_SYMBOL:
      case MySQLParser::MASTER_DELAY_SYMBOL:
      case MySQLParser::MASTER_HOST_SYMBOL:
      case MySQLParser::MASTER_LOG_FILE_SYMBOL:
      case MySQLParser::MASTER_LOG_POS_SYMBOL:
      case MySQLParser::MASTER_PASSWORD_SYMBOL:
      case MySQLParser::MASTER_PORT_SYMBOL:
      case MySQLParser::MASTER_RETRY_COUNT_SYMBOL:
      case MySQLParser::MASTER_SERVER_ID_SYMBOL:
      case MySQLParser::MASTER_SSL_CAPATH_SYMBOL:
      case MySQLParser::MASTER_SSL_CA_SYMBOL:
      case MySQLParser::MASTER_SSL_CERT_SYMBOL:
      case MySQLParser::MASTER_SSL_CIPHER_SYMBOL:
      case MySQLParser::MASTER_SSL_CRL_SYMBOL:
      case MySQLParser::MASTER_SSL_CRLPATH_SYMBOL:
      case MySQLParser::MASTER_SSL_KEY_SYMBOL:
      case MySQLParser::MASTER_SSL_SYMBOL:
      case MySQLParser::MASTER_SYMBOL:
      case MySQLParser::MASTER_TLS_VERSION_SYMBOL:
      case MySQLParser::MASTER_USER_SYMBOL:
      case MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL:
      case MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL:
      case MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL:
      case MySQLParser::MAX_ROWS_SYMBOL:
      case MySQLParser::MAX_SIZE_SYMBOL:
      case MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL:
      case MySQLParser::MAX_USER_CONNECTIONS_SYMBOL:
      case MySQLParser::MEDIUM_SYMBOL:
      case MySQLParser::MEMORY_SYMBOL:
      case MySQLParser::MERGE_SYMBOL:
      case MySQLParser::MESSAGE_TEXT_SYMBOL:
      case MySQLParser::MICROSECOND_SYMBOL:
      case MySQLParser::MIGRATE_SYMBOL:
      case MySQLParser::MINUTE_SYMBOL:
      case MySQLParser::MIN_ROWS_SYMBOL:
      case MySQLParser::MODE_SYMBOL:
      case MySQLParser::MODIFY_SYMBOL:
      case MySQLParser::MONTH_SYMBOL:
      case MySQLParser::MULTILINESTRING_SYMBOL:
      case MySQLParser::MULTIPOINT_SYMBOL:
      case MySQLParser::MULTIPOLYGON_SYMBOL:
      case MySQLParser::MUTEX_SYMBOL:
      case MySQLParser::MYSQL_ERRNO_SYMBOL:
      case MySQLParser::NAMES_SYMBOL:
      case MySQLParser::NAME_SYMBOL:
      case MySQLParser::NATIONAL_SYMBOL:
      case MySQLParser::NCHAR_SYMBOL:
      case MySQLParser::NDBCLUSTER_SYMBOL:
      case MySQLParser::NEVER_SYMBOL:
      case MySQLParser::NEW_SYMBOL:
      case MySQLParser::NEXT_SYMBOL:
      case MySQLParser::NODEGROUP_SYMBOL:
      case MySQLParser::NO_WAIT_SYMBOL:
      case MySQLParser::NUMBER_SYMBOL:
      case MySQLParser::NVARCHAR_SYMBOL:
      case MySQLParser::OFFSET_SYMBOL:
      case MySQLParser::ONE_SYMBOL:
      case MySQLParser::ONLY_SYMBOL:
      case MySQLParser::OPEN_SYMBOL:
      case MySQLParser::OPTIONS_SYMBOL:
      case MySQLParser::OWNER_SYMBOL:
      case MySQLParser::PACK_KEYS_SYMBOL:
      case MySQLParser::PAGE_SYMBOL:
      case MySQLParser::PARSER_SYMBOL:
      case MySQLParser::PARTIAL_SYMBOL:
      case MySQLParser::PARTITIONING_SYMBOL:
      case MySQLParser::PARTITIONS_SYMBOL:
      case MySQLParser::PASSWORD_SYMBOL:
      case MySQLParser::PHASE_SYMBOL:
      case MySQLParser::PLUGINS_SYMBOL:
      case MySQLParser::PLUGIN_DIR_SYMBOL:
      case MySQLParser::PLUGIN_SYMBOL:
      case MySQLParser::POINT_SYMBOL:
      case MySQLParser::POLYGON_SYMBOL:
      case MySQLParser::PORT_SYMBOL:
      case MySQLParser::PRESERVE_SYMBOL:
      case MySQLParser::PREV_SYMBOL:
      case MySQLParser::PRIVILEGES_SYMBOL:
      case MySQLParser::PROCESSLIST_SYMBOL:
      case MySQLParser::PROFILE_SYMBOL:
      case MySQLParser::PROFILES_SYMBOL:
      case MySQLParser::QUARTER_SYMBOL:
      case MySQLParser::QUERY_SYMBOL:
      case MySQLParser::QUICK_SYMBOL:
      case MySQLParser::READ_ONLY_SYMBOL:
      case MySQLParser::REBUILD_SYMBOL:
      case MySQLParser::RECOVER_SYMBOL:
      case MySQLParser::REDO_BUFFER_SIZE_SYMBOL:
      case MySQLParser::REDUNDANT_SYMBOL:
      case MySQLParser::RELAY_SYMBOL:
      case MySQLParser::RELAYLOG_SYMBOL:
      case MySQLParser::RELAY_LOG_FILE_SYMBOL:
      case MySQLParser::RELAY_LOG_POS_SYMBOL:
      case MySQLParser::RELAY_THREAD_SYMBOL:
      case MySQLParser::REMOVE_SYMBOL:
      case MySQLParser::REORGANIZE_SYMBOL:
      case MySQLParser::REPEATABLE_SYMBOL:
      case MySQLParser::REPLICATE_DO_DB_SYMBOL:
      case MySQLParser::REPLICATE_IGNORE_DB_SYMBOL:
      case MySQLParser::REPLICATE_DO_TABLE_SYMBOL:
      case MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL:
      case MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL:
      case MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL:
      case MySQLParser::REPLICATE_REWRITE_DB_SYMBOL:
      case MySQLParser::RESTORE_SYMBOL:
      case MySQLParser::RESUME_SYMBOL:
      case MySQLParser::RETURNED_SQLSTATE_SYMBOL:
      case MySQLParser::RETURNS_SYMBOL:
      case MySQLParser::REVERSE_SYMBOL:
      case MySQLParser::ROLLUP_SYMBOL:
      case MySQLParser::ROTATE_SYMBOL:
      case MySQLParser::ROUTINE_SYMBOL:
      case MySQLParser::ROW_COUNT_SYMBOL:
      case MySQLParser::ROW_FORMAT_SYMBOL:
      case MySQLParser::RTREE_SYMBOL:
      case MySQLParser::SCHEDULE_SYMBOL:
      case MySQLParser::SCHEMA_NAME_SYMBOL:
      case MySQLParser::SECOND_SYMBOL:
      case MySQLParser::SECURITY_SYMBOL:
      case MySQLParser::SERIALIZABLE_SYMBOL:
      case MySQLParser::SERIAL_SYMBOL:
      case MySQLParser::SERVER_SYMBOL:
      case MySQLParser::SHARE_SYMBOL:
      case MySQLParser::SIMPLE_SYMBOL:
      case MySQLParser::SLOW_SYMBOL:
      case MySQLParser::SNAPSHOT_SYMBOL:
      case MySQLParser::SOCKET_SYMBOL:
      case MySQLParser::SONAME_SYMBOL:
      case MySQLParser::SOUNDS_SYMBOL:
      case MySQLParser::SOURCE_SYMBOL:
      case MySQLParser::SQL_AFTER_GTIDS_SYMBOL:
      case MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL:
      case MySQLParser::SQL_BEFORE_GTIDS_SYMBOL:
      case MySQLParser::SQL_BUFFER_RESULT_SYMBOL:
      case MySQLParser::SQL_NO_CACHE_SYMBOL:
      case MySQLParser::SQL_THREAD_SYMBOL:
      case MySQLParser::STACKED_SYMBOL:
      case MySQLParser::STARTS_SYMBOL:
      case MySQLParser::STATS_AUTO_RECALC_SYMBOL:
      case MySQLParser::STATS_PERSISTENT_SYMBOL:
      case MySQLParser::STATS_SAMPLE_PAGES_SYMBOL:
      case MySQLParser::STATUS_SYMBOL:
      case MySQLParser::STORAGE_SYMBOL:
      case MySQLParser::STRING_SYMBOL:
      case MySQLParser::SUBCLASS_ORIGIN_SYMBOL:
      case MySQLParser::SUBDATE_SYMBOL:
      case MySQLParser::SUBJECT_SYMBOL:
      case MySQLParser::SUBPARTITIONS_SYMBOL:
      case MySQLParser::SUBPARTITION_SYMBOL:
      case MySQLParser::SUSPEND_SYMBOL:
      case MySQLParser::SWAPS_SYMBOL:
      case MySQLParser::SWITCHES_SYMBOL:
      case MySQLParser::TABLES_SYMBOL:
      case MySQLParser::TABLESPACE_SYMBOL:
      case MySQLParser::TABLE_CHECKSUM_SYMBOL:
      case MySQLParser::TABLE_NAME_SYMBOL:
      case MySQLParser::TEMPORARY_SYMBOL:
      case MySQLParser::TEMPTABLE_SYMBOL:
      case MySQLParser::TEXT_SYMBOL:
      case MySQLParser::THAN_SYMBOL:
      case MySQLParser::TIMESTAMP_SYMBOL:
      case MySQLParser::TIMESTAMP_ADD_SYMBOL:
      case MySQLParser::TIMESTAMP_DIFF_SYMBOL:
      case MySQLParser::TIME_SYMBOL:
      case MySQLParser::TRANSACTION_SYMBOL:
      case MySQLParser::TRIGGERS_SYMBOL:
      case MySQLParser::TYPES_SYMBOL:
      case MySQLParser::TYPE_SYMBOL:
      case MySQLParser::UNCOMMITTED_SYMBOL:
      case MySQLParser::UNDEFINED_SYMBOL:
      case MySQLParser::UNDOFILE_SYMBOL:
      case MySQLParser::UNDO_BUFFER_SIZE_SYMBOL:
      case MySQLParser::UNKNOWN_SYMBOL:
      case MySQLParser::UNTIL_SYMBOL:
      case MySQLParser::UPGRADE_SYMBOL:
      case MySQLParser::USER_RESOURCES_SYMBOL:
      case MySQLParser::USER_SYMBOL:
      case MySQLParser::USE_FRM_SYMBOL:
      case MySQLParser::VALIDATION_SYMBOL:
      case MySQLParser::VALUE_SYMBOL:
      case MySQLParser::VARIABLES_SYMBOL:
      case MySQLParser::VIEW_SYMBOL:
      case MySQLParser::WAIT_SYMBOL:
      case MySQLParser::WARNINGS_SYMBOL:
      case MySQLParser::WEEK_SYMBOL:
      case MySQLParser::WEIGHT_STRING_SYMBOL:
      case MySQLParser::WITHOUT_SYMBOL:
      case MySQLParser::WORK_SYMBOL:
      case MySQLParser::WRAPPER_SYMBOL:
      case MySQLParser::X509_SYMBOL:
      case MySQLParser::XID_SYMBOL:
      case MySQLParser::XML_SYMBOL:
      case MySQLParser::YEAR_SYMBOL:
      case MySQLParser::ROLE_SYMBOL:
      case MySQLParser::ADMIN_SYMBOL:
      case MySQLParser::INVISIBLE_SYMBOL:
      case MySQLParser::VISIBLE_SYMBOL:
      case MySQLParser::COMPONENT_SYMBOL:
      case MySQLParser::SKIP_SYMBOL:
      case MySQLParser::LOCKED_SYMBOL:
      case MySQLParser::NOWAIT_SYMBOL:
      case MySQLParser::HISTOGRAM_SYMBOL:
      case MySQLParser::BUCKETS_SYMBOL:
      case MySQLParser::EXCLUDE_SYMBOL:
      case MySQLParser::FOLLOWING_SYMBOL:
      case MySQLParser::NULLS_SYMBOL:
      case MySQLParser::OTHERS_SYMBOL:
      case MySQLParser::PRECEDING_SYMBOL:
      case MySQLParser::RESPECT_SYMBOL:
      case MySQLParser::TIES_SYMBOL:
      case MySQLParser::UNBOUNDED_SYMBOL:
      case MySQLParser::NESTED_SYMBOL:
      case MySQLParser::ORDINALITY_SYMBOL:
      case MySQLParser::PATH_SYMBOL:
      case MySQLParser::HISTORY_SYMBOL:
      case MySQLParser::REUSE_SYMBOL:
      case MySQLParser::SRID_SYMBOL:
      case MySQLParser::THREAD_PRIORITY_SYMBOL:
      case MySQLParser::VCPU_SYMBOL:
      case MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL:
      case MySQLParser::GET_MASTER_PUBLIC_KEY_SYMBOL:
      case MySQLParser::DEFINITION_SYMBOL:
      case MySQLParser::DESCRIPTION_SYMBOL:
      case MySQLParser::ORGANIZATION_SYMBOL:
      case MySQLParser::REFERENCE_SYMBOL:
      case MySQLParser::OPTIONAL_SYMBOL:
      case MySQLParser::SECONDARY_SYMBOL:
      case MySQLParser::SECONDARY_ENGINE_SYMBOL:
      case MySQLParser::SECONDARY_LOAD_SYMBOL:
      case MySQLParser::SECONDARY_UNLOAD_SYMBOL:
      case MySQLParser::ACTIVE_SYMBOL:
      case MySQLParser::INACTIVE_SYMBOL:
      case MySQLParser::RETAIN_SYMBOL:
      case MySQLParser::OLD_SYMBOL:
      case MySQLParser::NETWORK_NAMESPACE_SYMBOL:
      case MySQLParser::ENFORCED_SYMBOL:
      case MySQLParser::OJ_SYMBOL: {
        enterOuterAlt(_localctx, 1);
        setState(8284);
        identifierKeywordsUnambiguous();
        break;
      }

      case MySQLParser::EXECUTE_SYMBOL:
      case MySQLParser::SHUTDOWN_SYMBOL:
      case MySQLParser::RESTART_SYMBOL: {
        enterOuterAlt(_localctx, 2);
        setState(8285);
        identifierKeywordsAmbiguous1RolesAndLabels();
        break;
      }

      case MySQLParser::ASCII_SYMBOL:
      case MySQLParser::BEGIN_SYMBOL:
      case MySQLParser::BYTE_SYMBOL:
      case MySQLParser::CACHE_SYMBOL:
      case MySQLParser::CHARSET_SYMBOL:
      case MySQLParser::CHECKSUM_SYMBOL:
      case MySQLParser::COMMENT_SYMBOL:
      case MySQLParser::COMMIT_SYMBOL:
      case MySQLParser::CONTAINS_SYMBOL:
      case MySQLParser::DEALLOCATE_SYMBOL:
      case MySQLParser::DO_SYMBOL:
      case MySQLParser::END_SYMBOL:
      case MySQLParser::FLUSH_SYMBOL:
      case MySQLParser::FOLLOWS_SYMBOL:
      case MySQLParser::HANDLER_SYMBOL:
      case MySQLParser::HELP_SYMBOL:
      case MySQLParser::IMPORT_SYMBOL:
      case MySQLParser::INSTALL_SYMBOL:
      case MySQLParser::LANGUAGE_SYMBOL:
      case MySQLParser::NO_SYMBOL:
      case MySQLParser::PRECEDES_SYMBOL:
      case MySQLParser::PREPARE_SYMBOL:
      case MySQLParser::REPAIR_SYMBOL:
      case MySQLParser::RESET_SYMBOL:
      case MySQLParser::ROLLBACK_SYMBOL:
      case MySQLParser::SAVEPOINT_SYMBOL:
      case MySQLParser::SIGNED_SYMBOL:
      case MySQLParser::SLAVE_SYMBOL:
      case MySQLParser::START_SYMBOL:
      case MySQLParser::STOP_SYMBOL:
      case MySQLParser::TRUNCATE_SYMBOL:
      case MySQLParser::UNICODE_SYMBOL:
      case MySQLParser::UNINSTALL_SYMBOL:
      case MySQLParser::XA_SYMBOL:
      case MySQLParser::CLONE_SYMBOL: {
        enterOuterAlt(_localctx, 3);
        setState(8286);
        identifierKeywordsAmbiguous2Labels();
        break;
      }

      case MySQLParser::EVENT_SYMBOL:
      case MySQLParser::FILE_SYMBOL:
      case MySQLParser::NONE_SYMBOL:
      case MySQLParser::PROCESS_SYMBOL:
      case MySQLParser::PROXY_SYMBOL:
      case MySQLParser::RELOAD_SYMBOL:
      case MySQLParser::REPLICATION_SYMBOL:
      case MySQLParser::SUPER_SYMBOL:
      case MySQLParser::RESOURCE_SYMBOL: {
        enterOuterAlt(_localctx, 4);
        setState(8287);
        identifierKeywordsAmbiguous3Roles();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IdentifierKeywordsAmbiguous4SystemVariablesContext ------------------------------------------------------------------

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::IdentifierKeywordsAmbiguous4SystemVariablesContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::PERSIST_SYMBOL() {
  return getToken(MySQLParser::PERSIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::PERSIST_ONLY_SYMBOL() {
  return getToken(MySQLParser::PERSIST_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}


size_t MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::getRuleIndex() const {
  return MySQLParser::RuleIdentifierKeywordsAmbiguous4SystemVariables;
}

void MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterIdentifierKeywordsAmbiguous4SystemVariables(this);
}

void MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitIdentifierKeywordsAmbiguous4SystemVariables(this);
}

MySQLParser::IdentifierKeywordsAmbiguous4SystemVariablesContext* MySQLParser::identifierKeywordsAmbiguous4SystemVariables() {
  IdentifierKeywordsAmbiguous4SystemVariablesContext *_localctx = _tracker.createInstance<IdentifierKeywordsAmbiguous4SystemVariablesContext>(_ctx, getState());
  enterRule(_localctx, 1198, MySQLParser::RuleIdentifierKeywordsAmbiguous4SystemVariables);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(8290);
    _la = _input->LA(1);
    if (!(_la == MySQLParser::GLOBAL_SYMBOL || _la == MySQLParser::LOCAL_SYMBOL || _la == MySQLParser::SESSION_SYMBOL || _la == MySQLParser::PERSIST_SYMBOL

    || _la == MySQLParser::PERSIST_ONLY_SYMBOL)) {
    _errHandler->recoverInline(this);
    }
    else {
      _errHandler->reportMatch(this);
      consume();
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrIdentifierKeywordContext ------------------------------------------------------------------

MySQLParser::RoleOrIdentifierKeywordContext::RoleOrIdentifierKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ACCOUNT_SYMBOL() {
  return getToken(MySQLParser::ACCOUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ASCII_SYMBOL() {
  return getToken(MySQLParser::ASCII_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ALWAYS_SYMBOL() {
  return getToken(MySQLParser::ALWAYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::BACKUP_SYMBOL() {
  return getToken(MySQLParser::BACKUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::BEGIN_SYMBOL() {
  return getToken(MySQLParser::BEGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::BYTE_SYMBOL() {
  return getToken(MySQLParser::BYTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CACHE_SYMBOL() {
  return getToken(MySQLParser::CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CHARSET_SYMBOL() {
  return getToken(MySQLParser::CHARSET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CLONE_SYMBOL() {
  return getToken(MySQLParser::CLONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CLOSE_SYMBOL() {
  return getToken(MySQLParser::CLOSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::COMMENT_SYMBOL() {
  return getToken(MySQLParser::COMMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::COMMIT_SYMBOL() {
  return getToken(MySQLParser::COMMIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::CONTAINS_SYMBOL() {
  return getToken(MySQLParser::CONTAINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::DEALLOCATE_SYMBOL() {
  return getToken(MySQLParser::DEALLOCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::DO_SYMBOL() {
  return getToken(MySQLParser::DO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::END_SYMBOL() {
  return getToken(MySQLParser::END_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::FLUSH_SYMBOL() {
  return getToken(MySQLParser::FLUSH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::FOLLOWS_SYMBOL() {
  return getToken(MySQLParser::FOLLOWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::FORMAT_SYMBOL() {
  return getToken(MySQLParser::FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::GROUP_REPLICATION_SYMBOL() {
  return getToken(MySQLParser::GROUP_REPLICATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::HANDLER_SYMBOL() {
  return getToken(MySQLParser::HANDLER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::HELP_SYMBOL() {
  return getToken(MySQLParser::HELP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::HOST_SYMBOL() {
  return getToken(MySQLParser::HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::INSTALL_SYMBOL() {
  return getToken(MySQLParser::INSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::INVISIBLE_SYMBOL() {
  return getToken(MySQLParser::INVISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::LANGUAGE_SYMBOL() {
  return getToken(MySQLParser::LANGUAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::NO_SYMBOL() {
  return getToken(MySQLParser::NO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::OPEN_SYMBOL() {
  return getToken(MySQLParser::OPEN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::OPTIONS_SYMBOL() {
  return getToken(MySQLParser::OPTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::OWNER_SYMBOL() {
  return getToken(MySQLParser::OWNER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PARSER_SYMBOL() {
  return getToken(MySQLParser::PARSER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PARTITION_SYMBOL() {
  return getToken(MySQLParser::PARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PORT_SYMBOL() {
  return getToken(MySQLParser::PORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PRECEDES_SYMBOL() {
  return getToken(MySQLParser::PRECEDES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::PREPARE_SYMBOL() {
  return getToken(MySQLParser::PREPARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::REMOVE_SYMBOL() {
  return getToken(MySQLParser::REMOVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::REPAIR_SYMBOL() {
  return getToken(MySQLParser::REPAIR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::RESET_SYMBOL() {
  return getToken(MySQLParser::RESET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::RESTORE_SYMBOL() {
  return getToken(MySQLParser::RESTORE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ROLE_SYMBOL() {
  return getToken(MySQLParser::ROLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::ROLLBACK_SYMBOL() {
  return getToken(MySQLParser::ROLLBACK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SAVEPOINT_SYMBOL() {
  return getToken(MySQLParser::SAVEPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_ENGINE_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_LOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_LOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECONDARY_UNLOAD_SYMBOL() {
  return getToken(MySQLParser::SECONDARY_UNLOAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SECURITY_SYMBOL() {
  return getToken(MySQLParser::SECURITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SERVER_SYMBOL() {
  return getToken(MySQLParser::SERVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SIGNED_SYMBOL() {
  return getToken(MySQLParser::SIGNED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SOCKET_SYMBOL() {
  return getToken(MySQLParser::SOCKET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SLAVE_SYMBOL() {
  return getToken(MySQLParser::SLAVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SONAME_SYMBOL() {
  return getToken(MySQLParser::SONAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::START_SYMBOL() {
  return getToken(MySQLParser::START_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::STOP_SYMBOL() {
  return getToken(MySQLParser::STOP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::TRUNCATE_SYMBOL() {
  return getToken(MySQLParser::TRUNCATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::UNICODE_SYMBOL() {
  return getToken(MySQLParser::UNICODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::UNINSTALL_SYMBOL() {
  return getToken(MySQLParser::UNINSTALL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::UPGRADE_SYMBOL() {
  return getToken(MySQLParser::UPGRADE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::VISIBLE_SYMBOL() {
  return getToken(MySQLParser::VISIBLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::WRAPPER_SYMBOL() {
  return getToken(MySQLParser::WRAPPER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::XA_SYMBOL() {
  return getToken(MySQLParser::XA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrIdentifierKeywordContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}


size_t MySQLParser::RoleOrIdentifierKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrIdentifierKeyword;
}

void MySQLParser::RoleOrIdentifierKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrIdentifierKeyword(this);
}

void MySQLParser::RoleOrIdentifierKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrIdentifierKeyword(this);
}

MySQLParser::RoleOrIdentifierKeywordContext* MySQLParser::roleOrIdentifierKeyword() {
  RoleOrIdentifierKeywordContext *_localctx = _tracker.createInstance<RoleOrIdentifierKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1200, MySQLParser::RuleRoleOrIdentifierKeyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8297);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1112, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8292);
      _la = _input->LA(1);
      if (!(((((_la - 50) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 50)) & ((1ULL << (MySQLParser::ACCOUNT_SYMBOL - 50))
        | (1ULL << (MySQLParser::ALWAYS_SYMBOL - 50))
        | (1ULL << (MySQLParser::ASCII_SYMBOL - 50))
        | (1ULL << (MySQLParser::BACKUP_SYMBOL - 50))
        | (1ULL << (MySQLParser::BEGIN_SYMBOL - 50))
        | (1ULL << (MySQLParser::BYTE_SYMBOL - 50))
        | (1ULL << (MySQLParser::CACHE_SYMBOL - 50))
        | (1ULL << (MySQLParser::CHARSET_SYMBOL - 50))
        | (1ULL << (MySQLParser::CHECKSUM_SYMBOL - 50))
        | (1ULL << (MySQLParser::CLOSE_SYMBOL - 50)))) != 0) || ((((_la - 122) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 122)) & ((1ULL << (MySQLParser::COMMENT_SYMBOL - 122))
        | (1ULL << (MySQLParser::COMMIT_SYMBOL - 122))
        | (1ULL << (MySQLParser::CONTAINS_SYMBOL - 122))
        | (1ULL << (MySQLParser::DEALLOCATE_SYMBOL - 122)))) != 0) || ((((_la - 190) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 190)) & ((1ULL << (MySQLParser::DO_SYMBOL - 190))
        | (1ULL << (MySQLParser::END_SYMBOL - 190))
        | (1ULL << (MySQLParser::FLUSH_SYMBOL - 190))
        | (1ULL << (MySQLParser::FOLLOWS_SYMBOL - 190))
        | (1ULL << (MySQLParser::FORMAT_SYMBOL - 190))
        | (1ULL << (MySQLParser::GROUP_REPLICATION_SYMBOL - 190)))) != 0) || ((((_la - 258) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 258)) & ((1ULL << (MySQLParser::HANDLER_SYMBOL - 258))
        | (1ULL << (MySQLParser::HELP_SYMBOL - 258))
        | (1ULL << (MySQLParser::HOST_SYMBOL - 258))
        | (1ULL << (MySQLParser::INSTALL_SYMBOL - 258))
        | (1ULL << (MySQLParser::LANGUAGE_SYMBOL - 258)))) != 0) || ((((_la - 406) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 406)) & ((1ULL << (MySQLParser::NO_SYMBOL - 406))
        | (1ULL << (MySQLParser::OPEN_SYMBOL - 406))
        | (1ULL << (MySQLParser::OPTIONS_SYMBOL - 406))
        | (1ULL << (MySQLParser::OWNER_SYMBOL - 406))
        | (1ULL << (MySQLParser::PARSER_SYMBOL - 406))
        | (1ULL << (MySQLParser::PARTITION_SYMBOL - 406))
        | (1ULL << (MySQLParser::PORT_SYMBOL - 406))
        | (1ULL << (MySQLParser::PRECEDES_SYMBOL - 406))
        | (1ULL << (MySQLParser::PREPARE_SYMBOL - 406)))) != 0) || ((((_la - 486) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 486)) & ((1ULL << (MySQLParser::REMOVE_SYMBOL - 486))
        | (1ULL << (MySQLParser::REPAIR_SYMBOL - 486))
        | (1ULL << (MySQLParser::RESET_SYMBOL - 486))
        | (1ULL << (MySQLParser::RESTORE_SYMBOL - 486))
        | (1ULL << (MySQLParser::ROLLBACK_SYMBOL - 486))
        | (1ULL << (MySQLParser::SAVEPOINT_SYMBOL - 486))
        | (1ULL << (MySQLParser::SECURITY_SYMBOL - 486))
        | (1ULL << (MySQLParser::SERVER_SYMBOL - 486))
        | (1ULL << (MySQLParser::SIGNED_SYMBOL - 486))
        | (1ULL << (MySQLParser::SLAVE_SYMBOL - 486))
        | (1ULL << (MySQLParser::SOCKET_SYMBOL - 486)))) != 0) || ((((_la - 550) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 550)) & ((1ULL << (MySQLParser::SONAME_SYMBOL - 550))
        | (1ULL << (MySQLParser::START_SYMBOL - 550))
        | (1ULL << (MySQLParser::STOP_SYMBOL - 550)))) != 0) || ((((_la - 627) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 627)) & ((1ULL << (MySQLParser::TRUNCATE_SYMBOL - 627))
        | (1ULL << (MySQLParser::UNICODE_SYMBOL - 627))
        | (1ULL << (MySQLParser::UNINSTALL_SYMBOL - 627))
        | (1ULL << (MySQLParser::UPGRADE_SYMBOL - 627))
        | (1ULL << (MySQLParser::WRAPPER_SYMBOL - 627))
        | (1ULL << (MySQLParser::XA_SYMBOL - 627))
        | (1ULL << (MySQLParser::ROLE_SYMBOL - 627)))) != 0) || ((((_la - 692) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 692)) & ((1ULL << (MySQLParser::INVISIBLE_SYMBOL - 692))
        | (1ULL << (MySQLParser::VISIBLE_SYMBOL - 692))
        | (1ULL << (MySQLParser::CLONE_SYMBOL - 692))
        | (1ULL << (MySQLParser::SECONDARY_SYMBOL - 692))
        | (1ULL << (MySQLParser::SECONDARY_ENGINE_SYMBOL - 692))
        | (1ULL << (MySQLParser::SECONDARY_LOAD_SYMBOL - 692))
        | (1ULL << (MySQLParser::SECONDARY_UNLOAD_SYMBOL - 692)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8293);

      if (!(serverVersion >= 50709)) throw FailedPredicateException(this, "serverVersion >= 50709");
      setState(8294);
      match(MySQLParser::SHUTDOWN_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8295);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(8296);
      match(MySQLParser::IMPORT_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RoleOrLabelKeywordContext ------------------------------------------------------------------

MySQLParser::RoleOrLabelKeywordContext::RoleOrLabelKeywordContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ACTION_SYMBOL() {
  return getToken(MySQLParser::ACTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ACTIVE_SYMBOL() {
  return getToken(MySQLParser::ACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ADDDATE_SYMBOL() {
  return getToken(MySQLParser::ADDDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AFTER_SYMBOL() {
  return getToken(MySQLParser::AFTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AGAINST_SYMBOL() {
  return getToken(MySQLParser::AGAINST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AGGREGATE_SYMBOL() {
  return getToken(MySQLParser::AGGREGATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ALGORITHM_SYMBOL() {
  return getToken(MySQLParser::ALGORITHM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ANALYSE_SYMBOL() {
  return getToken(MySQLParser::ANALYSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ANY_SYMBOL() {
  return getToken(MySQLParser::ANY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AT_SYMBOL() {
  return getToken(MySQLParser::AT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AUTHORS_SYMBOL() {
  return getToken(MySQLParser::AUTHORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AUTO_INCREMENT_SYMBOL() {
  return getToken(MySQLParser::AUTO_INCREMENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AUTOEXTEND_SIZE_SYMBOL() {
  return getToken(MySQLParser::AUTOEXTEND_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AVG_ROW_LENGTH_SYMBOL() {
  return getToken(MySQLParser::AVG_ROW_LENGTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::AVG_SYMBOL() {
  return getToken(MySQLParser::AVG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BINLOG_SYMBOL() {
  return getToken(MySQLParser::BINLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BIT_SYMBOL() {
  return getToken(MySQLParser::BIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BLOCK_SYMBOL() {
  return getToken(MySQLParser::BLOCK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BOOL_SYMBOL() {
  return getToken(MySQLParser::BOOL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BOOLEAN_SYMBOL() {
  return getToken(MySQLParser::BOOLEAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BTREE_SYMBOL() {
  return getToken(MySQLParser::BTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::BUCKETS_SYMBOL() {
  return getToken(MySQLParser::BUCKETS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CASCADED_SYMBOL() {
  return getToken(MySQLParser::CASCADED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CATALOG_NAME_SYMBOL() {
  return getToken(MySQLParser::CATALOG_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CHAIN_SYMBOL() {
  return getToken(MySQLParser::CHAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CHANGED_SYMBOL() {
  return getToken(MySQLParser::CHANGED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CHANNEL_SYMBOL() {
  return getToken(MySQLParser::CHANNEL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CIPHER_SYMBOL() {
  return getToken(MySQLParser::CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CLIENT_SYMBOL() {
  return getToken(MySQLParser::CLIENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::CLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COALESCE_SYMBOL() {
  return getToken(MySQLParser::COALESCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CODE_SYMBOL() {
  return getToken(MySQLParser::CODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLLATION_SYMBOL() {
  return getToken(MySQLParser::COLLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLUMN_NAME_SYMBOL() {
  return getToken(MySQLParser::COLUMN_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLUMN_FORMAT_SYMBOL() {
  return getToken(MySQLParser::COLUMN_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COLUMNS_SYMBOL() {
  return getToken(MySQLParser::COLUMNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMMITTED_SYMBOL() {
  return getToken(MySQLParser::COMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPACT_SYMBOL() {
  return getToken(MySQLParser::COMPACT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPLETION_SYMBOL() {
  return getToken(MySQLParser::COMPLETION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPONENT_SYMBOL() {
  return getToken(MySQLParser::COMPONENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPRESSED_SYMBOL() {
  return getToken(MySQLParser::COMPRESSED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::COMPRESSION_SYMBOL() {
  return getToken(MySQLParser::COMPRESSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONCURRENT_SYMBOL() {
  return getToken(MySQLParser::CONCURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONNECTION_SYMBOL() {
  return getToken(MySQLParser::CONNECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSISTENT_SYMBOL() {
  return getToken(MySQLParser::CONSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_CATALOG_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_CATALOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_SCHEMA_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_SCHEMA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONSTRAINT_NAME_SYMBOL() {
  return getToken(MySQLParser::CONSTRAINT_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONTEXT_SYMBOL() {
  return getToken(MySQLParser::CONTEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CONTRIBUTORS_SYMBOL() {
  return getToken(MySQLParser::CONTRIBUTORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CPU_SYMBOL() {
  return getToken(MySQLParser::CPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CURRENT_SYMBOL() {
  return getToken(MySQLParser::CURRENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CURSOR_NAME_SYMBOL() {
  return getToken(MySQLParser::CURSOR_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATA_SYMBOL() {
  return getToken(MySQLParser::DATA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATAFILE_SYMBOL() {
  return getToken(MySQLParser::DATAFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATETIME_SYMBOL() {
  return getToken(MySQLParser::DATETIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DATE_SYMBOL() {
  return getToken(MySQLParser::DATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DAY_SYMBOL() {
  return getToken(MySQLParser::DAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DEFAULT_AUTH_SYMBOL() {
  return getToken(MySQLParser::DEFAULT_AUTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DEFINER_SYMBOL() {
  return getToken(MySQLParser::DEFINER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DELAY_KEY_WRITE_SYMBOL() {
  return getToken(MySQLParser::DELAY_KEY_WRITE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DES_KEY_FILE_SYMBOL() {
  return getToken(MySQLParser::DES_KEY_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DESCRIPTION_SYMBOL() {
  return getToken(MySQLParser::DESCRIPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DIAGNOSTICS_SYMBOL() {
  return getToken(MySQLParser::DIAGNOSTICS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DIRECTORY_SYMBOL() {
  return getToken(MySQLParser::DIRECTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DISABLE_SYMBOL() {
  return getToken(MySQLParser::DISABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DISCARD_SYMBOL() {
  return getToken(MySQLParser::DISCARD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DISK_SYMBOL() {
  return getToken(MySQLParser::DISK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DUMPFILE_SYMBOL() {
  return getToken(MySQLParser::DUMPFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DUPLICATE_SYMBOL() {
  return getToken(MySQLParser::DUPLICATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::DYNAMIC_SYMBOL() {
  return getToken(MySQLParser::DYNAMIC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENCRYPTION_SYMBOL() {
  return getToken(MySQLParser::ENCRYPTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENDS_SYMBOL() {
  return getToken(MySQLParser::ENDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENUM_SYMBOL() {
  return getToken(MySQLParser::ENUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENGINE_SYMBOL() {
  return getToken(MySQLParser::ENGINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENGINES_SYMBOL() {
  return getToken(MySQLParser::ENGINES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ERROR_SYMBOL() {
  return getToken(MySQLParser::ERROR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ERRORS_SYMBOL() {
  return getToken(MySQLParser::ERRORS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ESCAPE_SYMBOL() {
  return getToken(MySQLParser::ESCAPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EVENTS_SYMBOL() {
  return getToken(MySQLParser::EVENTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EVERY_SYMBOL() {
  return getToken(MySQLParser::EVERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXCLUDE_SYMBOL() {
  return getToken(MySQLParser::EXCLUDE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXPANSION_SYMBOL() {
  return getToken(MySQLParser::EXPANSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXPORT_SYMBOL() {
  return getToken(MySQLParser::EXPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXTENDED_SYMBOL() {
  return getToken(MySQLParser::EXTENDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXTENT_SIZE_SYMBOL() {
  return getToken(MySQLParser::EXTENT_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FAULTS_SYMBOL() {
  return getToken(MySQLParser::FAULTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FAST_SYMBOL() {
  return getToken(MySQLParser::FAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FOLLOWING_SYMBOL() {
  return getToken(MySQLParser::FOLLOWING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FOUND_SYMBOL() {
  return getToken(MySQLParser::FOUND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ENABLE_SYMBOL() {
  return getToken(MySQLParser::ENABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FULL_SYMBOL() {
  return getToken(MySQLParser::FULL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FILE_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::FILE_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FILTER_SYMBOL() {
  return getToken(MySQLParser::FILTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FIRST_SYMBOL() {
  return getToken(MySQLParser::FIRST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FIXED_SYMBOL() {
  return getToken(MySQLParser::FIXED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GENERAL_SYMBOL() {
  return getToken(MySQLParser::GENERAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GEOMETRY_SYMBOL() {
  return getToken(MySQLParser::GEOMETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GEOMETRYCOLLECTION_SYMBOL() {
  return getToken(MySQLParser::GEOMETRYCOLLECTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GET_FORMAT_SYMBOL() {
  return getToken(MySQLParser::GET_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GRANTS_SYMBOL() {
  return getToken(MySQLParser::GRANTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::GLOBAL_SYMBOL() {
  return getToken(MySQLParser::GLOBAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HASH_SYMBOL() {
  return getToken(MySQLParser::HASH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HISTOGRAM_SYMBOL() {
  return getToken(MySQLParser::HISTOGRAM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HISTORY_SYMBOL() {
  return getToken(MySQLParser::HISTORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HOSTS_SYMBOL() {
  return getToken(MySQLParser::HOSTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::HOUR_SYMBOL() {
  return getToken(MySQLParser::HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IDENTIFIED_SYMBOL() {
  return getToken(MySQLParser::IDENTIFIED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IGNORE_SERVER_IDS_SYMBOL() {
  return getToken(MySQLParser::IGNORE_SERVER_IDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INVOKER_SYMBOL() {
  return getToken(MySQLParser::INVOKER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INDEXES_SYMBOL() {
  return getToken(MySQLParser::INDEXES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INITIAL_SIZE_SYMBOL() {
  return getToken(MySQLParser::INITIAL_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INSTANCE_SYMBOL() {
  return getToken(MySQLParser::INSTANCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INACTIVE_SYMBOL() {
  return getToken(MySQLParser::INACTIVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IO_SYMBOL() {
  return getToken(MySQLParser::IO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IPC_SYMBOL() {
  return getToken(MySQLParser::IPC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ISOLATION_SYMBOL() {
  return getToken(MySQLParser::ISOLATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ISSUER_SYMBOL() {
  return getToken(MySQLParser::ISSUER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::INSERT_METHOD_SYMBOL() {
  return getToken(MySQLParser::INSERT_METHOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::JSON_SYMBOL() {
  return getToken(MySQLParser::JSON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::KEY_BLOCK_SIZE_SYMBOL() {
  return getToken(MySQLParser::KEY_BLOCK_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LAST_SYMBOL() {
  return getToken(MySQLParser::LAST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LEAVES_SYMBOL() {
  return getToken(MySQLParser::LEAVES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LESS_SYMBOL() {
  return getToken(MySQLParser::LESS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LEVEL_SYMBOL() {
  return getToken(MySQLParser::LEVEL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LINESTRING_SYMBOL() {
  return getToken(MySQLParser::LINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LIST_SYMBOL() {
  return getToken(MySQLParser::LIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOCAL_SYMBOL() {
  return getToken(MySQLParser::LOCAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOCKED_SYMBOL() {
  return getToken(MySQLParser::LOCKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOCKS_SYMBOL() {
  return getToken(MySQLParser::LOCKS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOGFILE_SYMBOL() {
  return getToken(MySQLParser::LOGFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::LOGS_SYMBOL() {
  return getToken(MySQLParser::LOGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_ROWS_SYMBOL() {
  return getToken(MySQLParser::MAX_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_HEARTBEAT_PERIOD_SYMBOL() {
  return getToken(MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_HOST_SYMBOL() {
  return getToken(MySQLParser::MASTER_HOST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_PORT_SYMBOL() {
  return getToken(MySQLParser::MASTER_PORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::MASTER_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_USER_SYMBOL() {
  return getToken(MySQLParser::MASTER_USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::MASTER_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_PUBLIC_KEY_PATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SERVER_ID_SYMBOL() {
  return getToken(MySQLParser::MASTER_SERVER_ID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_CONNECT_RETRY_SYMBOL() {
  return getToken(MySQLParser::MASTER_CONNECT_RETRY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_RETRY_COUNT_SYMBOL() {
  return getToken(MySQLParser::MASTER_RETRY_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_DELAY_SYMBOL() {
  return getToken(MySQLParser::MASTER_DELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CA_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CA_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CAPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CAPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_TLS_VERSION_SYMBOL() {
  return getToken(MySQLParser::MASTER_TLS_VERSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CERT_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CERT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CIPHER_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CIPHER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CRL_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_CRLPATH_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_CRLPATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_SSL_KEY_SYMBOL() {
  return getToken(MySQLParser::MASTER_SSL_KEY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MASTER_AUTO_POSITION_SYMBOL() {
  return getToken(MySQLParser::MASTER_AUTO_POSITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_CONNECTIONS_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_QUERIES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_STATEMENT_TIME_SYMBOL() {
  return getToken(MySQLParser::MAX_STATEMENT_TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_SIZE_SYMBOL() {
  return getToken(MySQLParser::MAX_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_UPDATES_PER_HOUR_SYMBOL() {
  return getToken(MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MAX_USER_CONNECTIONS_SYMBOL() {
  return getToken(MySQLParser::MAX_USER_CONNECTIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MEDIUM_SYMBOL() {
  return getToken(MySQLParser::MEDIUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MEMORY_SYMBOL() {
  return getToken(MySQLParser::MEMORY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MERGE_SYMBOL() {
  return getToken(MySQLParser::MERGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MESSAGE_TEXT_SYMBOL() {
  return getToken(MySQLParser::MESSAGE_TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MICROSECOND_SYMBOL() {
  return getToken(MySQLParser::MICROSECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MIGRATE_SYMBOL() {
  return getToken(MySQLParser::MIGRATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MINUTE_SYMBOL() {
  return getToken(MySQLParser::MINUTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MIN_ROWS_SYMBOL() {
  return getToken(MySQLParser::MIN_ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MODIFY_SYMBOL() {
  return getToken(MySQLParser::MODIFY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MODE_SYMBOL() {
  return getToken(MySQLParser::MODE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MONTH_SYMBOL() {
  return getToken(MySQLParser::MONTH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MULTILINESTRING_SYMBOL() {
  return getToken(MySQLParser::MULTILINESTRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MULTIPOINT_SYMBOL() {
  return getToken(MySQLParser::MULTIPOINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MULTIPOLYGON_SYMBOL() {
  return getToken(MySQLParser::MULTIPOLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MUTEX_SYMBOL() {
  return getToken(MySQLParser::MUTEX_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::MYSQL_ERRNO_SYMBOL() {
  return getToken(MySQLParser::MYSQL_ERRNO_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NAME_SYMBOL() {
  return getToken(MySQLParser::NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NAMES_SYMBOL() {
  return getToken(MySQLParser::NAMES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NATIONAL_SYMBOL() {
  return getToken(MySQLParser::NATIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NCHAR_SYMBOL() {
  return getToken(MySQLParser::NCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NDBCLUSTER_SYMBOL() {
  return getToken(MySQLParser::NDBCLUSTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NESTED_SYMBOL() {
  return getToken(MySQLParser::NESTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NEVER_SYMBOL() {
  return getToken(MySQLParser::NEVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NEXT_SYMBOL() {
  return getToken(MySQLParser::NEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NEW_SYMBOL() {
  return getToken(MySQLParser::NEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NO_WAIT_SYMBOL() {
  return getToken(MySQLParser::NO_WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NODEGROUP_SYMBOL() {
  return getToken(MySQLParser::NODEGROUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NULLS_SYMBOL() {
  return getToken(MySQLParser::NULLS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NOWAIT_SYMBOL() {
  return getToken(MySQLParser::NOWAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NUMBER_SYMBOL() {
  return getToken(MySQLParser::NUMBER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::NVARCHAR_SYMBOL() {
  return getToken(MySQLParser::NVARCHAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OFFSET_SYMBOL() {
  return getToken(MySQLParser::OFFSET_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OLD_SYMBOL() {
  return getToken(MySQLParser::OLD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OLD_PASSWORD_SYMBOL() {
  return getToken(MySQLParser::OLD_PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ONE_SHOT_SYMBOL() {
  return getToken(MySQLParser::ONE_SHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ONE_SYMBOL() {
  return getToken(MySQLParser::ONE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OPTIONAL_SYMBOL() {
  return getToken(MySQLParser::OPTIONAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ORDINALITY_SYMBOL() {
  return getToken(MySQLParser::ORDINALITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ORGANIZATION_SYMBOL() {
  return getToken(MySQLParser::ORGANIZATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::OTHERS_SYMBOL() {
  return getToken(MySQLParser::OTHERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PACK_KEYS_SYMBOL() {
  return getToken(MySQLParser::PACK_KEYS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PAGE_SYMBOL() {
  return getToken(MySQLParser::PAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PARTIAL_SYMBOL() {
  return getToken(MySQLParser::PARTIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PARTITIONING_SYMBOL() {
  return getToken(MySQLParser::PARTITIONING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PARTITIONS_SYMBOL() {
  return getToken(MySQLParser::PARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PASSWORD_SYMBOL() {
  return getToken(MySQLParser::PASSWORD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PATH_SYMBOL() {
  return getToken(MySQLParser::PATH_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PHASE_SYMBOL() {
  return getToken(MySQLParser::PHASE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PLUGIN_DIR_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_DIR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PLUGIN_SYMBOL() {
  return getToken(MySQLParser::PLUGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PLUGINS_SYMBOL() {
  return getToken(MySQLParser::PLUGINS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::POINT_SYMBOL() {
  return getToken(MySQLParser::POINT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::POLYGON_SYMBOL() {
  return getToken(MySQLParser::POLYGON_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PRECEDING_SYMBOL() {
  return getToken(MySQLParser::PRECEDING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PRESERVE_SYMBOL() {
  return getToken(MySQLParser::PRESERVE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PREV_SYMBOL() {
  return getToken(MySQLParser::PREV_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::THREAD_PRIORITY_SYMBOL() {
  return getToken(MySQLParser::THREAD_PRIORITY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PRIVILEGES_SYMBOL() {
  return getToken(MySQLParser::PRIVILEGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PROCESSLIST_SYMBOL() {
  return getToken(MySQLParser::PROCESSLIST_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PROFILE_SYMBOL() {
  return getToken(MySQLParser::PROFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::PROFILES_SYMBOL() {
  return getToken(MySQLParser::PROFILES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::QUARTER_SYMBOL() {
  return getToken(MySQLParser::QUARTER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::QUERY_SYMBOL() {
  return getToken(MySQLParser::QUERY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::QUICK_SYMBOL() {
  return getToken(MySQLParser::QUICK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::READ_ONLY_SYMBOL() {
  return getToken(MySQLParser::READ_ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REBUILD_SYMBOL() {
  return getToken(MySQLParser::REBUILD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RECOVER_SYMBOL() {
  return getToken(MySQLParser::RECOVER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::REDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REDOFILE_SYMBOL() {
  return getToken(MySQLParser::REDOFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REDUNDANT_SYMBOL() {
  return getToken(MySQLParser::REDUNDANT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_SYMBOL() {
  return getToken(MySQLParser::RELAY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAYLOG_SYMBOL() {
  return getToken(MySQLParser::RELAYLOG_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_LOG_FILE_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_FILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_LOG_POS_SYMBOL() {
  return getToken(MySQLParser::RELAY_LOG_POS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RELAY_THREAD_SYMBOL() {
  return getToken(MySQLParser::RELAY_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REMOTE_SYMBOL() {
  return getToken(MySQLParser::REMOTE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REORGANIZE_SYMBOL() {
  return getToken(MySQLParser::REORGANIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPEATABLE_SYMBOL() {
  return getToken(MySQLParser::REPEATABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_DO_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_IGNORE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_WILD_DO_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_WILD_IGNORE_TABLE_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REPLICATE_REWRITE_DB_SYMBOL() {
  return getToken(MySQLParser::REPLICATE_REWRITE_DB_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::USER_RESOURCES_SYMBOL() {
  return getToken(MySQLParser::USER_RESOURCES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RESPECT_SYMBOL() {
  return getToken(MySQLParser::RESPECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RESUME_SYMBOL() {
  return getToken(MySQLParser::RESUME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RETAIN_SYMBOL() {
  return getToken(MySQLParser::RETAIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RETURNED_SQLSTATE_SYMBOL() {
  return getToken(MySQLParser::RETURNED_SQLSTATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RETURNS_SYMBOL() {
  return getToken(MySQLParser::RETURNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REUSE_SYMBOL() {
  return getToken(MySQLParser::REUSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::REVERSE_SYMBOL() {
  return getToken(MySQLParser::REVERSE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROLLUP_SYMBOL() {
  return getToken(MySQLParser::ROLLUP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROTATE_SYMBOL() {
  return getToken(MySQLParser::ROTATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROUTINE_SYMBOL() {
  return getToken(MySQLParser::ROUTINE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROW_COUNT_SYMBOL() {
  return getToken(MySQLParser::ROW_COUNT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROW_FORMAT_SYMBOL() {
  return getToken(MySQLParser::ROW_FORMAT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::RTREE_SYMBOL() {
  return getToken(MySQLParser::RTREE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SCHEDULE_SYMBOL() {
  return getToken(MySQLParser::SCHEDULE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SCHEMA_NAME_SYMBOL() {
  return getToken(MySQLParser::SCHEMA_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SECOND_SYMBOL() {
  return getToken(MySQLParser::SECOND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SERIAL_SYMBOL() {
  return getToken(MySQLParser::SERIAL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SERIALIZABLE_SYMBOL() {
  return getToken(MySQLParser::SERIALIZABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SESSION_SYMBOL() {
  return getToken(MySQLParser::SESSION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SHARE_SYMBOL() {
  return getToken(MySQLParser::SHARE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SIMPLE_SYMBOL() {
  return getToken(MySQLParser::SIMPLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SKIP_SYMBOL() {
  return getToken(MySQLParser::SKIP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SLOW_SYMBOL() {
  return getToken(MySQLParser::SLOW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SNAPSHOT_SYMBOL() {
  return getToken(MySQLParser::SNAPSHOT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SOUNDS_SYMBOL() {
  return getToken(MySQLParser::SOUNDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SOURCE_SYMBOL() {
  return getToken(MySQLParser::SOURCE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_AFTER_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_AFTER_MTS_GAPS_SYMBOL() {
  return getToken(MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_BEFORE_GTIDS_SYMBOL() {
  return getToken(MySQLParser::SQL_BEFORE_GTIDS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_BUFFER_RESULT_SYMBOL() {
  return getToken(MySQLParser::SQL_BUFFER_RESULT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_NO_CACHE_SYMBOL() {
  return getToken(MySQLParser::SQL_NO_CACHE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SQL_THREAD_SYMBOL() {
  return getToken(MySQLParser::SQL_THREAD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SRID_SYMBOL() {
  return getToken(MySQLParser::SRID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STACKED_SYMBOL() {
  return getToken(MySQLParser::STACKED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STARTS_SYMBOL() {
  return getToken(MySQLParser::STARTS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATS_AUTO_RECALC_SYMBOL() {
  return getToken(MySQLParser::STATS_AUTO_RECALC_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATS_PERSISTENT_SYMBOL() {
  return getToken(MySQLParser::STATS_PERSISTENT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATS_SAMPLE_PAGES_SYMBOL() {
  return getToken(MySQLParser::STATS_SAMPLE_PAGES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STATUS_SYMBOL() {
  return getToken(MySQLParser::STATUS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STORAGE_SYMBOL() {
  return getToken(MySQLParser::STORAGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::STRING_SYMBOL() {
  return getToken(MySQLParser::STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBCLASS_ORIGIN_SYMBOL() {
  return getToken(MySQLParser::SUBCLASS_ORIGIN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBDATE_SYMBOL() {
  return getToken(MySQLParser::SUBDATE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBJECT_SYMBOL() {
  return getToken(MySQLParser::SUBJECT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBPARTITION_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUBPARTITIONS_SYMBOL() {
  return getToken(MySQLParser::SUBPARTITIONS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUPER_SYMBOL() {
  return getToken(MySQLParser::SUPER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SUSPEND_SYMBOL() {
  return getToken(MySQLParser::SUSPEND_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SWAPS_SYMBOL() {
  return getToken(MySQLParser::SWAPS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SWITCHES_SYMBOL() {
  return getToken(MySQLParser::SWITCHES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLE_NAME_SYMBOL() {
  return getToken(MySQLParser::TABLE_NAME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLES_SYMBOL() {
  return getToken(MySQLParser::TABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLE_CHECKSUM_SYMBOL() {
  return getToken(MySQLParser::TABLE_CHECKSUM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TABLESPACE_SYMBOL() {
  return getToken(MySQLParser::TABLESPACE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TEMPORARY_SYMBOL() {
  return getToken(MySQLParser::TEMPORARY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TEMPTABLE_SYMBOL() {
  return getToken(MySQLParser::TEMPTABLE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TEXT_SYMBOL() {
  return getToken(MySQLParser::TEXT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::THAN_SYMBOL() {
  return getToken(MySQLParser::THAN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIES_SYMBOL() {
  return getToken(MySQLParser::TIES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TRANSACTION_SYMBOL() {
  return getToken(MySQLParser::TRANSACTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TRIGGERS_SYMBOL() {
  return getToken(MySQLParser::TRIGGERS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIMESTAMP_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIMESTAMP_ADD_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_ADD_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIMESTAMP_DIFF_SYMBOL() {
  return getToken(MySQLParser::TIMESTAMP_DIFF_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TIME_SYMBOL() {
  return getToken(MySQLParser::TIME_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TYPES_SYMBOL() {
  return getToken(MySQLParser::TYPES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::TYPE_SYMBOL() {
  return getToken(MySQLParser::TYPE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UDF_RETURNS_SYMBOL() {
  return getToken(MySQLParser::UDF_RETURNS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNBOUNDED_SYMBOL() {
  return getToken(MySQLParser::UNBOUNDED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNCOMMITTED_SYMBOL() {
  return getToken(MySQLParser::UNCOMMITTED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNDEFINED_SYMBOL() {
  return getToken(MySQLParser::UNDEFINED_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNDO_BUFFER_SIZE_SYMBOL() {
  return getToken(MySQLParser::UNDO_BUFFER_SIZE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNDOFILE_SYMBOL() {
  return getToken(MySQLParser::UNDOFILE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNKNOWN_SYMBOL() {
  return getToken(MySQLParser::UNKNOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::UNTIL_SYMBOL() {
  return getToken(MySQLParser::UNTIL_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::USER_SYMBOL() {
  return getToken(MySQLParser::USER_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::USE_FRM_SYMBOL() {
  return getToken(MySQLParser::USE_FRM_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VARIABLES_SYMBOL() {
  return getToken(MySQLParser::VARIABLES_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VCPU_SYMBOL() {
  return getToken(MySQLParser::VCPU_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VIEW_SYMBOL() {
  return getToken(MySQLParser::VIEW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VALUE_SYMBOL() {
  return getToken(MySQLParser::VALUE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WARNINGS_SYMBOL() {
  return getToken(MySQLParser::WARNINGS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WAIT_SYMBOL() {
  return getToken(MySQLParser::WAIT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WEEK_SYMBOL() {
  return getToken(MySQLParser::WEEK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WORK_SYMBOL() {
  return getToken(MySQLParser::WORK_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WEIGHT_STRING_SYMBOL() {
  return getToken(MySQLParser::WEIGHT_STRING_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::X509_SYMBOL() {
  return getToken(MySQLParser::X509_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::XID_SYMBOL() {
  return getToken(MySQLParser::XID_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::XML_SYMBOL() {
  return getToken(MySQLParser::XML_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::YEAR_SYMBOL() {
  return getToken(MySQLParser::YEAR_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::SHUTDOWN_SYMBOL() {
  return getToken(MySQLParser::SHUTDOWN_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::CUBE_SYMBOL() {
  return getToken(MySQLParser::CUBE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::IMPORT_SYMBOL() {
  return getToken(MySQLParser::IMPORT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::FUNCTION_SYMBOL() {
  return getToken(MySQLParser::FUNCTION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROWS_SYMBOL() {
  return getToken(MySQLParser::ROWS_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ROW_SYMBOL() {
  return getToken(MySQLParser::ROW_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXCHANGE_SYMBOL() {
  return getToken(MySQLParser::EXCHANGE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::EXPIRE_SYMBOL() {
  return getToken(MySQLParser::EXPIRE_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ONLY_SYMBOL() {
  return getToken(MySQLParser::ONLY_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::VALIDATION_SYMBOL() {
  return getToken(MySQLParser::VALIDATION_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::WITHOUT_SYMBOL() {
  return getToken(MySQLParser::WITHOUT_SYMBOL, 0);
}

tree::TerminalNode* MySQLParser::RoleOrLabelKeywordContext::ADMIN_SYMBOL() {
  return getToken(MySQLParser::ADMIN_SYMBOL, 0);
}


size_t MySQLParser::RoleOrLabelKeywordContext::getRuleIndex() const {
  return MySQLParser::RuleRoleOrLabelKeyword;
}

void MySQLParser::RoleOrLabelKeywordContext::enterRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->enterRoleOrLabelKeyword(this);
}

void MySQLParser::RoleOrLabelKeywordContext::exitRule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast<MySQLParserListener *>(listener);
  if (parserListener != nullptr)
    parserListener->exitRoleOrLabelKeyword(this);
}

MySQLParser::RoleOrLabelKeywordContext* MySQLParser::roleOrLabelKeyword() {
  RoleOrLabelKeywordContext *_localctx = _tracker.createInstance<RoleOrLabelKeywordContext>(_ctx, getState());
  enterRule(_localctx, 1202, MySQLParser::RuleRoleOrLabelKeyword);
  size_t _la = 0;

  auto onExit = finally([=] {
    exitRule();
  });
  try {
    setState(8308);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 1113, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(8299);
      _la = _input->LA(1);
      if (!(((((_la - 51) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 51)) & ((1ULL << (MySQLParser::ACTION_SYMBOL - 51))
        | (1ULL << (MySQLParser::ADDDATE_SYMBOL - 51))
        | (1ULL << (MySQLParser::AFTER_SYMBOL - 51))
        | (1ULL << (MySQLParser::AGAINST_SYMBOL - 51))
        | (1ULL << (MySQLParser::AGGREGATE_SYMBOL - 51))
        | (1ULL << (MySQLParser::ALGORITHM_SYMBOL - 51))
        | (1ULL << (MySQLParser::ANALYSE_SYMBOL - 51))
        | (1ULL << (MySQLParser::ANY_SYMBOL - 51))
        | (1ULL << (MySQLParser::AT_SYMBOL - 51))
        | (1ULL << (MySQLParser::AUTHORS_SYMBOL - 51))
        | (1ULL << (MySQLParser::AUTOEXTEND_SIZE_SYMBOL - 51))
        | (1ULL << (MySQLParser::AUTO_INCREMENT_SYMBOL - 51))
        | (1ULL << (MySQLParser::AVG_ROW_LENGTH_SYMBOL - 51))
        | (1ULL << (MySQLParser::AVG_SYMBOL - 51))
        | (1ULL << (MySQLParser::BINLOG_SYMBOL - 51))
        | (1ULL << (MySQLParser::BIT_SYMBOL - 51))
        | (1ULL << (MySQLParser::BLOCK_SYMBOL - 51))
        | (1ULL << (MySQLParser::BOOLEAN_SYMBOL - 51))
        | (1ULL << (MySQLParser::BOOL_SYMBOL - 51))
        | (1ULL << (MySQLParser::BTREE_SYMBOL - 51))
        | (1ULL << (MySQLParser::CASCADED_SYMBOL - 51))
        | (1ULL << (MySQLParser::CATALOG_NAME_SYMBOL - 51))
        | (1ULL << (MySQLParser::CHAIN_SYMBOL - 51))
        | (1ULL << (MySQLParser::CHANGED_SYMBOL - 51))
        | (1ULL << (MySQLParser::CHANNEL_SYMBOL - 51))
        | (1ULL << (MySQLParser::CIPHER_SYMBOL - 51))
        | (1ULL << (MySQLParser::CLASS_ORIGIN_SYMBOL - 51))
        | (1ULL << (MySQLParser::CLIENT_SYMBOL - 51))
        | (1ULL << (MySQLParser::COALESCE_SYMBOL - 51)))) != 0) || ((((_la - 115) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 115)) & ((1ULL << (MySQLParser::CODE_SYMBOL - 115))
        | (1ULL << (MySQLParser::COLLATION_SYMBOL - 115))
        | (1ULL << (MySQLParser::COLUMNS_SYMBOL - 115))
        | (1ULL << (MySQLParser::COLUMN_NAME_SYMBOL - 115))
        | (1ULL << (MySQLParser::COLUMN_FORMAT_SYMBOL - 115))
        | (1ULL << (MySQLParser::COMMITTED_SYMBOL - 115))
        | (1ULL << (MySQLParser::COMPACT_SYMBOL - 115))
        | (1ULL << (MySQLParser::COMPLETION_SYMBOL - 115))
        | (1ULL << (MySQLParser::COMPRESSED_SYMBOL - 115))
        | (1ULL << (MySQLParser::COMPRESSION_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONCURRENT_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONNECTION_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONSISTENT_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONSTRAINT_CATALOG_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONSTRAINT_NAME_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONSTRAINT_SCHEMA_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONTEXT_SYMBOL - 115))
        | (1ULL << (MySQLParser::CONTRIBUTORS_SYMBOL - 115))
        | (1ULL << (MySQLParser::CPU_SYMBOL - 115))
        | (1ULL << (MySQLParser::CURRENT_SYMBOL - 115))
        | (1ULL << (MySQLParser::CURSOR_NAME_SYMBOL - 115))
        | (1ULL << (MySQLParser::DATAFILE_SYMBOL - 115))
        | (1ULL << (MySQLParser::DATA_SYMBOL - 115))
        | (1ULL << (MySQLParser::DATETIME_SYMBOL - 115))
        | (1ULL << (MySQLParser::DATE_SYMBOL - 115))
        | (1ULL << (MySQLParser::DAY_SYMBOL - 115))
        | (1ULL << (MySQLParser::DEFAULT_AUTH_SYMBOL - 115))
        | (1ULL << (MySQLParser::DEFINER_SYMBOL - 115))
        | (1ULL << (MySQLParser::DELAY_KEY_WRITE_SYMBOL - 115)))) != 0) || ((((_la - 180) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 180)) & ((1ULL << (MySQLParser::DES_KEY_FILE_SYMBOL - 180))
        | (1ULL << (MySQLParser::DIAGNOSTICS_SYMBOL - 180))
        | (1ULL << (MySQLParser::DIRECTORY_SYMBOL - 180))
        | (1ULL << (MySQLParser::DISABLE_SYMBOL - 180))
        | (1ULL << (MySQLParser::DISCARD_SYMBOL - 180))
        | (1ULL << (MySQLParser::DISK_SYMBOL - 180))
        | (1ULL << (MySQLParser::DUMPFILE_SYMBOL - 180))
        | (1ULL << (MySQLParser::DUPLICATE_SYMBOL - 180))
        | (1ULL << (MySQLParser::DYNAMIC_SYMBOL - 180))
        | (1ULL << (MySQLParser::ENABLE_SYMBOL - 180))
        | (1ULL << (MySQLParser::ENCRYPTION_SYMBOL - 180))
        | (1ULL << (MySQLParser::ENDS_SYMBOL - 180))
        | (1ULL << (MySQLParser::ENGINES_SYMBOL - 180))
        | (1ULL << (MySQLParser::ENGINE_SYMBOL - 180))
        | (1ULL << (MySQLParser::ENUM_SYMBOL - 180))
        | (1ULL << (MySQLParser::ERROR_SYMBOL - 180))
        | (1ULL << (MySQLParser::ERRORS_SYMBOL - 180))
        | (1ULL << (MySQLParser::ESCAPE_SYMBOL - 180))
        | (1ULL << (MySQLParser::EVENTS_SYMBOL - 180))
        | (1ULL << (MySQLParser::EVERY_SYMBOL - 180))
        | (1ULL << (MySQLParser::EXPANSION_SYMBOL - 180))
        | (1ULL << (MySQLParser::EXPORT_SYMBOL - 180))
        | (1ULL << (MySQLParser::EXTENDED_SYMBOL - 180))
        | (1ULL << (MySQLParser::EXTENT_SIZE_SYMBOL - 180))
        | (1ULL << (MySQLParser::FAST_SYMBOL - 180))
        | (1ULL << (MySQLParser::FAULTS_SYMBOL - 180))
        | (1ULL << (MySQLParser::FILE_BLOCK_SIZE_SYMBOL - 180))
        | (1ULL << (MySQLParser::FILTER_SYMBOL - 180))
        | (1ULL << (MySQLParser::FIRST_SYMBOL - 180))
        | (1ULL << (MySQLParser::FIXED_SYMBOL - 180))
        | (1ULL << (MySQLParser::FOUND_SYMBOL - 180))
        | (1ULL << (MySQLParser::FULL_SYMBOL - 180)))) != 0) || ((((_la - 247) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 247)) & ((1ULL << (MySQLParser::GENERAL_SYMBOL - 247))
        | (1ULL << (MySQLParser::GEOMETRYCOLLECTION_SYMBOL - 247))
        | (1ULL << (MySQLParser::GEOMETRY_SYMBOL - 247))
        | (1ULL << (MySQLParser::GET_FORMAT_SYMBOL - 247))
        | (1ULL << (MySQLParser::GLOBAL_SYMBOL - 247))
        | (1ULL << (MySQLParser::GRANTS_SYMBOL - 247))
        | (1ULL << (MySQLParser::HASH_SYMBOL - 247))
        | (1ULL << (MySQLParser::HOSTS_SYMBOL - 247))
        | (1ULL << (MySQLParser::HOUR_SYMBOL - 247))
        | (1ULL << (MySQLParser::IDENTIFIED_SYMBOL - 247))
        | (1ULL << (MySQLParser::IGNORE_SERVER_IDS_SYMBOL - 247))
        | (1ULL << (MySQLParser::INDEXES_SYMBOL - 247))
        | (1ULL << (MySQLParser::INITIAL_SIZE_SYMBOL - 247))
        | (1ULL << (MySQLParser::INSERT_METHOD_SYMBOL - 247))
        | (1ULL << (MySQLParser::INSTANCE_SYMBOL - 247))
        | (1ULL << (MySQLParser::INVOKER_SYMBOL - 247))
        | (1ULL << (MySQLParser::IO_SYMBOL - 247))
        | (1ULL << (MySQLParser::IPC_SYMBOL - 247))
        | (1ULL << (MySQLParser::ISOLATION_SYMBOL - 247))
        | (1ULL << (MySQLParser::ISSUER_SYMBOL - 247))
        | (1ULL << (MySQLParser::JSON_SYMBOL - 247))
        | (1ULL << (MySQLParser::KEY_BLOCK_SIZE_SYMBOL - 247))
        | (1ULL << (MySQLParser::LAST_SYMBOL - 247))
        | (1ULL << (MySQLParser::LEAVES_SYMBOL - 247))
        | (1ULL << (MySQLParser::LESS_SYMBOL - 247)))) != 0) || ((((_la - 311) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 311)) & ((1ULL << (MySQLParser::LEVEL_SYMBOL - 311))
        | (1ULL << (MySQLParser::LINESTRING_SYMBOL - 311))
        | (1ULL << (MySQLParser::LIST_SYMBOL - 311))
        | (1ULL << (MySQLParser::LOCAL_SYMBOL - 311))
        | (1ULL << (MySQLParser::LOCKS_SYMBOL - 311))
        | (1ULL << (MySQLParser::LOGFILE_SYMBOL - 311))
        | (1ULL << (MySQLParser::LOGS_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_AUTO_POSITION_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_CONNECT_RETRY_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_DELAY_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_HOST_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_LOG_FILE_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_LOG_POS_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_PASSWORD_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_PORT_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_RETRY_COUNT_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SERVER_ID_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_CAPATH_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_CA_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_CERT_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_CIPHER_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_CRL_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_CRLPATH_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_KEY_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SSL_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_TLS_VERSION_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_USER_SYMBOL - 311))
        | (1ULL << (MySQLParser::MASTER_HEARTBEAT_PERIOD_SYMBOL - 311))
        | (1ULL << (MySQLParser::MAX_CONNECTIONS_PER_HOUR_SYMBOL - 311))
        | (1ULL << (MySQLParser::MAX_QUERIES_PER_HOUR_SYMBOL - 311))
        | (1ULL << (MySQLParser::MAX_ROWS_SYMBOL - 311))
        | (1ULL << (MySQLParser::MAX_SIZE_SYMBOL - 311))
        | (1ULL << (MySQLParser::MAX_STATEMENT_TIME_SYMBOL - 311))
        | (1ULL << (MySQLParser::MAX_UPDATES_PER_HOUR_SYMBOL - 311))
        | (1ULL << (MySQLParser::MAX_USER_CONNECTIONS_SYMBOL - 311))
        | (1ULL << (MySQLParser::MEDIUM_SYMBOL - 311))
        | (1ULL << (MySQLParser::MEMORY_SYMBOL - 311))
        | (1ULL << (MySQLParser::MERGE_SYMBOL - 311))
        | (1ULL << (MySQLParser::MESSAGE_TEXT_SYMBOL - 311))
        | (1ULL << (MySQLParser::MICROSECOND_SYMBOL - 311))
        | (1ULL << (MySQLParser::MIGRATE_SYMBOL - 311)))) != 0) || ((((_la - 377) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 377)) & ((1ULL << (MySQLParser::MINUTE_SYMBOL - 377))
        | (1ULL << (MySQLParser::MIN_ROWS_SYMBOL - 377))
        | (1ULL << (MySQLParser::MODE_SYMBOL - 377))
        | (1ULL << (MySQLParser::MODIFY_SYMBOL - 377))
        | (1ULL << (MySQLParser::MONTH_SYMBOL - 377))
        | (1ULL << (MySQLParser::MULTILINESTRING_SYMBOL - 377))
        | (1ULL << (MySQLParser::MULTIPOINT_SYMBOL - 377))
        | (1ULL << (MySQLParser::MULTIPOLYGON_SYMBOL - 377))
        | (1ULL << (MySQLParser::MUTEX_SYMBOL - 377))
        | (1ULL << (MySQLParser::MYSQL_ERRNO_SYMBOL - 377))
        | (1ULL << (MySQLParser::NAMES_SYMBOL - 377))
        | (1ULL << (MySQLParser::NAME_SYMBOL - 377))
        | (1ULL << (MySQLParser::NATIONAL_SYMBOL - 377))
        | (1ULL << (MySQLParser::NCHAR_SYMBOL - 377))
        | (1ULL << (MySQLParser::NDBCLUSTER_SYMBOL - 377))
        | (1ULL << (MySQLParser::NEVER_SYMBOL - 377))
        | (1ULL << (MySQLParser::NEW_SYMBOL - 377))
        | (1ULL << (MySQLParser::NEXT_SYMBOL - 377))
        | (1ULL << (MySQLParser::NODEGROUP_SYMBOL - 377))
        | (1ULL << (MySQLParser::NO_WAIT_SYMBOL - 377))
        | (1ULL << (MySQLParser::NUMBER_SYMBOL - 377))
        | (1ULL << (MySQLParser::NVARCHAR_SYMBOL - 377))
        | (1ULL << (MySQLParser::OFFSET_SYMBOL - 377))
        | (1ULL << (MySQLParser::OLD_PASSWORD_SYMBOL - 377))
        | (1ULL << (MySQLParser::ONE_SHOT_SYMBOL - 377))
        | (1ULL << (MySQLParser::ONE_SYMBOL - 377))
        | (1ULL << (MySQLParser::PACK_KEYS_SYMBOL - 377))
        | (1ULL << (MySQLParser::PAGE_SYMBOL - 377))
        | (1ULL << (MySQLParser::PARTIAL_SYMBOL - 377))
        | (1ULL << (MySQLParser::PARTITIONING_SYMBOL - 377))
        | (1ULL << (MySQLParser::PARTITIONS_SYMBOL - 377))
        | (1ULL << (MySQLParser::PASSWORD_SYMBOL - 377)))) != 0) || ((((_la - 441) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 441)) & ((1ULL << (MySQLParser::PHASE_SYMBOL - 441))
        | (1ULL << (MySQLParser::PLUGINS_SYMBOL - 441))
        | (1ULL << (MySQLParser::PLUGIN_DIR_SYMBOL - 441))
        | (1ULL << (MySQLParser::PLUGIN_SYMBOL - 441))
        | (1ULL << (MySQLParser::POINT_SYMBOL - 441))
        | (1ULL << (MySQLParser::POLYGON_SYMBOL - 441))
        | (1ULL << (MySQLParser::PRESERVE_SYMBOL - 441))
        | (1ULL << (MySQLParser::PREV_SYMBOL - 441))
        | (1ULL << (MySQLParser::PRIVILEGES_SYMBOL - 441))
        | (1ULL << (MySQLParser::PROCESSLIST_SYMBOL - 441))
        | (1ULL << (MySQLParser::PROFILE_SYMBOL - 441))
        | (1ULL << (MySQLParser::PROFILES_SYMBOL - 441))
        | (1ULL << (MySQLParser::QUARTER_SYMBOL - 441))
        | (1ULL << (MySQLParser::QUERY_SYMBOL - 441))
        | (1ULL << (MySQLParser::QUICK_SYMBOL - 441))
        | (1ULL << (MySQLParser::READ_ONLY_SYMBOL - 441))
        | (1ULL << (MySQLParser::REBUILD_SYMBOL - 441))
        | (1ULL << (MySQLParser::RECOVER_SYMBOL - 441))
        | (1ULL << (MySQLParser::REDOFILE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REDO_BUFFER_SIZE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REDUNDANT_SYMBOL - 441))
        | (1ULL << (MySQLParser::RELAY_SYMBOL - 441))
        | (1ULL << (MySQLParser::RELAYLOG_SYMBOL - 441))
        | (1ULL << (MySQLParser::RELAY_LOG_FILE_SYMBOL - 441))
        | (1ULL << (MySQLParser::RELAY_LOG_POS_SYMBOL - 441))
        | (1ULL << (MySQLParser::RELAY_THREAD_SYMBOL - 441))
        | (1ULL << (MySQLParser::REORGANIZE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPEATABLE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPLICATE_DO_DB_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPLICATE_IGNORE_DB_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPLICATE_DO_TABLE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPLICATE_IGNORE_TABLE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPLICATE_WILD_DO_TABLE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPLICATE_WILD_IGNORE_TABLE_SYMBOL - 441))
        | (1ULL << (MySQLParser::REPLICATE_REWRITE_DB_SYMBOL - 441)))) != 0) || ((((_la - 506) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 506)) & ((1ULL << (MySQLParser::RESUME_SYMBOL - 506))
        | (1ULL << (MySQLParser::RETURNED_SQLSTATE_SYMBOL - 506))
        | (1ULL << (MySQLParser::RETURNS_SYMBOL - 506))
        | (1ULL << (MySQLParser::REVERSE_SYMBOL - 506))
        | (1ULL << (MySQLParser::ROLLUP_SYMBOL - 506))
        | (1ULL << (MySQLParser::ROTATE_SYMBOL - 506))
        | (1ULL << (MySQLParser::ROUTINE_SYMBOL - 506))
        | (1ULL << (MySQLParser::ROW_COUNT_SYMBOL - 506))
        | (1ULL << (MySQLParser::ROW_FORMAT_SYMBOL - 506))
        | (1ULL << (MySQLParser::RTREE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SCHEDULE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SCHEMA_NAME_SYMBOL - 506))
        | (1ULL << (MySQLParser::SECOND_SYMBOL - 506))
        | (1ULL << (MySQLParser::SERIALIZABLE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SERIAL_SYMBOL - 506))
        | (1ULL << (MySQLParser::SESSION_SYMBOL - 506))
        | (1ULL << (MySQLParser::SHARE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SIMPLE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SLOW_SYMBOL - 506))
        | (1ULL << (MySQLParser::SNAPSHOT_SYMBOL - 506))
        | (1ULL << (MySQLParser::SOUNDS_SYMBOL - 506))
        | (1ULL << (MySQLParser::SOURCE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SQL_AFTER_GTIDS_SYMBOL - 506))
        | (1ULL << (MySQLParser::SQL_AFTER_MTS_GAPS_SYMBOL - 506))
        | (1ULL << (MySQLParser::SQL_BEFORE_GTIDS_SYMBOL - 506))
        | (1ULL << (MySQLParser::SQL_BUFFER_RESULT_SYMBOL - 506))
        | (1ULL << (MySQLParser::SQL_CACHE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SQL_NO_CACHE_SYMBOL - 506))
        | (1ULL << (MySQLParser::SQL_THREAD_SYMBOL - 506)))) != 0) || ((((_la - 570) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 570)) & ((1ULL << (MySQLParser::STACKED_SYMBOL - 570))
        | (1ULL << (MySQLParser::STARTS_SYMBOL - 570))
        | (1ULL << (MySQLParser::STATS_AUTO_RECALC_SYMBOL - 570))
        | (1ULL << (MySQLParser::STATS_PERSISTENT_SYMBOL - 570))
        | (1ULL << (MySQLParser::STATS_SAMPLE_PAGES_SYMBOL - 570))
        | (1ULL << (MySQLParser::STATUS_SYMBOL - 570))
        | (1ULL << (MySQLParser::STORAGE_SYMBOL - 570))
        | (1ULL << (MySQLParser::STRING_SYMBOL - 570))
        | (1ULL << (MySQLParser::SUBCLASS_ORIGIN_SYMBOL - 570))
        | (1ULL << (MySQLParser::SUBDATE_SYMBOL - 570))
        | (1ULL << (MySQLParser::SUBJECT_SYMBOL - 570))
        | (1ULL << (MySQLParser::SUBPARTITIONS_SYMBOL - 570))
        | (1ULL << (MySQLParser::SUBPARTITION_SYMBOL - 570))
        | (1ULL << (MySQLParser::SUPER_SYMBOL - 570))
        | (1ULL << (MySQLParser::SUSPEND_SYMBOL - 570))
        | (1ULL << (MySQLParser::SWAPS_SYMBOL - 570))
        | (1ULL << (MySQLParser::SWITCHES_SYMBOL - 570))
        | (1ULL << (MySQLParser::TABLES_SYMBOL - 570))
        | (1ULL << (MySQLParser::TABLESPACE_SYMBOL - 570))
        | (1ULL << (MySQLParser::TABLE_CHECKSUM_SYMBOL - 570))
        | (1ULL << (MySQLParser::TABLE_NAME_SYMBOL - 570))
        | (1ULL << (MySQLParser::TEMPORARY_SYMBOL - 570))
        | (1ULL << (MySQLParser::TEMPTABLE_SYMBOL - 570))
        | (1ULL << (MySQLParser::TEXT_SYMBOL - 570))
        | (1ULL << (MySQLParser::THAN_SYMBOL - 570))
        | (1ULL << (MySQLParser::TIMESTAMP_SYMBOL - 570))
        | (1ULL << (MySQLParser::TIMESTAMP_ADD_SYMBOL - 570))
        | (1ULL << (MySQLParser::TIMESTAMP_DIFF_SYMBOL - 570))
        | (1ULL << (MySQLParser::TIME_SYMBOL - 570))
        | (1ULL << (MySQLParser::TRANSACTION_SYMBOL - 570))
        | (1ULL << (MySQLParser::TRIGGERS_SYMBOL - 570))
        | (1ULL << (MySQLParser::TYPES_SYMBOL - 570))
        | (1ULL << (MySQLParser::TYPE_SYMBOL - 570))
        | (1ULL << (MySQLParser::UDF_RETURNS_SYMBOL - 570))
        | (1ULL << (MySQLParser::UNCOMMITTED_SYMBOL - 570))
        | (1ULL << (MySQLParser::UNDEFINED_SYMBOL - 570))
        | (1ULL << (MySQLParser::UNDOFILE_SYMBOL - 570)))) != 0) || ((((_la - 634) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 634)) & ((1ULL << (MySQLParser::UNDO_BUFFER_SIZE_SYMBOL - 634))
        | (1ULL << (MySQLParser::UNKNOWN_SYMBOL - 634))
        | (1ULL << (MySQLParser::UNTIL_SYMBOL - 634))
        | (1ULL << (MySQLParser::USER_RESOURCES_SYMBOL - 634))
        | (1ULL << (MySQLParser::USER_SYMBOL - 634))
        | (1ULL << (MySQLParser::USE_FRM_SYMBOL - 634))
        | (1ULL << (MySQLParser::VALUE_SYMBOL - 634))
        | (1ULL << (MySQLParser::VARIABLES_SYMBOL - 634))
        | (1ULL << (MySQLParser::VIEW_SYMBOL - 634))
        | (1ULL << (MySQLParser::WAIT_SYMBOL - 634))
        | (1ULL << (MySQLParser::WARNINGS_SYMBOL - 634))
        | (1ULL << (MySQLParser::WEEK_SYMBOL - 634))
        | (1ULL << (MySQLParser::WEIGHT_STRING_SYMBOL - 634))
        | (1ULL << (MySQLParser::WORK_SYMBOL - 634))
        | (1ULL << (MySQLParser::X509_SYMBOL - 634))
        | (1ULL << (MySQLParser::XID_SYMBOL - 634))
        | (1ULL << (MySQLParser::XML_SYMBOL - 634))
        | (1ULL << (MySQLParser::YEAR_SYMBOL - 634))
        | (1ULL << (MySQLParser::COMPONENT_SYMBOL - 634)))) != 0) || ((((_la - 700) & ~ 0x3fULL) == 0) &&
        ((1ULL << (_la - 700)) & ((1ULL << (MySQLParser::SKIP_SYMBOL - 700))
        | (1ULL << (MySQLParser::LOCKED_SYMBOL - 700))
        | (1ULL << (MySQLParser::NOWAIT_SYMBOL - 700))
        | (1ULL << (MySQLParser::HISTOGRAM_SYMBOL - 700))
        | (1ULL << (MySQLParser::BUCKETS_SYMBOL - 700))
        | (1ULL << (MySQLParser::REMOTE_SYMBOL - 700))
        | (1ULL << (MySQLParser::EXCLUDE_SYMBOL - 700))
        | (1ULL << (MySQLParser::FOLLOWING_SYMBOL - 700))
        | (1ULL << (MySQLParser::NULLS_SYMBOL - 700))
        | (1ULL << (MySQLParser::OTHERS_SYMBOL - 700))
        | (1ULL << (MySQLParser::PRECEDING_SYMBOL - 700))
        | (1ULL << (MySQLParser::RESPECT_SYMBOL - 700))
        | (1ULL << (MySQLParser::TIES_SYMBOL - 700))
        | (1ULL << (MySQLParser::UNBOUNDED_SYMBOL - 700))
        | (1ULL << (MySQLParser::NESTED_SYMBOL - 700))
        | (1ULL << (MySQLParser::ORDINALITY_SYMBOL - 700))
        | (1ULL << (MySQLParser::PATH_SYMBOL - 700))
        | (1ULL << (MySQLParser::HISTORY_SYMBOL - 700))
        | (1ULL << (MySQLParser::REUSE_SYMBOL - 700))
        | (1ULL << (MySQLParser::SRID_SYMBOL - 700))
        | (1ULL << (MySQLParser::THREAD_PRIORITY_SYMBOL - 700))
        | (1ULL << (MySQLParser::VCPU_SYMBOL - 700))
        | (1ULL << (MySQLParser::MASTER_PUBLIC_KEY_PATH_SYMBOL - 700))
        | (1ULL << (MySQLParser::DESCRIPTION_SYMBOL - 700))
        | (1ULL << (MySQLParser::ORGANIZATION_SYMBOL - 700))
        | (1ULL << (MySQLParser::OPTIONAL_SYMBOL - 700))
        | (1ULL << (MySQLParser::ACTIVE_SYMBOL - 700))
        | (1ULL << (MySQLParser::INACTIVE_SYMBOL - 700))
        | (1ULL << (MySQLParser::RETAIN_SYMBOL - 700))
        | (1ULL << (MySQLParser::OLD_SYMBOL - 700)))) != 0))) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(8300);

      if (!(serverVersion < 50709)) throw FailedPredicateException(this, "serverVersion < 50709");
      setState(8301);
      match(MySQLParser::SHUTDOWN_SYMBOL);
      break;
    }

    case 3: {
      enterOuterAlt(_localctx, 3);
      setState(8302);

      if (!(serverVersion < 80000)) throw FailedPredicateException(this, "serverVersion < 80000");
      setState(8303);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::CUBE_SYMBOL || _la == MySQLParser::FUNCTION_SYMBOL

      || _la == MySQLParser::IMPORT_SYMBOL || _la == MySQLParser::ROWS_SYMBOL

      || _la == MySQLParser::ROW_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 4: {
      enterOuterAlt(_localctx, 4);
      setState(8304);

      if (!(serverVersion >= 80000)) throw FailedPredicateException(this, "serverVersion >= 80000");
      setState(8305);
      _la = _input->LA(1);
      if (!(_la == MySQLParser::EXCHANGE_SYMBOL

      || _la == MySQLParser::EXPIRE_SYMBOL || _la == MySQLParser::ONLY_SYMBOL || _la == MySQLParser::SUPER_SYMBOL

      || _la == MySQLParser::VALIDATION_SYMBOL || _la == MySQLParser::WITHOUT_SYMBOL)) {
      _errHandler->recoverInline(this);
      }
      else {
        _errHandler->reportMatch(this);
        consume();
      }
      break;
    }

    case 5: {
      enterOuterAlt(_localctx, 5);
      setState(8306);

      if (!(serverVersion >= 80014)) throw FailedPredicateException(this, "serverVersion >= 80014");
      setState(8307);
      match(MySQLParser::ADMIN_SYMBOL);
      break;
    }

    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool MySQLParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 3: return simpleStatementSempred(dynamic_cast<SimpleStatementContext *>(context), predicateIndex);
    case 4: return alterStatementSempred(dynamic_cast<AlterStatementContext *>(context), predicateIndex);
    case 5: return alterDatabaseSempred(dynamic_cast<AlterDatabaseContext *>(context), predicateIndex);
    case 11: return alterTableSempred(dynamic_cast<AlterTableContext *>(context), predicateIndex);
    case 15: return standaloneAlterCommandsSempred(dynamic_cast<StandaloneAlterCommandsContext *>(context), predicateIndex);
    case 16: return alterPartitionSempred(dynamic_cast<AlterPartitionContext *>(context), predicateIndex);
    case 18: return alterCommandsModifierSempred(dynamic_cast<AlterCommandsModifierContext *>(context), predicateIndex);
    case 19: return alterListItemSempred(dynamic_cast<AlterListItemContext *>(context), predicateIndex);
    case 25: return indexLockAndAlgorithmSempred(dynamic_cast<IndexLockAndAlgorithmContext *>(context), predicateIndex);
    case 26: return withValidationSempred(dynamic_cast<WithValidationContext *>(context), predicateIndex);
    case 30: return alterTablespaceSempred(dynamic_cast<AlterTablespaceContext *>(context), predicateIndex);
    case 41: return createStatementSempred(dynamic_cast<CreateStatementContext *>(context), predicateIndex);
    case 43: return createDatabaseOptionSempred(dynamic_cast<CreateDatabaseOptionContext *>(context), predicateIndex);
    case 56: return createIndexSempred(dynamic_cast<CreateIndexContext *>(context), predicateIndex);
    case 67: return tsDataFileNameSempred(dynamic_cast<TsDataFileNameContext *>(context), predicateIndex);
    case 70: return tablespaceOptionSempred(dynamic_cast<TablespaceOptionContext *>(context), predicateIndex);
    case 87: return triggerFollowsPrecedesClauseSempred(dynamic_cast<TriggerFollowsPrecedesClauseContext *>(context), predicateIndex);
    case 92: return dropStatementSempred(dynamic_cast<DropStatementContext *>(context), predicateIndex);
    case 113: return deleteStatementSempred(dynamic_cast<DeleteStatementContext *>(context), predicateIndex);
    case 114: return partitionDeleteSempred(dynamic_cast<PartitionDeleteContext *>(context), predicateIndex);
    case 116: return doStatementSempred(dynamic_cast<DoStatementContext *>(context), predicateIndex);
    case 137: return queryExpressionSempred(dynamic_cast<QueryExpressionContext *>(context), predicateIndex);
    case 138: return queryExpressionBodySempred(dynamic_cast<QueryExpressionBodyContext *>(context), predicateIndex);
    case 140: return querySpecificationSempred(dynamic_cast<QuerySpecificationContext *>(context), predicateIndex);
    case 164: return olapOptionSempred(dynamic_cast<OlapOptionContext *>(context), predicateIndex);
    case 169: return selectOptionSempred(dynamic_cast<SelectOptionContext *>(context), predicateIndex);
    case 170: return lockingClauseSempred(dynamic_cast<LockingClauseContext *>(context), predicateIndex);
    case 171: return lockStrenghSempred(dynamic_cast<LockStrenghContext *>(context), predicateIndex);
    case 177: return tableReferenceSempred(dynamic_cast<TableReferenceContext *>(context), predicateIndex);
    case 183: return tableFactorSempred(dynamic_cast<TableFactorContext *>(context), predicateIndex);
    case 186: return derivedTableSempred(dynamic_cast<DerivedTableContext *>(context), predicateIndex);
    case 190: return jtColumnSempred(dynamic_cast<JtColumnContext *>(context), predicateIndex);
    case 196: return tableAliasSempred(dynamic_cast<TableAliasContext *>(context), predicateIndex);
    case 205: return updateStatementSempred(dynamic_cast<UpdateStatementContext *>(context), predicateIndex);
    case 209: return transactionCharacteristicSempred(dynamic_cast<TransactionCharacteristicContext *>(context), predicateIndex);
    case 210: return setTransactionCharacteristicSempred(dynamic_cast<SetTransactionCharacteristicContext *>(context), predicateIndex);
    case 213: return lockStatementSempred(dynamic_cast<LockStatementContext *>(context), predicateIndex);
    case 217: return xaConvertSempred(dynamic_cast<XaConvertContext *>(context), predicateIndex);
    case 219: return replicationStatementSempred(dynamic_cast<ReplicationStatementContext *>(context), predicateIndex);
    case 220: return resetOptionSempred(dynamic_cast<ResetOptionContext *>(context), predicateIndex);
    case 221: return masterResetOptionsSempred(dynamic_cast<MasterResetOptionsContext *>(context), predicateIndex);
    case 228: return changeReplicationSempred(dynamic_cast<ChangeReplicationContext *>(context), predicateIndex);
    case 236: return slaveUntilOptionsSempred(dynamic_cast<SlaveUntilOptionsContext *>(context), predicateIndex);
    case 237: return slaveConnectionOptionsSempred(dynamic_cast<SlaveConnectionOptionsContext *>(context), predicateIndex);
    case 244: return cloneStatementSempred(dynamic_cast<CloneStatementContext *>(context), predicateIndex);
    case 247: return accountManagementStatementSempred(dynamic_cast<AccountManagementStatementContext *>(context), predicateIndex);
    case 248: return alterUserSempred(dynamic_cast<AlterUserContext *>(context), predicateIndex);
    case 249: return alterUserTailSempred(dynamic_cast<AlterUserTailContext *>(context), predicateIndex);
    case 250: return createUserSempred(dynamic_cast<CreateUserContext *>(context), predicateIndex);
    case 251: return createUserTailSempred(dynamic_cast<CreateUserTailContext *>(context), predicateIndex);
    case 252: return defaultRoleClauseSempred(dynamic_cast<DefaultRoleClauseContext *>(context), predicateIndex);
    case 255: return accountLockPasswordExpireOptionsSempred(dynamic_cast<AccountLockPasswordExpireOptionsContext *>(context), predicateIndex);
    case 256: return dropUserSempred(dynamic_cast<DropUserContext *>(context), predicateIndex);
    case 257: return grantSempred(dynamic_cast<GrantContext *>(context), predicateIndex);
    case 258: return grantTargetListSempred(dynamic_cast<GrantTargetListContext *>(context), predicateIndex);
    case 259: return grantOptionsSempred(dynamic_cast<GrantOptionsContext *>(context), predicateIndex);
    case 263: return versionedRequireClauseSempred(dynamic_cast<VersionedRequireClauseContext *>(context), predicateIndex);
    case 265: return revokeSempred(dynamic_cast<RevokeContext *>(context), predicateIndex);
    case 266: return onTypeToSempred(dynamic_cast<OnTypeToContext *>(context), predicateIndex);
    case 268: return setPasswordSempred(dynamic_cast<SetPasswordContext *>(context), predicateIndex);
    case 270: return roleOrPrivilegeSempred(dynamic_cast<RoleOrPrivilegeContext *>(context), predicateIndex);
    case 271: return grantIdentifierSempred(dynamic_cast<GrantIdentifierContext *>(context), predicateIndex);
    case 278: return tableAdministrationStatementSempred(dynamic_cast<TableAdministrationStatementContext *>(context), predicateIndex);
    case 284: return optionValueNoOptionTypeSempred(dynamic_cast<OptionValueNoOptionTypeContext *>(context), predicateIndex);
    case 287: return setExprOrDefaultSempred(dynamic_cast<SetExprOrDefaultContext *>(context), predicateIndex);
    case 290: return showStatementSempred(dynamic_cast<ShowStatementContext *>(context), predicateIndex);
    case 291: return showCommandTypeSempred(dynamic_cast<ShowCommandTypeContext *>(context), predicateIndex);
    case 292: return nonBlockingSempred(dynamic_cast<NonBlockingContext *>(context), predicateIndex);
    case 296: return otherAdministrativeStatementSempred(dynamic_cast<OtherAdministrativeStatementContext *>(context), predicateIndex);
    case 304: return flushOptionSempred(dynamic_cast<FlushOptionContext *>(context), predicateIndex);
    case 307: return flushTablesOptionsSempred(dynamic_cast<FlushTablesOptionsContext *>(context), predicateIndex);
    case 322: return utilityStatementSempred(dynamic_cast<UtilityStatementContext *>(context), predicateIndex);
    case 324: return explainCommandSempred(dynamic_cast<ExplainCommandContext *>(context), predicateIndex);
    case 325: return explainableStatementSempred(dynamic_cast<ExplainableStatementContext *>(context), predicateIndex);
    case 329: return exprSempred(dynamic_cast<ExprContext *>(context), predicateIndex);
    case 330: return boolPriSempred(dynamic_cast<BoolPriContext *>(context), predicateIndex);
    case 332: return predicateSempred(dynamic_cast<PredicateContext *>(context), predicateIndex);
    case 334: return bitExprSempred(dynamic_cast<BitExprContext *>(context), predicateIndex);
    case 335: return simpleExprSempred(dynamic_cast<SimpleExprContext *>(context), predicateIndex);
    case 336: return arrayCastSempred(dynamic_cast<ArrayCastContext *>(context), predicateIndex);
    case 337: return jsonOperatorSempred(dynamic_cast<JsonOperatorContext *>(context), predicateIndex);
    case 338: return sumExprSempred(dynamic_cast<SumExprContext *>(context), predicateIndex);
    case 349: return runtimeFunctionCallSempred(dynamic_cast<RuntimeFunctionCallContext *>(context), predicateIndex);
    case 350: return geometryFunctionSempred(dynamic_cast<GeometryFunctionContext *>(context), predicateIndex);
    case 352: return fractionalPrecisionSempred(dynamic_cast<FractionalPrecisionContext *>(context), predicateIndex);
    case 364: return internalVariableNameSempred(dynamic_cast<InternalVariableNameContext *>(context), predicateIndex);
    case 368: return castTypeSempred(dynamic_cast<CastTypeContext *>(context), predicateIndex);
    case 382: return channelSempred(dynamic_cast<ChannelContext *>(context), predicateIndex);
    case 411: return getDiagnosticsSempred(dynamic_cast<GetDiagnosticsContext *>(context), predicateIndex);
    case 424: return checkOrReferencesSempred(dynamic_cast<CheckOrReferencesContext *>(context), predicateIndex);
    case 427: return tableConstraintDefSempred(dynamic_cast<TableConstraintDefContext *>(context), predicateIndex);
    case 429: return fieldDefinitionSempred(dynamic_cast<FieldDefinitionContext *>(context), predicateIndex);
    case 430: return columnAttributeSempred(dynamic_cast<ColumnAttributeContext *>(context), predicateIndex);
    case 440: return keyListVariantsSempred(dynamic_cast<KeyListVariantsContext *>(context), predicateIndex);
    case 443: return commonIndexOptionSempred(dynamic_cast<CommonIndexOptionContext *>(context), predicateIndex);
    case 449: return dataTypeSempred(dynamic_cast<DataTypeContext *>(context), predicateIndex);
    case 460: return typeDatetimePrecisionSempred(dynamic_cast<TypeDatetimePrecisionContext *>(context), predicateIndex);
    case 461: return charsetNameSempred(dynamic_cast<CharsetNameContext *>(context), predicateIndex);
    case 462: return collationNameSempred(dynamic_cast<CollationNameContext *>(context), predicateIndex);
    case 465: return createTableOptionSempred(dynamic_cast<CreateTableOptionContext *>(context), predicateIndex);
    case 473: return partitionKeyAlgorithmSempred(dynamic_cast<PartitionKeyAlgorithmContext *>(context), predicateIndex);
    case 500: return createUserEntrySempred(dynamic_cast<CreateUserEntryContext *>(context), predicateIndex);
    case 508: return onlineOptionSempred(dynamic_cast<OnlineOptionContext *>(context), predicateIndex);
    case 510: return usePartitionSempred(dynamic_cast<UsePartitionContext *>(context), predicateIndex);
    case 512: return columnNameSempred(dynamic_cast<ColumnNameContext *>(context), predicateIndex);
    case 555: return pureIdentifierSempred(dynamic_cast<PureIdentifierContext *>(context), predicateIndex);
    case 560: return simpleIdentifierSempred(dynamic_cast<SimpleIdentifierContext *>(context), predicateIndex);
    case 565: return real_ulonglong_numberSempred(dynamic_cast<Real_ulonglong_numberContext *>(context), predicateIndex);
    case 569: return textStringLiteralSempred(dynamic_cast<TextStringLiteralContext *>(context), predicateIndex);
    case 571: return textStringHashSempred(dynamic_cast<TextStringHashContext *>(context), predicateIndex);
    case 591: return identifierKeywordSempred(dynamic_cast<IdentifierKeywordContext *>(context), predicateIndex);
    case 594: return labelKeywordSempred(dynamic_cast<LabelKeywordContext *>(context), predicateIndex);
    case 597: return roleKeywordSempred(dynamic_cast<RoleKeywordContext *>(context), predicateIndex);
    case 600: return roleOrIdentifierKeywordSempred(dynamic_cast<RoleOrIdentifierKeywordContext *>(context), predicateIndex);
    case 601: return roleOrLabelKeywordSempred(dynamic_cast<RoleOrLabelKeywordContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool MySQLParser::simpleStatementSempred(SimpleStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return serverVersion >= 80000;
    case 1: return serverVersion >= 80000;
    case 2: return serverVersion >= 80000;
    case 3: return serverVersion >= 50604;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterStatementSempred(AlterStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 4: return serverVersion >= 80014;
    case 5: return serverVersion >= 50713;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterDatabaseSempred(AlterDatabaseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 6: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterTableSempred(AlterTableContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 7: return serverVersion < 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::standaloneAlterCommandsSempred(StandaloneAlterCommandsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 8: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterPartitionSempred(AlterPartitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 9: return serverVersion >= 50704;
    case 10: return serverVersion >= 50704;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterCommandsModifierSempred(AlterCommandsModifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 11: return serverVersion >= 50600;
    case 12: return serverVersion >= 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterListItemSempred(AlterListItemContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 13: return serverVersion >= 50700;
    case 14: return serverVersion < 50700;
    case 15: return serverVersion >= 80014;
    case 16: return serverVersion >= 80000;
    case 17: return serverVersion >= 80017;
    case 18: return serverVersion >= 80000;
    case 19: return serverVersion >= 50700;
    case 20: return serverVersion >= 80014;
    case 21: return serverVersion >= 50708 && serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::indexLockAndAlgorithmSempred(IndexLockAndAlgorithmContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 22: return serverVersion >= 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::withValidationSempred(WithValidationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 23: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterTablespaceSempred(AlterTablespaceContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 24: return serverVersion < 80000;
    case 25: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createStatementSempred(CreateStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 26: return serverVersion >= 80000;
    case 27: return serverVersion >= 80011;
    case 28: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createDatabaseOptionSempred(CreateDatabaseOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 29: return serverVersion >= 80016;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createIndexSempred(CreateIndexContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 30: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tsDataFileNameSempred(TsDataFileNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 31: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tablespaceOptionSempred(TablespaceOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 32: return serverVersion >= 50707;
    case 33: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::triggerFollowsPrecedesClauseSempred(TriggerFollowsPrecedesClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 34: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::dropStatementSempred(DropStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 35: return serverVersion >= 80000;
    case 36: return serverVersion >= 80011;
    case 37: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::deleteStatementSempred(DeleteStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 38: return serverVersion >= 80000;
    case 39: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::partitionDeleteSempred(PartitionDeleteContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 40: return serverVersion >= 50602;

  default:
    break;
  }
  return true;
}

bool MySQLParser::doStatementSempred(DoStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 41: return serverVersion < 50709;
    case 42: return serverVersion >= 50709;

  default:
    break;
  }
  return true;
}

bool MySQLParser::queryExpressionSempred(QueryExpressionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 43: return serverVersion >= 80000;
    case 44: return serverVersion < 80000;
    case 45: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::queryExpressionBodySempred(QueryExpressionBodyContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 46: return precpred(_ctx, 2);

  default:
    break;
  }
  return true;
}

bool MySQLParser::querySpecificationSempred(QuerySpecificationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 47: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::olapOptionSempred(OlapOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 48: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::selectOptionSempred(SelectOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 49: return serverVersion < 80000;
    case 50: return serverVersion >= 50704 && serverVersion < 50708;

  default:
    break;
  }
  return true;
}

bool MySQLParser::lockingClauseSempred(LockingClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 51: return serverVersion >= 80000;
    case 52: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::lockStrenghSempred(LockStrenghContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 53: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tableReferenceSempred(TableReferenceContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 54: return serverVersion < 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tableFactorSempred(TableFactorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 55: return serverVersion >= 80004;

  default:
    break;
  }
  return true;
}

bool MySQLParser::derivedTableSempred(DerivedTableContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 56: return serverVersion >= 80000;
    case 57: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::jtColumnSempred(JtColumnContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 58: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tableAliasSempred(TableAliasContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 59: return serverVersion < 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::updateStatementSempred(UpdateStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 60: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::transactionCharacteristicSempred(TransactionCharacteristicContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 61: return serverVersion >= 50605;

  default:
    break;
  }
  return true;
}

bool MySQLParser::setTransactionCharacteristicSempred(SetTransactionCharacteristicContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 62: return serverVersion >= 50605;

  default:
    break;
  }
  return true;
}

bool MySQLParser::lockStatementSempred(LockStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 63: return serverVersion >= 80000;
    case 64: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::xaConvertSempred(XaConvertContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 65: return serverVersion >= 50704;

  default:
    break;
  }
  return true;
}

bool MySQLParser::replicationStatementSempred(ReplicationStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 66: return serverVersion > 80000;
    case 67: return serverVersion >= 50700;
    case 68: return serverVersion > 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::resetOptionSempred(ResetOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 69: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::masterResetOptionsSempred(MasterResetOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 70: return serverVersion >= 80000;
    case 71: return serverVersion < 80017;
    case 72: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::changeReplicationSempred(ChangeReplicationContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 73: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::slaveUntilOptionsSempred(SlaveUntilOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 74: return serverVersion >= 50606;
    case 75: return serverVersion >= 50606;

  default:
    break;
  }
  return true;
}

bool MySQLParser::slaveConnectionOptionsSempred(SlaveConnectionOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 76: return serverVersion >= 50604;

  default:
    break;
  }
  return true;
}

bool MySQLParser::cloneStatementSempred(CloneStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 77: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::accountManagementStatementSempred(AccountManagementStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 78: return serverVersion >= 50606;
    case 79: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterUserSempred(AlterUserContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 80: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::alterUserTailSempred(AlterUserTailContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 81: return serverVersion < 80014;
    case 82: return serverVersion >= 80014;
    case 83: return serverVersion >= 50706;
    case 84: return serverVersion >= 80014;
    case 85: return serverVersion >= 80014;
    case 86: return serverVersion >= 80014;
    case 87: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createUserSempred(CreateUserContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 88: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createUserTailSempred(CreateUserTailContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 89: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::defaultRoleClauseSempred(DefaultRoleClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 90: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::accountLockPasswordExpireOptionsSempred(AccountLockPasswordExpireOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 91: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::dropUserSempred(DropUserContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 92: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::grantSempred(GrantContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 93: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::grantTargetListSempred(GrantTargetListContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 94: return serverVersion < 80011;
    case 95: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::grantOptionsSempred(GrantOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 96: return serverVersion < 80011;
    case 97: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::versionedRequireClauseSempred(VersionedRequireClauseContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 98: return serverVersion < 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::revokeSempred(RevokeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 99: return serverVersion >= 80000;
    case 100: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::onTypeToSempred(OnTypeToContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 101: return serverVersion < 80000;
    case 102: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::setPasswordSempred(SetPasswordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 103: return serverVersion < 50706;
    case 104: return serverVersion >= 80014;
    case 105: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

bool MySQLParser::roleOrPrivilegeSempred(RoleOrPrivilegeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 106: return serverVersion > 80000;
    case 107: return serverVersion > 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::grantIdentifierSempred(GrantIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 108: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tableAdministrationStatementSempred(TableAdministrationStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 109: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::optionValueNoOptionTypeSempred(OptionValueNoOptionTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 110: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::setExprOrDefaultSempred(SetExprOrDefaultContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 111: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::showStatementSempred(ShowStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 112: return serverVersion < 50700;
    case 113: return serverVersion >= 80000;
    case 114: return serverVersion < 50700;
    case 115: return serverVersion >= 50704;

  default:
    break;
  }
  return true;
}

bool MySQLParser::showCommandTypeSempred(ShowCommandTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 116: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::nonBlockingSempred(NonBlockingContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 117: return serverVersion >= 50700 && serverVersion < 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::otherAdministrativeStatementSempred(OtherAdministrativeStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 118: return serverVersion >= 50709;

  default:
    break;
  }
  return true;
}

bool MySQLParser::flushOptionSempred(FlushOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 119: return serverVersion < 80000;
    case 120: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::flushTablesOptionsSempred(FlushTablesOptionsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 121: return serverVersion >= 50606;

  default:
    break;
  }
  return true;
}

bool MySQLParser::utilityStatementSempred(UtilityStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 122: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::explainCommandSempred(ExplainCommandContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 123: return serverVersion < 80000;
    case 124: return serverVersion < 80000;
    case 125: return serverVersion >= 50605;

  default:
    break;
  }
  return true;
}

bool MySQLParser::explainableStatementSempred(ExplainableStatementContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 126: return serverVersion >= 50603;
    case 127: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 128: return precpred(_ctx, 3);
    case 129: return precpred(_ctx, 2);
    case 130: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool MySQLParser::boolPriSempred(BoolPriContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 131: return precpred(_ctx, 3);
    case 132: return precpred(_ctx, 2);
    case 133: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

bool MySQLParser::predicateSempred(PredicateContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 134: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::bitExprSempred(BitExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 135: return precpred(_ctx, 7);
    case 136: return precpred(_ctx, 6);
    case 137: return precpred(_ctx, 5);
    case 138: return precpred(_ctx, 3);
    case 139: return precpred(_ctx, 2);
    case 140: return precpred(_ctx, 1);
    case 141: return precpred(_ctx, 4);

  default:
    break;
  }
  return true;
}

bool MySQLParser::simpleExprSempred(SimpleExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 142: return serverVersion >= 80000;
    case 143: return serverVersion >= 80000;
    case 144: return precpred(_ctx, 15);
    case 145: return precpred(_ctx, 21);

  default:
    break;
  }
  return true;
}

bool MySQLParser::arrayCastSempred(ArrayCastContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 146: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::jsonOperatorSempred(JsonOperatorContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 147: return serverVersion >= 50708;
    case 148: return serverVersion >= 50713;

  default:
    break;
  }
  return true;
}

bool MySQLParser::sumExprSempred(SumExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 149: return serverVersion >= 80000;
    case 150: return serverVersion >= 80000;
    case 151: return serverVersion >= 80000;
    case 152: return serverVersion >= 80000;
    case 153: return serverVersion >= 80000;
    case 154: return serverVersion >= 80000;
    case 155: return serverVersion >= 80000;
    case 156: return serverVersion >= 80000;
    case 157: return serverVersion >= 80000;
    case 158: return serverVersion >= 80000;
    case 159: return serverVersion >= 80000;
    case 160: return serverVersion >= 80000;
    case 161: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::runtimeFunctionCallSempred(RuntimeFunctionCallContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 162: return serverVersion < 50607;
    case 163: return serverVersion < 80011;
    case 164: return serverVersion >= 50600;
    case 165: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::geometryFunctionSempred(GeometryFunctionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 166: return serverVersion < 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::fractionalPrecisionSempred(FractionalPrecisionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 167: return serverVersion >= 50604;

  default:
    break;
  }
  return true;
}

bool MySQLParser::internalVariableNameSempred(InternalVariableNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 168: return serverVersion < 80017;
    case 169: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::castTypeSempred(CastTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 170: return serverVersion >= 50708;
    case 171: return serverVersion >= 80017;
    case 172: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::channelSempred(ChannelContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 173: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::getDiagnosticsSempred(GetDiagnosticsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 174: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::checkOrReferencesSempred(CheckOrReferencesContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 175: return serverVersion < 80016;

  default:
    break;
  }
  return true;
}

bool MySQLParser::tableConstraintDefSempred(TableConstraintDefContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 176: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::fieldDefinitionSempred(FieldDefinitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 177: return serverVersion >= 50707;
    case 178: return serverVersion < 80000;
    case 179: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::columnAttributeSempred(ColumnAttributeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 180: return serverVersion >= 80014;
    case 181: return serverVersion >= 80013;
    case 182: return serverVersion >= 80000;
    case 183: return serverVersion >= 80017;
    case 184: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::keyListVariantsSempred(KeyListVariantsContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 185: return serverVersion >= 80013;
    case 186: return serverVersion < 80013;

  default:
    break;
  }
  return true;
}

bool MySQLParser::commonIndexOptionSempred(CommonIndexOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 187: return serverVersion >= 50600;
    case 188: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::dataTypeSempred(DataTypeContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 189: return serverVersion >= 50708;

  default:
    break;
  }
  return true;
}

bool MySQLParser::typeDatetimePrecisionSempred(TypeDatetimePrecisionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 190: return serverVersion >= 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::charsetNameSempred(CharsetNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 191: return serverVersion < 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::collationNameSempred(CollationNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 192: return serverVersion < 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createTableOptionSempred(CreateTableOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 193: return serverVersion >= 80014;
    case 194: return serverVersion >= 50708;
    case 195: return serverVersion >= 50711;
    case 196: return serverVersion >= 50600;
    case 197: return serverVersion >= 50707;

  default:
    break;
  }
  return true;
}

bool MySQLParser::partitionKeyAlgorithmSempred(PartitionKeyAlgorithmContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 198: return serverVersion >= 50700;

  default:
    break;
  }
  return true;
}

bool MySQLParser::createUserEntrySempred(CreateUserEntryContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 199: return serverVersion < 80011;
    case 200: return serverVersion >= 50600;
    case 201: return serverVersion >= 50706;

  default:
    break;
  }
  return true;
}

bool MySQLParser::onlineOptionSempred(OnlineOptionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 202: return serverVersion < 50600;

  default:
    break;
  }
  return true;
}

bool MySQLParser::usePartitionSempred(UsePartitionContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 203: return serverVersion >= 50602;

  default:
    break;
  }
  return true;
}

bool MySQLParser::columnNameSempred(ColumnNameContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 204: return serverVersion >= 80000;
    case 205: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::pureIdentifierSempred(PureIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 206: return isSqlModeActive(AnsiQuotes);

  default:
    break;
  }
  return true;
}

bool MySQLParser::simpleIdentifierSempred(SimpleIdentifierContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 207: return serverVersion < 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::real_ulonglong_numberSempred(Real_ulonglong_numberContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 208: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::textStringLiteralSempred(TextStringLiteralContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 209: return !isSqlModeActive(AnsiQuotes);

  default:
    break;
  }
  return true;
}

bool MySQLParser::textStringHashSempred(TextStringHashContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 210: return serverVersion >= 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::identifierKeywordSempred(IdentifierKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 211: return serverVersion < 80017;
    case 212: return serverVersion >= 50709;
    case 213: return serverVersion >= 80011;

  default:
    break;
  }
  return true;
}

bool MySQLParser::labelKeywordSempred(LabelKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 214: return serverVersion < 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::roleKeywordSempred(RoleKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 215: return serverVersion < 80017;

  default:
    break;
  }
  return true;
}

bool MySQLParser::roleOrIdentifierKeywordSempred(RoleOrIdentifierKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 216: return serverVersion >= 50709;
    case 217: return serverVersion >= 80000;

  default:
    break;
  }
  return true;
}

bool MySQLParser::roleOrLabelKeywordSempred(RoleOrLabelKeywordContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 218: return serverVersion < 50709;
    case 219: return serverVersion < 80000;
    case 220: return serverVersion >= 80000;
    case 221: return serverVersion >= 80014;

  default:
    break;
  }
  return true;
}

// Static vars and initialization.
std::vector<dfa::DFA> MySQLParser::_decisionToDFA;
atn::PredictionContextCache MySQLParser::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN MySQLParser::_atn;
std::vector<uint16_t> MySQLParser::_serializedATN;

std::vector<std::string> MySQLParser::_ruleNames = {
  "queries", "aux_query", "query", "simpleStatement", "alterStatement", 
  "alterDatabase", "alterEvent", "alterLogfileGroup", "alterLogfileGroupOptions", 
  "alterLogfileGroupOption", "alterServer", "alterTable", "alterTableActions", 
  "alterCommandList", "alterCommandsModifierList", "standaloneAlterCommands", 
  "alterPartition", "alterList", "alterCommandsModifier", "alterListItem", 
  "place", "restrict", "alterOrderList", "alterAlgorithmOption", "alterLockOption", 
  "indexLockAndAlgorithm", "withValidation", "removePartitioning", "allOrPartitionNameList", 
  "reorgPartitionRule", "alterTablespace", "alterUndoTablespace", "undoTableSpaceOptions", 
  "undoTableSpaceOption", "alterTablespaceOptions", "alterTablespaceOption", 
  "changeTablespaceOption", "alterView", "viewTail", "viewSelect", "viewCheckOption", 
  "createStatement", "createDatabase", "createDatabaseOption", "createTable", 
  "tableElementList", "tableElement", "duplicateAsQueryExpression", "queryExpressionOrParens", 
  "createRoutine", "createProcedure", "createFunction", "createUdf", "routineCreateOption", 
  "routineAlterOptions", "routineOption", "createIndex", "indexNameAndType", 
  "createIndexTarget", "createLogfileGroup", "logfileGroupOptions", "logfileGroupOption", 
  "createServer", "serverOptions", "serverOption", "createTablespace", "createUndoTablespace", 
  "tsDataFileName", "tsDataFile", "tablespaceOptions", "tablespaceOption", 
  "tsOptionInitialSize", "tsOptionUndoRedoBufferSize", "tsOptionAutoextendSize", 
  "tsOptionMaxSize", "tsOptionExtentSize", "tsOptionNodegroup", "tsOptionEngine", 
  "tsOptionWait", "tsOptionComment", "tsOptionFileblockSize", "tsOptionEncryption", 
  "createView", "viewReplaceOrAlgorithm", "viewAlgorithm", "viewSuid", "createTrigger", 
  "triggerFollowsPrecedesClause", "createEvent", "createRole", "createSpatialReference", 
  "srsAttribute", "dropStatement", "dropDatabase", "dropEvent", "dropFunction", 
  "dropProcedure", "dropIndex", "dropLogfileGroup", "dropLogfileGroupOption", 
  "dropServer", "dropTable", "dropTableSpace", "dropTrigger", "dropView", 
  "dropRole", "dropSpatialReference", "dropUndoTablespace", "renameTableStatement", 
  "renamePair", "truncateTableStatement", "importStatement", "callStatement", 
  "deleteStatement", "partitionDelete", "deleteStatementOption", "doStatement", 
  "handlerStatement", "handlerReadOrScan", "insertStatement", "insertLockOption", 
  "insertFromConstructor", "fields", "insertValues", "insertQueryExpression", 
  "valueList", "values", "insertUpdateList", "loadStatement", "dataOrXml", 
  "xmlRowsIdentifiedBy", "loadDataFileTail", "loadDataFileTargetList", "fieldOrVariableList", 
  "replaceStatement", "selectStatement", "selectStatementWithInto", "queryExpression", 
  "queryExpressionBody", "queryExpressionParens", "querySpecification", 
  "subquery", "querySpecOption", "limitClause", "simpleLimitClause", "limitOptions", 
  "limitOption", "intoClause", "procedureAnalyseClause", "havingClause", 
  "windowClause", "windowDefinition", "windowSpec", "windowSpecDetails", 
  "windowFrameClause", "windowFrameUnits", "windowFrameExtent", "windowFrameStart", 
  "windowFrameBetween", "windowFrameBound", "windowFrameExclusion", "withClause", 
  "commonTableExpression", "groupByClause", "olapOption", "orderClause", 
  "direction", "fromClause", "tableReferenceList", "selectOption", "lockingClause", 
  "lockStrengh", "lockedRowAction", "selectItemList", "selectItem", "selectAlias", 
  "whereClause", "tableReference", "escapedTableReference", "joinedTable", 
  "naturalJoinType", "innerJoinType", "outerJoinType", "tableFactor", "singleTable", 
  "singleTableParens", "derivedTable", "tableReferenceListParens", "tableFunction", 
  "columnsClause", "jtColumn", "onEmptyOrError", "onEmpty", "onError", "jtOnResponse", 
  "unionOption", "tableAlias", "indexHintList", "indexHint", "indexHintType", 
  "keyOrIndex", "constraintKeyType", "indexHintClause", "indexList", "indexListElement", 
  "updateStatement", "transactionOrLockingStatement", "transactionStatement", 
  "beginWork", "transactionCharacteristic", "setTransactionCharacteristic", 
  "isolationLevel", "savepointStatement", "lockStatement", "lockItem", "lockOption", 
  "xaStatement", "xaConvert", "xid", "replicationStatement", "resetOption", 
  "masterResetOptions", "replicationLoad", "changeMaster", "changeMasterOptions", 
  "masterOption", "masterFileDef", "serverIdList", "changeReplication", 
  "filterDefinition", "filterDbList", "filterTableList", "filterStringList", 
  "filterWildDbTableString", "filterDbPairList", "slave", "slaveUntilOptions", 
  "slaveConnectionOptions", "slaveThreadOptions", "slaveThreadOption", "groupReplication", 
  "preparedStatement", "executeStatement", "executeVarList", "cloneStatement", 
  "dataDirSSL", "ssl", "accountManagementStatement", "alterUser", "alterUserTail", 
  "createUser", "createUserTail", "defaultRoleClause", "requireClause", 
  "connectOptions", "accountLockPasswordExpireOptions", "dropUser", "grant", 
  "grantTargetList", "grantOptions", "exceptRoleList", "withRoles", "grantAs", 
  "versionedRequireClause", "renameUser", "revoke", "onTypeTo", "aclType", 
  "setPassword", "roleOrPrivilegesList", "roleOrPrivilege", "grantIdentifier", 
  "requireList", "requireListElement", "grantOption", "setRole", "roleList", 
  "role", "tableAdministrationStatement", "histogram", "checkOption", "repairType", 
  "installUninstallStatment", "setStatement", "optionValueNoOptionType", 
  "setSystemVariable", "optionValueFollowingOptionType", "setExprOrDefault", 
  "optionValueList", "optionValue", "showStatement", "showCommandType", 
  "nonBlocking", "fromOrIn", "inDb", "profileType", "otherAdministrativeStatement", 
  "keyCacheListOrParts", "keyCacheList", "assignToKeycache", "assignToKeycachePartition", 
  "cacheKeyList", "keyUsageElement", "keyUsageList", "flushOption", "logType", 
  "flushTables", "flushTablesOptions", "preloadTail", "preloadList", "preloadKeys", 
  "adminPartition", "resourceGroupManagement", "createResourceGroup", "resourceGroupVcpuList", 
  "vcpuNumOrRange", "resourceGroupPriority", "resourceGroupEnableDisable", 
  "alterResourceGroup", "setResourceGroup", "threadIdList", "dropResourceGroup", 
  "utilityStatement", "describeCommand", "explainCommand", "explainableStatement", 
  "helpCommand", "useCommand", "restartServer", "expr", "boolPri", "compOp", 
  "predicate", "predicateOperations", "bitExpr", "simpleExpr", "arrayCast", 
  "jsonOperator", "sumExpr", "groupingOperation", "windowFunctionCall", 
  "windowingClause", "leadLagInfo", "nullTreatment", "jsonFunction", "inSumExpr", 
  "identListArg", "identList", "fulltextOptions", "runtimeFunctionCall", 
  "geometryFunction", "timeFunctionParameters", "fractionalPrecision", "weightStringLevels", 
  "weightStringLevelListItem", "dateTimeTtype", "trimFunction", "substringFunction", 
  "functionCall", "udfExprList", "udfExpr", "variable", "userVariable", 
  "systemVariable", "internalVariableName", "whenExpression", "thenExpression", 
  "elseExpression", "castType", "exprList", "charset", "notRule", "not2Rule", 
  "interval", "intervalTimeStamp", "exprListWithParentheses", "exprWithParentheses", 
  "simpleExprWithParentheses", "orderList", "orderExpression", "groupList", 
  "groupingExpression", "channel", "compoundStatement", "returnStatement", 
  "ifStatement", "ifBody", "thenStatement", "compoundStatementList", "caseStatement", 
  "elseStatement", "labeledBlock", "unlabeledBlock", "label", "beginEndBlock", 
  "labeledControl", "unlabeledControl", "loopBlock", "whileDoBlock", "repeatUntilBlock", 
  "spDeclarations", "spDeclaration", "variableDeclaration", "conditionDeclaration", 
  "spCondition", "sqlstate", "handlerDeclaration", "handlerCondition", "cursorDeclaration", 
  "iterateStatement", "leaveStatement", "getDiagnostics", "signalAllowedExpr", 
  "statementInformationItem", "conditionInformationItem", "signalInformationItemName", 
  "signalStatement", "resignalStatement", "signalInformationItem", "cursorOpen", 
  "cursorClose", "cursorFetch", "schedule", "columnDefinition", "checkOrReferences", 
  "checkConstraint", "constraintEnforcement", "tableConstraintDef", "constraintName", 
  "fieldDefinition", "columnAttribute", "columnFormat", "storageMedia", 
  "gcolAttribute", "references", "deleteOption", "keyList", "keyPart", "keyListWithExpression", 
  "keyPartOrExpression", "keyListVariants", "indexType", "indexOption", 
  "commonIndexOption", "visibility", "indexTypeClause", "fulltextIndexOption", 
  "spatialIndexOption", "dataTypeDefinition", "dataType", "nchar", "varchar", 
  "nvarchar", "realType", "fieldLength", "fieldOptions", "charsetWithOptBinary", 
  "ascii", "unicode", "wsNumCodepoints", "typeDatetimePrecision", "charsetName", 
  "collationName", "createTableOptions", "createTableOptionsSpaceSeparated", 
  "createTableOption", "ternaryOption", "defaultCollation", "defaultEncryption", 
  "defaultCharset", "partitionClause", "partitionTypeDef", "subPartitions", 
  "partitionKeyAlgorithm", "partitionDefinitions", "partitionDefinition", 
  "partitionValuesIn", "partitionOption", "subpartitionDefinition", "partitionValueItemListParen", 
  "partitionValueItem", "definerClause", "ifExists", "ifNotExists", "procedureParameter", 
  "functionParameter", "collate", "typeWithOptCollate", "schemaIdentifierPair", 
  "viewRefList", "updateList", "updateElement", "charsetClause", "fieldsClause", 
  "fieldTerm", "linesClause", "lineTerm", "userList", "createUserList", 
  "alterUserList", "createUserEntry", "alterUserEntry", "retainCurrentPassword", 
  "discardOldPassword", "replacePassword", "user", "likeClause", "likeOrWhere", 
  "onlineOption", "noWriteToBinLog", "usePartition", "fieldIdentifier", 
  "columnName", "columnInternalRef", "columnInternalRefList", "columnRef", 
  "insertIdentifier", "indexName", "indexRef", "tableWild", "schemaName", 
  "schemaRef", "procedureName", "procedureRef", "functionName", "functionRef", 
  "triggerName", "triggerRef", "viewName", "viewRef", "tablespaceName", 
  "tablespaceRef", "logfileGroupName", "logfileGroupRef", "eventName", "eventRef", 
  "udfName", "serverName", "serverRef", "engineRef", "tableName", "filterTableRef", 
  "tableRefWithWildcard", "tableRef", "tableRefList", "tableAliasRefList", 
  "parameterName", "labelIdentifier", "labelRef", "roleIdentifier", "roleRef", 
  "pluginRef", "componentRef", "resourceGroupRef", "windowName", "pureIdentifier", 
  "identifier", "identifierList", "identifierListWithParentheses", "qualifiedIdentifier", 
  "simpleIdentifier", "dotIdentifier", "ulong_number", "real_ulong_number", 
  "ulonglong_number", "real_ulonglong_number", "literal", "signedLiteral", 
  "stringList", "textStringLiteral", "textString", "textStringHash", "textLiteral", 
  "textStringNoLinebreak", "textStringLiteralList", "numLiteral", "boolLiteral", 
  "nullLiteral", "temporalLiteral", "floatOptions", "standardFloatOptions", 
  "precision", "textOrIdentifier", "lValueIdentifier", "roleIdentifierOrText", 
  "sizeNumber", "parentheses", "equal", "optionType", "varIdentType", "setVarIdentType", 
  "identifierKeyword", "identifierKeywordsAmbiguous1RolesAndLabels", "identifierKeywordsAmbiguous2Labels", 
  "labelKeyword", "identifierKeywordsAmbiguous3Roles", "identifierKeywordsUnambiguous", 
  "roleKeyword", "lValueKeyword", "identifierKeywordsAmbiguous4SystemVariables", 
  "roleOrIdentifierKeyword", "roleOrLabelKeyword"
};

std::vector<std::string> MySQLParser::_literalNames = {
  "", "", "", "", "", "", "", "'='", "':='", "'<=>'", "'>='", "'>'", "'<='", 
  "'<'", "'!='", "'+'", "'-'", "'*'", "'/'", "'%'", "'!'", "'~'", "'<<'", 
  "'>>'", "'&&'", "'&'", "'^'", "'||'", "'|'", "'.'", "','", "';'", "':'", 
  "'('", "')'", "'{'", "'}'", "'_'", "'->'", "'->>'", "'@'", "", "'@@'", 
  "'\\N'", "'?'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
  "'<>'"
};

std::vector<std::string> MySQLParser::_symbolicNames = {
  "", "NOT2_SYMBOL", "CONCAT_PIPES_SYMBOL", "INNODB_SYMBOL", "INT_NUMBER", 
  "LONG_NUMBER", "ULONGLONG_NUMBER", "EQUAL_OPERATOR", "ASSIGN_OPERATOR", 
  "NULL_SAFE_EQUAL_OPERATOR", "GREATER_OR_EQUAL_OPERATOR", "GREATER_THAN_OPERATOR", 
  "LESS_OR_EQUAL_OPERATOR", "LESS_THAN_OPERATOR", "NOT_EQUAL_OPERATOR", 
  "PLUS_OPERATOR", "MINUS_OPERATOR", "MULT_OPERATOR", "DIV_OPERATOR", "MOD_OPERATOR", 
  "LOGICAL_NOT_OPERATOR", "BITWISE_NOT_OPERATOR", "SHIFT_LEFT_OPERATOR", 
  "SHIFT_RIGHT_OPERATOR", "LOGICAL_AND_OPERATOR", "BITWISE_AND_OPERATOR", 
  "BITWISE_XOR_OPERATOR", "LOGICAL_OR_OPERATOR", "BITWISE_OR_OPERATOR", 
  "DOT_SYMBOL", "COMMA_SYMBOL", "SEMICOLON_SYMBOL", "COLON_SYMBOL", "OPEN_PAR_SYMBOL", 
  "CLOSE_PAR_SYMBOL", "OPEN_CURLY_SYMBOL", "CLOSE_CURLY_SYMBOL", "UNDERLINE_SYMBOL", 
  "JSON_SEPARATOR_SYMBOL", "JSON_UNQUOTED_SEPARATOR_SYMBOL", "AT_SIGN_SYMBOL", 
  "AT_TEXT_SUFFIX", "AT_AT_SIGN_SYMBOL", "NULL2_SYMBOL", "PARAM_MARKER", 
  "HEX_NUMBER", "BIN_NUMBER", "DECIMAL_NUMBER", "FLOAT_NUMBER", "ACCESSIBLE_SYMBOL", 
  "ACCOUNT_SYMBOL", "ACTION_SYMBOL", "ADD_SYMBOL", "ADDDATE_SYMBOL", "AFTER_SYMBOL", 
  "AGAINST_SYMBOL", "AGGREGATE_SYMBOL", "ALGORITHM_SYMBOL", "ALL_SYMBOL", 
  "ALTER_SYMBOL", "ALWAYS_SYMBOL", "ANALYSE_SYMBOL", "ANALYZE_SYMBOL", "AND_SYMBOL", 
  "ANY_SYMBOL", "AS_SYMBOL", "ASC_SYMBOL", "ASCII_SYMBOL", "ASENSITIVE_SYMBOL", 
  "AT_SYMBOL", "AUTHORS_SYMBOL", "AUTOEXTEND_SIZE_SYMBOL", "AUTO_INCREMENT_SYMBOL", 
  "AVG_ROW_LENGTH_SYMBOL", "AVG_SYMBOL", "BACKUP_SYMBOL", "BEFORE_SYMBOL", 
  "BEGIN_SYMBOL", "BETWEEN_SYMBOL", "BIGINT_SYMBOL", "BINARY_SYMBOL", "BINLOG_SYMBOL", 
  "BIN_NUM_SYMBOL", "BIT_AND_SYMBOL", "BIT_OR_SYMBOL", "BIT_SYMBOL", "BIT_XOR_SYMBOL", 
  "BLOB_SYMBOL", "BLOCK_SYMBOL", "BOOLEAN_SYMBOL", "BOOL_SYMBOL", "BOTH_SYMBOL", 
  "BTREE_SYMBOL", "BY_SYMBOL", "BYTE_SYMBOL", "CACHE_SYMBOL", "CALL_SYMBOL", 
  "CASCADE_SYMBOL", "CASCADED_SYMBOL", "CASE_SYMBOL", "CAST_SYMBOL", "CATALOG_NAME_SYMBOL", 
  "CHAIN_SYMBOL", "CHANGE_SYMBOL", "CHANGED_SYMBOL", "CHANNEL_SYMBOL", "CHARSET_SYMBOL", 
  "CHAR_SYMBOL", "CHECKSUM_SYMBOL", "CHECK_SYMBOL", "CIPHER_SYMBOL", "CLASS_ORIGIN_SYMBOL", 
  "CLIENT_SYMBOL", "CLOSE_SYMBOL", "COALESCE_SYMBOL", "CODE_SYMBOL", "COLLATE_SYMBOL", 
  "COLLATION_SYMBOL", "COLUMNS_SYMBOL", "COLUMN_SYMBOL", "COLUMN_NAME_SYMBOL", 
  "COLUMN_FORMAT_SYMBOL", "COMMENT_SYMBOL", "COMMITTED_SYMBOL", "COMMIT_SYMBOL", 
  "COMPACT_SYMBOL", "COMPLETION_SYMBOL", "COMPRESSED_SYMBOL", "COMPRESSION_SYMBOL", 
  "CONCURRENT_SYMBOL", "CONDITION_SYMBOL", "CONNECTION_SYMBOL", "CONSISTENT_SYMBOL", 
  "CONSTRAINT_SYMBOL", "CONSTRAINT_CATALOG_SYMBOL", "CONSTRAINT_NAME_SYMBOL", 
  "CONSTRAINT_SCHEMA_SYMBOL", "CONTAINS_SYMBOL", "CONTEXT_SYMBOL", "CONTINUE_SYMBOL", 
  "CONTRIBUTORS_SYMBOL", "CONVERT_SYMBOL", "COUNT_SYMBOL", "CPU_SYMBOL", 
  "CREATE_SYMBOL", "CROSS_SYMBOL", "CUBE_SYMBOL", "CURDATE_SYMBOL", "CURRENT_SYMBOL", 
  "CURRENT_DATE_SYMBOL", "CURRENT_TIME_SYMBOL", "CURRENT_USER_SYMBOL", "CURSOR_SYMBOL", 
  "CURSOR_NAME_SYMBOL", "CURTIME_SYMBOL", "DATABASE_SYMBOL", "DATABASES_SYMBOL", 
  "DATAFILE_SYMBOL", "DATA_SYMBOL", "DATETIME_SYMBOL", "DATE_ADD_SYMBOL", 
  "DATE_SUB_SYMBOL", "DATE_SYMBOL", "DAY_HOUR_SYMBOL", "DAY_MICROSECOND_SYMBOL", 
  "DAY_MINUTE_SYMBOL", "DAY_SECOND_SYMBOL", "DAY_SYMBOL", "DEALLOCATE_SYMBOL", 
  "DECIMAL_NUM_SYMBOL", "DECIMAL_SYMBOL", "DECLARE_SYMBOL", "DEFAULT_SYMBOL", 
  "DEFAULT_AUTH_SYMBOL", "DEFINER_SYMBOL", "DELAYED_SYMBOL", "DELAY_KEY_WRITE_SYMBOL", 
  "DELETE_SYMBOL", "DESC_SYMBOL", "DESCRIBE_SYMBOL", "DES_KEY_FILE_SYMBOL", 
  "DETERMINISTIC_SYMBOL", "DIAGNOSTICS_SYMBOL", "DIRECTORY_SYMBOL", "DISABLE_SYMBOL", 
  "DISCARD_SYMBOL", "DISK_SYMBOL", "DISTINCT_SYMBOL", "DIV_SYMBOL", "DOUBLE_SYMBOL", 
  "DO_SYMBOL", "DROP_SYMBOL", "DUAL_SYMBOL", "DUMPFILE_SYMBOL", "DUPLICATE_SYMBOL", 
  "DYNAMIC_SYMBOL", "EACH_SYMBOL", "ELSE_SYMBOL", "ELSEIF_SYMBOL", "ENABLE_SYMBOL", 
  "ENCLOSED_SYMBOL", "ENCRYPTION_SYMBOL", "END_SYMBOL", "ENDS_SYMBOL", "END_OF_INPUT_SYMBOL", 
  "ENGINES_SYMBOL", "ENGINE_SYMBOL", "ENUM_SYMBOL", "ERROR_SYMBOL", "ERRORS_SYMBOL", 
  "ESCAPED_SYMBOL", "ESCAPE_SYMBOL", "EVENTS_SYMBOL", "EVENT_SYMBOL", "EVERY_SYMBOL", 
  "EXCHANGE_SYMBOL", "EXECUTE_SYMBOL", "EXISTS_SYMBOL", "EXIT_SYMBOL", "EXPANSION_SYMBOL", 
  "EXPIRE_SYMBOL", "EXPORT_SYMBOL", "EXTENDED_SYMBOL", "EXTENT_SIZE_SYMBOL", 
  "EXTRACT_SYMBOL", "FALSE_SYMBOL", "FAST_SYMBOL", "FAULTS_SYMBOL", "FETCH_SYMBOL", 
  "FILE_SYMBOL", "FILE_BLOCK_SIZE_SYMBOL", "FILTER_SYMBOL", "FIRST_SYMBOL", 
  "FIXED_SYMBOL", "FLOAT_SYMBOL", "FLUSH_SYMBOL", "FOLLOWS_SYMBOL", "FORCE_SYMBOL", 
  "FOREIGN_SYMBOL", "FOR_SYMBOL", "FORMAT_SYMBOL", "FOUND_SYMBOL", "FROM_SYMBOL", 
  "FULL_SYMBOL", "FULLTEXT_SYMBOL", "FUNCTION_SYMBOL", "GET_SYMBOL", "GENERAL_SYMBOL", 
  "GENERATED_SYMBOL", "GROUP_REPLICATION_SYMBOL", "GEOMETRYCOLLECTION_SYMBOL", 
  "GEOMETRY_SYMBOL", "GET_FORMAT_SYMBOL", "GLOBAL_SYMBOL", "GRANT_SYMBOL", 
  "GRANTS_SYMBOL", "GROUP_SYMBOL", "GROUP_CONCAT_SYMBOL", "HANDLER_SYMBOL", 
  "HASH_SYMBOL", "HAVING_SYMBOL", "HELP_SYMBOL", "HIGH_PRIORITY_SYMBOL", 
  "HOST_SYMBOL", "HOSTS_SYMBOL", "HOUR_MICROSECOND_SYMBOL", "HOUR_MINUTE_SYMBOL", 
  "HOUR_SECOND_SYMBOL", "HOUR_SYMBOL", "IDENTIFIED_SYMBOL", "IF_SYMBOL", 
  "IGNORE_SYMBOL", "IGNORE_SERVER_IDS_SYMBOL", "IMPORT_SYMBOL", "INDEXES_SYMBOL", 
  "INDEX_SYMBOL", "INFILE_SYMBOL", "INITIAL_SIZE_SYMBOL", "INNER_SYMBOL", 
  "INOUT_SYMBOL", "INSENSITIVE_SYMBOL", "INSERT_SYMBOL", "INSERT_METHOD_SYMBOL", 
  "INSTANCE_SYMBOL", "INSTALL_SYMBOL", "INTERVAL_SYMBOL", "INTO_SYMBOL", 
  "INT_SYMBOL", "INVOKER_SYMBOL", "IN_SYMBOL", "IO_AFTER_GTIDS_SYMBOL", 
  "IO_BEFORE_GTIDS_SYMBOL", "IO_SYMBOL", "IPC_SYMBOL", "IS_SYMBOL", "ISOLATION_SYMBOL", 
  "ISSUER_SYMBOL", "ITERATE_SYMBOL", "JOIN_SYMBOL", "JSON_SYMBOL", "KEYS_SYMBOL", 
  "KEY_BLOCK_SIZE_SYMBOL", "KEY_SYMBOL", "KILL_SYMBOL", "LANGUAGE_SYMBOL", 
  "LAST_SYMBOL", "LEADING_SYMBOL", "LEAVES_SYMBOL", "LEAVE_SYMBOL", "LEFT_SYMBOL", 
  "LESS_SYMBOL", "LEVEL_SYMBOL", "LIKE_SYMBOL", "LIMIT_SYMBOL", "LINEAR_SYMBOL", 
  "LINES_SYMBOL", "LINESTRING_SYMBOL", "LIST_SYMBOL", "LOAD_SYMBOL", "LOCAL_SYMBOL", 
  "LOCATOR_SYMBOL", "LOCKS_SYMBOL", "LOCK_SYMBOL", "LOGFILE_SYMBOL", "LOGS_SYMBOL", 
  "LONGBLOB_SYMBOL", "LONGTEXT_SYMBOL", "LONG_NUM_SYMBOL", "LONG_SYMBOL", 
  "LOOP_SYMBOL", "LOW_PRIORITY_SYMBOL", "MASTER_AUTO_POSITION_SYMBOL", "MASTER_BIND_SYMBOL", 
  "MASTER_CONNECT_RETRY_SYMBOL", "MASTER_DELAY_SYMBOL", "MASTER_HOST_SYMBOL", 
  "MASTER_LOG_FILE_SYMBOL", "MASTER_LOG_POS_SYMBOL", "MASTER_PASSWORD_SYMBOL", 
  "MASTER_PORT_SYMBOL", "MASTER_RETRY_COUNT_SYMBOL", "MASTER_SERVER_ID_SYMBOL", 
  "MASTER_SSL_CAPATH_SYMBOL", "MASTER_SSL_CA_SYMBOL", "MASTER_SSL_CERT_SYMBOL", 
  "MASTER_SSL_CIPHER_SYMBOL", "MASTER_SSL_CRL_SYMBOL", "MASTER_SSL_CRLPATH_SYMBOL", 
  "MASTER_SSL_KEY_SYMBOL", "MASTER_SSL_SYMBOL", "MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL", 
  "MASTER_SYMBOL", "MASTER_TLS_VERSION_SYMBOL", "MASTER_USER_SYMBOL", "MASTER_HEARTBEAT_PERIOD_SYMBOL", 
  "MATCH_SYMBOL", "MAX_CONNECTIONS_PER_HOUR_SYMBOL", "MAX_QUERIES_PER_HOUR_SYMBOL", 
  "MAX_ROWS_SYMBOL", "MAX_SIZE_SYMBOL", "MAX_STATEMENT_TIME_SYMBOL", "MAX_SYMBOL", 
  "MAX_UPDATES_PER_HOUR_SYMBOL", "MAX_USER_CONNECTIONS_SYMBOL", "MAXVALUE_SYMBOL", 
  "MEDIUMBLOB_SYMBOL", "MEDIUMINT_SYMBOL", "MEDIUMTEXT_SYMBOL", "MEDIUM_SYMBOL", 
  "MEMORY_SYMBOL", "MERGE_SYMBOL", "MESSAGE_TEXT_SYMBOL", "MICROSECOND_SYMBOL", 
  "MID_SYMBOL", "MIGRATE_SYMBOL", "MINUTE_MICROSECOND_SYMBOL", "MINUTE_SECOND_SYMBOL", 
  "MINUTE_SYMBOL", "MIN_ROWS_SYMBOL", "MIN_SYMBOL", "MODE_SYMBOL", "MODIFIES_SYMBOL", 
  "MODIFY_SYMBOL", "MOD_SYMBOL", "MONTH_SYMBOL", "MULTILINESTRING_SYMBOL", 
  "MULTIPOINT_SYMBOL", "MULTIPOLYGON_SYMBOL", "MUTEX_SYMBOL", "MYSQL_ERRNO_SYMBOL", 
  "NAMES_SYMBOL", "NAME_SYMBOL", "NATIONAL_SYMBOL", "NATURAL_SYMBOL", "NCHAR_STRING_SYMBOL", 
  "NCHAR_SYMBOL", "NDBCLUSTER_SYMBOL", "NEG_SYMBOL", "NEVER_SYMBOL", "NEW_SYMBOL", 
  "NEXT_SYMBOL", "NODEGROUP_SYMBOL", "NONE_SYMBOL", "NONBLOCKING_SYMBOL", 
  "NOT_SYMBOL", "NOW_SYMBOL", "NO_SYMBOL", "NO_WAIT_SYMBOL", "NO_WRITE_TO_BINLOG_SYMBOL", 
  "NULL_SYMBOL", "NUMBER_SYMBOL", "NUMERIC_SYMBOL", "NVARCHAR_SYMBOL", "OFFLINE_SYMBOL", 
  "OFFSET_SYMBOL", "OLD_PASSWORD_SYMBOL", "ON_SYMBOL", "ONE_SHOT_SYMBOL", 
  "ONE_SYMBOL", "ONLINE_SYMBOL", "ONLY_SYMBOL", "OPEN_SYMBOL", "OPTIMIZE_SYMBOL", 
  "OPTIMIZER_COSTS_SYMBOL", "OPTIONS_SYMBOL", "OPTION_SYMBOL", "OPTIONALLY_SYMBOL", 
  "ORDER_SYMBOL", "OR_SYMBOL", "OUTER_SYMBOL", "OUTFILE_SYMBOL", "OUT_SYMBOL", 
  "OWNER_SYMBOL", "PACK_KEYS_SYMBOL", "PAGE_SYMBOL", "PARSER_SYMBOL", "PARTIAL_SYMBOL", 
  "PARTITIONING_SYMBOL", "PARTITIONS_SYMBOL", "PARTITION_SYMBOL", "PASSWORD_SYMBOL", 
  "PHASE_SYMBOL", "PLUGINS_SYMBOL", "PLUGIN_DIR_SYMBOL", "PLUGIN_SYMBOL", 
  "POINT_SYMBOL", "POLYGON_SYMBOL", "PORT_SYMBOL", "POSITION_SYMBOL", "PRECEDES_SYMBOL", 
  "PRECISION_SYMBOL", "PREPARE_SYMBOL", "PRESERVE_SYMBOL", "PREV_SYMBOL", 
  "PRIMARY_SYMBOL", "PRIVILEGES_SYMBOL", "PROCEDURE_SYMBOL", "PROCESS_SYMBOL", 
  "PROCESSLIST_SYMBOL", "PROFILE_SYMBOL", "PROFILES_SYMBOL", "PROXY_SYMBOL", 
  "PURGE_SYMBOL", "QUARTER_SYMBOL", "QUERY_SYMBOL", "QUICK_SYMBOL", "RANGE_SYMBOL", 
  "READS_SYMBOL", "READ_ONLY_SYMBOL", "READ_SYMBOL", "READ_WRITE_SYMBOL", 
  "REAL_SYMBOL", "REBUILD_SYMBOL", "RECOVER_SYMBOL", "REDOFILE_SYMBOL", 
  "REDO_BUFFER_SIZE_SYMBOL", "REDUNDANT_SYMBOL", "REFERENCES_SYMBOL", "REGEXP_SYMBOL", 
  "RELAY_SYMBOL", "RELAYLOG_SYMBOL", "RELAY_LOG_FILE_SYMBOL", "RELAY_LOG_POS_SYMBOL", 
  "RELAY_THREAD_SYMBOL", "RELEASE_SYMBOL", "RELOAD_SYMBOL", "REMOVE_SYMBOL", 
  "RENAME_SYMBOL", "REORGANIZE_SYMBOL", "REPAIR_SYMBOL", "REPEATABLE_SYMBOL", 
  "REPEAT_SYMBOL", "REPLACE_SYMBOL", "REPLICATION_SYMBOL", "REPLICATE_DO_DB_SYMBOL", 
  "REPLICATE_IGNORE_DB_SYMBOL", "REPLICATE_DO_TABLE_SYMBOL", "REPLICATE_IGNORE_TABLE_SYMBOL", 
  "REPLICATE_WILD_DO_TABLE_SYMBOL", "REPLICATE_WILD_IGNORE_TABLE_SYMBOL", 
  "REPLICATE_REWRITE_DB_SYMBOL", "REQUIRE_SYMBOL", "RESET_SYMBOL", "RESIGNAL_SYMBOL", 
  "RESTORE_SYMBOL", "RESTRICT_SYMBOL", "RESUME_SYMBOL", "RETURNED_SQLSTATE_SYMBOL", 
  "RETURNS_SYMBOL", "RETURN_SYMBOL", "REVERSE_SYMBOL", "REVOKE_SYMBOL", 
  "RIGHT_SYMBOL", "ROLLBACK_SYMBOL", "ROLLUP_SYMBOL", "ROTATE_SYMBOL", "ROUTINE_SYMBOL", 
  "ROWS_SYMBOL", "ROW_COUNT_SYMBOL", "ROW_FORMAT_SYMBOL", "ROW_SYMBOL", 
  "RTREE_SYMBOL", "SAVEPOINT_SYMBOL", "SCHEDULE_SYMBOL", "SCHEMA_NAME_SYMBOL", 
  "SECOND_MICROSECOND_SYMBOL", "SECOND_SYMBOL", "SECURITY_SYMBOL", "SELECT_SYMBOL", 
  "SENSITIVE_SYMBOL", "SEPARATOR_SYMBOL", "SERIALIZABLE_SYMBOL", "SERIAL_SYMBOL", 
  "SESSION_SYMBOL", "SERVER_SYMBOL", "SERVER_OPTIONS_SYMBOL", "SESSION_USER_SYMBOL", 
  "SET_SYMBOL", "SET_VAR_SYMBOL", "SHARE_SYMBOL", "SHOW_SYMBOL", "SHUTDOWN_SYMBOL", 
  "SIGNAL_SYMBOL", "SIGNED_SYMBOL", "SIMPLE_SYMBOL", "SLAVE_SYMBOL", "SLOW_SYMBOL", 
  "SMALLINT_SYMBOL", "SNAPSHOT_SYMBOL", "SOCKET_SYMBOL", "SONAME_SYMBOL", 
  "SOUNDS_SYMBOL", "SOURCE_SYMBOL", "SPATIAL_SYMBOL", "SPECIFIC_SYMBOL", 
  "SQLEXCEPTION_SYMBOL", "SQLSTATE_SYMBOL", "SQLWARNING_SYMBOL", "SQL_AFTER_GTIDS_SYMBOL", 
  "SQL_AFTER_MTS_GAPS_SYMBOL", "SQL_BEFORE_GTIDS_SYMBOL", "SQL_BIG_RESULT_SYMBOL", 
  "SQL_BUFFER_RESULT_SYMBOL", "SQL_CACHE_SYMBOL", "SQL_CALC_FOUND_ROWS_SYMBOL", 
  "SQL_NO_CACHE_SYMBOL", "SQL_SMALL_RESULT_SYMBOL", "SQL_SYMBOL", "SQL_THREAD_SYMBOL", 
  "SSL_SYMBOL", "STACKED_SYMBOL", "STARTING_SYMBOL", "STARTS_SYMBOL", "START_SYMBOL", 
  "STATS_AUTO_RECALC_SYMBOL", "STATS_PERSISTENT_SYMBOL", "STATS_SAMPLE_PAGES_SYMBOL", 
  "STATUS_SYMBOL", "STDDEV_SAMP_SYMBOL", "STDDEV_SYMBOL", "STDDEV_POP_SYMBOL", 
  "STD_SYMBOL", "STOP_SYMBOL", "STORAGE_SYMBOL", "STORED_SYMBOL", "STRAIGHT_JOIN_SYMBOL", 
  "STRING_SYMBOL", "SUBCLASS_ORIGIN_SYMBOL", "SUBDATE_SYMBOL", "SUBJECT_SYMBOL", 
  "SUBPARTITIONS_SYMBOL", "SUBPARTITION_SYMBOL", "SUBSTR_SYMBOL", "SUBSTRING_SYMBOL", 
  "SUM_SYMBOL", "SUPER_SYMBOL", "SUSPEND_SYMBOL", "SWAPS_SYMBOL", "SWITCHES_SYMBOL", 
  "SYSDATE_SYMBOL", "SYSTEM_USER_SYMBOL", "TABLES_SYMBOL", "TABLESPACE_SYMBOL", 
  "TABLE_REF_PRIORITY_SYMBOL", "TABLE_SYMBOL", "TABLE_CHECKSUM_SYMBOL", 
  "TABLE_NAME_SYMBOL", "TEMPORARY_SYMBOL", "TEMPTABLE_SYMBOL", "TERMINATED_SYMBOL", 
  "TEXT_SYMBOL", "THAN_SYMBOL", "THEN_SYMBOL", "TIMESTAMP_SYMBOL", "TIMESTAMP_ADD_SYMBOL", 
  "TIMESTAMP_DIFF_SYMBOL", "TIME_SYMBOL", "TINYBLOB_SYMBOL", "TINYINT_SYMBOL", 
  "TINYTEXT_SYMBOL", "TO_SYMBOL", "TRAILING_SYMBOL", "TRANSACTION_SYMBOL", 
  "TRIGGERS_SYMBOL", "TRIGGER_SYMBOL", "TRIM_SYMBOL", "TRUE_SYMBOL", "TRUNCATE_SYMBOL", 
  "TYPES_SYMBOL", "TYPE_SYMBOL", "UDF_RETURNS_SYMBOL", "UNCOMMITTED_SYMBOL", 
  "UNDEFINED_SYMBOL", "UNDOFILE_SYMBOL", "UNDO_BUFFER_SIZE_SYMBOL", "UNDO_SYMBOL", 
  "UNICODE_SYMBOL", "UNINSTALL_SYMBOL", "UNION_SYMBOL", "UNIQUE_SYMBOL", 
  "UNKNOWN_SYMBOL", "UNLOCK_SYMBOL", "UNSIGNED_SYMBOL", "UNTIL_SYMBOL", 
  "UPDATE_SYMBOL", "UPGRADE_SYMBOL", "USAGE_SYMBOL", "USER_RESOURCES_SYMBOL", 
  "USER_SYMBOL", "USE_FRM_SYMBOL", "USE_SYMBOL", "USING_SYMBOL", "UTC_DATE_SYMBOL", 
  "UTC_TIMESTAMP_SYMBOL", "UTC_TIME_SYMBOL", "VALIDATION_SYMBOL", "VALUES_SYMBOL", 
  "VALUE_SYMBOL", "VARBINARY_SYMBOL", "VARCHAR_SYMBOL", "VARIABLES_SYMBOL", 
  "VARIANCE_SYMBOL", "VARYING_SYMBOL", "VAR_POP_SYMBOL", "VAR_SAMP_SYMBOL", 
  "VIEW_SYMBOL", "VIRTUAL_SYMBOL", "WAIT_SYMBOL", "WARNINGS_SYMBOL", "WEEK_SYMBOL", 
  "WEIGHT_STRING_SYMBOL", "WHEN_SYMBOL", "WHERE_SYMBOL", "WHILE_SYMBOL", 
  "WITH_SYMBOL", "WITH_CUBE_SYMBOL", "WITH_ROLLUP_SYMBOL", "WITHOUT_SYMBOL", 
  "WORK_SYMBOL", "WRAPPER_SYMBOL", "WRITE_SYMBOL", "X509_SYMBOL", "XA_SYMBOL", 
  "XID_SYMBOL", "XML_SYMBOL", "XOR_SYMBOL", "YEAR_MONTH_SYMBOL", "YEAR_SYMBOL", 
  "ZEROFILL_SYMBOL", "PERSIST_SYMBOL", "ROLE_SYMBOL", "ADMIN_SYMBOL", "INVISIBLE_SYMBOL", 
  "VISIBLE_SYMBOL", "EXCEPT_SYMBOL", "COMPONENT_SYMBOL", "RECURSIVE_SYMBOL", 
  "JSON_OBJECTAGG_SYMBOL", "JSON_ARRAYAGG_SYMBOL", "OF_SYMBOL", "SKIP_SYMBOL", 
  "LOCKED_SYMBOL", "NOWAIT_SYMBOL", "GROUPING_SYMBOL", "PERSIST_ONLY_SYMBOL", 
  "HISTOGRAM_SYMBOL", "BUCKETS_SYMBOL", "REMOTE_SYMBOL", "CLONE_SYMBOL", 
  "CUME_DIST_SYMBOL", "DENSE_RANK_SYMBOL", "EXCLUDE_SYMBOL", "FIRST_VALUE_SYMBOL", 
  "FOLLOWING_SYMBOL", "GROUPS_SYMBOL", "LAG_SYMBOL", "LAST_VALUE_SYMBOL", 
  "LEAD_SYMBOL", "NTH_VALUE_SYMBOL", "NTILE_SYMBOL", "NULLS_SYMBOL", "OTHERS_SYMBOL", 
  "OVER_SYMBOL", "PERCENT_RANK_SYMBOL", "PRECEDING_SYMBOL", "RANK_SYMBOL", 
  "RESPECT_SYMBOL", "ROW_NUMBER_SYMBOL", "TIES_SYMBOL", "UNBOUNDED_SYMBOL", 
  "WINDOW_SYMBOL", "EMPTY_SYMBOL", "JSON_TABLE_SYMBOL", "NESTED_SYMBOL", 
  "ORDINALITY_SYMBOL", "PATH_SYMBOL", "HISTORY_SYMBOL", "REUSE_SYMBOL", 
  "SRID_SYMBOL", "THREAD_PRIORITY_SYMBOL", "RESOURCE_SYMBOL", "SYSTEM_SYMBOL", 
  "VCPU_SYMBOL", "MASTER_PUBLIC_KEY_PATH_SYMBOL", "GET_MASTER_PUBLIC_KEY_SYMBOL", 
  "RESTART_SYMBOL", "DEFINITION_SYMBOL", "DESCRIPTION_SYMBOL", "ORGANIZATION_SYMBOL", 
  "REFERENCE_SYMBOL", "OPTIONAL_SYMBOL", "SECONDARY_SYMBOL", "SECONDARY_ENGINE_SYMBOL", 
  "SECONDARY_LOAD_SYMBOL", "SECONDARY_UNLOAD_SYMBOL", "ACTIVE_SYMBOL", "INACTIVE_SYMBOL", 
  "LATERAL_SYMBOL", "RETAIN_SYMBOL", "OLD_SYMBOL", "NETWORK_NAMESPACE_SYMBOL", 
  "ENFORCED_SYMBOL", "ARRAY_SYMBOL", "OJ_SYMBOL", "MEMBER_SYMBOL", "WHITESPACE", 
  "INVALID_INPUT", "UNDERSCORE_CHARSET", "IDENTIFIER", "NCHAR_TEXT", "BACK_TICK_QUOTED_ID", 
  "DOUBLE_QUOTED_TEXT", "SINGLE_QUOTED_TEXT", "VERSION_COMMENT_START", "MYSQL_COMMENT_START", 
  "VERSION_COMMENT_END", "BLOCK_COMMENT", "POUND_COMMENT", "DASHDASH_COMMENT", 
  "NOT_EQUAL2_OPERATOR"
};

dfa::Vocabulary MySQLParser::_vocabulary(_literalNames, _symbolicNames);

std::vector<std::string> MySQLParser::_tokenNames;

MySQLParser::Initializer::Initializer() {
	for (size_t i = 0; i < _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  static uint16_t serializedATNSegment0[] = {
    0x3, 0x608b, 0xa72a, 0x8133, 0xb9ed, 0x417c, 0x3be7, 0x7786, 0x5964, 
       0x3, 0x30d, 0x2079, 0x4, 0x2, 0x9, 0x2, 0x4, 0x3, 0x9, 0x3, 0x4, 
       0x4, 0x9, 0x4, 0x4, 0x5, 0x9, 0x5, 0x4, 0x6, 0x9, 0x6, 0x4, 0x7, 
       0x9, 0x7, 0x4, 0x8, 0x9, 0x8, 0x4, 0x9, 0x9, 0x9, 0x4, 0xa, 0x9, 
       0xa, 0x4, 0xb, 0x9, 0xb, 0x4, 0xc, 0x9, 0xc, 0x4, 0xd, 0x9, 0xd, 
       0x4, 0xe, 0x9, 0xe, 0x4, 0xf, 0x9, 0xf, 0x4, 0x10, 0x9, 0x10, 0x4, 
       0x11, 0x9, 0x11, 0x4, 0x12, 0x9, 0x12, 0x4, 0x13, 0x9, 0x13, 0x4, 
       0x14, 0x9, 0x14, 0x4, 0x15, 0x9, 0x15, 0x4, 0x16, 0x9, 0x16, 0x4, 
       0x17, 0x9, 0x17, 0x4, 0x18, 0x9, 0x18, 0x4, 0x19, 0x9, 0x19, 0x4, 
       0x1a, 0x9, 0x1a, 0x4, 0x1b, 0x9, 0x1b, 0x4, 0x1c, 0x9, 0x1c, 0x4, 
       0x1d, 0x9, 0x1d, 0x4, 0x1e, 0x9, 0x1e, 0x4, 0x1f, 0x9, 0x1f, 0x4, 
       0x20, 0x9, 0x20, 0x4, 0x21, 0x9, 0x21, 0x4, 0x22, 0x9, 0x22, 0x4, 
       0x23, 0x9, 0x23, 0x4, 0x24, 0x9, 0x24, 0x4, 0x25, 0x9, 0x25, 0x4, 
       0x26, 0x9, 0x26, 0x4, 0x27, 0x9, 0x27, 0x4, 0x28, 0x9, 0x28, 0x4, 
       0x29, 0x9, 0x29, 0x4, 0x2a, 0x9, 0x2a, 0x4, 0x2b, 0x9, 0x2b, 0x4, 
       0x2c, 0x9, 0x2c, 0x4, 0x2d, 0x9, 0x2d, 0x4, 0x2e, 0x9, 0x2e, 0x4, 
       0x2f, 0x9, 0x2f, 0x4, 0x30, 0x9, 0x30, 0x4, 0x31, 0x9, 0x31, 0x4, 
       0x32, 0x9, 0x32, 0x4, 0x33, 0x9, 0x33, 0x4, 0x34, 0x9, 0x34, 0x4, 
       0x35, 0x9, 0x35, 0x4, 0x36, 0x9, 0x36, 0x4, 0x37, 0x9, 0x37, 0x4, 
       0x38, 0x9, 0x38, 0x4, 0x39, 0x9, 0x39, 0x4, 0x3a, 0x9, 0x3a, 0x4, 
       0x3b, 0x9, 0x3b, 0x4, 0x3c, 0x9, 0x3c, 0x4, 0x3d, 0x9, 0x3d, 0x4, 
       0x3e, 0x9, 0x3e, 0x4, 0x3f, 0x9, 0x3f, 0x4, 0x40, 0x9, 0x40, 0x4, 
       0x41, 0x9, 0x41, 0x4, 0x42, 0x9, 0x42, 0x4, 0x43, 0x9, 0x43, 0x4, 
       0x44, 0x9, 0x44, 0x4, 0x45, 0x9, 0x45, 0x4, 0x46, 0x9, 0x46, 0x4, 
       0x47, 0x9, 0x47, 0x4, 0x48, 0x9, 0x48, 0x4, 0x49, 0x9, 0x49, 0x4, 
       0x4a, 0x9, 0x4a, 0x4, 0x4b, 0x9, 0x4b, 0x4, 0x4c, 0x9, 0x4c, 0x4, 
       0x4d, 0x9, 0x4d, 0x4, 0x4e, 0x9, 0x4e, 0x4, 0x4f, 0x9, 0x4f, 0x4, 
       0x50, 0x9, 0x50, 0x4, 0x51, 0x9, 0x51, 0x4, 0x52, 0x9, 0x52, 0x4, 
       0x53, 0x9, 0x53, 0x4, 0x54, 0x9, 0x54, 0x4, 0x55, 0x9, 0x55, 0x4, 
       0x56, 0x9, 0x56, 0x4, 0x57, 0x9, 0x57, 0x4, 0x58, 0x9, 0x58, 0x4, 
       0x59, 0x9, 0x59, 0x4, 0x5a, 0x9, 0x5a, 0x4, 0x5b, 0x9, 0x5b, 0x4, 
       0x5c, 0x9, 0x5c, 0x4, 0x5d, 0x9, 0x5d, 0x4, 0x5e, 0x9, 0x5e, 0x4, 
       0x5f, 0x9, 0x5f, 0x4, 0x60, 0x9, 0x60, 0x4, 0x61, 0x9, 0x61, 0x4, 
       0x62, 0x9, 0x62, 0x4, 0x63, 0x9, 0x63, 0x4, 0x64, 0x9, 0x64, 0x4, 
       0x65, 0x9, 0x65, 0x4, 0x66, 0x9, 0x66, 0x4, 0x67, 0x9, 0x67, 0x4, 
       0x68, 0x9, 0x68, 0x4, 0x69, 0x9, 0x69, 0x4, 0x6a, 0x9, 0x6a, 0x4, 
       0x6b, 0x9, 0x6b, 0x4, 0x6c, 0x9, 0x6c, 0x4, 0x6d, 0x9, 0x6d, 0x4, 
       0x6e, 0x9, 0x6e, 0x4, 0x6f, 0x9, 0x6f, 0x4, 0x70, 0x9, 0x70, 0x4, 
       0x71, 0x9, 0x71, 0x4, 0x72, 0x9, 0x72, 0x4, 0x73, 0x9, 0x73, 0x4, 
       0x74, 0x9, 0x74, 0x4, 0x75, 0x9, 0x75, 0x4, 0x76, 0x9, 0x76, 0x4, 
       0x77, 0x9, 0x77, 0x4, 0x78, 0x9, 0x78, 0x4, 0x79, 0x9, 0x79, 0x4, 
       0x7a, 0x9, 0x7a, 0x4, 0x7b, 0x9, 0x7b, 0x4, 0x7c, 0x9, 0x7c, 0x4, 
       0x7d, 0x9, 0x7d, 0x4, 0x7e, 0x9, 0x7e, 0x4, 0x7f, 0x9, 0x7f, 0x4, 
       0x80, 0x9, 0x80, 0x4, 0x81, 0x9, 0x81, 0x4, 0x82, 0x9, 0x82, 0x4, 
       0x83, 0x9, 0x83, 0x4, 0x84, 0x9, 0x84, 0x4, 0x85, 0x9, 0x85, 0x4, 
       0x86, 0x9, 0x86, 0x4, 0x87, 0x9, 0x87, 0x4, 0x88, 0x9, 0x88, 0x4, 
       0x89, 0x9, 0x89, 0x4, 0x8a, 0x9, 0x8a, 0x4, 0x8b, 0x9, 0x8b, 0x4, 
       0x8c, 0x9, 0x8c, 0x4, 0x8d, 0x9, 0x8d, 0x4, 0x8e, 0x9, 0x8e, 0x4, 
       0x8f, 0x9, 0x8f, 0x4, 0x90, 0x9, 0x90, 0x4, 0x91, 0x9, 0x91, 0x4, 
       0x92, 0x9, 0x92, 0x4, 0x93, 0x9, 0x93, 0x4, 0x94, 0x9, 0x94, 0x4, 
       0x95, 0x9, 0x95, 0x4, 0x96, 0x9, 0x96, 0x4, 0x97, 0x9, 0x97, 0x4, 
       0x98, 0x9, 0x98, 0x4, 0x99, 0x9, 0x99, 0x4, 0x9a, 0x9, 0x9a, 0x4, 
       0x9b, 0x9, 0x9b, 0x4, 0x9c, 0x9, 0x9c, 0x4, 0x9d, 0x9, 0x9d, 0x4, 
       0x9e, 0x9, 0x9e, 0x4, 0x9f, 0x9, 0x9f, 0x4, 0xa0, 0x9, 0xa0, 0x4, 
       0xa1, 0x9, 0xa1, 0x4, 0xa2, 0x9, 0xa2, 0x4, 0xa3, 0x9, 0xa3, 0x4, 
       0xa4, 0x9, 0xa4, 0x4, 0xa5, 0x9, 0xa5, 0x4, 0xa6, 0x9, 0xa6, 0x4, 
       0xa7, 0x9, 0xa7, 0x4, 0xa8, 0x9, 0xa8, 0x4, 0xa9, 0x9, 0xa9, 0x4, 
       0xaa, 0x9, 0xaa, 0x4, 0xab, 0x9, 0xab, 0x4, 0xac, 0x9, 0xac, 0x4, 
       0xad, 0x9, 0xad, 0x4, 0xae, 0x9, 0xae, 0x4, 0xaf, 0x9, 0xaf, 0x4, 
       0xb0, 0x9, 0xb0, 0x4, 0xb1, 0x9, 0xb1, 0x4, 0xb2, 0x9, 0xb2, 0x4, 
       0xb3, 0x9, 0xb3, 0x4, 0xb4, 0x9, 0xb4, 0x4, 0xb5, 0x9, 0xb5, 0x4, 
       0xb6, 0x9, 0xb6, 0x4, 0xb7, 0x9, 0xb7, 0x4, 0xb8, 0x9, 0xb8, 0x4, 
       0xb9, 0x9, 0xb9, 0x4, 0xba, 0x9, 0xba, 0x4, 0xbb, 0x9, 0xbb, 0x4, 
       0xbc, 0x9, 0xbc, 0x4, 0xbd, 0x9, 0xbd, 0x4, 0xbe, 0x9, 0xbe, 0x4, 
       0xbf, 0x9, 0xbf, 0x4, 0xc0, 0x9, 0xc0, 0x4, 0xc1, 0x9, 0xc1, 0x4, 
       0xc2, 0x9, 0xc2, 0x4, 0xc3, 0x9, 0xc3, 0x4, 0xc4, 0x9, 0xc4, 0x4, 
       0xc5, 0x9, 0xc5, 0x4, 0xc6, 0x9, 0xc6, 0x4, 0xc7, 0x9, 0xc7, 0x4, 
       0xc8, 0x9, 0xc8, 0x4, 0xc9, 0x9, 0xc9, 0x4, 0xca, 0x9, 0xca, 0x4, 
       0xcb, 0x9, 0xcb, 0x4, 0xcc, 0x9, 0xcc, 0x4, 0xcd, 0x9, 0xcd, 0x4, 
       0xce, 0x9, 0xce, 0x4, 0xcf, 0x9, 0xcf, 0x4, 0xd0, 0x9, 0xd0, 0x4, 
       0xd1, 0x9, 0xd1, 0x4, 0xd2, 0x9, 0xd2, 0x4, 0xd3, 0x9, 0xd3, 0x4, 
       0xd4, 0x9, 0xd4, 0x4, 0xd5, 0x9, 0xd5, 0x4, 0xd6, 0x9, 0xd6, 0x4, 
       0xd7, 0x9, 0xd7, 0x4, 0xd8, 0x9, 0xd8, 0x4, 0xd9, 0x9, 0xd9, 0x4, 
       0xda, 0x9, 0xda, 0x4, 0xdb, 0x9, 0xdb, 0x4, 0xdc, 0x9, 0xdc, 0x4, 
       0xdd, 0x9, 0xdd, 0x4, 0xde, 0x9, 0xde, 0x4, 0xdf, 0x9, 0xdf, 0x4, 
       0xe0, 0x9, 0xe0, 0x4, 0xe1, 0x9, 0xe1, 0x4, 0xe2, 0x9, 0xe2, 0x4, 
       0xe3, 0x9, 0xe3, 0x4, 0xe4, 0x9, 0xe4, 0x4, 0xe5, 0x9, 0xe5, 0x4, 
       0xe6, 0x9, 0xe6, 0x4, 0xe7, 0x9, 0xe7, 0x4, 0xe8, 0x9, 0xe8, 0x4, 
       0xe9, 0x9, 0xe9, 0x4, 0xea, 0x9, 0xea, 0x4, 0xeb, 0x9, 0xeb, 0x4, 
       0xec, 0x9, 0xec, 0x4, 0xed, 0x9, 0xed, 0x4, 0xee, 0x9, 0xee, 0x4, 
       0xef, 0x9, 0xef, 0x4, 0xf0, 0x9, 0xf0, 0x4, 0xf1, 0x9, 0xf1, 0x4, 
       0xf2, 0x9, 0xf2, 0x4, 0xf3, 0x9, 0xf3, 0x4, 0xf4, 0x9, 0xf4, 0x4, 
       0xf5, 0x9, 0xf5, 0x4, 0xf6, 0x9, 0xf6, 0x4, 0xf7, 0x9, 0xf7, 0x4, 
       0xf8, 0x9, 0xf8, 0x4, 0xf9, 0x9, 0xf9, 0x4, 0xfa, 0x9, 0xfa, 0x4, 
       0xfb, 0x9, 0xfb, 0x4, 0xfc, 0x9, 0xfc, 0x4, 0xfd, 0x9, 0xfd, 0x4, 
       0xfe, 0x9, 0xfe, 0x4, 0xff, 0x9, 0xff, 0x4, 0x100, 0x9, 0x100, 0x4, 
       0x101, 0x9, 0x101, 0x4, 0x102, 0x9, 0x102, 0x4, 0x103, 0x9, 0x103, 
       0x4, 0x104, 0x9, 0x104, 0x4, 0x105, 0x9, 0x105, 0x4, 0x106, 0x9, 
       0x106, 0x4, 0x107, 0x9, 0x107, 0x4, 0x108, 0x9, 0x108, 0x4, 0x109, 
       0x9, 0x109, 0x4, 0x10a, 0x9, 0x10a, 0x4, 0x10b, 0x9, 0x10b, 0x4, 
       0x10c, 0x9, 0x10c, 0x4, 0x10d, 0x9, 0x10d, 0x4, 0x10e, 0x9, 0x10e, 
       0x4, 0x10f, 0x9, 0x10f, 0x4, 0x110, 0x9, 0x110, 0x4, 0x111, 0x9, 
       0x111, 0x4, 0x112, 0x9, 0x112, 0x4, 0x113, 0x9, 0x113, 0x4, 0x114, 
       0x9, 0x114, 0x4, 0x115, 0x9, 0x115, 0x4, 0x116, 0x9, 0x116, 0x4, 
       0x117, 0x9, 0x117, 0x4, 0x118, 0x9, 0x118, 0x4, 0x119, 0x9, 0x119, 
       0x4, 0x11a, 0x9, 0x11a, 0x4, 0x11b, 0x9, 0x11b, 0x4, 0x11c, 0x9, 
       0x11c, 0x4, 0x11d, 0x9, 0x11d, 0x4, 0x11e, 0x9, 0x11e, 0x4, 0x11f, 
       0x9, 0x11f, 0x4, 0x120, 0x9, 0x120, 0x4, 0x121, 0x9, 0x121, 0x4, 
       0x122, 0x9, 0x122, 0x4, 0x123, 0x9, 0x123, 0x4, 0x124, 0x9, 0x124, 
       0x4, 0x125, 0x9, 0x125, 0x4, 0x126, 0x9, 0x126, 0x4, 0x127, 0x9, 
       0x127, 0x4, 0x128, 0x9, 0x128, 0x4, 0x129, 0x9, 0x129, 0x4, 0x12a, 
       0x9, 0x12a, 0x4, 0x12b, 0x9, 0x12b, 0x4, 0x12c, 0x9, 0x12c, 0x4, 
       0x12d, 0x9, 0x12d, 0x4, 0x12e, 0x9, 0x12e, 0x4, 0x12f, 0x9, 0x12f, 
       0x4, 0x130, 0x9, 0x130, 0x4, 0x131, 0x9, 0x131, 0x4, 0x132, 0x9, 
       0x132, 0x4, 0x133, 0x9, 0x133, 0x4, 0x134, 0x9, 0x134, 0x4, 0x135, 
       0x9, 0x135, 0x4, 0x136, 0x9, 0x136, 0x4, 0x137, 0x9, 0x137, 0x4, 
       0x138, 0x9, 0x138, 0x4, 0x139, 0x9, 0x139, 0x4, 0x13a, 0x9, 0x13a, 
       0x4, 0x13b, 0x9, 0x13b, 0x4, 0x13c, 0x9, 0x13c, 0x4, 0x13d, 0x9, 
       0x13d, 0x4, 0x13e, 0x9, 0x13e, 0x4, 0x13f, 0x9, 0x13f, 0x4, 0x140, 
       0x9, 0x140, 0x4, 0x141, 0x9, 0x141, 0x4, 0x142, 0x9, 0x142, 0x4, 
       0x143, 0x9, 0x143, 0x4, 0x144, 0x9, 0x144, 0x4, 0x145, 0x9, 0x145, 
       0x4, 0x146, 0x9, 0x146, 0x4, 0x147, 0x9, 0x147, 0x4, 0x148, 0x9, 
       0x148, 0x4, 0x149, 0x9, 0x149, 0x4, 0x14a, 0x9, 0x14a, 0x4, 0x14b, 
       0x9, 0x14b, 0x4, 0x14c, 0x9, 0x14c, 0x4, 0x14d, 0x9, 0x14d, 0x4, 
       0x14e, 0x9, 0x14e, 0x4, 0x14f, 0x9, 0x14f, 0x4, 0x150, 0x9, 0x150, 
       0x4, 0x151, 0x9, 0x151, 0x4, 0x152, 0x9, 0x152, 0x4, 0x153, 0x9, 
       0x153, 0x4, 0x154, 0x9, 0x154, 0x4, 0x155, 0x9, 0x155, 0x4, 0x156, 
       0x9, 0x156, 0x4, 0x157, 0x9, 0x157, 0x4, 0x158, 0x9, 0x158, 0x4, 
       0x159, 0x9, 0x159, 0x4, 0x15a, 0x9, 0x15a, 0x4, 0x15b, 0x9, 0x15b, 
       0x4, 0x15c, 0x9, 0x15c, 0x4, 0x15d, 0x9, 0x15d, 0x4, 0x15e, 0x9, 
       0x15e, 0x4, 0x15f, 0x9, 0x15f, 0x4, 0x160, 0x9, 0x160, 0x4, 0x161, 
       0x9, 0x161, 0x4, 0x162, 0x9, 0x162, 0x4, 0x163, 0x9, 0x163, 0x4, 
       0x164, 0x9, 0x164, 0x4, 0x165, 0x9, 0x165, 0x4, 0x166, 0x9, 0x166, 
       0x4, 0x167, 0x9, 0x167, 0x4, 0x168, 0x9, 0x168, 0x4, 0x169, 0x9, 
       0x169, 0x4, 0x16a, 0x9, 0x16a, 0x4, 0x16b, 0x9, 0x16b, 0x4, 0x16c, 
       0x9, 0x16c, 0x4, 0x16d, 0x9, 0x16d, 0x4, 0x16e, 0x9, 0x16e, 0x4, 
       0x16f, 0x9, 0x16f, 0x4, 0x170, 0x9, 0x170, 0x4, 0x171, 0x9, 0x171, 
       0x4, 0x172, 0x9, 0x172, 0x4, 0x173, 0x9, 0x173, 0x4, 0x174, 0x9, 
       0x174, 0x4, 0x175, 0x9, 0x175, 0x4, 0x176, 0x9, 0x176, 0x4, 0x177, 
       0x9, 0x177, 0x4, 0x178, 0x9, 0x178, 0x4, 0x179, 0x9, 0x179, 0x4, 
       0x17a, 0x9, 0x17a, 0x4, 0x17b, 0x9, 0x17b, 0x4, 0x17c, 0x9, 0x17c, 
       0x4, 0x17d, 0x9, 0x17d, 0x4, 0x17e, 0x9, 0x17e, 0x4, 0x17f, 0x9, 
       0x17f, 0x4, 0x180, 0x9, 0x180, 0x4, 0x181, 0x9, 0x181, 0x4, 0x182, 
       0x9, 0x182, 0x4, 0x183, 0x9, 0x183, 0x4, 0x184, 0x9, 0x184, 0x4, 
       0x185, 0x9, 0x185, 0x4, 0x186, 0x9, 0x186, 0x4, 0x187, 0x9, 0x187, 
       0x4, 0x188, 0x9, 0x188, 0x4, 0x189, 0x9, 0x189, 0x4, 0x18a, 0x9, 
       0x18a, 0x4, 0x18b, 0x9, 0x18b, 0x4, 0x18c, 0x9, 0x18c, 0x4, 0x18d, 
       0x9, 0x18d, 0x4, 0x18e, 0x9, 0x18e, 0x4, 0x18f, 0x9, 0x18f, 0x4, 
       0x190, 0x9, 0x190, 0x4, 0x191, 0x9, 0x191, 0x4, 0x192, 0x9, 0x192, 
       0x4, 0x193, 0x9, 0x193, 0x4, 0x194, 0x9, 0x194, 0x4, 0x195, 0x9, 
       0x195, 0x4, 0x196, 0x9, 0x196, 0x4, 0x197, 0x9, 0x197, 0x4, 0x198, 
       0x9, 0x198, 0x4, 0x199, 0x9, 0x199, 0x4, 0x19a, 0x9, 0x19a, 0x4, 
       0x19b, 0x9, 0x19b, 0x4, 0x19c, 0x9, 0x19c, 0x4, 0x19d, 0x9, 0x19d, 
       0x4, 0x19e, 0x9, 0x19e, 0x4, 0x19f, 0x9, 0x19f, 0x4, 0x1a0, 0x9, 
       0x1a0, 0x4, 0x1a1, 0x9, 0x1a1, 0x4, 0x1a2, 0x9, 0x1a2, 0x4, 0x1a3, 
       0x9, 0x1a3, 0x4, 0x1a4, 0x9, 0x1a4, 0x4, 0x1a5, 0x9, 0x1a5, 0x4, 
       0x1a6, 0x9, 0x1a6, 0x4, 0x1a7, 0x9, 0x1a7, 0x4, 0x1a8, 0x9, 0x1a8, 
       0x4, 0x1a9, 0x9, 0x1a9, 0x4, 0x1aa, 0x9, 0x1aa, 0x4, 0x1ab, 0x9, 
       0x1ab, 0x4, 0x1ac, 0x9, 0x1ac, 0x4, 0x1ad, 0x9, 0x1ad, 0x4, 0x1ae, 
       0x9, 0x1ae, 0x4, 0x1af, 0x9, 0x1af, 0x4, 0x1b0, 0x9, 0x1b0, 0x4, 
       0x1b1, 0x9, 0x1b1, 0x4, 0x1b2, 0x9, 0x1b2, 0x4, 0x1b3, 0x9, 0x1b3, 
       0x4, 0x1b4, 0x9, 0x1b4, 0x4, 0x1b5, 0x9, 0x1b5, 0x4, 0x1b6, 0x9, 
       0x1b6, 0x4, 0x1b7, 0x9, 0x1b7, 0x4, 0x1b8, 0x9, 0x1b8, 0x4, 0x1b9, 
       0x9, 0x1b9, 0x4, 0x1ba, 0x9, 0x1ba, 0x4, 0x1bb, 0x9, 0x1bb, 0x4, 
       0x1bc, 0x9, 0x1bc, 0x4, 0x1bd, 0x9, 0x1bd, 0x4, 0x1be, 0x9, 0x1be, 
       0x4, 0x1bf, 0x9, 0x1bf, 0x4, 0x1c0, 0x9, 0x1c0, 0x4, 0x1c1, 0x9, 
       0x1c1, 0x4, 0x1c2, 0x9, 0x1c2, 0x4, 0x1c3, 0x9, 0x1c3, 0x4, 0x1c4, 
       0x9, 0x1c4, 0x4, 0x1c5, 0x9, 0x1c5, 0x4, 0x1c6, 0x9, 0x1c6, 0x4, 
       0x1c7, 0x9, 0x1c7, 0x4, 0x1c8, 0x9, 0x1c8, 0x4, 0x1c9, 0x9, 0x1c9, 
       0x4, 0x1ca, 0x9, 0x1ca, 0x4, 0x1cb, 0x9, 0x1cb, 0x4, 0x1cc, 0x9, 
       0x1cc, 0x4, 0x1cd, 0x9, 0x1cd, 0x4, 0x1ce, 0x9, 0x1ce, 0x4, 0x1cf, 
       0x9, 0x1cf, 0x4, 0x1d0, 0x9, 0x1d0, 0x4, 0x1d1, 0x9, 0x1d1, 0x4, 
       0x1d2, 0x9, 0x1d2, 0x4, 0x1d3, 0x9, 0x1d3, 0x4, 0x1d4, 0x9, 0x1d4, 
       0x4, 0x1d5, 0x9, 0x1d5, 0x4, 0x1d6, 0x9, 0x1d6, 0x4, 0x1d7, 0x9, 
       0x1d7, 0x4, 0x1d8, 0x9, 0x1d8, 0x4, 0x1d9, 0x9, 0x1d9, 0x4, 0x1da, 
       0x9, 0x1da, 0x4, 0x1db, 0x9, 0x1db, 0x4, 0x1dc, 0x9, 0x1dc, 0x4, 
       0x1dd, 0x9, 0x1dd, 0x4, 0x1de, 0x9, 0x1de, 0x4, 0x1df, 0x9, 0x1df, 
       0x4, 0x1e0, 0x9, 0x1e0, 0x4, 0x1e1, 0x9, 0x1e1, 0x4, 0x1e2, 0x9, 
       0x1e2, 0x4, 0x1e3, 0x9, 0x1e3, 0x4, 0x1e4, 0x9, 0x1e4, 0x4, 0x1e5, 
       0x9, 0x1e5, 0x4, 0x1e6, 0x9, 0x1e6, 0x4, 0x1e7, 0x9, 0x1e7, 0x4, 
       0x1e8, 0x9, 0x1e8, 0x4, 0x1e9, 0x9, 0x1e9, 0x4, 0x1ea, 0x9, 0x1ea, 
       0x4, 0x1eb, 0x9, 0x1eb, 0x4, 0x1ec, 0x9, 0x1ec, 0x4, 0x1ed, 0x9, 
       0x1ed, 0x4, 0x1ee, 0x9, 0x1ee, 0x4, 0x1ef, 0x9, 0x1ef, 0x4, 0x1f0, 
       0x9, 0x1f0, 0x4, 0x1f1, 0x9, 0x1f1, 0x4, 0x1f2, 0x9, 0x1f2, 0x4, 
       0x1f3, 0x9, 0x1f3, 0x4, 0x1f4, 0x9, 0x1f4, 0x4, 0x1f5, 0x9, 0x1f5, 
       0x4, 0x1f6, 0x9, 0x1f6, 0x4, 0x1f7, 0x9, 0x1f7, 0x4, 0x1f8, 0x9, 
       0x1f8, 0x4, 0x1f9, 0x9, 0x1f9, 0x4, 0x1fa, 0x9, 0x1fa, 0x4, 0x1fb, 
       0x9, 0x1fb, 0x4, 0x1fc, 0x9, 0x1fc, 0x4, 0x1fd, 0x9, 0x1fd, 0x4, 
       0x1fe, 0x9, 0x1fe, 0x4, 0x1ff, 0x9, 0x1ff, 0x4, 0x200, 0x9, 0x200, 
       0x4, 0x201, 0x9, 0x201, 0x4, 0x202, 0x9, 0x202, 0x4, 0x203, 0x9, 
       0x203, 0x4, 0x204, 0x9, 0x204, 0x4, 0x205, 0x9, 0x205, 0x4, 0x206, 
       0x9, 0x206, 0x4, 0x207, 0x9, 0x207, 0x4, 0x208, 0x9, 0x208, 0x4, 
       0x209, 0x9, 0x209, 0x4, 0x20a, 0x9, 0x20a, 0x4, 0x20b, 0x9, 0x20b, 
       0x4, 0x20c, 0x9, 0x20c, 0x4, 0x20d, 0x9, 0x20d, 0x4, 0x20e, 0x9, 
       0x20e, 0x4, 0x20f, 0x9, 0x20f, 0x4, 0x210, 0x9, 0x210, 0x4, 0x211, 
       0x9, 0x211, 0x4, 0x212, 0x9, 0x212, 0x4, 0x213, 0x9, 0x213, 0x4, 
       0x214, 0x9, 0x214, 0x4, 0x215, 0x9, 0x215, 0x4, 0x216, 0x9, 0x216, 
       0x4, 0x217, 0x9, 0x217, 0x4, 0x218, 0x9, 0x218, 0x4, 0x219, 0x9, 
       0x219, 0x4, 0x21a, 0x9, 0x21a, 0x4, 0x21b, 0x9, 0x21b, 0x4, 0x21c, 
       0x9, 0x21c, 0x4, 0x21d, 0x9, 0x21d, 0x4, 0x21e, 0x9, 0x21e, 0x4, 
       0x21f, 0x9, 0x21f, 0x4, 0x220, 0x9, 0x220, 0x4, 0x221, 0x9, 0x221, 
       0x4, 0x222, 0x9, 0x222, 0x4, 0x223, 0x9, 0x223, 0x4, 0x224, 0x9, 
       0x224, 0x4, 0x225, 0x9, 0x225, 0x4, 0x226, 0x9, 0x226, 0x4, 0x227, 
       0x9, 0x227, 0x4, 0x228, 0x9, 0x228, 0x4, 0x229, 0x9, 0x229, 0x4, 
       0x22a, 0x9, 0x22a, 0x4, 0x22b, 0x9, 0x22b, 0x4, 0x22c, 0x9, 0x22c, 
       0x4, 0x22d, 0x9, 0x22d, 0x4, 0x22e, 0x9, 0x22e, 0x4, 0x22f, 0x9, 
       0x22f, 0x4, 0x230, 0x9, 0x230, 0x4, 0x231, 0x9, 0x231, 0x4, 0x232, 
       0x9, 0x232, 0x4, 0x233, 0x9, 0x233, 0x4, 0x234, 0x9, 0x234, 0x4, 
       0x235, 0x9, 0x235, 0x4, 0x236, 0x9, 0x236, 0x4, 0x237, 0x9, 0x237, 
       0x4, 0x238, 0x9, 0x238, 0x4, 0x239, 0x9, 0x239, 0x4, 0x23a, 0x9, 
       0x23a, 0x4, 0x23b, 0x9, 0x23b, 0x4, 0x23c, 0x9, 0x23c, 0x4, 0x23d, 
       0x9, 0x23d, 0x4, 0x23e, 0x9, 0x23e, 0x4, 0x23f, 0x9, 0x23f, 0x4, 
       0x240, 0x9, 0x240, 0x4, 0x241, 0x9, 0x241, 0x4, 0x242, 0x9, 0x242, 
       0x4, 0x243, 0x9, 0x243, 0x4, 0x244, 0x9, 0x244, 0x4, 0x245, 0x9, 
       0x245, 0x4, 0x246, 0x9, 0x246, 0x4, 0x247, 0x9, 0x247, 0x4, 0x248, 
       0x9, 0x248, 0x4, 0x249, 0x9, 0x249, 0x4, 0x24a, 0x9, 0x24a, 0x4, 
       0x24b, 0x9, 0x24b, 0x4, 0x24c, 0x9, 0x24c, 0x4, 0x24d, 0x9, 0x24d, 
       0x4, 0x24e, 0x9, 0x24e, 0x4, 0x24f, 0x9, 0x24f, 0x4, 0x250, 0x9, 
       0x250, 0x4, 0x251, 0x9, 0x251, 0x4, 0x252, 0x9, 0x252, 0x4, 0x253, 
       0x9, 0x253, 0x4, 0x254, 0x9, 0x254, 0x4, 0x255, 0x9, 0x255, 0x4, 
       0x256, 0x9, 0x256, 0x4, 0x257, 0x9, 0x257, 0x4, 0x258, 0x9, 0x258, 
       0x4, 0x259, 0x9, 0x259, 0x4, 0x25a, 0x9, 0x25a, 0x4, 0x25b, 0x9, 
       0x25b, 0x3, 0x2, 0x3, 0x2, 0x3, 0x3, 0x3, 0x3, 0x5, 0x3, 0x4bb, 0xa, 
       0x3, 0x3, 0x3, 0x7, 0x3, 0x4be, 0xa, 0x3, 0xc, 0x3, 0xe, 0x3, 0x4c1, 
       0xb, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x4, 0x3, 0x4, 0x3, 0x4, 0x5, 
       0x4, 0x4c8, 0xa, 0x4, 0x3, 0x4, 0x3, 0x4, 0x5, 0x4, 0x4cc, 0xa, 0x4, 
       0x3, 0x4, 0x5, 0x4, 0x4cf, 0xa, 0x4, 0x5, 0x4, 0x4d1, 0xa, 0x4, 0x3, 
       0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 
       0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 
       0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 
       0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 
       0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 0x3, 0x5, 
       0x3, 0x5, 0x5, 0x5, 0x4f5, 0xa, 0x5, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 
       0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x4fd, 0xa, 0x6, 0x3, 0x6, 
       0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 0x502, 0xa, 0x6, 0x3, 0x6, 0x3, 0x6, 
       0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 
       0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x3, 0x6, 0x5, 0x6, 
       0x512, 0xa, 0x6, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x6, 0x7, 0x517, 0xa, 
       0x7, 0xd, 0x7, 0xe, 0x7, 0x518, 0x3, 0x7, 0x3, 0x7, 0x3, 0x7, 0x3, 
       0x7, 0x3, 0x7, 0x5, 0x7, 0x520, 0xa, 0x7, 0x3, 0x8, 0x5, 0x8, 0x523, 
       0xa, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x5, 
       0x8, 0x52a, 0xa, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 0x5, 0x8, 0x52f, 
       0xa, 0x8, 0x3, 0x8, 0x5, 0x8, 0x532, 0xa, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x5, 0x8, 0x537, 0xa, 0x8, 0x3, 0x8, 0x3, 0x8, 0x3, 0x8, 
       0x3, 0x8, 0x5, 0x8, 0x53d, 0xa, 0x8, 0x5, 0x8, 0x53f, 0xa, 0x8, 0x3, 
       0x8, 0x3, 0x8, 0x5, 0x8, 0x543, 0xa, 0x8, 0x3, 0x8, 0x3, 0x8, 0x5, 
       0x8, 0x547, 0xa, 0x8, 0x3, 0x9, 0x3, 0x9, 0x3, 0x9, 0x3, 0x9, 0x3, 
       0x9, 0x3, 0x9, 0x3, 0x9, 0x5, 0x9, 0x550, 0xa, 0x9, 0x3, 0xa, 0x3, 
       0xa, 0x5, 0xa, 0x554, 0xa, 0xa, 0x3, 0xa, 0x7, 0xa, 0x557, 0xa, 0xa, 
       0xc, 0xa, 0xe, 0xa, 0x55a, 0xb, 0xa, 0x3, 0xb, 0x3, 0xb, 0x3, 0xb, 
       0x5, 0xb, 0x55f, 0xa, 0xb, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 0x3, 0xc, 
       0x3, 0xd, 0x5, 0xd, 0x566, 0xa, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 
       0x56a, 0xa, 0xd, 0x3, 0xd, 0x3, 0xd, 0x3, 0xd, 0x5, 0xd, 0x56f, 0xa, 
       0xd, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x5, 0xe, 0x574, 0xa, 0xe, 0x3, 
       0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x3, 0xe, 0x5, 0xe, 0x57b, 0xa, 
       0xe, 0x3, 0xe, 0x5, 0xe, 0x57e, 0xa, 0xe, 0x3, 0xf, 0x3, 0xf, 0x3, 
       0xf, 0x3, 0xf, 0x5, 0xf, 0x584, 0xa, 0xf, 0x3, 0xf, 0x5, 0xf, 0x587, 
       0xa, 0xf, 0x3, 0x10, 0x3, 0x10, 0x3, 0x10, 0x7, 0x10, 0x58c, 0xa, 
       0x10, 0xc, 0x10, 0xe, 0x10, 0x58f, 0xb, 0x10, 0x3, 0x11, 0x3, 0x11, 
       0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x3, 0x11, 0x5, 0x11, 
       0x598, 0xa, 0x11, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x59d, 
       0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x5a2, 0xa, 
       0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 
       0x12, 0x5, 0x12, 0x5aa, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 
       0x3, 0x12, 0x5, 0x12, 0x5b0, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 
       0x12, 0x5b4, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 
       0x5b9, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 
       0x12, 0x7, 0x12, 0x5c0, 0xa, 0x12, 0xc, 0x12, 0xe, 0x12, 0x5c3, 0xb, 
       0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x5c8, 0xa, 0x12, 
       0x3, 0x12, 0x3, 0x12, 0x7, 0x12, 0x5cc, 0xa, 0x12, 0xc, 0x12, 0xe, 
       0x12, 0x5cf, 0xb, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 
       0x5d4, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 
       0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x5de, 0xa, 0x12, 
       0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x5e4, 0xa, 
       0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 
       0x12, 0x3, 0x12, 0x5, 0x12, 0x5ed, 0xa, 0x12, 0x3, 0x12, 0x3, 0x12, 
       0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 
       0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x3, 0x12, 0x5, 0x12, 0x5fb, 0xa, 
       0x12, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x5ff, 0xa, 0x13, 0x3, 0x13, 
       0x3, 0x13, 0x3, 0x13, 0x3, 0x13, 0x5, 0x13, 0x605, 0xa, 0x13, 0x7, 
       0x13, 0x607, 0xa, 0x13, 0xc, 0x13, 0xe, 0x13, 0x60a, 0xb, 0x13, 0x3, 
       0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x3, 0x14, 0x5, 0x14, 0x611, 
       0xa, 0x14, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x615, 0xa, 0x15, 0x3, 
       0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x61a, 0xa, 0x15, 0x3, 0x15, 
       0x5, 0x15, 0x61d, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x5, 0x15, 0x623, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x5, 0x15, 0x629, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x3, 0x15, 0x5, 0x15, 0x62f, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x5, 0x15, 0x633, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 
       0x15, 0x638, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x63c, 0xa, 
       0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x640, 0xa, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 
       0x648, 0xa, 0x15, 0x5, 0x15, 0x64a, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x651, 0xa, 0x15, 0x3, 
       0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 
       0x15, 0x659, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x661, 0xa, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x5, 0x15, 0x665, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 
       0x5, 0x15, 0x67c, 0xa, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 0x15, 0x68c, 
       0xa, 0x15, 0x3, 0x15, 0x5, 0x15, 0x68f, 0xa, 0x15, 0x3, 0x15, 0x3, 
       0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x3, 0x15, 0x5, 
       0x15, 0x698, 0xa, 0x15, 0x3, 0x16, 0x3, 0x16, 0x3, 0x16, 0x5, 0x16, 
       0x69d, 0xa, 0x16, 0x3, 0x17, 0x3, 0x17, 0x3, 0x18, 0x3, 0x18, 0x5, 
       0x18, 0x6a3, 0xa, 0x18, 0x3, 0x18, 0x3, 0x18, 0x3, 0x18, 0x5, 0x18, 
       0x6a8, 0xa, 0x18, 0x7, 0x18, 0x6aa, 0xa, 0x18, 0xc, 0x18, 0xe, 0x18, 
       0x6ad, 0xb, 0x18, 0x3, 0x19, 0x3, 0x19, 0x5, 0x19, 0x6b1, 0xa, 0x19, 
       0x3, 0x19, 0x3, 0x19, 0x5, 0x19, 0x6b5, 0xa, 0x19, 0x3, 0x1a, 0x3, 
       0x1a, 0x5, 0x1a, 0x6b9, 0xa, 0x1a, 0x3, 0x1a, 0x3, 0x1a, 0x5, 0x1a, 
       0x6bd, 0xa, 0x1a, 0x3, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x5, 0x1b, 0x6c2, 
       0xa, 0x1b, 0x3, 0x1b, 0x3, 0x1b, 0x5, 0x1b, 0x6c6, 0xa, 0x1b, 0x5, 
       0x1b, 0x6c8, 0xa, 0x1b, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 0x3, 0x1c, 
       0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1d, 0x3, 0x1e, 0x3, 0x1e, 0x5, 0x1e, 
       0x6d3, 0xa, 0x1e, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x5, 0x1f, 0x6d8, 
       0xa, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x3, 0x1f, 0x5, 0x1f, 
       0x6de, 0xa, 0x1f, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 
       0x20, 0x3, 0x20, 0x5, 0x20, 0x6e6, 0xa, 0x20, 0x3, 0x20, 0x3, 0x20, 
       0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 
       0x6ef, 0xa, 0x20, 0x3, 0x20, 0x7, 0x20, 0x6f2, 0xa, 0x20, 0xc, 0x20, 
       0xe, 0x20, 0x6f5, 0xb, 0x20, 0x5, 0x20, 0x6f7, 0xa, 0x20, 0x3, 0x20, 
       0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x6fc, 0xa, 0x20, 0x3, 0x20, 0x3, 
       0x20, 0x3, 0x20, 0x3, 0x20, 0x3, 0x20, 0x5, 0x20, 0x703, 0xa, 0x20, 
       0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 0x3, 0x21, 
       0x5, 0x21, 0x70b, 0xa, 0x21, 0x3, 0x22, 0x3, 0x22, 0x5, 0x22, 0x70f, 
       0xa, 0x22, 0x3, 0x22, 0x7, 0x22, 0x712, 0xa, 0x22, 0xc, 0x22, 0xe, 
       0x22, 0x715, 0xb, 0x22, 0x3, 0x23, 0x3, 0x23, 0x3, 0x24, 0x3, 0x24, 
       0x5, 0x24, 0x71b, 0xa, 0x24, 0x3, 0x24, 0x7, 0x24, 0x71e, 0xa, 0x24, 
       0xc, 0x24, 0xe, 0x24, 0x721, 0xb, 0x24, 0x3, 0x25, 0x3, 0x25, 0x5, 
       0x25, 0x725, 0xa, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 0x3, 0x25, 
       0x3, 0x25, 0x3, 0x25, 0x5, 0x25, 0x72d, 0xa, 0x25, 0x3, 0x26, 0x3, 
       0x26, 0x5, 0x26, 0x731, 0xa, 0x26, 0x3, 0x26, 0x3, 0x26, 0x3, 0x26, 
       0x5, 0x26, 0x736, 0xa, 0x26, 0x3, 0x27, 0x5, 0x27, 0x739, 0xa, 0x27, 
       0x3, 0x27, 0x5, 0x27, 0x73c, 0xa, 0x27, 0x3, 0x27, 0x5, 0x27, 0x73f, 
       0xa, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x27, 0x3, 0x28, 
       0x5, 0x28, 0x746, 0xa, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 0x28, 0x3, 
       0x29, 0x3, 0x29, 0x5, 0x29, 0x74d, 0xa, 0x29, 0x3, 0x2a, 0x3, 0x2a, 
       0x5, 0x2a, 0x751, 0xa, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 0x2a, 0x3, 
       0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 
       0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 
       0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 0x2b, 0x3, 
       0x2b, 0x5, 0x2b, 0x769, 0xa, 0x2b, 0x3, 0x2c, 0x3, 0x2c, 0x5, 0x2c, 
       0x76d, 0xa, 0x2c, 0x3, 0x2c, 0x3, 0x2c, 0x7, 0x2c, 0x771, 0xa, 0x2c, 
       0xc, 0x2c, 0xe, 0x2c, 0x774, 0xb, 0x2c, 0x3, 0x2d, 0x3, 0x2d, 0x3, 
       0x2d, 0x3, 0x2d, 0x5, 0x2d, 0x77a, 0xa, 0x2d, 0x3, 0x2e, 0x5, 0x2e, 
       0x77d, 0xa, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x781, 0xa, 0x2e, 
       0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 
       0x788, 0xa, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x78b, 0xa, 0x2e, 0x3, 0x2e, 
       0x5, 0x2e, 0x78e, 0xa, 0x2e, 0x3, 0x2e, 0x5, 0x2e, 0x791, 0xa, 0x2e, 
       0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 0x3, 0x2e, 
       0x3, 0x2e, 0x5, 0x2e, 0x79a, 0xa, 0x2e, 0x3, 0x2f, 0x3, 0x2f, 0x3, 
       0x2f, 0x7, 0x2f, 0x79f, 0xa, 0x2f, 0xc, 0x2f, 0xe, 0x2f, 0x7a2, 0xb, 
       0x2f, 0x3, 0x30, 0x3, 0x30, 0x5, 0x30, 0x7a6, 0xa, 0x30, 0x3, 0x31, 
       0x5, 0x31, 0x7a9, 0xa, 0x31, 0x3, 0x31, 0x5, 0x31, 0x7ac, 0xa, 0x31, 
       0x3, 0x31, 0x3, 0x31, 0x3, 0x32, 0x3, 0x32, 0x5, 0x32, 0x7b2, 0xa, 
       0x32, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x3, 0x33, 0x5, 0x33, 0x7b8, 
       0xa, 0x33, 0x3, 0x33, 0x5, 0x33, 0x7bb, 0xa, 0x33, 0x3, 0x33, 0x3, 
       0x33, 0x3, 0x34, 0x5, 0x34, 0x7c0, 0xa, 0x34, 0x3, 0x34, 0x3, 0x34, 
       0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x34, 0x7, 0x34, 0x7c8, 0xa, 
       0x34, 0xc, 0x34, 0xe, 0x34, 0x7cb, 0xb, 0x34, 0x5, 0x34, 0x7cd, 0xa, 
       0x34, 0x3, 0x34, 0x3, 0x34, 0x7, 0x34, 0x7d1, 0xa, 0x34, 0xc, 0x34, 
       0xe, 0x34, 0x7d4, 0xb, 0x34, 0x3, 0x34, 0x3, 0x34, 0x3, 0x35, 0x5, 
       0x35, 0x7d9, 0xa, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x35, 
       0x3, 0x35, 0x3, 0x35, 0x7, 0x35, 0x7e1, 0xa, 0x35, 0xc, 0x35, 0xe, 
       0x35, 0x7e4, 0xb, 0x35, 0x5, 0x35, 0x7e6, 0xa, 0x35, 0x3, 0x35, 0x3, 
       0x35, 0x3, 0x35, 0x3, 0x35, 0x7, 0x35, 0x7ec, 0xa, 0x35, 0xc, 0x35, 
       0xe, 0x35, 0x7ef, 0xb, 0x35, 0x3, 0x35, 0x3, 0x35, 0x3, 0x36, 0x5, 
       0x36, 0x7f4, 0xa, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 
       0x3, 0x36, 0x3, 0x36, 0x3, 0x36, 0x3, 0x37, 0x3, 0x37, 0x5, 0x37, 
       0x7ff, 0xa, 0x37, 0x3, 0x37, 0x5, 0x37, 0x802, 0xa, 0x37, 0x3, 0x38, 
       0x6, 0x38, 0x805, 0xa, 0x38, 0xd, 0x38, 0xe, 0x38, 0x806, 0x3, 0x39, 
       0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 
       0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 
       0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x3, 0x39, 0x5, 0x39, 0x81a, 0xa, 
       0x39, 0x3, 0x3a, 0x5, 0x3a, 0x81d, 0xa, 0x3a, 0x3, 0x3a, 0x5, 0x3a, 
       0x820, 0xa, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x5, 
       0x3a, 0x826, 0xa, 0x3a, 0x3, 0x3a, 0x5, 0x3a, 0x829, 0xa, 0x3a, 0x5, 
       0x3a, 0x82b, 0xa, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x7, 0x3a, 0x82f, 0xa, 
       0x3a, 0xc, 0x3a, 0xe, 0x3a, 0x832, 0xb, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 
       0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x7, 0x3a, 0x839, 0xa, 0x3a, 0xc, 
       0x3a, 0xe, 0x3a, 0x83c, 0xb, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 0x3, 0x3a, 
       0x3, 0x3a, 0x3, 0x3a, 0x7, 0x3a, 0x843, 0xa, 0x3a, 0xc, 0x3a, 0xe, 
       0x3a, 0x846, 0xb, 0x3a, 0x5, 0x3a, 0x848, 0xa, 0x3a, 0x3, 0x3a, 0x5, 
       0x3a, 0x84b, 0xa, 0x3a, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x5, 0x3b, 
       0x850, 0xa, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x3, 0x3b, 0x5, 
       0x3b, 0x856, 0xa, 0x3b, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 0x3, 0x3c, 
       0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 0x3, 0x3d, 
       0x3, 0x3d, 0x5, 0x3d, 0x863, 0xa, 0x3d, 0x3, 0x3e, 0x3, 0x3e, 0x5, 
       0x3e, 0x867, 0xa, 0x3e, 0x3, 0x3e, 0x7, 0x3e, 0x86a, 0xa, 0x3e, 0xc, 
       0x3e, 0xe, 0x3e, 0x86d, 0xb, 0x3e, 0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 
       0x3, 0x3f, 0x3, 0x3f, 0x3, 0x3f, 0x5, 0x3f, 0x875, 0xa, 0x3f, 0x3, 
       0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 0x40, 0x3, 
       0x40, 0x3, 0x40, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 
       0x41, 0x7, 0x41, 0x884, 0xa, 0x41, 0xc, 0x41, 0xe, 0x41, 0x887, 0xb, 
       0x41, 0x3, 0x41, 0x3, 0x41, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 
       0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 
       0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x3, 0x42, 0x5, 0x42, 0x899, 
       0xa, 0x42, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 0x3, 0x43, 
       0x3, 0x43, 0x3, 0x43, 0x5, 0x43, 0x8a2, 0xa, 0x43, 0x3, 0x43, 0x5, 
       0x43, 0x8a5, 0xa, 0x43, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 0x3, 0x44, 
       0x3, 0x44, 0x3, 0x44, 0x5, 0x44, 0x8ad, 0xa, 0x44, 0x3, 0x45, 0x3, 
       0x45, 0x3, 0x45, 0x5, 0x45, 0x8b2, 0xa, 0x45, 0x3, 0x45, 0x3, 0x45, 
       0x5, 0x45, 0x8b6, 0xa, 0x45, 0x3, 0x46, 0x3, 0x46, 0x3, 0x46, 0x3, 
       0x47, 0x3, 0x47, 0x5, 0x47, 0x8bd, 0xa, 0x47, 0x3, 0x47, 0x7, 0x47, 
       0x8c0, 0xa, 0x47, 0xc, 0x47, 0xe, 0x47, 0x8c3, 0xb, 0x47, 0x3, 0x48, 
       0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 
       0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x3, 0x48, 0x5, 0x48, 
       0x8d1, 0xa, 0x48, 0x3, 0x49, 0x3, 0x49, 0x5, 0x49, 0x8d5, 0xa, 0x49, 
       0x3, 0x49, 0x3, 0x49, 0x3, 0x4a, 0x3, 0x4a, 0x5, 0x4a, 0x8db, 0xa, 
       0x4a, 0x3, 0x4a, 0x3, 0x4a, 0x3, 0x4b, 0x3, 0x4b, 0x5, 0x4b, 0x8e1, 
       0xa, 0x4b, 0x3, 0x4b, 0x3, 0x4b, 0x3, 0x4c, 0x3, 0x4c, 0x5, 0x4c, 
       0x8e7, 0xa, 0x4c, 0x3, 0x4c, 0x3, 0x4c, 0x3, 0x4d, 0x3, 0x4d, 0x5, 
       0x4d, 0x8ed, 0xa, 0x4d, 0x3, 0x4d, 0x3, 0x4d, 0x3, 0x4e, 0x3, 0x4e, 
       0x5, 0x4e, 0x8f3, 0xa, 0x4e, 0x3, 0x4e, 0x3, 0x4e, 0x3, 0x4f, 0x5, 
       0x4f, 0x8f8, 0xa, 0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x5, 0x4f, 0x8fc, 0xa, 
       0x4f, 0x3, 0x4f, 0x3, 0x4f, 0x3, 0x50, 0x3, 0x50, 0x3, 0x51, 0x3, 
       0x51, 0x5, 0x51, 0x904, 0xa, 0x51, 0x3, 0x51, 0x3, 0x51, 0x3, 0x52, 
       0x3, 0x52, 0x5, 0x52, 0x90a, 0xa, 0x52, 0x3, 0x52, 0x3, 0x52, 0x3, 
       0x53, 0x3, 0x53, 0x5, 0x53, 0x910, 0xa, 0x53, 0x3, 0x53, 0x3, 0x53, 
       0x3, 0x54, 0x5, 0x54, 0x915, 0xa, 0x54, 0x3, 0x54, 0x5, 0x54, 0x918, 
       0xa, 0x54, 0x3, 0x54, 0x5, 0x54, 0x91b, 0xa, 0x54, 0x3, 0x54, 0x3, 
       0x54, 0x3, 0x54, 0x3, 0x54, 0x3, 0x55, 0x3, 0x55, 0x3, 0x55, 0x5, 
       0x55, 0x924, 0xa, 0x55, 0x3, 0x55, 0x5, 0x55, 0x927, 0xa, 0x55, 0x3, 
       0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x56, 0x3, 0x57, 0x3, 0x57, 0x3, 
       0x57, 0x3, 0x57, 0x3, 0x58, 0x5, 0x58, 0x932, 0xa, 0x58, 0x3, 0x58, 
       0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 
       0x3, 0x58, 0x3, 0x58, 0x3, 0x58, 0x5, 0x58, 0x93e, 0xa, 0x58, 0x3, 
       0x58, 0x3, 0x58, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 0x59, 0x3, 
       0x5a, 0x5, 0x5a, 0x947, 0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 
       0x94b, 0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 
       0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x954, 0xa, 0x5a, 0x3, 0x5a, 
       0x5, 0x5a, 0x957, 0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 0x3, 
       0x5a, 0x5, 0x5a, 0x95d, 0xa, 0x5a, 0x5, 0x5a, 0x95f, 0xa, 0x5a, 0x3, 
       0x5a, 0x3, 0x5a, 0x5, 0x5a, 0x963, 0xa, 0x5a, 0x3, 0x5a, 0x3, 0x5a, 
       0x3, 0x5a, 0x3, 0x5b, 0x3, 0x5b, 0x5, 0x5b, 0x96a, 0xa, 0x5b, 0x3, 
       0x5b, 0x3, 0x5b, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 
       0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x7, 0x5c, 0x975, 0xa, 0x5c, 0xc, 0x5c, 
       0xe, 0x5c, 0x978, 0xb, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x3, 
       0x5c, 0x5, 0x5c, 0x97e, 0xa, 0x5c, 0x3, 0x5c, 0x3, 0x5c, 0x7, 0x5c, 
       0x982, 0xa, 0x5c, 0xc, 0x5c, 0xe, 0x5c, 0x985, 0xb, 0x5c, 0x5, 0x5c, 
       0x987, 0xa, 0x5c, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 
       0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 
       0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x3, 0x5d, 0x5, 0x5d, 0x998, 
       0xa, 0x5d, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 
       0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 
       0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 0x3, 0x5e, 
       0x3, 0x5e, 0x5, 0x5e, 0x9ac, 0xa, 0x5e, 0x3, 0x5f, 0x3, 0x5f, 0x5, 
       0x5f, 0x9b0, 0xa, 0x5f, 0x3, 0x5f, 0x3, 0x5f, 0x3, 0x60, 0x3, 0x60, 
       0x5, 0x60, 0x9b6, 0xa, 0x60, 0x3, 0x60, 0x3, 0x60, 0x3, 0x61, 0x3, 
       0x61, 0x5, 0x61, 0x9bc, 0xa, 0x61, 0x3, 0x61, 0x3, 0x61, 0x3, 0x62, 
       0x3, 0x62, 0x5, 0x62, 0x9c2, 0xa, 0x62, 0x3, 0x62, 0x3, 0x62, 0x3, 
       0x63, 0x5, 0x63, 0x9c7, 0xa, 0x63, 0x3, 0x63, 0x3, 0x63, 0x3, 0x63, 
       0x3, 0x63, 0x3, 0x63, 0x5, 0x63, 0x9ce, 0xa, 0x63, 0x3, 0x64, 0x3, 
       0x64, 0x3, 0x64, 0x3, 0x64, 0x3, 0x64, 0x5, 0x64, 0x9d5, 0xa, 0x64, 
       0x3, 0x64, 0x7, 0x64, 0x9d8, 0xa, 0x64, 0xc, 0x64, 0xe, 0x64, 0x9db, 
       0xb, 0x64, 0x5, 0x64, 0x9dd, 0xa, 0x64, 0x3, 0x65, 0x3, 0x65, 0x5, 
       0x65, 0x9e1, 0xa, 0x65, 0x3, 0x66, 0x3, 0x66, 0x5, 0x66, 0x9e5, 0xa, 
       0x66, 0x3, 0x66, 0x3, 0x66, 0x3, 0x67, 0x5, 0x67, 0x9ea, 0xa, 0x67, 
       0x3, 0x67, 0x3, 0x67, 0x5, 0x67, 0x9ee, 0xa, 0x67, 0x3, 0x67, 0x3, 
       0x67, 0x5, 0x67, 0x9f2, 0xa, 0x67, 0x3, 0x68, 0x3, 0x68, 0x3, 0x68, 
       0x3, 0x68, 0x5, 0x68, 0x9f8, 0xa, 0x68, 0x3, 0x68, 0x7, 0x68, 0x9fb, 
       0xa, 0x68, 0xc, 0x68, 0xe, 0x68, 0x9fe, 0xb, 0x68, 0x5, 0x68, 0xa00, 
       0xa, 0x68, 0x3, 0x69, 0x3, 0x69, 0x5, 0x69, 0xa04, 0xa, 0x69, 0x3, 
       0x69, 0x3, 0x69, 0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 0xa0a, 0xa, 0x6a, 
       0x3, 0x6a, 0x3, 0x6a, 0x5, 0x6a, 0xa0e, 0xa, 0x6a, 0x3, 0x6b, 0x3, 
       0x6b, 0x5, 0x6b, 0xa12, 0xa, 0x6b, 0x3, 0x6b, 0x3, 0x6b, 0x3, 0x6c, 
       0x3, 0x6c, 0x3, 0x6c, 0x3, 0x6c, 0x5, 0x6c, 0xa1a, 0xa, 0x6c, 0x3, 
       0x6c, 0x3, 0x6c, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x3, 0x6d, 0x5, 
       0x6d, 0xa22, 0xa, 0x6d, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 0x3, 0x6e, 
       0x3, 0x6e, 0x7, 0x6e, 0xa29, 0xa, 0x6e, 0xc, 0x6e, 0xe, 0x6e, 0xa2c, 
       0xb, 0x6e, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x6f, 0x3, 0x70, 
       0x3, 0x70, 0x5, 0x70, 0xa34, 0xa, 0x70, 0x3, 0x70, 0x3, 0x70, 0x3, 
       0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x71, 0x3, 0x72, 0x3, 
       0x72, 0x3, 0x72, 0x3, 0x72, 0x5, 0x72, 0xa41, 0xa, 0x72, 0x3, 0x72, 
       0x5, 0x72, 0xa44, 0xa, 0x72, 0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0xa48, 
       0xa, 0x73, 0x3, 0x73, 0x3, 0x73, 0x7, 0x73, 0xa4c, 0xa, 0x73, 0xc, 
       0x73, 0xe, 0x73, 0xa4f, 0xb, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 
       0x3, 0x73, 0x3, 0x73, 0x5, 0x73, 0xa56, 0xa, 0x73, 0x3, 0x73, 0x3, 
       0x73, 0x3, 0x73, 0x5, 0x73, 0xa5b, 0xa, 0x73, 0x3, 0x73, 0x5, 0x73, 
       0xa5e, 0xa, 0x73, 0x3, 0x73, 0x5, 0x73, 0xa61, 0xa, 0x73, 0x3, 0x73, 
       0x5, 0x73, 0xa64, 0xa, 0x73, 0x3, 0x73, 0x5, 0x73, 0xa67, 0xa, 0x73, 
       0x5, 0x73, 0xa69, 0xa, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 0x73, 0x3, 
       0x73, 0x5, 0x73, 0xa6f, 0xa, 0x73, 0x5, 0x73, 0xa71, 0xa, 0x73, 0x3, 
       0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 0x74, 0x3, 
       0x75, 0x3, 0x75, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 0x76, 0x3, 
       0x76, 0x5, 0x76, 0xa80, 0xa, 0x76, 0x3, 0x77, 0x3, 0x77, 0x3, 0x77, 
       0x3, 0x77, 0x5, 0x77, 0xa86, 0xa, 0x77, 0x3, 0x77, 0x3, 0x77, 0x3, 
       0x77, 0x3, 0x77, 0x3, 0x77, 0x5, 0x77, 0xa8d, 0xa, 0x77, 0x3, 0x77, 
       0x5, 0x77, 0xa90, 0xa, 0x77, 0x5, 0x77, 0xa92, 0xa, 0x77, 0x5, 0x77, 
       0xa94, 0xa, 0x77, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 
       0x78, 0x3, 0x78, 0x3, 0x78, 0x3, 0x78, 0x5, 0x78, 0xa9e, 0xa, 0x78, 
       0x5, 0x78, 0xaa0, 0xa, 0x78, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xaa4, 
       0xa, 0x79, 0x3, 0x79, 0x5, 0x79, 0xaa7, 0xa, 0x79, 0x3, 0x79, 0x5, 
       0x79, 0xaaa, 0xa, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xaae, 0xa, 
       0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x3, 0x79, 0x5, 0x79, 0xab4, 
       0xa, 0x79, 0x3, 0x79, 0x5, 0x79, 0xab7, 0xa, 0x79, 0x3, 0x7a, 0x3, 
       0x7a, 0x3, 0x7b, 0x3, 0x7b, 0x5, 0x7b, 0xabd, 0xa, 0x7b, 0x3, 0x7b, 
       0x5, 0x7b, 0xac0, 0xa, 0x7b, 0x3, 0x7b, 0x3, 0x7b, 0x3, 0x7c, 0x3, 
       0x7c, 0x3, 0x7c, 0x7, 0x7c, 0xac7, 0xa, 0x7c, 0xc, 0x7c, 0xe, 0x7c, 
       0xaca, 0xb, 0x7c, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7d, 0x3, 0x7e, 0x3, 
       0x7e, 0x3, 0x7e, 0x5, 0x7e, 0xad2, 0xa, 0x7e, 0x3, 0x7e, 0x3, 0x7e, 
       0x5, 0x7e, 0xad6, 0xa, 0x7e, 0x3, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 0xada, 
       0xa, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x3, 0x7f, 0x5, 0x7f, 
       0xae0, 0xa, 0x7f, 0x3, 0x7f, 0x7, 0x7f, 0xae3, 0xa, 0x7f, 0xc, 0x7f, 
       0xe, 0x7f, 0xae6, 0xb, 0x7f, 0x3, 0x80, 0x3, 0x80, 0x5, 0x80, 0xaea, 
       0xa, 0x80, 0x3, 0x80, 0x3, 0x80, 0x3, 0x80, 0x5, 0x80, 0xaef, 0xa, 
       0x80, 0x7, 0x80, 0xaf1, 0xa, 0x80, 0xc, 0x80, 0xe, 0x80, 0xaf4, 0xb, 
       0x80, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 0x81, 0x3, 
       0x81, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 0x5, 0x82, 0xaff, 0xa, 0x82, 
       0x3, 0x82, 0x5, 0x82, 0xb02, 0xa, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 
       0x82, 0x5, 0x82, 0xb07, 0xa, 0x82, 0x3, 0x82, 0x3, 0x82, 0x3, 0x82, 
       0x3, 0x82, 0x5, 0x82, 0xb0d, 0xa, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb10, 
       0xa, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb13, 0xa, 0x82, 0x3, 0x82, 0x5, 
       0x82, 0xb16, 0xa, 0x82, 0x3, 0x82, 0x5, 0x82, 0xb19, 0xa, 0x82, 0x3, 
       0x82, 0x3, 0x82, 0x3, 0x83, 0x3, 0x83, 0x3, 0x84, 0x3, 0x84, 0x3, 
       0x84, 0x3, 0x84, 0x3, 0x84, 0x3, 0x85, 0x3, 0x85, 0x3, 0x85, 0x5, 
       0x85, 0xb27, 0xa, 0x85, 0x3, 0x85, 0x5, 0x85, 0xb2a, 0xa, 0x85, 0x3, 
       0x85, 0x3, 0x85, 0x5, 0x85, 0xb2e, 0xa, 0x85, 0x3, 0x86, 0x3, 0x86, 
       0x5, 0x86, 0xb32, 0xa, 0x86, 0x3, 0x86, 0x3, 0x86, 0x3, 0x87, 0x3, 
       0x87, 0x5, 0x87, 0xb38, 0xa, 0x87, 0x3, 0x87, 0x3, 0x87, 0x3, 0x87, 
       0x5, 0x87, 0xb3d, 0xa, 0x87, 0x7, 0x87, 0xb3f, 0xa, 0x87, 0xc, 0x87, 
       0xe, 0x87, 0xb42, 0xb, 0x87, 0x3, 0x88, 0x3, 0x88, 0x5, 0x88, 0xb46, 
       0xa, 0x88, 0x3, 0x88, 0x5, 0x88, 0xb49, 0xa, 0x88, 0x3, 0x88, 0x3, 
       0x88, 0x5, 0x88, 0xb4d, 0xa, 0x88, 0x3, 0x88, 0x3, 0x88, 0x3, 0x88, 
       0x3, 0x88, 0x5, 0x88, 0xb53, 0xa, 0x88, 0x3, 0x89, 0x3, 0x89, 0x3, 
       0x89, 0x5, 0x89, 0xb58, 0xa, 0x89, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 
       0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x3, 0x8a, 0x5, 0x8a, 0xb61, 0xa, 
       0x8a, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb65, 0xa, 0x8b, 0x3, 0x8b, 
       0x3, 0x8b, 0x5, 0x8b, 0xb69, 0xa, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb6c, 
       0xa, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb71, 0xa, 
       0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb74, 0xa, 0x8b, 0x5, 0x8b, 0xb76, 0xa, 
       0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x5, 0x8b, 0xb7a, 0xa, 0x8b, 0x3, 0x8b, 
       0x5, 0x8b, 0xb7d, 0xa, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 0x8b, 0x3, 
       0x8b, 0x5, 0x8b, 0xb83, 0xa, 0x8b, 0x5, 0x8b, 0xb85, 0xa, 0x8b, 0x3, 
       0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0xb8c, 
       0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0xb90, 0xa, 0x8c, 0x5, 
       0x8c, 0xb92, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 
       0xb97, 0xa, 0x8c, 0x3, 0x8c, 0x3, 0x8c, 0x5, 0x8c, 0xb9b, 0xa, 0x8c, 
       0x7, 0x8c, 0xb9d, 0xa, 0x8c, 0xc, 0x8c, 0xe, 0x8c, 0xba0, 0xb, 0x8c, 
       0x3, 0x8d, 0x3, 0x8d, 0x3, 0x8d, 0x5, 0x8d, 0xba5, 0xa, 0x8d, 0x3, 
       0x8d, 0x3, 0x8d, 0x3, 0x8e, 0x3, 0x8e, 0x7, 0x8e, 0xbab, 0xa, 0x8e, 
       0xc, 0x8e, 0xe, 0x8e, 0xbae, 0xb, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 0x5, 
       0x8e, 0xbb2, 0xa, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0xbb5, 0xa, 0x8e, 0x3, 
       0x8e, 0x5, 0x8e, 0xbb8, 0xa, 0x8e, 0x3, 0x8e, 0x5, 0x8e, 0xbbb, 0xa, 
       0x8e, 0x3, 0x8e, 0x5, 0x8e, 0xbbe, 0xa, 0x8e, 0x3, 0x8e, 0x3, 0x8e, 
       0x5, 0x8e, 0xbc2, 0xa, 0x8e, 0x3, 0x8f, 0x3, 0x8f, 0x3, 0x90, 0x3, 
       0x90, 0x3, 0x91, 0x3, 0x91, 0x3, 0x91, 0x3, 0x92, 0x3, 0x92, 0x3, 
       0x92, 0x3, 0x93, 0x3, 0x93, 0x3, 0x93, 0x5, 0x93, 0xbd1, 0xa, 0x93, 
       0x3, 0x94, 0x3, 0x94, 0x5, 0x94, 0xbd5, 0xa, 0x94, 0x3, 0x95, 0x3, 
       0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xbdb, 0xa, 0x95, 0x3, 0x95, 
       0x5, 0x95, 0xbde, 0xa, 0x95, 0x3, 0x95, 0x5, 0x95, 0xbe1, 0xa, 0x95, 
       0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xbe7, 0xa, 
       0x95, 0x3, 0x95, 0x3, 0x95, 0x3, 0x95, 0x5, 0x95, 0xbec, 0xa, 0x95, 
       0x7, 0x95, 0xbee, 0xa, 0x95, 0xc, 0x95, 0xe, 0x95, 0xbf1, 0xb, 0x95, 
       0x5, 0x95, 0xbf3, 0xa, 0x95, 0x3, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 
       0x96, 0x3, 0x96, 0x3, 0x96, 0x5, 0x96, 0xbfb, 0xa, 0x96, 0x5, 0x96, 
       0xbfd, 0xa, 0x96, 0x3, 0x96, 0x3, 0x96, 0x3, 0x97, 0x3, 0x97, 0x3, 
       0x97, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x3, 0x98, 0x7, 0x98, 0xc08, 
       0xa, 0x98, 0xc, 0x98, 0xe, 0x98, 0xc0b, 0xb, 0x98, 0x3, 0x99, 0x3, 
       0x99, 0x3, 0x99, 0x3, 0x99, 0x3, 0x9a, 0x3, 0x9a, 0x3, 0x9a, 0x3, 
       0x9a, 0x3, 0x9b, 0x5, 0x9b, 0xc16, 0xa, 0x9b, 0x3, 0x9b, 0x3, 0x9b, 
       0x3, 0x9b, 0x5, 0x9b, 0xc1b, 0xa, 0x9b, 0x3, 0x9b, 0x5, 0x9b, 0xc1e, 
       0xa, 0x9b, 0x3, 0x9b, 0x5, 0x9b, 0xc21, 0xa, 0x9b, 0x3, 0x9c, 0x3, 
       0x9c, 0x3, 0x9c, 0x5, 0x9c, 0xc26, 0xa, 0x9c, 0x3, 0x9d, 0x3, 0x9d, 
       0x3, 0x9e, 0x3, 0x9e, 0x5, 0x9e, 0xc2c, 0xa, 0x9e, 0x3, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 
       0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 0x9f, 0x3, 
       0x9f, 0x5, 0x9f, 0xc3c, 0xa, 0x9f, 0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa0, 
       0x3, 0xa0, 0x3, 0xa0, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 
       0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 
       0x3, 0xa1, 0x3, 0xa1, 0x3, 0xa1, 0x5, 0xa1, 0xc50, 0xa, 0xa1, 0x3, 
       0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 0xa2, 0x3, 
       0xa2, 0x5, 0xa2, 0xc59, 0xa, 0xa2, 0x3, 0xa3, 0x3, 0xa3, 0x5, 0xa3, 
       0xc5d, 0xa, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x3, 0xa3, 0x7, 0xa3, 0xc62, 
       0xa, 0xa3, 0xc, 0xa3, 0xe, 0xa3, 0xc65, 0xb, 0xa3, 0x3, 0xa4, 0x3, 
       0xa4, 0x5, 0xa4, 0xc69, 0xa, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 0x3, 0xa4, 
       0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x3, 0xa5, 0x5, 0xa5, 0xc72, 0xa, 
       0xa5, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x3, 0xa6, 0x5, 
       0xa6, 0xc79, 0xa, 0xa6, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 0x3, 0xa7, 
       0x3, 0xa8, 0x3, 0xa8, 0x3, 0xa9, 0x3, 0xa9, 0x3, 0xa9, 0x5, 0xa9, 
       0xc84, 0xa, 0xa9, 0x3, 0xaa, 0x3, 0xaa, 0x3, 0xaa, 0x7, 0xaa, 0xc89, 
       0xa, 0xaa, 0xc, 0xaa, 0xe, 0xaa, 0xc8c, 0xb, 0xaa, 0x3, 0xab, 0x3, 
       0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 0xab, 0x3, 
       0xab, 0x5, 0xab, 0xc96, 0xa, 0xab, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x3, 0xac, 0x5, 0xac, 0xc9d, 0xa, 0xac, 0x3, 0xac, 0x3, 
       0xac, 0x5, 0xac, 0xca1, 0xa, 0xac, 0x3, 0xac, 0x3, 0xac, 0x3, 0xac, 
       0x3, 0xac, 0x5, 0xac, 0xca7, 0xa, 0xac, 0x3, 0xad, 0x3, 0xad, 0x3, 
       0xad, 0x5, 0xad, 0xcac, 0xa, 0xad, 0x3, 0xae, 0x3, 0xae, 0x3, 0xae, 
       0x5, 0xae, 0xcb1, 0xa, 0xae, 0x3, 0xaf, 0x3, 0xaf, 0x5, 0xaf, 0xcb5, 
       0xa, 0xaf, 0x3, 0xaf, 0x3, 0xaf, 0x7, 0xaf, 0xcb9, 0xa, 0xaf, 0xc, 
       0xaf, 0xe, 0xaf, 0xcbc, 0xb, 0xaf, 0x3, 0xb0, 0x3, 0xb0, 0x3, 0xb0, 
       0x5, 0xb0, 0xcc1, 0xa, 0xb0, 0x5, 0xb0, 0xcc3, 0xa, 0xb0, 0x3, 0xb1, 
       0x5, 0xb1, 0xcc6, 0xa, 0xb1, 0x3, 0xb1, 0x3, 0xb1, 0x5, 0xb1, 0xcca, 
       0xa, 0xb1, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb2, 0x3, 0xb3, 0x3, 0xb3, 
       0x3, 0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xcd4, 0xa, 0xb3, 0x3, 
       0xb3, 0x3, 0xb3, 0x3, 0xb3, 0x5, 0xb3, 0xcd9, 0xa, 0xb3, 0x3, 0xb3, 
       0x7, 0xb3, 0xcdc, 0xa, 0xb3, 0xc, 0xb3, 0xe, 0xb3, 0xcdf, 0xb, 0xb3, 
       0x3, 0xb4, 0x3, 0xb4, 0x7, 0xb4, 0xce3, 0xa, 0xb4, 0xc, 0xb4, 0xe, 
       0xb4, 0xce6, 0xb, 0xb4, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 
       0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xcee, 0xa, 0xb5, 0x3, 0xb5, 0x3, 
       0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xcf6, 
       0xa, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x3, 0xb5, 0x5, 0xb5, 0xcfb, 0xa, 
       0xb5, 0x3, 0xb6, 0x3, 0xb6, 0x5, 0xb6, 0xcff, 0xa, 0xb6, 0x3, 0xb6, 
       0x3, 0xb6, 0x3, 0xb6, 0x3, 0xb6, 0x5, 0xb6, 0xd05, 0xa, 0xb6, 0x3, 
       0xb6, 0x5, 0xb6, 0xd08, 0xa, 0xb6, 0x3, 0xb7, 0x5, 0xb7, 0xd0b, 0xa, 
       0xb7, 0x3, 0xb7, 0x3, 0xb7, 0x5, 0xb7, 0xd0f, 0xa, 0xb7, 0x3, 0xb8, 
       0x3, 0xb8, 0x5, 0xb8, 0xd13, 0xa, 0xb8, 0x3, 0xb8, 0x3, 0xb8, 0x3, 
       0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x3, 0xb9, 0x5, 
       0xb9, 0xd1d, 0xa, 0xb9, 0x3, 0xba, 0x3, 0xba, 0x5, 0xba, 0xd21, 0xa, 
       0xba, 0x3, 0xba, 0x5, 0xba, 0xd24, 0xa, 0xba, 0x3, 0xba, 0x5, 0xba, 
       0xd27, 0xa, 0xba, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x5, 0xbb, 0xd2c, 
       0xa, 0xbb, 0x3, 0xbb, 0x3, 0xbb, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 
       0xd32, 0xa, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xd36, 0xa, 0xbc, 
       0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xd3c, 0xa, 
       0xbc, 0x3, 0xbc, 0x5, 0xbc, 0xd3f, 0xa, 0xbc, 0x5, 0xbc, 0xd41, 0xa, 
       0xbc, 0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbd, 0x5, 0xbd, 0xd46, 0xa, 0xbd, 
       0x3, 0xbd, 0x3, 0xbd, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 
       0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x3, 0xbe, 0x5, 0xbe, 0xd52, 0xa, 
       0xbe, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x3, 0xbf, 0x7, 
       0xbf, 0xd59, 0xa, 0xbf, 0xc, 0xbf, 0xe, 0xbf, 0xd5c, 0xb, 0xbf, 0x3, 
       0xbf, 0x3, 0xbf, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 0xd68, 0xa, 0xc0, 
       0x3, 0xc0, 0x5, 0xc0, 0xd6b, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 
       0xc0, 0x5, 0xc0, 0xd70, 0xa, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 0x3, 0xc0, 
       0x3, 0xc0, 0x3, 0xc0, 0x5, 0xc0, 0xd77, 0xa, 0xc0, 0x3, 0xc1, 0x3, 
       0xc1, 0x5, 0xc1, 0xd7b, 0xa, 0xc1, 0x3, 0xc1, 0x3, 0xc1, 0x5, 0xc1, 
       0xd7f, 0xa, 0xc1, 0x5, 0xc1, 0xd81, 0xa, 0xc1, 0x3, 0xc2, 0x3, 0xc2, 
       0x3, 0xc2, 0x3, 0xc2, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 0x3, 0xc3, 
       0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x3, 0xc4, 0x5, 0xc4, 0xd8f, 0xa, 
       0xc4, 0x3, 0xc5, 0x3, 0xc5, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x5, 
       0xc6, 0xd96, 0xa, 0xc6, 0x3, 0xc6, 0x3, 0xc6, 0x3, 0xc7, 0x3, 0xc7, 
       0x3, 0xc7, 0x7, 0xc7, 0xd9d, 0xa, 0xc7, 0xc, 0xc7, 0xe, 0xc7, 0xda0, 
       0xb, 0xc7, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0xda5, 0xa, 
       0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x3, 
       0xc8, 0x3, 0xc8, 0x5, 0xc8, 0xdae, 0xa, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 
       0x5, 0xc8, 0xdb2, 0xa, 0xc8, 0x3, 0xc8, 0x3, 0xc8, 0x5, 0xc8, 0xdb6, 
       0xa, 0xc8, 0x3, 0xc9, 0x3, 0xc9, 0x3, 0xca, 0x3, 0xca, 0x3, 0xcb, 
       0x3, 0xcb, 0x3, 0xcb, 0x3, 0xcb, 0x5, 0xcb, 0xdc0, 0xa, 0xcb, 0x5, 
       0xcb, 0xdc2, 0xa, 0xcb, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 0x3, 0xcc, 
       0x3, 0xcc, 0x3, 0xcc, 0x5, 0xcc, 0xdca, 0xa, 0xcc, 0x3, 0xcd, 0x3, 
       0xcd, 0x3, 0xcd, 0x7, 0xcd, 0xdcf, 0xa, 0xcd, 0xc, 0xcd, 0xe, 0xcd, 
       0xdd2, 0xb, 0xcd, 0x3, 0xce, 0x3, 0xce, 0x5, 0xce, 0xdd6, 0xa, 0xce, 
       0x3, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xdda, 0xa, 0xcf, 0x3, 0xcf, 0x3, 
       0xcf, 0x5, 0xcf, 0xdde, 0xa, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xde1, 0xa, 
       0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xde7, 
       0xa, 0xcf, 0x3, 0xcf, 0x5, 0xcf, 0xdea, 0xa, 0xcf, 0x3, 0xcf, 0x5, 
       0xcf, 0xded, 0xa, 0xcf, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 0x3, 0xd0, 
       0x5, 0xd0, 0xdf3, 0xa, 0xd0, 0x3, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 0x7, 
       0xd1, 0xdf8, 0xa, 0xd1, 0xc, 0xd1, 0xe, 0xd1, 0xdfb, 0xb, 0xd1, 0x3, 
       0xd1, 0x3, 0xd1, 0x5, 0xd1, 0xdff, 0xa, 0xd1, 0x3, 0xd1, 0x3, 0xd1, 
       0x5, 0xd1, 0xe03, 0xa, 0xd1, 0x3, 0xd1, 0x5, 0xd1, 0xe06, 0xa, 0xd1, 
       0x3, 0xd1, 0x5, 0xd1, 0xe09, 0xa, 0xd1, 0x3, 0xd1, 0x5, 0xd1, 0xe0c, 
       0xa, 0xd1, 0x5, 0xd1, 0xe0e, 0xa, 0xd1, 0x3, 0xd2, 0x3, 0xd2, 0x5, 
       0xd2, 0xe12, 0xa, 0xd2, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 0x3, 0xd3, 
       0x3, 0xd3, 0x3, 0xd3, 0x5, 0xd3, 0xe1a, 0xa, 0xd3, 0x3, 0xd4, 0x3, 
       0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x3, 0xd4, 0x5, 0xd4, 0xe22, 
       0xa, 0xd4, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 0x3, 0xd5, 
       0x5, 0xd5, 0xe29, 0xa, 0xd5, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 
       0xd6, 0x5, 0xd6, 0xe2f, 0xa, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 
       0xe33, 0xa, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xe38, 
       0xa, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xe3b, 0xa, 0xd6, 0x3, 0xd6, 0x5, 
       0xd6, 0xe3e, 0xa, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 0xe41, 0xa, 0xd6, 0x5, 
       0xd6, 0xe43, 0xa, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x3, 0xd6, 0x5, 0xd6, 
       0xe48, 0xa, 0xd6, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 
       0xd7, 0x7, 0xd7, 0xe4f, 0xa, 0xd7, 0xc, 0xd7, 0xe, 0xd7, 0xe52, 0xb, 
       0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 
       0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x3, 0xd7, 0x5, 0xd7, 0xe5e, 
       0xa, 0xd7, 0x5, 0xd7, 0xe60, 0xa, 0xd7, 0x3, 0xd8, 0x3, 0xd8, 0x5, 
       0xd8, 0xe64, 0xa, 0xd8, 0x3, 0xd8, 0x3, 0xd8, 0x3, 0xd9, 0x3, 0xd9, 
       0x5, 0xd9, 0xe6a, 0xa, 0xd9, 0x3, 0xd9, 0x5, 0xd9, 0xe6d, 0xa, 0xd9, 
       0x3, 0xd9, 0x5, 0xd9, 0xe70, 0xa, 0xd9, 0x3, 0xda, 0x3, 0xda, 0x3, 
       0xda, 0x3, 0xda, 0x5, 0xda, 0xe76, 0xa, 0xda, 0x3, 0xda, 0x3, 0xda, 
       0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0xe7d, 0xa, 0xda, 0x5, 
       0xda, 0xe7f, 0xa, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 0x3, 0xda, 
       0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0xe87, 0xa, 0xda, 0x3, 0xda, 0x3, 
       0xda, 0x3, 0xda, 0x3, 0xda, 0x5, 0xda, 0xe8d, 0xa, 0xda, 0x3, 0xdb, 
       0x3, 0xdb, 0x3, 0xdb, 0x5, 0xdb, 0xe92, 0xa, 0xdb, 0x3, 0xdb, 0x5, 
       0xdb, 0xe95, 0xa, 0xdb, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 0x3, 0xdc, 
       0x3, 0xdc, 0x5, 0xdc, 0xe9c, 0xa, 0xdc, 0x5, 0xdc, 0xe9e, 0xa, 0xdc, 
       0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 
       0x3, 0xdd, 0x5, 0xdd, 0xea7, 0xa, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 
       0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x7, 0xdd, 0xeae, 0xa, 0xdd, 0xc, 0xdd, 
       0xe, 0xdd, 0xeb1, 0xb, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 
       0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x5, 0xdd, 0xeb9, 0xa, 0xdd, 0x3, 0xdd, 
       0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x3, 0xdd, 0x5, 0xdd, 
       0xec1, 0xa, 0xdd, 0x3, 0xde, 0x3, 0xde, 0x5, 0xde, 0xec5, 0xa, 0xde, 
       0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x3, 0xde, 0x5, 0xde, 
       0xecc, 0xa, 0xde, 0x3, 0xde, 0x5, 0xde, 0xecf, 0xa, 0xde, 0x5, 0xde, 
       0xed1, 0xa, 0xde, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 0xdf, 0x3, 
       0xdf, 0x3, 0xdf, 0x5, 0xdf, 0xed9, 0xa, 0xdf, 0x3, 0xe0, 0x3, 0xe0, 
       0x3, 0xe0, 0x3, 0xe0, 0x5, 0xe0, 0xedf, 0xa, 0xe0, 0x3, 0xe0, 0x3, 
       0xe0, 0x3, 0xe0, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 0xe1, 0x3, 
       0xe1, 0x5, 0xe1, 0xee9, 0xa, 0xe1, 0x3, 0xe2, 0x3, 0xe2, 0x3, 0xe2, 
       0x7, 0xe2, 0xeee, 0xa, 0xe2, 0xc, 0xe2, 0xe, 0xe2, 0xef1, 0xb, 0xe2, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 0x3, 0xe3, 
       0x3, 0xe3, 0x5, 0xe3, 0xf3c, 0xa, 0xe3, 0x3, 0xe4, 0x3, 0xe4, 0x3, 
       0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 
       0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x3, 0xe4, 0x5, 0xe4, 0xf4a, 0xa, 0xe4, 
       0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x7, 0xe5, 0xf50, 0xa, 
       0xe5, 0xc, 0xe5, 0xe, 0xe5, 0xf53, 0xb, 0xe5, 0x5, 0xe5, 0xf55, 0xa, 
       0xe5, 0x3, 0xe5, 0x3, 0xe5, 0x3, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x3, 
       0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x7, 0xe6, 0xf5f, 0xa, 0xe6, 0xc, 0xe6, 
       0xe, 0xe6, 0xf62, 0xb, 0xe6, 0x3, 0xe6, 0x3, 0xe6, 0x5, 0xe6, 0xf66, 
       0xa, 0xe6, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x5, 0xe7, 
       0xf6c, 0xa, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 
       0xe7, 0x5, 0xe7, 0xf73, 0xa, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 
       0x3, 0xe7, 0x3, 0xe7, 0x5, 0xe7, 0xf7a, 0xa, 0xe7, 0x3, 0xe7, 0x3, 
       0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x5, 0xe7, 0xf81, 0xa, 0xe7, 
       0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x5, 0xe7, 
       0xf88, 0xa, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 
       0xe7, 0x5, 0xe7, 0xf8f, 0xa, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 0x3, 0xe7, 
       0x3, 0xe7, 0x3, 0xe7, 0x5, 0xe7, 0xf96, 0xa, 0xe7, 0x3, 0xe7, 0x5, 
       0xe7, 0xf99, 0xa, 0xe7, 0x3, 0xe8, 0x3, 0xe8, 0x3, 0xe8, 0x7, 0xe8, 
       0xf9e, 0xa, 0xe8, 0xc, 0xe8, 0xe, 0xe8, 0xfa1, 0xb, 0xe8, 0x3, 0xe9, 
       0x3, 0xe9, 0x3, 0xe9, 0x7, 0xe9, 0xfa6, 0xa, 0xe9, 0xc, 0xe9, 0xe, 
       0xe9, 0xfa9, 0xb, 0xe9, 0x3, 0xea, 0x3, 0xea, 0x3, 0xea, 0x7, 0xea, 
       0xfae, 0xa, 0xea, 0xc, 0xea, 0xe, 0xea, 0xfb1, 0xb, 0xea, 0x3, 0xeb, 
       0x3, 0xeb, 0x3, 0xec, 0x3, 0xec, 0x3, 0xec, 0x7, 0xec, 0xfb8, 0xa, 
       0xec, 0xc, 0xec, 0xe, 0xec, 0xfbb, 0xb, 0xec, 0x3, 0xed, 0x3, 0xed, 
       0x3, 0xed, 0x5, 0xed, 0xfc0, 0xa, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 
       0xed, 0xfc4, 0xa, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xfc8, 0xa, 
       0xed, 0x3, 0xed, 0x3, 0xed, 0x3, 0xed, 0x5, 0xed, 0xfcd, 0xa, 0xed, 
       0x3, 0xed, 0x5, 0xed, 0xfd0, 0xa, 0xed, 0x5, 0xed, 0xfd2, 0xa, 0xed, 
       0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 0x3, 0xee, 
       0x3, 0xee, 0x5, 0xee, 0xfdb, 0xa, 0xee, 0x3, 0xee, 0x3, 0xee, 0x7, 
       0xee, 0xfdf, 0xa, 0xee, 0xc, 0xee, 0xe, 0xee, 0xfe2, 0xb, 0xee, 0x3, 
       0xef, 0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 0xfe8, 0xa, 0xef, 
       0x3, 0xef, 0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 0xfed, 0xa, 0xef, 0x3, 
       0xef, 0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 0xff2, 0xa, 0xef, 0x3, 0xef, 
       0x3, 0xef, 0x3, 0xef, 0x5, 0xef, 0xff7, 0xa, 0xef, 0x3, 0xef, 0x5, 
       0xef, 0xffa, 0xa, 0xef, 0x3, 0xf0, 0x3, 0xf0, 0x3, 0xf0, 0x7, 0xf0, 
       0xfff, 0xa, 0xf0, 0xc, 0xf0, 0xe, 0xf0, 0x1002, 0xb, 0xf0, 0x3, 0xf1, 
       0x3, 0xf1, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf2, 0x3, 0xf3, 0x3, 0xf3, 
       0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x5, 0xf3, 0x100e, 0xa, 0xf3, 0x3, 
       0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x3, 0xf3, 0x5, 0xf3, 0x1014, 0xa, 0xf3, 
       0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x3, 0xf4, 0x5, 0xf4, 0x101a, 0xa, 
       0xf4, 0x3, 0xf5, 0x3, 0xf5, 0x3, 0xf5, 0x7, 0xf5, 0x101f, 0xa, 0xf5, 
       0xc, 0xf5, 0xe, 0xf5, 0x1022, 0xb, 0xf5, 0x3, 0xf6, 0x3, 0xf6, 0x3, 
       0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x5, 0xf6, 0x1029, 0xa, 0xf6, 0x3, 0xf6, 
       0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x5, 0xf6, 0x102f, 0xa, 0xf6, 0x3, 
       0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 
       0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x3, 0xf6, 0x5, 0xf6, 0x103b, 0xa, 0xf6, 
       0x5, 0xf6, 0x103d, 0xa, 0xf6, 0x3, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x3, 
       0xf7, 0x5, 0xf7, 0x1043, 0xa, 0xf7, 0x3, 0xf7, 0x3, 0xf7, 0x5, 0xf7, 
       0x1047, 0xa, 0xf7, 0x5, 0xf7, 0x1049, 0xa, 0xf7, 0x3, 0xf8, 0x3, 
       0xf8, 0x5, 0xf8, 0x104d, 0xa, 0xf8, 0x3, 0xf8, 0x3, 0xf8, 0x3, 0xf9, 
       0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 
       0x3, 0xf9, 0x3, 0xf9, 0x3, 0xf9, 0x5, 0xf9, 0x105b, 0xa, 0xf9, 0x3, 
       0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfa, 0x5, 0xfa, 0x1061, 0xa, 0xfa, 
       0x3, 0xfa, 0x3, 0xfa, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 
       0x5, 0xfb, 0x1069, 0xa, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 
       0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 
       0xfb, 0x5, 0xfb, 0x1075, 0xa, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x5, 0xfb, 
       0x1079, 0xa, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 
       0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 0xfb, 0x3, 
       0xfb, 0x3, 0xfb, 0x5, 0xfb, 0x1087, 0xa, 0xfb, 0x5, 0xfb, 0x1089, 
       0xa, 0xfb, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 
       0x5, 0xfc, 0x1090, 0xa, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x3, 0xfc, 0x3, 
       0xfc, 0x3, 0xfd, 0x3, 0xfd, 0x5, 0xfd, 0x1098, 0xa, 0xfd, 0x3, 0xfd, 
       0x5, 0xfd, 0x109b, 0xa, 0xfd, 0x3, 0xfd, 0x7, 0xfd, 0x109e, 0xa, 
       0xfd, 0xc, 0xfd, 0xe, 0xfd, 0x10a1, 0xb, 0xfd, 0x3, 0xfd, 0x5, 0xfd, 
       0x10a4, 0xa, 0xfd, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x3, 0xfe, 0x5, 
       0xfe, 0x10aa, 0xa, 0xfe, 0x3, 0xfe, 0x5, 0xfe, 0x10ad, 0xa, 0xfe, 
       0x3, 0xff, 0x3, 0xff, 0x3, 0xff, 0x5, 0xff, 0x10b2, 0xa, 0xff, 0x3, 
       0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 
       0x3, 0x100, 0x3, 0x100, 0x3, 0x100, 0x6, 0x100, 0x10bd, 0xa, 0x100, 
       0xd, 0x100, 0xe, 0x100, 0x10be, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 
       0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 
       0x101, 0x3, 0x101, 0x5, 0x101, 0x10cb, 0xa, 0x101, 0x3, 0x101, 0x3, 
       0x101, 0x3, 0x101, 0x5, 0x101, 0x10d0, 0xa, 0x101, 0x3, 0x101, 0x3, 
       0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x5, 0x101, 
       0x10d8, 0xa, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 0x3, 0x101, 
       0x5, 0x101, 0x10de, 0xa, 0x101, 0x5, 0x101, 0x10e0, 0xa, 0x101, 0x5, 
       0x101, 0x10e2, 0xa, 0x101, 0x3, 0x102, 0x3, 0x102, 0x3, 0x102, 0x3, 
       0x102, 0x5, 0x102, 0x10e8, 0xa, 0x102, 0x3, 0x102, 0x3, 0x102, 0x3, 
       0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x3, 0x103, 0x5, 0x103, 0x10f4, 0xa, 0x103, 0x3, 0x103, 
       0x3, 0x103, 0x3, 0x103, 0x5, 0x103, 0x10f9, 0xa, 0x103, 0x5, 0x103, 
       0x10fb, 0xa, 0x103, 0x3, 0x103, 0x3, 0x103, 0x5, 0x103, 0x10ff, 0xa, 
       0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x5, 0x103, 
       0x1105, 0xa, 0x103, 0x3, 0x103, 0x5, 0x103, 0x1108, 0xa, 0x103, 0x3, 
       0x103, 0x5, 0x103, 0x110b, 0xa, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 
       0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 0x3, 0x103, 
       0x5, 0x103, 0x1115, 0xa, 0x103, 0x5, 0x103, 0x1117, 0xa, 0x103, 0x3, 
       0x104, 0x3, 0x104, 0x3, 0x104, 0x3, 0x104, 0x5, 0x104, 0x111d, 0xa, 
       0x104, 0x3, 0x105, 0x3, 0x105, 0x3, 0x105, 0x6, 0x105, 0x1122, 0xa, 
       0x105, 0xd, 0x105, 0xe, 0x105, 0x1123, 0x3, 0x105, 0x3, 0x105, 0x3, 
       0x105, 0x3, 0x105, 0x5, 0x105, 0x112a, 0xa, 0x105, 0x3, 0x106, 0x3, 
       0x106, 0x3, 0x106, 0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 0x3, 0x107, 
       0x3, 0x107, 0x5, 0x107, 0x1134, 0xa, 0x107, 0x3, 0x107, 0x3, 0x107, 
       0x5, 0x107, 0x1138, 0xa, 0x107, 0x3, 0x108, 0x3, 0x108, 0x3, 0x108, 
       0x5, 0x108, 0x113d, 0xa, 0x108, 0x3, 0x109, 0x3, 0x109, 0x3, 0x109, 
       0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 
       0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x3, 0x10a, 0x7, 0x10a, 
       0x114c, 0xa, 0x10a, 0xc, 0x10a, 0xe, 0x10a, 0x114f, 0xb, 0x10a, 0x3, 
       0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 
       0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x3, 0x10b, 0x5, 0x10b, 0x115e, 0xa, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x3, 0x10b, 0x5, 0x10b, 0x1163, 0xa, 0x10b, 0x3, 0x10b, 0x3, 
       0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x5, 0x10b, 
       0x116b, 0xa, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 0x3, 0x10b, 
       0x3, 0x10b, 0x3, 0x10b, 0x5, 0x10b, 0x1173, 0xa, 0x10b, 0x3, 0x10c, 
       0x3, 0x10c, 0x3, 0x10c, 0x5, 0x10c, 0x1178, 0xa, 0x10c, 0x3, 0x10c, 
       0x3, 0x10c, 0x3, 0x10c, 0x3, 0x10c, 0x5, 0x10c, 0x117e, 0xa, 0x10c, 
       0x3, 0x10c, 0x5, 0x10c, 0x1181, 0xa, 0x10c, 0x5, 0x10c, 0x1183, 0xa, 
       0x10c, 0x3, 0x10d, 0x3, 0x10d, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 
       0x3, 0x10e, 0x5, 0x10e, 0x118b, 0xa, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 
       0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 
       0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 
       0x5, 0x10e, 0x119a, 0xa, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x5, 0x10e, 
       0x119e, 0xa, 0x10e, 0x3, 0x10e, 0x3, 0x10e, 0x5, 0x10e, 0x11a2, 0xa, 
       0x10e, 0x3, 0x10f, 0x3, 0x10f, 0x3, 0x10f, 0x7, 0x10f, 0x11a7, 0xa, 
       0x10f, 0xc, 0x10f, 0xe, 0x10f, 0x11aa, 0xb, 0x10f, 0x3, 0x110, 0x3, 
       0x110, 0x3, 0x110, 0x5, 0x110, 0x11af, 0xa, 0x110, 0x3, 0x110, 0x3, 
       0x110, 0x3, 0x110, 0x3, 0x110, 0x5, 0x110, 0x11b5, 0xa, 0x110, 0x5, 
       0x110, 0x11b7, 0xa, 0x110, 0x3, 0x110, 0x3, 0x110, 0x5, 0x110, 0x11bb, 
       0xa, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 
       0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x5, 0x110, 
       0x11c6, 0xa, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 
       0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x5, 0x110, 0x11d0, 
       0xa, 0x110, 0x3, 0x110, 0x3, 0x110, 0x3, 0x110, 0x5, 0x110, 0x11d5, 
       0xa, 0x110, 0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 0x11da, 
       0xa, 0x111, 0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x5, 0x111, 0x11df, 
       0xa, 0x111, 0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x3, 0x111, 0x3, 
       0x111, 0x3, 0x111, 0x5, 0x111, 0x11e7, 0xa, 0x111, 0x3, 0x112, 0x3, 
       0x112, 0x5, 0x112, 0x11eb, 0xa, 0x112, 0x3, 0x112, 0x7, 0x112, 0x11ee, 
       0xa, 0x112, 0xc, 0x112, 0xe, 0x112, 0x11f1, 0xb, 0x112, 0x3, 0x113, 
       0x3, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 0x113, 0x3, 0x113, 0x5, 
       0x113, 0x11f9, 0xa, 0x113, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 
       0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 0x3, 0x114, 
       0x3, 0x114, 0x5, 0x114, 0x1205, 0xa, 0x114, 0x3, 0x115, 0x3, 0x115, 
       0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 
       0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x5, 0x115, 
       0x1213, 0xa, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 
       0x3, 0x115, 0x3, 0x115, 0x3, 0x115, 0x5, 0x115, 0x121c, 0xa, 0x115, 
       0x5, 0x115, 0x121e, 0xa, 0x115, 0x3, 0x116, 0x3, 0x116, 0x3, 0x116, 
       0x7, 0x116, 0x1223, 0xa, 0x116, 0xc, 0x116, 0xe, 0x116, 0x1226, 0xb, 
       0x116, 0x3, 0x117, 0x3, 0x117, 0x3, 0x117, 0x5, 0x117, 0x122b, 0xa, 
       0x117, 0x3, 0x118, 0x3, 0x118, 0x5, 0x118, 0x122f, 0xa, 0x118, 0x3, 
       0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 
       0x7, 0x118, 0x1237, 0xa, 0x118, 0xc, 0x118, 0xe, 0x118, 0x123a, 0xb, 
       0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x5, 0x118, 
       0x1240, 0xa, 0x118, 0x3, 0x118, 0x3, 0x118, 0x5, 0x118, 0x1244, 0xa, 
       0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x5, 0x118, 
       0x124a, 0xa, 0x118, 0x3, 0x118, 0x3, 0x118, 0x5, 0x118, 0x124e, 0xa, 
       0x118, 0x3, 0x118, 0x3, 0x118, 0x3, 0x118, 0x7, 0x118, 0x1253, 0xa, 
       0x118, 0xc, 0x118, 0xe, 0x118, 0x1256, 0xb, 0x118, 0x5, 0x118, 0x1258, 
       0xa, 0x118, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 
       0x119, 0x3, 0x119, 0x3, 0x119, 0x5, 0x119, 0x1261, 0xa, 0x119, 0x3, 
       0x119, 0x3, 0x119, 0x3, 0x119, 0x3, 0x119, 0x5, 0x119, 0x1267, 0xa, 
       0x119, 0x3, 0x11a, 0x3, 0x11a, 0x3, 0x11a, 0x5, 0x11a, 0x126c, 0xa, 
       0x11a, 0x3, 0x11b, 0x3, 0x11b, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 
       0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 
       0x3, 0x11c, 0x3, 0x11c, 0x3, 0x11c, 0x7, 0x11c, 0x1281, 0xa, 0x11c, 
       0xc, 0x11c, 0xe, 0x11c, 0x1284, 0xb, 0x11c, 0x5, 0x11c, 0x1286, 0xa, 
       0x11c, 0x3, 0x11d, 0x3, 0x11d, 0x5, 0x11d, 0x128a, 0xa, 0x11d, 0x3, 
       0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x5, 0x11d, 
       0x1291, 0xa, 0x11d, 0x5, 0x11d, 0x1293, 0xa, 0x11d, 0x3, 0x11d, 0x5, 
       0x11d, 0x1296, 0xa, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x3, 0x11d, 0x5, 
       0x11d, 0x129b, 0xa, 0x11d, 0x5, 0x11d, 0x129d, 0xa, 0x11d, 0x3, 0x11e, 
       0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 
       0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 
       0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 0x11e, 0x3, 
       0x11e, 0x3, 0x11e, 0x5, 0x11e, 0x12b2, 0xa, 0x11e, 0x3, 0x11e, 0x3, 
       0x11e, 0x5, 0x11e, 0x12b6, 0xa, 0x11e, 0x5, 0x11e, 0x12b8, 0xa, 0x11e, 
       0x3, 0x11f, 0x3, 0x11f, 0x5, 0x11f, 0x12bc, 0xa, 0x11f, 0x3, 0x11f, 
       0x3, 0x11f, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 0x3, 0x120, 0x3, 
       0x121, 0x3, 0x121, 0x3, 0x121, 0x3, 0x121, 0x5, 0x121, 0x12c8, 0xa, 
       0x121, 0x3, 0x122, 0x3, 0x122, 0x3, 0x122, 0x7, 0x122, 0x12cd, 0xa, 
       0x122, 0xc, 0x122, 0xe, 0x122, 0x12d0, 0xb, 0x122, 0x3, 0x123, 0x3, 
       0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x3, 0x123, 0x5, 0x123, 
       0x12d8, 0xa, 0x123, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x5, 0x124, 0x12df, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 
       0x12e2, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x12e6, 0xa, 
       0x124, 0x3, 0x124, 0x5, 0x124, 0x12e9, 0xa, 0x124, 0x3, 0x124, 0x5, 
       0x124, 0x12ec, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x12f0, 
       0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 0x12f3, 0xa, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x5, 0x124, 0x12f7, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 
       0x12fa, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 
       0x12ff, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1302, 0xa, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1307, 0xa, 0x124, 0x3, 
       0x124, 0x5, 0x124, 0x130a, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x5, 0x124, 0x1310, 0xa, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x5, 0x124, 0x1314, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x5, 0x124, 0x131a, 0xa, 0x124, 0x3, 0x124, 0x5, 
       0x124, 0x131d, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1326, 0xa, 
       0x124, 0x5, 0x124, 0x1328, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x5, 0x124, 0x132e, 0xa, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x5, 0x124, 0x1332, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1335, 
       0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1338, 0xa, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x5, 0x124, 0x133c, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1342, 0xa, 0x124, 0x3, 0x124, 
       0x5, 0x124, 0x1345, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1348, 0xa, 
       0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1352, 0xa, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1356, 0xa, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x7, 0x124, 0x135d, 
       0xa, 0x124, 0xc, 0x124, 0xe, 0x124, 0x1360, 0xb, 0x124, 0x5, 0x124, 
       0x1362, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 
       0x1367, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 0x136a, 0xa, 0x124, 0x3, 
       0x124, 0x5, 0x124, 0x136d, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 
       0x124, 0x1371, 0xa, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1374, 0xa, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1379, 0xa, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x137d, 0xa, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 
       0x124, 0x1385, 0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x1392, 0xa, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 
       0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x13a4, 
       0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x13a9, 
       0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x5, 0x124, 0x13ae, 
       0xa, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 0x124, 0x3, 
       0x124, 0x3, 0x124, 0x5, 0x124, 0x13b6, 0xa, 0x124, 0x3, 0x125, 0x3, 
       0x125, 0x3, 0x125, 0x3, 0x125, 0x5, 0x125, 0x13bc, 0xa, 0x125, 0x5, 
       0x125, 0x13be, 0xa, 0x125, 0x3, 0x126, 0x3, 0x126, 0x5, 0x126, 0x13c2, 
       0xa, 0x126, 0x3, 0x126, 0x5, 0x126, 0x13c5, 0xa, 0x126, 0x3, 0x127, 
       0x3, 0x127, 0x3, 0x128, 0x3, 0x128, 0x3, 0x128, 0x3, 0x129, 0x3, 
       0x129, 0x3, 0x129, 0x3, 0x129, 0x3, 0x129, 0x3, 0x129, 0x3, 0x129, 
       0x5, 0x129, 0x13d3, 0xa, 0x129, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 
       0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x5, 
       0x12a, 0x13dd, 0xa, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x5, 0x12a, 0x13e1, 
       0xa, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x7, 
       0x12a, 0x13e7, 0xa, 0x12a, 0xc, 0x12a, 0xe, 0x12a, 0x13ea, 0xb, 0x12a, 
       0x5, 0x12a, 0x13ec, 0xa, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x5, 0x12a, 
       0x13f0, 0xa, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 
       0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x3, 0x12a, 0x5, 0x12a, 0x13fa, 
       0xa, 0x12a, 0x3, 0x12b, 0x3, 0x12b, 0x5, 0x12b, 0x13fe, 0xa, 0x12b, 
       0x3, 0x12c, 0x3, 0x12c, 0x3, 0x12c, 0x7, 0x12c, 0x1403, 0xa, 0x12c, 
       0xc, 0x12c, 0xe, 0x12c, 0x1406, 0xb, 0x12c, 0x3, 0x12d, 0x3, 0x12d, 
       0x5, 0x12d, 0x140a, 0xa, 0x12d, 0x3, 0x12e, 0x3, 0x12e, 0x3, 0x12e, 
       0x3, 0x12e, 0x3, 0x12e, 0x3, 0x12e, 0x5, 0x12e, 0x1412, 0xa, 0x12e, 
       0x3, 0x12f, 0x3, 0x12f, 0x3, 0x12f, 0x5, 0x12f, 0x1417, 0xa, 0x12f, 
       0x3, 0x12f, 0x3, 0x12f, 0x3, 0x130, 0x3, 0x130, 0x5, 0x130, 0x141d, 
       0xa, 0x130, 0x3, 0x131, 0x3, 0x131, 0x3, 0x131, 0x7, 0x131, 0x1422, 
       0xa, 0x131, 0xc, 0x131, 0xe, 0x131, 0x1425, 0xb, 0x131, 0x3, 0x132, 
       0x3, 0x132, 0x5, 0x132, 0x1429, 0xa, 0x132, 0x3, 0x132, 0x3, 0x132, 
       0x3, 0x132, 0x3, 0x132, 0x5, 0x132, 0x142f, 0xa, 0x132, 0x3, 0x132, 
       0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x3, 0x132, 0x5, 0x132, 0x1436, 
       0xa, 0x132, 0x3, 0x133, 0x3, 0x133, 0x3, 0x134, 0x3, 0x134, 0x3, 
       0x134, 0x3, 0x134, 0x3, 0x134, 0x3, 0x134, 0x5, 0x134, 0x1440, 0xa, 
       0x134, 0x5, 0x134, 0x1442, 0xa, 0x134, 0x3, 0x135, 0x3, 0x135, 0x3, 
       0x135, 0x3, 0x135, 0x3, 0x135, 0x3, 0x135, 0x5, 0x135, 0x144a, 0xa, 
       0x135, 0x3, 0x136, 0x3, 0x136, 0x3, 0x136, 0x5, 0x136, 0x144f, 0xa, 
       0x136, 0x3, 0x136, 0x3, 0x136, 0x5, 0x136, 0x1453, 0xa, 0x136, 0x3, 
       0x136, 0x5, 0x136, 0x1456, 0xa, 0x136, 0x3, 0x137, 0x3, 0x137, 0x3, 
       0x137, 0x7, 0x137, 0x145b, 0xa, 0x137, 0xc, 0x137, 0xe, 0x137, 0x145e, 
       0xb, 0x137, 0x3, 0x138, 0x3, 0x138, 0x5, 0x138, 0x1462, 0xa, 0x138, 
       0x3, 0x138, 0x3, 0x138, 0x5, 0x138, 0x1466, 0xa, 0x138, 0x3, 0x139, 
       0x3, 0x139, 0x3, 0x139, 0x3, 0x139, 0x3, 0x139, 0x3, 0x13a, 0x3, 
       0x13a, 0x3, 0x13a, 0x3, 0x13a, 0x5, 0x13a, 0x1471, 0xa, 0x13a, 0x3, 
       0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 
       0x5, 0x13b, 0x1479, 0xa, 0x13b, 0x3, 0x13b, 0x3, 0x13b, 0x5, 0x13b, 
       0x147d, 0xa, 0x13b, 0x3, 0x13b, 0x5, 0x13b, 0x1480, 0xa, 0x13b, 0x3, 
       0x13b, 0x5, 0x13b, 0x1483, 0xa, 0x13b, 0x3, 0x13c, 0x3, 0x13c, 0x5, 
       0x13c, 0x1487, 0xa, 0x13c, 0x3, 0x13c, 0x3, 0x13c, 0x5, 0x13c, 0x148b, 
       0xa, 0x13c, 0x3, 0x13c, 0x7, 0x13c, 0x148e, 0xa, 0x13c, 0xc, 0x13c, 
       0xe, 0x13c, 0x1491, 0xb, 0x13c, 0x3, 0x13d, 0x3, 0x13d, 0x3, 0x13d, 
       0x5, 0x13d, 0x1496, 0xa, 0x13d, 0x3, 0x13e, 0x3, 0x13e, 0x5, 0x13e, 
       0x149a, 0xa, 0x13e, 0x3, 0x13e, 0x3, 0x13e, 0x3, 0x13f, 0x3, 0x13f, 
       0x3, 0x140, 0x3, 0x140, 0x3, 0x140, 0x3, 0x140, 0x3, 0x140, 0x5, 
       0x140, 0x14a5, 0xa, 0x140, 0x3, 0x140, 0x5, 0x140, 0x14a8, 0xa, 0x140, 
       0x3, 0x140, 0x5, 0x140, 0x14ab, 0xa, 0x140, 0x3, 0x140, 0x5, 0x140, 
       0x14ae, 0xa, 0x140, 0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 0x3, 0x141, 
       0x3, 0x141, 0x3, 0x141, 0x5, 0x141, 0x14b6, 0xa, 0x141, 0x3, 0x142, 
       0x3, 0x142, 0x5, 0x142, 0x14ba, 0xa, 0x142, 0x3, 0x142, 0x7, 0x142, 
       0x14bd, 0xa, 0x142, 0xc, 0x142, 0xe, 0x142, 0x14c0, 0xb, 0x142, 0x3, 
       0x143, 0x3, 0x143, 0x3, 0x143, 0x3, 0x143, 0x3, 0x143, 0x5, 0x143, 
       0x14c7, 0xa, 0x143, 0x3, 0x144, 0x3, 0x144, 0x3, 0x144, 0x3, 0x144, 
       0x3, 0x144, 0x3, 0x144, 0x5, 0x144, 0x14cf, 0xa, 0x144, 0x3, 0x145, 
       0x3, 0x145, 0x3, 0x145, 0x3, 0x145, 0x5, 0x145, 0x14d5, 0xa, 0x145, 
       0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 
       0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x146, 0x5, 0x146, 0x14e0, 0xa, 
       0x146, 0x3, 0x146, 0x3, 0x146, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 
       0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x5, 0x147, 0x14ea, 0xa, 0x147, 
       0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x3, 0x147, 0x5, 0x147, 0x14f0, 
       0xa, 0x147, 0x3, 0x148, 0x3, 0x148, 0x3, 0x148, 0x3, 0x149, 0x3, 
       0x149, 0x3, 0x149, 0x3, 0x14a, 0x3, 0x14a, 0x3, 0x14b, 0x3, 0x14b, 
       0x3, 0x14b, 0x3, 0x14b, 0x5, 0x14b, 0x14fe, 0xa, 0x14b, 0x3, 0x14b, 
       0x5, 0x14b, 0x1501, 0xa, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x5, 0x14b, 
       0x1505, 0xa, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 
       0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x3, 0x14b, 0x7, 
       0x14b, 0x1510, 0xa, 0x14b, 0xc, 0x14b, 0xe, 0x14b, 0x1513, 0xb, 0x14b, 
       0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x5, 0x14c, 0x151b, 0xa, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 
       0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 0x3, 0x14c, 
       0x3, 0x14c, 0x3, 0x14c, 0x7, 0x14c, 0x1527, 0xa, 0x14c, 0xc, 0x14c, 
       0xe, 0x14c, 0x152a, 0xb, 0x14c, 0x3, 0x14d, 0x3, 0x14d, 0x3, 0x14e, 
       0x3, 0x14e, 0x5, 0x14e, 0x1530, 0xa, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x1536, 0xa, 0x14e, 0x3, 0x14e, 
       0x3, 0x14e, 0x3, 0x14e, 0x3, 0x14e, 0x5, 0x14e, 0x153c, 0xa, 0x14e, 
       0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 
       0x14f, 0x5, 0x14f, 0x1544, 0xa, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 
       0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 
       0x3, 0x14f, 0x5, 0x14f, 0x154f, 0xa, 0x14f, 0x3, 0x14f, 0x3, 0x14f, 
       0x5, 0x14f, 0x1553, 0xa, 0x14f, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 
       0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 
       0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 0x3, 0x150, 
       0x3, 0x150, 0x3, 0x150, 0x7, 0x150, 0x1570, 0xa, 0x150, 0xc, 0x150, 
       0xe, 0x150, 0x1573, 0xb, 0x150, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x5, 0x151, 0x1579, 0xa, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x5, 0x151, 0x158a, 0xa, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x5, 0x151, 0x1591, 
       0xa, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x5, 0x151, 0x159f, 0xa, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x5, 0x151, 0x15ab, 0xa, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x5, 0x151, 
       0x15b1, 0xa, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x6, 0x151, 
       0x15b6, 0xa, 0x151, 0xd, 0x151, 0xe, 0x151, 0x15b7, 0x3, 0x151, 0x5, 
       0x151, 0x15bb, 0xa, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 
       0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x5, 0x151, 0x15dd, 0xa, 0x151, 0x3, 0x151, 0x3, 0x151, 
       0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x3, 0x151, 0x7, 0x151, 0x15e5, 
       0xa, 0x151, 0xc, 0x151, 0xe, 0x151, 0x15e8, 0xb, 0x151, 0x3, 0x152, 
       0x3, 0x152, 0x3, 0x152, 0x3, 0x153, 0x3, 0x153, 0x3, 0x153, 0x3, 
       0x153, 0x3, 0x153, 0x3, 0x153, 0x5, 0x153, 0x15f3, 0xa, 0x153, 0x3, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x15f8, 0xa, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x15fe, 0xa, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 
       0x3, 0x154, 0x5, 0x154, 0x1606, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 
       0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x160d, 0xa, 0x154, 
       0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1613, 
       0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1618, 
       0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 
       0x154, 0x161e, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 
       0x154, 0x1623, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 
       0x154, 0x1628, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 
       0x154, 0x5, 0x154, 0x162e, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 
       0x154, 0x5, 0x154, 0x1633, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x5, 0x154, 0x1639, 0xa, 0x154, 0x3, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 
       0x1641, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 
       0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1649, 0xa, 0x154, 0x3, 0x154, 
       0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 
       0x154, 0x1651, 0xa, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1659, 0xa, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x165e, 0xa, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1664, 0xa, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x1669, 0xa, 
       0x154, 0x3, 0x154, 0x3, 0x154, 0x5, 0x154, 0x166d, 0xa, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x5, 0x154, 0x1671, 0xa, 0x154, 0x3, 0x154, 0x3, 
       0x154, 0x3, 0x154, 0x5, 0x154, 0x1676, 0xa, 0x154, 0x5, 0x154, 0x1678, 
       0xa, 0x154, 0x3, 0x155, 0x3, 0x155, 0x3, 0x155, 0x3, 0x155, 0x3, 
       0x155, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 
       0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 
       0x156, 0x3, 0x156, 0x5, 0x156, 0x168b, 0xa, 0x156, 0x3, 0x156, 0x3, 
       0x156, 0x5, 0x156, 0x168f, 0xa, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 
       0x156, 0x3, 0x156, 0x3, 0x156, 0x5, 0x156, 0x1696, 0xa, 0x156, 0x3, 
       0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 
       0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x3, 0x156, 0x5, 0x156, 0x16a2, 
       0xa, 0x156, 0x3, 0x156, 0x5, 0x156, 0x16a5, 0xa, 0x156, 0x3, 0x156, 
       0x3, 0x156, 0x5, 0x156, 0x16a9, 0xa, 0x156, 0x3, 0x157, 0x3, 0x157, 
       0x3, 0x157, 0x5, 0x157, 0x16ae, 0xa, 0x157, 0x3, 0x158, 0x3, 0x158, 
       0x3, 0x158, 0x5, 0x158, 0x16b3, 0xa, 0x158, 0x3, 0x158, 0x3, 0x158, 
       0x5, 0x158, 0x16b7, 0xa, 0x158, 0x3, 0x159, 0x3, 0x159, 0x3, 0x159, 
       0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x5, 
       0x15a, 0x16c1, 0xa, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 
       0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x3, 0x15a, 0x5, 0x15a, 0x16ca, 0xa, 
       0x15a, 0x5, 0x15a, 0x16cc, 0xa, 0x15a, 0x3, 0x15b, 0x5, 0x15b, 0x16cf, 
       0xa, 0x15b, 0x3, 0x15b, 0x3, 0x15b, 0x3, 0x15c, 0x3, 0x15c, 0x3, 
       0x15c, 0x3, 0x15c, 0x3, 0x15c, 0x5, 0x15c, 0x16d8, 0xa, 0x15c, 0x3, 
       0x15d, 0x3, 0x15d, 0x3, 0x15d, 0x7, 0x15d, 0x16dd, 0xa, 0x15d, 0xc, 
       0x15d, 0xe, 0x15d, 0x16e0, 0xb, 0x15d, 0x3, 0x15e, 0x3, 0x15e, 0x3, 
       0x15e, 0x3, 0x15e, 0x3, 0x15e, 0x3, 0x15e, 0x3, 0x15e, 0x3, 0x15e, 
       0x3, 0x15e, 0x3, 0x15e, 0x5, 0x15e, 0x16ec, 0xa, 0x15e, 0x3, 0x15e, 
       0x3, 0x15e, 0x3, 0x15e, 0x5, 0x15e, 0x16f1, 0xa, 0x15e, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x16f8, 
       0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 
       0x15f, 0x16fe, 0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x6, 0x15f, 0x1716, 0xa, 0x15f, 0xd, 0x15f, 
       0xe, 0x15f, 0x1717, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x1737, 0xa, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x174b, 0xa, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x1751, 0xa, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x1755, 0xa, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x1770, 0xa, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x177c, 0xa, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x5, 0x15f, 0x1789, 0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 0x15f, 
       0x178d, 0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x1791, 0xa, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x5, 0x15f, 
       0x17ad, 0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x5, 0x15f, 0x17e5, 0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x5, 0x15f, 0x17f0, 0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x5, 0x15f, 0x17f4, 0xa, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 
       0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x1800, 0xa, 0x15f, 0x3, 0x15f, 0x3, 
       0x15f, 0x3, 0x15f, 0x5, 0x15f, 0x1805, 0xa, 0x15f, 0x3, 0x160, 0x3, 
       0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 
       0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x5, 0x160, 0x1812, 
       0xa, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 
       0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 
       0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 0x160, 0x3, 
       0x160, 0x3, 0x160, 0x3, 0x160, 0x5, 0x160, 0x1826, 0xa, 0x160, 0x3, 
       0x161, 0x3, 0x161, 0x5, 0x161, 0x182a, 0xa, 0x161, 0x3, 0x161, 0x3, 
       0x161, 0x3, 0x162, 0x3, 0x162, 0x3, 0x162, 0x3, 0x163, 0x3, 0x163, 
       0x3, 0x163, 0x3, 0x163, 0x3, 0x163, 0x3, 0x163, 0x3, 0x163, 0x3, 
       0x163, 0x7, 0x163, 0x1839, 0xa, 0x163, 0xc, 0x163, 0xe, 0x163, 0x183c, 
       0xb, 0x163, 0x5, 0x163, 0x183e, 0xa, 0x163, 0x3, 0x164, 0x3, 0x164, 
       0x3, 0x164, 0x5, 0x164, 0x1843, 0xa, 0x164, 0x3, 0x164, 0x5, 0x164, 
       0x1846, 0xa, 0x164, 0x3, 0x165, 0x3, 0x165, 0x3, 0x166, 0x3, 0x166, 
       0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 0x5, 0x166, 0x184f, 0xa, 0x166, 
       0x3, 0x166, 0x3, 0x166, 0x5, 0x166, 0x1853, 0xa, 0x166, 0x3, 0x166, 
       0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 0x5, 0x166, 0x1859, 0xa, 0x166, 
       0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 0x3, 0x166, 0x5, 0x166, 0x185f, 
       0xa, 0x166, 0x3, 0x166, 0x3, 0x166, 0x5, 0x166, 0x1863, 0xa, 0x166, 
       0x3, 0x166, 0x3, 0x166, 0x3, 0x167, 0x3, 0x167, 0x3, 0x167, 0x3, 
       0x167, 0x3, 0x167, 0x3, 0x167, 0x3, 0x167, 0x5, 0x167, 0x186e, 0xa, 
       0x167, 0x3, 0x167, 0x3, 0x167, 0x3, 0x167, 0x3, 0x167, 0x5, 0x167, 
       0x1874, 0xa, 0x167, 0x5, 0x167, 0x1876, 0xa, 0x167, 0x3, 0x167, 0x3, 
       0x167, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x5, 0x168, 0x187d, 0xa, 
       0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 0x3, 0x168, 
       0x5, 0x168, 0x1884, 0xa, 0x168, 0x3, 0x168, 0x3, 0x168, 0x5, 0x168, 
       0x1888, 0xa, 0x168, 0x3, 0x169, 0x3, 0x169, 0x3, 0x169, 0x7, 0x169, 
       0x188d, 0xa, 0x169, 0xc, 0x169, 0xe, 0x169, 0x1890, 0xb, 0x169, 0x3, 
       0x16a, 0x3, 0x16a, 0x5, 0x16a, 0x1894, 0xa, 0x16a, 0x3, 0x16b, 0x3, 
       0x16b, 0x3, 0x16b, 0x5, 0x16b, 0x1899, 0xa, 0x16b, 0x3, 0x16b, 0x5, 
       0x16b, 0x189c, 0xa, 0x16b, 0x3, 0x16c, 0x3, 0x16c, 0x3, 0x16c, 0x5, 
       0x16c, 0x18a1, 0xa, 0x16c, 0x3, 0x16d, 0x3, 0x16d, 0x5, 0x16d, 0x18a5, 
       0xa, 0x16d, 0x3, 0x16d, 0x3, 0x16d, 0x5, 0x16d, 0x18a9, 0xa, 0x16d, 
       0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x5, 0x16e, 0x18ae, 0xa, 0x16e, 
       0x3, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x5, 0x16e, 0x18b3, 0xa, 0x16e, 
       0x5, 0x16e, 0x18b5, 0xa, 0x16e, 0x3, 0x16e, 0x3, 0x16e, 0x5, 0x16e, 
       0x18b9, 0xa, 0x16e, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x16f, 0x3, 0x170, 
       0x3, 0x170, 0x3, 0x170, 0x3, 0x171, 0x3, 0x171, 0x3, 0x171, 0x3, 
       0x172, 0x3, 0x172, 0x5, 0x172, 0x18c6, 0xa, 0x172, 0x3, 0x172, 0x3, 
       0x172, 0x5, 0x172, 0x18ca, 0xa, 0x172, 0x3, 0x172, 0x5, 0x172, 0x18cd, 
       0xa, 0x172, 0x3, 0x172, 0x3, 0x172, 0x5, 0x172, 0x18d1, 0xa, 0x172, 
       0x3, 0x172, 0x3, 0x172, 0x5, 0x172, 0x18d5, 0xa, 0x172, 0x3, 0x172, 
       0x3, 0x172, 0x5, 0x172, 0x18d9, 0xa, 0x172, 0x3, 0x172, 0x3, 0x172, 
       0x3, 0x172, 0x5, 0x172, 0x18de, 0xa, 0x172, 0x3, 0x172, 0x3, 0x172, 
       0x5, 0x172, 0x18e2, 0xa, 0x172, 0x3, 0x172, 0x3, 0x172, 0x5, 0x172, 
       0x18e6, 0xa, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 
       0x3, 0x172, 0x3, 0x172, 0x3, 0x172, 0x5, 0x172, 0x18ef, 0xa, 0x172, 
       0x5, 0x172, 0x18f1, 0xa, 0x172, 0x3, 0x173, 0x3, 0x173, 0x3, 0x173, 
       0x7, 0x173, 0x18f6, 0xa, 0x173, 0xc, 0x173, 0xe, 0x173, 0x18f9, 0xb, 
       0x173, 0x3, 0x174, 0x3, 0x174, 0x3, 0x174, 0x5, 0x174, 0x18fe, 0xa, 
       0x174, 0x3, 0x175, 0x3, 0x175, 0x3, 0x176, 0x3, 0x176, 0x3, 0x177, 
       0x3, 0x177, 0x5, 0x177, 0x1906, 0xa, 0x177, 0x3, 0x178, 0x3, 0x178, 
       0x3, 0x179, 0x3, 0x179, 0x3, 0x179, 0x3, 0x179, 0x3, 0x17a, 0x3, 
       0x17a, 0x3, 0x17a, 0x3, 0x17a, 0x3, 0x17b, 0x3, 0x17b, 0x3, 0x17b, 
       0x3, 0x17b, 0x3, 0x17c, 0x3, 0x17c, 0x3, 0x17c, 0x7, 0x17c, 0x1919, 
       0xa, 0x17c, 0xc, 0x17c, 0xe, 0x17c, 0x191c, 0xb, 0x17c, 0x3, 0x17d, 
       0x3, 0x17d, 0x5, 0x17d, 0x1920, 0xa, 0x17d, 0x3, 0x17e, 0x3, 0x17e, 
       0x3, 0x17e, 0x7, 0x17e, 0x1925, 0xa, 0x17e, 0xc, 0x17e, 0xe, 0x17e, 
       0x1928, 0xb, 0x17e, 0x3, 0x17f, 0x3, 0x17f, 0x3, 0x180, 0x3, 0x180, 
       0x3, 0x180, 0x3, 0x180, 0x3, 0x180, 0x3, 0x181, 0x3, 0x181, 0x3, 
       0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 
       0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x3, 0x181, 0x5, 
       0x181, 0x193e, 0xa, 0x181, 0x3, 0x182, 0x3, 0x182, 0x3, 0x182, 0x3, 
       0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x183, 0x3, 0x184, 
       0x3, 0x184, 0x3, 0x184, 0x3, 0x184, 0x3, 0x184, 0x3, 0x184, 0x5, 
       0x184, 0x194e, 0xa, 0x184, 0x3, 0x185, 0x3, 0x185, 0x3, 0x185, 0x3, 
       0x186, 0x3, 0x186, 0x3, 0x186, 0x6, 0x186, 0x1956, 0xa, 0x186, 0xd, 
       0x186, 0xe, 0x186, 0x1957, 0x3, 0x187, 0x3, 0x187, 0x5, 0x187, 0x195c, 
       0xa, 0x187, 0x3, 0x187, 0x3, 0x187, 0x3, 0x187, 0x6, 0x187, 0x1961, 
       0xa, 0x187, 0xd, 0x187, 0xe, 0x187, 0x1962, 0x3, 0x187, 0x5, 0x187, 
       0x1966, 0xa, 0x187, 0x3, 0x187, 0x3, 0x187, 0x3, 0x187, 0x3, 0x188, 
       0x3, 0x188, 0x3, 0x188, 0x3, 0x189, 0x3, 0x189, 0x3, 0x189, 0x5, 
       0x189, 0x1971, 0xa, 0x189, 0x3, 0x18a, 0x3, 0x18a, 0x3, 0x18b, 0x3, 
       0x18b, 0x3, 0x18b, 0x3, 0x18c, 0x3, 0x18c, 0x5, 0x18c, 0x197a, 0xa, 
       0x18c, 0x3, 0x18c, 0x5, 0x18c, 0x197d, 0xa, 0x18c, 0x3, 0x18c, 0x3, 
       0x18c, 0x3, 0x18d, 0x3, 0x18d, 0x3, 0x18d, 0x5, 0x18d, 0x1984, 0xa, 
       0x18d, 0x3, 0x18e, 0x3, 0x18e, 0x3, 0x18e, 0x5, 0x18e, 0x1989, 0xa, 
       0x18e, 0x3, 0x18f, 0x3, 0x18f, 0x3, 0x18f, 0x3, 0x18f, 0x3, 0x18f, 
       0x3, 0x190, 0x3, 0x190, 0x3, 0x190, 0x3, 0x190, 0x3, 0x190, 0x3, 
       0x190, 0x3, 0x190, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 
       0x3, 0x191, 0x3, 0x191, 0x3, 0x191, 0x3, 0x192, 0x3, 0x192, 0x3, 
       0x192, 0x6, 0x192, 0x19a1, 0xa, 0x192, 0xd, 0x192, 0xe, 0x192, 0x19a2, 
       0x3, 0x193, 0x3, 0x193, 0x3, 0x193, 0x3, 0x193, 0x5, 0x193, 0x19a9, 
       0xa, 0x193, 0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x3, 0x194, 0x5, 
       0x194, 0x19af, 0xa, 0x194, 0x3, 0x194, 0x3, 0x194, 0x5, 0x194, 0x19b3, 
       0xa, 0x194, 0x3, 0x195, 0x3, 0x195, 0x3, 0x195, 0x3, 0x195, 0x3, 
       0x195, 0x3, 0x195, 0x3, 0x196, 0x3, 0x196, 0x5, 0x196, 0x19bd, 0xa, 
       0x196, 0x3, 0x197, 0x3, 0x197, 0x5, 0x197, 0x19c1, 0xa, 0x197, 0x3, 
       0x197, 0x3, 0x197, 0x3, 0x198, 0x3, 0x198, 0x3, 0x198, 0x3, 0x198, 
       0x3, 0x198, 0x3, 0x198, 0x3, 0x198, 0x7, 0x198, 0x19cc, 0xa, 0x198, 
       0xc, 0x198, 0xe, 0x198, 0x19cf, 0xb, 0x198, 0x3, 0x198, 0x3, 0x198, 
       0x3, 0x199, 0x3, 0x199, 0x3, 0x199, 0x3, 0x199, 0x3, 0x199, 0x3, 
       0x199, 0x3, 0x199, 0x5, 0x199, 0x19da, 0xa, 0x199, 0x3, 0x19a, 0x3, 
       0x19a, 0x3, 0x19a, 0x3, 0x19a, 0x3, 0x19a, 0x3, 0x19a, 0x3, 0x19b, 
       0x3, 0x19b, 0x3, 0x19b, 0x3, 0x19c, 0x3, 0x19c, 0x3, 0x19c, 0x3, 
       0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x5, 0x19d, 0x19ec, 0xa, 
       0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x7, 0x19d, 
       0x19f2, 0xa, 0x19d, 0xc, 0x19d, 0xe, 0x19d, 0x19f5, 0xb, 0x19d, 0x3, 
       0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x3, 0x19d, 0x7, 0x19d, 
       0x19fc, 0xa, 0x19d, 0xc, 0x19d, 0xe, 0x19d, 0x19ff, 0xb, 0x19d, 0x5, 
       0x19d, 0x1a01, 0xa, 0x19d, 0x3, 0x19e, 0x3, 0x19e, 0x3, 0x19e, 0x5, 
       0x19e, 0x1a06, 0xa, 0x19e, 0x3, 0x19f, 0x3, 0x19f, 0x5, 0x19f, 0x1a0a, 
       0xa, 0x19f, 0x3, 0x19f, 0x3, 0x19f, 0x3, 0x19f, 0x3, 0x1a0, 0x3, 
       0x1a0, 0x5, 0x1a0, 0x1a11, 0xa, 0x1a0, 0x3, 0x1a0, 0x3, 0x1a0, 0x3, 
       0x1a0, 0x5, 0x1a0, 0x1a16, 0xa, 0x1a0, 0x3, 0x1a1, 0x3, 0x1a1, 0x3, 
       0x1a2, 0x3, 0x1a2, 0x3, 0x1a2, 0x5, 0x1a2, 0x1a1d, 0xa, 0x1a2, 0x3, 
       0x1a2, 0x3, 0x1a2, 0x3, 0x1a2, 0x3, 0x1a2, 0x7, 0x1a2, 0x1a23, 0xa, 
       0x1a2, 0xc, 0x1a2, 0xe, 0x1a2, 0x1a26, 0xb, 0x1a2, 0x5, 0x1a2, 0x1a28, 
       0xa, 0x1a2, 0x3, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x5, 0x1a3, 0x1a2d, 
       0xa, 0x1a3, 0x3, 0x1a3, 0x5, 0x1a3, 0x1a30, 0xa, 0x1a3, 0x3, 0x1a3, 
       0x3, 0x1a3, 0x3, 0x1a3, 0x3, 0x1a3, 0x7, 0x1a3, 0x1a36, 0xa, 0x1a3, 
       0xc, 0x1a3, 0xe, 0x1a3, 0x1a39, 0xb, 0x1a3, 0x5, 0x1a3, 0x1a3b, 0xa, 
       0x1a3, 0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a4, 0x3, 0x1a5, 
       0x3, 0x1a5, 0x3, 0x1a5, 0x3, 0x1a6, 0x3, 0x1a6, 0x3, 0x1a6, 0x3, 
       0x1a7, 0x3, 0x1a7, 0x5, 0x1a7, 0x1a49, 0xa, 0x1a7, 0x3, 0x1a7, 0x5, 
       0x1a7, 0x1a4c, 0xa, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 0x1a7, 0x3, 
       0x1a7, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 0x3, 0x1a8, 
       0x3, 0x1a8, 0x3, 0x1a8, 0x5, 0x1a8, 0x1a59, 0xa, 0x1a8, 0x3, 0x1a8, 
       0x3, 0x1a8, 0x5, 0x1a8, 0x1a5d, 0xa, 0x1a8, 0x5, 0x1a8, 0x1a5f, 0xa, 
       0x1a8, 0x3, 0x1a9, 0x3, 0x1a9, 0x3, 0x1a9, 0x5, 0x1a9, 0x1a64, 0xa, 
       0x1a9, 0x3, 0x1aa, 0x3, 0x1aa, 0x3, 0x1aa, 0x5, 0x1aa, 0x1a69, 0xa, 
       0x1aa, 0x3, 0x1ab, 0x3, 0x1ab, 0x3, 0x1ab, 0x3, 0x1ac, 0x5, 0x1ac, 
       0x1a6f, 0xa, 0x1ac, 0x3, 0x1ac, 0x3, 0x1ac, 0x3, 0x1ad, 0x3, 0x1ad, 
       0x5, 0x1ad, 0x1a75, 0xa, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x7, 0x1ad, 
       0x1a79, 0xa, 0x1ad, 0xc, 0x1ad, 0xe, 0x1ad, 0x1a7c, 0xb, 0x1ad, 0x3, 
       0x1ad, 0x3, 0x1ad, 0x5, 0x1ad, 0x1a80, 0xa, 0x1ad, 0x3, 0x1ad, 0x5, 
       0x1ad, 0x1a83, 0xa, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x7, 0x1ad, 0x1a87, 
       0xa, 0x1ad, 0xc, 0x1ad, 0xe, 0x1ad, 0x1a8a, 0xb, 0x1ad, 0x3, 0x1ad, 
       0x3, 0x1ad, 0x5, 0x1ad, 0x1a8e, 0xa, 0x1ad, 0x3, 0x1ad, 0x5, 0x1ad, 
       0x1a91, 0xa, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x7, 0x1ad, 0x1a95, 0xa, 
       0x1ad, 0xc, 0x1ad, 0xe, 0x1ad, 0x1a98, 0xb, 0x1ad, 0x3, 0x1ad, 0x5, 
       0x1ad, 0x1a9b, 0xa, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 
       0x1ad, 0x5, 0x1ad, 0x1aa1, 0xa, 0x1ad, 0x5, 0x1ad, 0x1aa3, 0xa, 0x1ad, 
       0x3, 0x1ad, 0x5, 0x1ad, 0x1aa6, 0xa, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 
       0x7, 0x1ad, 0x1aaa, 0xa, 0x1ad, 0xc, 0x1ad, 0xe, 0x1ad, 0x1aad, 0xb, 
       0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x5, 0x1ad, 0x1ab2, 0xa, 
       0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 0x3, 0x1ad, 
       0x3, 0x1ad, 0x5, 0x1ad, 0x1aba, 0xa, 0x1ad, 0x5, 0x1ad, 0x1abc, 0xa, 
       0x1ad, 0x5, 0x1ad, 0x1abe, 0xa, 0x1ad, 0x3, 0x1ae, 0x3, 0x1ae, 0x5, 
       0x1ae, 0x1ac2, 0xa, 0x1ae, 0x3, 0x1af, 0x3, 0x1af, 0x7, 0x1af, 0x1ac6, 
       0xa, 0x1af, 0xc, 0x1af, 0xe, 0x1af, 0x1ac9, 0xb, 0x1af, 0x3, 0x1af, 
       0x3, 0x1af, 0x5, 0x1af, 0x1acd, 0xa, 0x1af, 0x3, 0x1af, 0x3, 0x1af, 
       0x5, 0x1af, 0x1ad1, 0xa, 0x1af, 0x3, 0x1af, 0x3, 0x1af, 0x3, 0x1af, 
       0x5, 0x1af, 0x1ad6, 0xa, 0x1af, 0x3, 0x1af, 0x3, 0x1af, 0x7, 0x1af, 
       0x1ada, 0xa, 0x1af, 0xc, 0x1af, 0xe, 0x1af, 0x1add, 0xb, 0x1af, 0x3, 
       0x1af, 0x3, 0x1af, 0x7, 0x1af, 0x1ae1, 0xa, 0x1af, 0xc, 0x1af, 0xe, 
       0x1af, 0x1ae4, 0xb, 0x1af, 0x5, 0x1af, 0x1ae6, 0xa, 0x1af, 0x5, 0x1af, 
       0x1ae8, 0xa, 0x1af, 0x3, 0x1b0, 0x5, 0x1b0, 0x1aeb, 0xa, 0x1b0, 0x3, 
       0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 
       0x3, 0x1b0, 0x3, 0x1b0, 0x5, 0x1b0, 0x1af5, 0xa, 0x1b0, 0x3, 0x1b0, 
       0x3, 0x1b0, 0x5, 0x1b0, 0x1af9, 0xa, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 
       0x3, 0x1b0, 0x3, 0x1b0, 0x5, 0x1b0, 0x1aff, 0xa, 0x1b0, 0x3, 0x1b0, 
       0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x5, 0x1b0, 0x1b06, 
       0xa, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x5, 0x1b0, 0x1b0b, 
       0xa, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 
       0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 0x3, 0x1b0, 
       0x3, 0x1b0, 0x3, 0x1b0, 0x5, 0x1b0, 0x1b19, 0xa, 0x1b0, 0x3, 0x1b0, 
       0x3, 0x1b0, 0x3, 0x1b0, 0x5, 0x1b0, 0x1b1e, 0xa, 0x1b0, 0x3, 0x1b1, 
       0x3, 0x1b1, 0x3, 0x1b2, 0x3, 0x1b2, 0x3, 0x1b3, 0x3, 0x1b3, 0x5, 
       0x1b3, 0x1b26, 0xa, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x5, 
       0x1b3, 0x1b2b, 0xa, 0x1b3, 0x3, 0x1b3, 0x3, 0x1b3, 0x5, 0x1b3, 0x1b2f, 
       0xa, 0x1b3, 0x3, 0x1b3, 0x5, 0x1b3, 0x1b32, 0xa, 0x1b3, 0x3, 0x1b4, 
       0x3, 0x1b4, 0x3, 0x1b4, 0x5, 0x1b4, 0x1b37, 0xa, 0x1b4, 0x3, 0x1b4, 
       0x3, 0x1b4, 0x5, 0x1b4, 0x1b3b, 0xa, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b4, 
       0x3, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b4, 0x5, 0x1b4, 0x1b43, 
       0xa, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b4, 0x3, 0x1b4, 0x3, 
       0x1b4, 0x3, 0x1b4, 0x5, 0x1b4, 0x1b4b, 0xa, 0x1b4, 0x5, 0x1b4, 0x1b4d, 
       0xa, 0x1b4, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 0x1b5, 0x3, 
       0x1b5, 0x5, 0x1b5, 0x1b54, 0xa, 0x1b5, 0x3, 0x1b6, 0x3, 0x1b6, 0x3, 
       0x1b6, 0x3, 0x1b6, 0x7, 0x1b6, 0x1b5a, 0xa, 0x1b6, 0xc, 0x1b6, 0xe, 
       0x1b6, 0x1b5d, 0xb, 0x1b6, 0x3, 0x1b6, 0x3, 0x1b6, 0x3, 0x1b7, 0x3, 
       0x1b7, 0x5, 0x1b7, 0x1b63, 0xa, 0x1b7, 0x3, 0x1b7, 0x5, 0x1b7, 0x1b66, 
       0xa, 0x1b7, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b8, 0x7, 
       0x1b8, 0x1b6c, 0xa, 0x1b8, 0xc, 0x1b8, 0xe, 0x1b8, 0x1b6f, 0xb, 0x1b8, 
       0x3, 0x1b8, 0x3, 0x1b8, 0x3, 0x1b9, 0x3, 0x1b9, 0x3, 0x1b9, 0x5, 
       0x1b9, 0x1b76, 0xa, 0x1b9, 0x5, 0x1b9, 0x1b78, 0xa, 0x1b9, 0x3, 0x1ba, 
       0x3, 0x1ba, 0x3, 0x1ba, 0x3, 0x1ba, 0x5, 0x1ba, 0x1b7e, 0xa, 0x1ba, 
       0x3, 0x1bb, 0x3, 0x1bb, 0x3, 0x1bc, 0x3, 0x1bc, 0x5, 0x1bc, 0x1b84, 
       0xa, 0x1bc, 0x3, 0x1bd, 0x3, 0x1bd, 0x5, 0x1bd, 0x1b88, 0xa, 0x1bd, 
       0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 0x1bd, 0x3, 
       0x1bd, 0x5, 0x1bd, 0x1b90, 0xa, 0x1bd, 0x3, 0x1be, 0x3, 0x1be, 0x3, 
       0x1bf, 0x3, 0x1bf, 0x3, 0x1bf, 0x3, 0x1c0, 0x3, 0x1c0, 0x3, 0x1c0, 
       0x3, 0x1c0, 0x5, 0x1c0, 0x1b9b, 0xa, 0x1c0, 0x3, 0x1c1, 0x3, 0x1c1, 
       0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c2, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 
       0x1c3, 0x1ba4, 0xa, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1ba7, 0xa, 0x1c3, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bac, 0xa, 0x1c3, 
       0x5, 0x1c3, 0x1bae, 0xa, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bb1, 0xa, 
       0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bb4, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 
       0x1c3, 0x5, 0x1c3, 0x1bb8, 0xa, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bbb, 
       0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bbf, 0xa, 0x1c3, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bc4, 0xa, 0x1c3, 
       0x3, 0x1c3, 0x5, 0x1c3, 0x1bc7, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 
       0x5, 0x1c3, 0x1bcb, 0xa, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bce, 0xa, 
       0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bd2, 0xa, 0x1c3, 0x3, 
       0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bd7, 0xa, 0x1c3, 0x3, 
       0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bdb, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 
       0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1be7, 0xa, 0x1c3, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1beb, 0xa, 0x1c3, 0x3, 0x1c3, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1bf1, 0xa, 0x1c3, 
       0x3, 0x1c3, 0x5, 0x1c3, 0x1bf4, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 
       0x3, 0x1c3, 0x5, 0x1c3, 0x1bf9, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 
       0x5, 0x1c3, 0x1bfd, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 
       0x1c01, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 
       0x1c06, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 
       0x3, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1c0f, 0xa, 0x1c3, 
       0x3, 0x1c3, 0x5, 0x1c3, 0x1c12, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 
       0x5, 0x1c3, 0x1c16, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 
       0x1c1a, 0xa, 0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1c1d, 0xa, 0x1c3, 0x3, 
       0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1c21, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 
       0x1c3, 0x5, 0x1c3, 0x1c25, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 
       0x1c3, 0x5, 0x1c3, 0x1c2a, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 
       0x1c3, 0x5, 0x1c3, 0x1c2f, 0xa, 0x1c3, 0x3, 0x1c3, 0x3, 0x1c3, 0x3, 
       0x1c3, 0x3, 0x1c3, 0x5, 0x1c3, 0x1c35, 0xa, 0x1c3, 0x3, 0x1c4, 0x3, 
       0x1c4, 0x3, 0x1c4, 0x5, 0x1c4, 0x1c3a, 0xa, 0x1c4, 0x3, 0x1c5, 0x3, 
       0x1c5, 0x3, 0x1c5, 0x5, 0x1c5, 0x1c3f, 0xa, 0x1c5, 0x3, 0x1c6, 0x3, 
       0x1c6, 0x3, 0x1c6, 0x3, 0x1c6, 0x3, 0x1c6, 0x3, 0x1c6, 0x3, 0x1c6, 
       0x3, 0x1c6, 0x3, 0x1c6, 0x3, 0x1c6, 0x5, 0x1c6, 0x1c4b, 0xa, 0x1c6, 
       0x3, 0x1c7, 0x3, 0x1c7, 0x3, 0x1c7, 0x5, 0x1c7, 0x1c50, 0xa, 0x1c7, 
       0x5, 0x1c7, 0x1c52, 0xa, 0x1c7, 0x3, 0x1c8, 0x3, 0x1c8, 0x3, 0x1c8, 
       0x5, 0x1c8, 0x1c57, 0xa, 0x1c8, 0x3, 0x1c8, 0x3, 0x1c8, 0x3, 0x1c9, 
       0x6, 0x1c9, 0x1c5c, 0xa, 0x1c9, 0xd, 0x1c9, 0xe, 0x1c9, 0x1c5d, 0x3, 
       0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 
       0x5, 0x1ca, 0x1c66, 0xa, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 0x3, 0x1ca, 
       0x3, 0x1ca, 0x5, 0x1ca, 0x1c6c, 0xa, 0x1ca, 0x5, 0x1ca, 0x1c6e, 0xa, 
       0x1ca, 0x3, 0x1cb, 0x3, 0x1cb, 0x5, 0x1cb, 0x1c72, 0xa, 0x1cb, 0x3, 
       0x1cb, 0x3, 0x1cb, 0x5, 0x1cb, 0x1c76, 0xa, 0x1cb, 0x3, 0x1cc, 0x3, 
       0x1cc, 0x5, 0x1cc, 0x1c7a, 0xa, 0x1cc, 0x3, 0x1cc, 0x3, 0x1cc, 0x5, 
       0x1cc, 0x1c7e, 0xa, 0x1cc, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 0x1cd, 0x3, 
       0x1cd, 0x3, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 0x3, 0x1ce, 
       0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 0x3, 0x1cf, 0x5, 0x1cf, 0x1c8d, 
       0xa, 0x1cf, 0x3, 0x1d0, 0x3, 0x1d0, 0x3, 0x1d0, 0x5, 0x1d0, 0x1c92, 
       0xa, 0x1d0, 0x3, 0x1d1, 0x3, 0x1d1, 0x5, 0x1d1, 0x1c96, 0xa, 0x1d1, 
       0x3, 0x1d1, 0x7, 0x1d1, 0x1c99, 0xa, 0x1d1, 0xc, 0x1d1, 0xe, 0x1d1, 
       0x1c9c, 0xb, 0x1d1, 0x3, 0x1d2, 0x6, 0x1d2, 0x1c9f, 0xa, 0x1d2, 0xd, 
       0x1d2, 0xe, 0x1d2, 0x1ca0, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1ca5, 
       0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 
       0x1d3, 0x1cab, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1caf, 
       0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1cb3, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1cb8, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1cbd, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1cc2, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1cc7, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1ccd, 
       0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 
       0x1d3, 0x1cd3, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 
       0x1d3, 0x1cd8, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 
       0x1d3, 0x1cdd, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 
       0x1d3, 0x5, 0x1d3, 0x1ce3, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 
       0x1d3, 0x5, 0x1d3, 0x1ce8, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 
       0x1d3, 0x5, 0x1d3, 0x1ced, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 
       0x1d3, 0x5, 0x1d3, 0x1cf2, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 
       0x1d3, 0x5, 0x1d3, 0x1cf7, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 
       0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 
       0x5, 0x1d3, 0x1d01, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 
       0x3, 0x1d3, 0x5, 0x1d3, 0x1d07, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1d0d, 0xa, 0x1d3, 0x3, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1d13, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x5, 0x1d3, 0x1d16, 0xa, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1d1d, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x3, 0x1d3, 0x3, 0x1d3, 0x5, 0x1d3, 0x1d22, 0xa, 0x1d3, 
       0x3, 0x1d3, 0x5, 0x1d3, 0x1d25, 0xa, 0x1d3, 0x3, 0x1d4, 0x3, 0x1d4, 
       0x5, 0x1d4, 0x1d29, 0xa, 0x1d4, 0x3, 0x1d5, 0x5, 0x1d5, 0x1d2c, 0xa, 
       0x1d5, 0x3, 0x1d5, 0x3, 0x1d5, 0x5, 0x1d5, 0x1d30, 0xa, 0x1d5, 0x3, 
       0x1d5, 0x3, 0x1d5, 0x3, 0x1d6, 0x5, 0x1d6, 0x1d35, 0xa, 0x1d6, 0x3, 
       0x1d6, 0x3, 0x1d6, 0x5, 0x1d6, 0x1d39, 0xa, 0x1d6, 0x3, 0x1d6, 0x3, 
       0x1d6, 0x3, 0x1d7, 0x5, 0x1d7, 0x1d3e, 0xa, 0x1d7, 0x3, 0x1d7, 0x3, 
       0x1d7, 0x5, 0x1d7, 0x1d42, 0xa, 0x1d7, 0x3, 0x1d7, 0x3, 0x1d7, 0x3, 
       0x1d8, 0x3, 0x1d8, 0x3, 0x1d8, 0x3, 0x1d8, 0x3, 0x1d8, 0x5, 0x1d8, 
       0x1d4b, 0xa, 0x1d8, 0x3, 0x1d8, 0x5, 0x1d8, 0x1d4e, 0xa, 0x1d8, 0x3, 
       0x1d8, 0x5, 0x1d8, 0x1d51, 0xa, 0x1d8, 0x3, 0x1d9, 0x5, 0x1d9, 0x1d54, 
       0xa, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x5, 0x1d9, 0x1d58, 0xa, 0x1d9, 
       0x3, 0x1d9, 0x3, 0x1d9, 0x5, 0x1d9, 0x1d5c, 0xa, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x5, 0x1d9, 0x1d60, 0xa, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 
       0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 0x3, 0x1d9, 
       0x5, 0x1d9, 0x1d6f, 0xa, 0x1d9, 0x3, 0x1d9, 0x5, 0x1d9, 0x1d72, 0xa, 
       0x1d9, 0x5, 0x1d9, 0x1d74, 0xa, 0x1d9, 0x3, 0x1da, 0x3, 0x1da, 0x3, 
       0x1da, 0x5, 0x1da, 0x1d79, 0xa, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 
       0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x3, 0x1da, 0x5, 0x1da, 
       0x1d82, 0xa, 0x1da, 0x3, 0x1da, 0x5, 0x1da, 0x1d85, 0xa, 0x1da, 0x3, 
       0x1da, 0x3, 0x1da, 0x5, 0x1da, 0x1d89, 0xa, 0x1da, 0x3, 0x1db, 0x3, 
       0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1db, 0x3, 0x1dc, 0x3, 0x1dc, 
       0x3, 0x1dc, 0x3, 0x1dc, 0x7, 0x1dc, 0x1d94, 0xa, 0x1dc, 0xc, 0x1dc, 
       0xe, 0x1dc, 0x1d97, 0xb, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dc, 0x3, 0x1dd, 
       0x3, 0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 0x3, 
       0x1dd, 0x5, 0x1dd, 0x1da2, 0xa, 0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 0x3, 
       0x1dd, 0x5, 0x1dd, 0x1da7, 0xa, 0x1dd, 0x3, 0x1dd, 0x7, 0x1dd, 0x1daa, 
       0xa, 0x1dd, 0xc, 0x1dd, 0xe, 0x1dd, 0x1dad, 0xb, 0x1dd, 0x3, 0x1dd, 
       0x3, 0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 0x7, 0x1dd, 0x1db3, 0xa, 0x1dd, 
       0xc, 0x1dd, 0xe, 0x1dd, 0x1db6, 0xb, 0x1dd, 0x3, 0x1dd, 0x3, 0x1dd, 
       0x5, 0x1dd, 0x1dba, 0xa, 0x1dd, 0x3, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 
       0x3, 0x1de, 0x3, 0x1de, 0x7, 0x1de, 0x1dc1, 0xa, 0x1de, 0xc, 0x1de, 
       0xe, 0x1de, 0x1dc4, 0xb, 0x1de, 0x3, 0x1de, 0x3, 0x1de, 0x5, 0x1de, 
       0x1dc8, 0xa, 0x1de, 0x3, 0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1dcc, 0xa, 
       0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1dd0, 0xa, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1dd4, 0xa, 0x1df, 0x3, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1dd9, 0xa, 0x1df, 0x3, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1dde, 0xa, 0x1df, 0x3, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1de4, 0xa, 0x1df, 0x3, 
       0x1df, 0x3, 0x1df, 0x3, 0x1df, 0x5, 0x1df, 0x1de9, 0xa, 0x1df, 0x3, 
       0x1df, 0x5, 0x1df, 0x1dec, 0xa, 0x1df, 0x3, 0x1e0, 0x3, 0x1e0, 0x3, 
       0x1e0, 0x7, 0x1e0, 0x1df1, 0xa, 0x1e0, 0xc, 0x1e0, 0xe, 0x1e0, 0x1df4, 
       0xb, 0x1e0, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e1, 0x7, 
       0x1e1, 0x1dfa, 0xa, 0x1e1, 0xc, 0x1e1, 0xe, 0x1e1, 0x1dfd, 0xb, 0x1e1, 
       0x3, 0x1e1, 0x3, 0x1e1, 0x3, 0x1e2, 0x3, 0x1e2, 0x5, 0x1e2, 0x1e03, 
       0xa, 0x1e2, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 0x1e3, 0x3, 
       0x1e4, 0x3, 0x1e4, 0x3, 0x1e4, 0x3, 0x1e5, 0x3, 0x1e5, 0x3, 0x1e5, 
       0x3, 0x1e5, 0x3, 0x1e6, 0x5, 0x1e6, 0x1e11, 0xa, 0x1e6, 0x3, 0x1e6, 
       0x3, 0x1e6, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e7, 0x3, 0x1e8, 0x3, 
       0x1e8, 0x3, 0x1e8, 0x3, 0x1e9, 0x3, 0x1e9, 0x5, 0x1e9, 0x1e1d, 0xa, 
       0x1e9, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 0x3, 0x1ea, 
       0x3, 0x1ea, 0x3, 0x1eb, 0x3, 0x1eb, 0x3, 0x1eb, 0x7, 0x1eb, 0x1e28, 
       0xa, 0x1eb, 0xc, 0x1eb, 0xe, 0x1eb, 0x1e2b, 0xb, 0x1eb, 0x3, 0x1ec, 
       0x3, 0x1ec, 0x3, 0x1ec, 0x7, 0x1ec, 0x1e30, 0xa, 0x1ec, 0xc, 0x1ec, 
       0xe, 0x1ec, 0x1e33, 0xb, 0x1ec, 0x3, 0x1ed, 0x3, 0x1ed, 0x3, 0x1ed, 
       0x3, 0x1ed, 0x5, 0x1ed, 0x1e39, 0xa, 0x1ed, 0x3, 0x1ee, 0x3, 0x1ee, 
       0x3, 0x1ee, 0x3, 0x1ef, 0x3, 0x1ef, 0x6, 0x1ef, 0x1e40, 0xa, 0x1ef, 
       0xd, 0x1ef, 0xe, 0x1ef, 0x1e41, 0x3, 0x1f0, 0x3, 0x1f0, 0x3, 0x1f0, 
       0x3, 0x1f0, 0x5, 0x1f0, 0x1e48, 0xa, 0x1f0, 0x3, 0x1f0, 0x3, 0x1f0, 
       0x3, 0x1f0, 0x3, 0x1f0, 0x3, 0x1f0, 0x3, 0x1f0, 0x5, 0x1f0, 0x1e50, 
       0xa, 0x1f0, 0x3, 0x1f1, 0x3, 0x1f1, 0x6, 0x1f1, 0x1e54, 0xa, 0x1f1, 
       0xd, 0x1f1, 0xe, 0x1f1, 0x1e55, 0x3, 0x1f2, 0x3, 0x1f2, 0x3, 0x1f2, 
       0x3, 0x1f2, 0x3, 0x1f3, 0x3, 0x1f3, 0x3, 0x1f3, 0x7, 0x1f3, 0x1e5f, 
       0xa, 0x1f3, 0xc, 0x1f3, 0xe, 0x1f3, 0x1e62, 0xb, 0x1f3, 0x3, 0x1f4, 
       0x3, 0x1f4, 0x3, 0x1f4, 0x7, 0x1f4, 0x1e67, 0xa, 0x1f4, 0xc, 0x1f4, 
       0xe, 0x1f4, 0x1e6a, 0xb, 0x1f4, 0x3, 0x1f5, 0x3, 0x1f5, 0x3, 0x1f5, 
       0x7, 0x1f5, 0x1e6f, 0xa, 0x1f5, 0xc, 0x1f5, 0xe, 0x1f5, 0x1e72, 0xb, 
       0x1f5, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 
       0x5, 0x1f6, 0x1e79, 0xa, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 
       0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 0x1f6, 0x3, 
       0x1f6, 0x5, 0x1f6, 0x1e84, 0xa, 0x1f6, 0x5, 0x1f6, 0x1e86, 0xa, 0x1f6, 
       0x5, 0x1f6, 0x1e88, 0xa, 0x1f6, 0x5, 0x1f6, 0x1e8a, 0xa, 0x1f6, 0x3, 
       0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x5, 0x1f7, 0x1e90, 0xa, 
       0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x5, 0x1f7, 
       0x1e96, 0xa, 0x1f7, 0x3, 0x1f7, 0x5, 0x1f7, 0x1e99, 0xa, 0x1f7, 0x3, 
       0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x3, 0x1f7, 0x5, 0x1f7, 
       0x1ea0, 0xa, 0x1f7, 0x5, 0x1f7, 0x1ea2, 0xa, 0x1f7, 0x5, 0x1f7, 0x1ea4, 
       0xa, 0x1f7, 0x3, 0x1f7, 0x5, 0x1f7, 0x1ea7, 0xa, 0x1f7, 0x5, 0x1f7, 
       0x1ea9, 0xa, 0x1f7, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 0x3, 0x1f8, 
       0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1f9, 0x3, 0x1fa, 0x3, 
       0x1fa, 0x3, 0x1fa, 0x3, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 
       0x5, 0x1fb, 0x1eba, 0xa, 0x1fb, 0x3, 0x1fb, 0x3, 0x1fb, 0x5, 0x1fb, 
       0x1ebe, 0xa, 0x1fb, 0x5, 0x1fb, 0x1ec0, 0xa, 0x1fb, 0x3, 0x1fc, 0x3, 
       0x1fc, 0x3, 0x1fc, 0x3, 0x1fd, 0x3, 0x1fd, 0x5, 0x1fd, 0x1ec7, 0xa, 
       0x1fd, 0x3, 0x1fe, 0x3, 0x1fe, 0x3, 0x1fe, 0x3, 0x1ff, 0x3, 0x1ff, 
       0x3, 0x200, 0x3, 0x200, 0x3, 0x200, 0x3, 0x200, 0x3, 0x201, 0x3, 
       0x201, 0x3, 0x201, 0x5, 0x201, 0x1ed5, 0xa, 0x201, 0x5, 0x201, 0x1ed7, 
       0xa, 0x201, 0x3, 0x202, 0x3, 0x202, 0x3, 0x202, 0x3, 0x202, 0x5, 
       0x202, 0x1edd, 0xa, 0x202, 0x3, 0x203, 0x3, 0x203, 0x3, 0x204, 0x3, 
       0x204, 0x3, 0x204, 0x3, 0x204, 0x7, 0x204, 0x1ee5, 0xa, 0x204, 0xc, 
       0x204, 0xe, 0x204, 0x1ee8, 0xb, 0x204, 0x3, 0x204, 0x3, 0x204, 0x3, 
       0x205, 0x3, 0x205, 0x3, 0x206, 0x3, 0x206, 0x5, 0x206, 0x1ef0, 0xa, 
       0x206, 0x3, 0x207, 0x3, 0x207, 0x3, 0x208, 0x3, 0x208, 0x3, 0x209, 
       0x3, 0x209, 0x3, 0x209, 0x3, 0x209, 0x3, 0x209, 0x5, 0x209, 0x1efb, 
       0xa, 0x209, 0x3, 0x209, 0x3, 0x209, 0x3, 0x20a, 0x3, 0x20a, 0x3, 
       0x20b, 0x3, 0x20b, 0x3, 0x20c, 0x3, 0x20c, 0x3, 0x20d, 0x3, 0x20d, 
       0x3, 0x20e, 0x3, 0x20e, 0x3, 0x20f, 0x3, 0x20f, 0x3, 0x210, 0x3, 
       0x210, 0x3, 0x211, 0x3, 0x211, 0x3, 0x212, 0x3, 0x212, 0x5, 0x212, 
       0x1f11, 0xa, 0x212, 0x3, 0x213, 0x3, 0x213, 0x5, 0x213, 0x1f15, 0xa, 
       0x213, 0x3, 0x214, 0x3, 0x214, 0x3, 0x215, 0x3, 0x215, 0x3, 0x216, 
       0x3, 0x216, 0x3, 0x217, 0x3, 0x217, 0x3, 0x218, 0x3, 0x218, 0x3, 
       0x219, 0x3, 0x219, 0x3, 0x21a, 0x3, 0x21a, 0x3, 0x21b, 0x3, 0x21b, 
       0x3, 0x21c, 0x3, 0x21c, 0x3, 0x21d, 0x3, 0x21d, 0x3, 0x21e, 0x3, 
       0x21e, 0x5, 0x21e, 0x1f2d, 0xa, 0x21e, 0x3, 0x21f, 0x3, 0x21f, 0x3, 
       0x21f, 0x3, 0x220, 0x3, 0x220, 0x3, 0x220, 0x3, 0x220, 0x3, 0x220, 
       0x3, 0x220, 0x5, 0x220, 0x1f38, 0xa, 0x220, 0x5, 0x220, 0x1f3a, 0xa, 
       0x220, 0x3, 0x221, 0x3, 0x221, 0x5, 0x221, 0x1f3e, 0xa, 0x221, 0x3, 
       0x222, 0x3, 0x222, 0x3, 0x222, 0x7, 0x222, 0x1f43, 0xa, 0x222, 0xc, 
       0x222, 0xe, 0x222, 0x1f46, 0xb, 0x222, 0x3, 0x223, 0x3, 0x223, 0x3, 
       0x223, 0x7, 0x223, 0x1f4b, 0xa, 0x223, 0xc, 0x223, 0xe, 0x223, 0x1f4e, 
       0xb, 0x223, 0x3, 0x224, 0x3, 0x224, 0x3, 0x225, 0x3, 0x225, 0x5, 
       0x225, 0x1f54, 0xa, 0x225, 0x3, 0x226, 0x3, 0x226, 0x3, 0x227, 0x3, 
       0x227, 0x5, 0x227, 0x1f5a, 0xa, 0x227, 0x3, 0x228, 0x3, 0x228, 0x3, 
       0x229, 0x3, 0x229, 0x3, 0x22a, 0x3, 0x22a, 0x3, 0x22b, 0x3, 0x22b, 
       0x3, 0x22c, 0x3, 0x22c, 0x3, 0x22d, 0x3, 0x22d, 0x3, 0x22d, 0x5, 
       0x22d, 0x1f69, 0xa, 0x22d, 0x3, 0x22e, 0x3, 0x22e, 0x5, 0x22e, 0x1f6d, 
       0xa, 0x22e, 0x3, 0x22f, 0x3, 0x22f, 0x3, 0x22f, 0x7, 0x22f, 0x1f72, 
       0xa, 0x22f, 0xc, 0x22f, 0xe, 0x22f, 0x1f75, 0xb, 0x22f, 0x3, 0x230, 
       0x3, 0x230, 0x3, 0x230, 0x3, 0x230, 0x3, 0x231, 0x3, 0x231, 0x5, 
       0x231, 0x1f7d, 0xa, 0x231, 0x3, 0x232, 0x3, 0x232, 0x3, 0x232, 0x5, 
       0x232, 0x1f82, 0xa, 0x232, 0x5, 0x232, 0x1f84, 0xa, 0x232, 0x3, 0x232, 
       0x3, 0x232, 0x3, 0x232, 0x3, 0x232, 0x5, 0x232, 0x1f8a, 0xa, 0x232, 
       0x3, 0x233, 0x3, 0x233, 0x3, 0x233, 0x3, 0x234, 0x3, 0x234, 0x3, 
       0x235, 0x3, 0x235, 0x3, 0x236, 0x3, 0x236, 0x3, 0x237, 0x3, 0x237, 
       0x3, 0x237, 0x3, 0x237, 0x3, 0x237, 0x5, 0x237, 0x1f9a, 0xa, 0x237, 
       0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 0x238, 0x3, 
       0x238, 0x5, 0x238, 0x1fa2, 0xa, 0x238, 0x3, 0x238, 0x5, 0x238, 0x1fa5, 
       0xa, 0x238, 0x3, 0x239, 0x3, 0x239, 0x3, 0x239, 0x3, 0x239, 0x3, 
       0x239, 0x5, 0x239, 0x1fac, 0xa, 0x239, 0x3, 0x23a, 0x3, 0x23a, 0x3, 
       0x23a, 0x3, 0x23a, 0x7, 0x23a, 0x1fb2, 0xa, 0x23a, 0xc, 0x23a, 0xe, 
       0x23a, 0x1fb5, 0xb, 0x23a, 0x3, 0x23a, 0x3, 0x23a, 0x3, 0x23b, 0x3, 
       0x23b, 0x3, 0x23b, 0x5, 0x23b, 0x1fbc, 0xa, 0x23b, 0x3, 0x23c, 0x3, 
       0x23c, 0x3, 0x23c, 0x5, 0x23c, 0x1fc1, 0xa, 0x23c, 0x3, 0x23d, 0x3, 
       0x23d, 0x3, 0x23d, 0x5, 0x23d, 0x1fc6, 0xa, 0x23d, 0x3, 0x23e, 0x5, 
       0x23e, 0x1fc9, 0xa, 0x23e, 0x3, 0x23e, 0x3, 0x23e, 0x5, 0x23e, 0x1fcd, 
       0xa, 0x23e, 0x3, 0x23e, 0x7, 0x23e, 0x1fd0, 0xa, 0x23e, 0xc, 0x23e, 
       0xe, 0x23e, 0x1fd3, 0xb, 0x23e, 0x3, 0x23f, 0x3, 0x23f, 0x3, 0x240, 
       0x3, 0x240, 0x3, 0x240, 0x7, 0x240, 0x1fda, 0xa, 0x240, 0xc, 0x240, 
       0xe, 0x240, 0x1fdd, 0xb, 0x240, 0x3, 0x241, 0x3, 0x241, 0x3, 0x242, 
       0x3, 0x242, 0x3, 0x243, 0x3, 0x243, 0x3, 0x244, 0x3, 0x244, 0x3, 
       0x244, 0x3, 0x244, 0x3, 0x244, 0x3, 0x244, 0x5, 0x244, 0x1feb, 0xa, 
       0x244, 0x3, 0x245, 0x3, 0x245, 0x5, 0x245, 0x1fef, 0xa, 0x245, 0x3, 
       0x246, 0x3, 0x246, 0x3, 0x247, 0x3, 0x247, 0x3, 0x247, 0x3, 0x247, 
       0x3, 0x247, 0x3, 0x247, 0x3, 0x248, 0x3, 0x248, 0x5, 0x248, 0x1ffb, 
       0xa, 0x248, 0x3, 0x249, 0x3, 0x249, 0x5, 0x249, 0x1fff, 0xa, 0x249, 
       0x3, 0x24a, 0x3, 0x24a, 0x5, 0x24a, 0x2003, 0xa, 0x24a, 0x3, 0x24b, 
       0x3, 0x24b, 0x5, 0x24b, 0x2007, 0xa, 0x24b, 0x3, 0x24c, 0x3, 0x24c, 
       0x3, 0x24c, 0x3, 0x24d, 0x3, 0x24d, 0x3, 0x24e, 0x3, 0x24e, 0x3, 
       0x24f, 0x3, 0x24f, 0x3, 0x24f, 0x3, 0x24f, 0x3, 0x24f, 0x3, 0x24f, 
       0x5, 0x24f, 0x2016, 0xa, 0x24f, 0x3, 0x250, 0x3, 0x250, 0x3, 0x250, 
       0x3, 0x250, 0x3, 0x250, 0x3, 0x250, 0x3, 0x250, 0x3, 0x250, 0x3, 
       0x250, 0x3, 0x250, 0x5, 0x250, 0x2022, 0xa, 0x250, 0x3, 0x251, 0x3, 
       0x251, 0x3, 0x251, 0x3, 0x251, 0x3, 0x251, 0x3, 0x251, 0x3, 0x251, 
       0x3, 0x251, 0x5, 0x251, 0x202c, 0xa, 0x251, 0x3, 0x251, 0x3, 0x251, 
       0x3, 0x251, 0x3, 0x251, 0x3, 0x251, 0x5, 0x251, 0x2033, 0xa, 0x251, 
       0x5, 0x251, 0x2035, 0xa, 0x251, 0x3, 0x252, 0x3, 0x252, 0x3, 0x253, 
       0x3, 0x253, 0x3, 0x254, 0x3, 0x254, 0x3, 0x254, 0x3, 0x254, 0x3, 
       0x254, 0x3, 0x254, 0x3, 0x254, 0x3, 0x254, 0x3, 0x254, 0x3, 0x254, 
       0x3, 0x254, 0x5, 0x254, 0x2046, 0xa, 0x254, 0x3, 0x254, 0x3, 0x254, 
       0x3, 0x254, 0x5, 0x254, 0x204b, 0xa, 0x254, 0x5, 0x254, 0x204d, 0xa, 
       0x254, 0x3, 0x255, 0x3, 0x255, 0x3, 0x256, 0x3, 0x256, 0x3, 0x257, 
       0x3, 0x257, 0x3, 0x257, 0x5, 0x257, 0x2056, 0xa, 0x257, 0x3, 0x257, 
       0x3, 0x257, 0x3, 0x257, 0x5, 0x257, 0x205b, 0xa, 0x257, 0x5, 0x257, 
       0x205d, 0xa, 0x257, 0x3, 0x258, 0x3, 0x258, 0x3, 0x258, 0x3, 0x258, 
       0x5, 0x258, 0x2063, 0xa, 0x258, 0x3, 0x259, 0x3, 0x259, 0x3, 0x25a, 
       0x3, 0x25a, 0x3, 0x25a, 0x3, 0x25a, 0x3, 0x25a, 0x5, 0x25a, 0x206c, 
       0xa, 0x25a, 0x3, 0x25b, 0x3, 0x25b, 0x3, 0x25b, 0x3, 0x25b, 0x3, 
       0x25b, 0x3, 0x25b, 0x3, 0x25b, 0x3, 0x25b, 0x3, 0x25b, 0x5, 0x25b, 
       0x2077, 0xa, 0x25b, 0x3, 0x25b, 0x2, 0x7, 0x116, 0x294, 0x296, 0x29e, 
       0x2a0, 0x25c, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x10, 0x12, 0x14, 
       0x16, 0x18, 0x1a, 0x1c, 0x1e, 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 
       0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e, 0x40, 
       0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 
       0x58, 0x5a, 0x5c, 0x5e, 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 
       0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e, 0x80, 0x82, 
       0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 
       0x9a, 0x9c, 0x9e, 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 
       0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe, 0xc0, 0xc2, 0xc4, 
       0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 
       0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 
       0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe, 0x100, 0x102, 0x104, 0x106, 
       0x108, 0x10a, 0x10c, 0x10e, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11a, 
       0x11c, 0x11e, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12a, 0x12c, 0x12e, 
       0x130, 0x132, 0x134, 0x136, 0x138, 0x13a, 0x13c, 0x13e, 0x140, 0x142, 
       0x144, 0x146, 0x148, 0x14a, 0x14c, 0x14e, 0x150, 0x152, 0x154, 0x156, 
       0x158, 0x15a, 0x15c, 0x15e, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16a, 
       0x16c, 0x16e, 0x170, 0x172, 0x174, 0x176, 0x178, 0x17a, 0x17c, 0x17e, 
       0x180, 0x182, 0x184, 0x186, 0x188, 0x18a, 0x18c, 0x18e, 0x190, 0x192, 
       0x194, 0x196, 0x198, 0x19a, 0x19c, 0x19e, 0x1a0, 0x1a2, 0x1a4, 0x1a6, 
       0x1a8, 0x1aa, 0x1ac, 0x1ae, 0x1b0, 0x1b2, 0x1b4, 0x1b6, 0x1b8, 0x1ba, 
       0x1bc, 0x1be, 0x1c0, 0x1c2, 0x1c4, 0x1c6, 0x1c8, 0x1ca, 0x1cc, 0x1ce, 
       0x1d0, 0x1d2, 0x1d4, 0x1d6, 0x1d8, 0x1da, 0x1dc, 0x1de, 0x1e0, 0x1e2, 
       0x1e4, 0x1e6, 0x1e8, 0x1ea, 0x1ec, 0x1ee, 0x1f0, 0x1f2, 0x1f4, 0x1f6, 
       0x1f8, 0x1fa, 0x1fc, 0x1fe, 0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 
       0x20c, 0x20e, 0x210, 0x212, 0x214, 0x216, 0x218, 0x21a, 0x21c, 0x21e, 
       0x220, 0x222, 0x224, 0x226, 0x228, 0x22a, 0x22c, 0x22e, 0x230, 0x232, 
       0x234, 0x236, 0x238, 0x23a, 0x23c, 0x23e, 0x240, 0x242, 0x244, 0x246, 
       0x248, 0x24a, 0x24c, 0x24e, 0x250, 0x252, 0x254, 0x256, 0x258, 0x25a, 
       0x25c, 0x25e, 0x260, 0x262, 0x264, 0x266, 0x268, 0x26a, 0x26c, 0x26e, 
       0x270, 0x272, 0x274, 0x276, 0x278, 0x27a, 0x27c, 0x27e, 0x280, 0x282, 
       0x284, 0x286, 0x288, 0x28a, 0x28c, 0x28e, 0x290, 0x292, 0x294, 0x296, 
       0x298, 0x29a, 0x29c, 0x29e, 0x2a0, 0x2a2, 0x2a4, 0x2a6, 0x2a8, 0x2aa, 
       0x2ac, 0x2ae, 0x2b0, 0x2b2, 0x2b4, 0x2b6, 0x2b8, 0x2ba, 0x2bc, 0x2be, 
       0x2c0, 0x2c2, 0x2c4, 0x2c6, 0x2c8, 0x2ca, 0x2cc, 0x2ce, 0x2d0, 0x2d2, 
       0x2d4, 0x2d6, 0x2d8, 0x2da, 0x2dc, 0x2de, 0x2e0, 0x2e2, 0x2e4, 0x2e6, 
       0x2e8, 0x2ea, 0x2ec, 0x2ee, 0x2f0, 0x2f2, 0x2f4, 0x2f6, 0x2f8, 0x2fa, 
       0x2fc, 0x2fe, 0x300, 0x302, 0x304, 0x306, 0x308, 0x30a, 0x30c, 0x30e, 
       0x310, 0x312, 0x314, 0x316, 0x318, 0x31a, 0x31c, 0x31e, 0x320, 0x322, 
       0x324, 0x326, 0x328, 0x32a, 0x32c, 0x32e, 0x330, 0x332, 0x334, 0x336, 
       0x338, 0x33a, 0x33c, 0x33e, 0x340, 0x342, 0x344, 0x346, 0x348, 0x34a, 
       0x34c, 0x34e, 0x350, 0x352, 0x354, 0x356, 0x358, 0x35a, 0x35c, 0x35e, 
       0x360, 0x362, 0x364, 0x366, 0x368, 0x36a, 0x36c, 0x36e, 0x370, 0x372, 
       0x374, 0x376, 0x378, 0x37a, 0x37c, 0x37e, 0x380, 0x382, 0x384, 0x386, 
       0x388, 0x38a, 0x38c, 0x38e, 0x390, 0x392, 0x394, 0x396, 0x398, 0x39a, 
       0x39c, 0x39e, 0x3a0, 0x3a2, 0x3a4, 0x3a6, 0x3a8, 0x3aa, 0x3ac, 0x3ae, 
       0x3b0, 0x3b2, 0x3b4, 0x3b6, 0x3b8, 0x3ba, 0x3bc, 0x3be, 0x3c0, 0x3c2, 
       0x3c4, 0x3c6, 0x3c8, 0x3ca, 0x3cc, 0x3ce, 0x3d0, 0x3d2, 0x3d4, 0x3d6, 
       0x3d8, 0x3da, 0x3dc, 0x3de, 0x3e0, 0x3e2, 0x3e4, 0x3e6, 0x3e8, 0x3ea, 
       0x3ec, 0x3ee, 0x3f0, 0x3f2, 0x3f4, 0x3f6, 0x3f8, 0x3fa, 0x3fc, 0x3fe, 
       0x400, 0x402, 0x404, 0x406, 0x408, 0x40a, 0x40c, 0x40e, 0x410, 0x412, 
       0x414, 0x416, 0x418, 0x41a, 0x41c, 0x41e, 0x420, 0x422, 0x424, 0x426, 
       0x428, 0x42a, 0x42c, 0x42e, 0x430, 0x432, 0x434, 0x436, 0x438, 0x43a, 
       0x43c, 0x43e, 0x440, 0x442, 0x444, 0x446, 0x448, 0x44a, 0x44c, 0x44e, 
       0x450, 0x452, 0x454, 0x456, 0x458, 0x45a, 0x45c, 0x45e, 0x460, 0x462, 
       0x464, 0x466, 0x468, 0x46a, 0x46c, 0x46e, 0x470, 0x472, 0x474, 0x476, 
       0x478, 0x47a, 0x47c, 0x47e, 0x480, 0x482, 0x484, 0x486, 0x488, 0x48a, 
       0x48c, 0x48e, 0x490, 0x492, 0x494, 0x496, 0x498, 0x49a, 0x49c, 0x49e, 
       0x4a0, 0x4a2, 0x4a4, 0x4a6, 0x4a8, 0x4aa, 0x4ac, 0x4ae, 0x4b0, 0x4b2, 
       0x4b4, 0x2, 0x92, 0x3, 0x2, 0x2f3, 0x2f4, 0x4, 0x2, 0x43, 0x43, 0x26e, 
       0x26e, 0x4, 0x2, 0x63, 0x63, 0x1fb, 0x1fb, 0x4, 0x2, 0x2a4, 0x2a4, 
       0x2a7, 0x2a7, 0x4, 0x2, 0x36, 0x36, 0xc1, 0xc1, 0x4, 0x2, 0x1d6, 
       0x1d6, 0x1d8, 0x1d8, 0x3, 0x2, 0x2f5, 0x2f6, 0x4, 0x2, 0x64, 0x64, 
       0x141, 0x141, 0x4, 0x2, 0x111, 0x111, 0x1ee, 0x1ee, 0x6, 0x2, 0xac, 
       0xac, 0x121, 0x121, 0x1d9, 0x1d9, 0x24c, 0x24c, 0x4, 0x2, 0xb0, 0xb0, 
       0x122, 0x122, 0x4, 0x2, 0x1dc, 0x1dc, 0x27b, 0x27b, 0x4, 0x2, 0x1dd, 
       0x1dd, 0x27c, 0x27c, 0x4, 0x2, 0x199, 0x199, 0x29d, 0x29d, 0x5, 0x2, 
       0x174, 0x174, 0x262, 0x262, 0x27a, 0x27a, 0x4, 0x2, 0x38, 0x38, 0x4e, 
       0x4e, 0x5, 0x2, 0xb3, 0xb3, 0x11b, 0x11b, 0x286, 0x286, 0x4, 0x2, 
       0xee, 0xee, 0x1c3, 0x1c3, 0x4, 0x2, 0x25b, 0x25b, 0x25e, 0x25e, 0x5, 
       0x2, 0x111, 0x111, 0x14c, 0x14c, 0x1d3, 0x1d3, 0x4, 0x2, 0xea, 0xea, 
       0x192, 0x192, 0x6, 0x2, 0xea, 0xea, 0x133, 0x133, 0x192, 0x192, 0x1c7, 
       0x1c7, 0x4, 0x2, 0x9, 0x9, 0xc, 0xf, 0x5, 0x2, 0xb1, 0xb1, 0x108, 
       0x108, 0x14c, 0x14c, 0x3, 0x2, 0x292, 0x293, 0x4, 0x2, 0x83, 0x83, 
       0x14c, 0x14c, 0x4, 0x2, 0xa0, 0xa0, 0x2ae, 0x2ae, 0x4, 0x2, 0x13d, 
       0x13d, 0x207, 0x207, 0x4, 0x2, 0xb1, 0xb1, 0x14c, 0x14c, 0x9, 0x2, 
       0x3c, 0x3c, 0xbd, 0xbd, 0x108, 0x108, 0x233, 0x234, 0x236, 0x236, 
       0x238, 0x238, 0x24b, 0x24b, 0x4, 0x2, 0x20, 0x20, 0x1a0, 0x1a0, 0x4, 
       0x2, 0x6, 0x8, 0x2e, 0x2e, 0x5, 0x2, 0x1d4, 0x1d4, 0x207, 0x207, 
       0x2cc, 0x2cc, 0x4, 0x2, 0x44, 0x44, 0xb4, 0xb4, 0x4, 0x2, 0x137, 
       0x137, 0x202, 0x202, 0x4, 0x2, 0x93, 0x93, 0x118, 0x118, 0x4, 0x2, 
       0x3c, 0x3c, 0xbd, 0xbd, 0x4, 0x2, 0xef, 0xef, 0x111, 0x111, 0x4, 
       0x2, 0x115, 0x115, 0x130, 0x130, 0x4, 0x2, 0x1a6, 0x1a6, 0x2aa, 0x2aa, 
       0x4, 0x2, 0x7d, 0x7d, 0x279, 0x279, 0x4, 0x2, 0x4f, 0x4f, 0x23f, 
       0x23f, 0x4, 0x2, 0x12c, 0x12c, 0x1fc, 0x1fc, 0x4, 0x2, 0x52, 0x52, 
       0x161, 0x161, 0x4, 0x2, 0x230, 0x230, 0x232, 0x232, 0x4, 0x2, 0x1e5, 
       0x1e5, 0x23a, 0x23a, 0x4, 0x2, 0x23f, 0x23f, 0x248, 0x248, 0x4, 0x2, 
       0xaa, 0xaa, 0xc1, 0xc1, 0x5, 0x2, 0x194, 0x194, 0x23b, 0x23b, 0x2ab, 
       0x2ab, 0x4, 0x2, 0x144, 0x144, 0x283, 0x283, 0x4, 0x2, 0xae, 0xae, 
       0x2f0, 0x2f0, 0x5, 0x2, 0xf7, 0xf7, 0x1ca, 0x1ca, 0x25e, 0x25e, 0x6, 
       0x2, 0x11b, 0x11b, 0x1df, 0x1df, 0x212, 0x212, 0x286, 0x286, 0xf, 
       0x2, 0xb3, 0xb3, 0xc1, 0xc1, 0xd7, 0xd7, 0xda, 0xda, 0xe7, 0xe7, 
       0x115, 0x115, 0x1cb, 0x1cb, 0x1cf, 0x1cf, 0x1e7, 0x1e7, 0x21f, 0x21f, 
       0x255, 0x255, 0x272, 0x272, 0x288, 0x288, 0x6, 0x2, 0x206, 0x206, 
       0x25c, 0x25c, 0x28a, 0x28a, 0x29b, 0x29b, 0x4, 0x2, 0x72, 0x72, 0x223, 
       0x223, 0x4, 0x2, 0x92, 0x92, 0xc1, 0xc1, 0x4, 0x2, 0xae, 0xae, 0x194, 
       0x194, 0x4, 0x2, 0xe0, 0xe0, 0x1d3, 0x1d3, 0x7, 0x2, 0x6a, 0x6a, 
       0xe0, 0xe0, 0xe4, 0xe4, 0x172, 0x172, 0x1d3, 0x1d3, 0x5, 0x2, 0xe0, 
       0xe0, 0x1d3, 0x1d3, 0x28b, 0x28b, 0x6, 0x2, 0x3c, 0x3c, 0x52, 0x52, 
       0xae, 0xae, 0x1a2, 0x1a2, 0x4, 0x2, 0x20a, 0x20a, 0x2e7, 0x2e7, 0x5, 
       0x2, 0x146, 0x146, 0x186, 0x186, 0x243, 0x243, 0x4, 0x2, 0xf4, 0xf4, 
       0x123, 0x123, 0x4, 0x2, 0x53, 0x53, 0x1e2, 0x1e2, 0x4, 0x2, 0x114, 
       0x115, 0x12e, 0x12e, 0x4, 0x2, 0xd3, 0xd3, 0x29e, 0x29e, 0x4, 0x2, 
       0x243, 0x243, 0x296, 0x296, 0x8, 0x2, 0x3c, 0x3c, 0x91, 0x91, 0x127, 
       0x127, 0x173, 0x173, 0x22a, 0x22a, 0x257, 0x257, 0x4, 0x2, 0x85, 
       0x85, 0x1d2, 0x1d2, 0x7, 0x2, 0xb6, 0xb6, 0x10a, 0x10a, 0x1c9, 0x1c9, 
       0x243, 0x243, 0x289, 0x289, 0x7, 0x2, 0x52, 0x52, 0xd0, 0xd0, 0xd2, 
       0xd2, 0xf9, 0xf9, 0x224, 0x224, 0x4, 0x2, 0x28a, 0x28a, 0x2e7, 0x2e7, 
       0x4, 0x2, 0xba, 0xba, 0xc9, 0xc9, 0x3, 0x2, 0xb4, 0xb5, 0x5, 0x2, 
       0xe3, 0xe3, 0x274, 0x274, 0x282, 0x282, 0x4, 0x2, 0x1a, 0x1a, 0x41, 
       0x41, 0x4, 0x2, 0x1d, 0x1d, 0x1ae, 0x1ae, 0x4, 0x2, 0x3c, 0x3c, 0x42, 
       0x42, 0x4, 0x2, 0x9, 0x9, 0xb, 0x10, 0x5, 0x2, 0x13, 0x15, 0xbe, 
       0xbe, 0x181, 0x181, 0x3, 0x2, 0x11, 0x12, 0x3, 0x2, 0x18, 0x19, 0x4, 
       0x2, 0x11, 0x12, 0x17, 0x17, 0x4, 0x2, 0x55, 0x56, 0x58, 0x58, 0x6, 
       0x2, 0x2c7, 0x2c8, 0x2d5, 0x2d5, 0x2d7, 0x2d7, 0x2d9, 0x2d9, 0x4, 
       0x2, 0x2cd, 0x2cd, 0x2cf, 0x2cf, 0x4, 0x2, 0x2ca, 0x2ca, 0x2ce, 0x2ce, 
       0x4, 0x2, 0xea, 0xea, 0x133, 0x133, 0x4, 0x2, 0x111, 0x111, 0x2d8, 
       0x2d8, 0x4, 0x2, 0x37, 0x37, 0x24e, 0x24e, 0x3, 0x2, 0xa2, 0xa3, 
       0x3, 0x2, 0x268, 0x269, 0x6, 0x2, 0xa1, 0xa1, 0xa4, 0xa4, 0x267, 
       0x267, 0x26a, 0x26a, 0x4, 0x2, 0x3, 0x3, 0x196, 0x196, 0x4, 0x2, 
       0x3, 0x3, 0x16, 0x16, 0x7, 0x2, 0xa5, 0xa8, 0x10b, 0x10d, 0x179, 
       0x17a, 0x20f, 0x20f, 0x2b0, 0x2b0, 0xb, 0x2, 0xa9, 0xa9, 0x10e, 0x10e, 
       0x176, 0x176, 0x17b, 0x17b, 0x182, 0x182, 0x1d1, 0x1d1, 0x210, 0x210, 
       0x29f, 0x29f, 0x2b1, 0x2b1, 0x5, 0x2, 0x8d, 0x8d, 0xdc, 0xdc, 0x27d, 
       0x27d, 0x4, 0x2, 0x19c, 0x19c, 0x208, 0x208, 0xc, 0x2, 0x67, 0x67, 
       0x71, 0x71, 0x7a, 0x7a, 0x88, 0x8a, 0x9b, 0x9b, 0x175, 0x175, 0x187, 
       0x187, 0x20e, 0x20e, 0x24d, 0x24d, 0x260, 0x260, 0x4, 0x2, 0x24a, 
       0x24a, 0x29c, 0x29c, 0x5, 0x2, 0xae, 0xae, 0xc5, 0xc5, 0xeb, 0xeb, 
       0x5, 0x2, 0xae, 0xae, 0xbc, 0xbc, 0x173, 0x173, 0x5, 0x2, 0xf5, 0xf5, 
       0x1b6, 0x1b6, 0x222, 0x222, 0x5, 0x2, 0x5e, 0x5e, 0x105, 0x105, 0x20b, 
       0x20b, 0x3, 0x2, 0x2b6, 0x2b7, 0x4, 0x2, 0x277, 0x277, 0x28d, 0x28d, 
       0x7, 0x2, 0x51, 0x51, 0x121, 0x121, 0x170, 0x170, 0x225, 0x225, 0x26c, 
       0x26c, 0x5, 0x2, 0xac, 0xac, 0xeb, 0xec, 0x19d, 0x19d, 0x3, 0x2, 
       0x5b, 0x5c, 0x4, 0x2, 0x147, 0x147, 0x16f, 0x16f, 0x6, 0x2, 0xfc, 
       0xfd, 0x13e, 0x13e, 0x183, 0x185, 0x1bf, 0x1c0, 0x5, 0x2, 0x221, 
       0x221, 0x284, 0x284, 0x2b2, 0x2b2, 0x3, 0x2, 0x240, 0x242, 0x4, 0x2, 
       0x6e, 0x6e, 0x25f, 0x25f, 0x8, 0x2, 0x7f, 0x7f, 0x81, 0x81, 0xae, 
       0xae, 0xc5, 0xc5, 0xeb, 0xeb, 0x1de, 0x1de, 0x5, 0x2, 0xea, 0xea, 
       0x133, 0x133, 0x198, 0x198, 0x4, 0x2, 0xbc, 0xbc, 0x173, 0x173, 0x4, 
       0x2, 0x13f, 0x13f, 0x1d4, 0x1d4, 0x4, 0x2, 0x168, 0x168, 0x17c, 0x17c, 
       0x4, 0x2, 0xa0, 0xa0, 0x115, 0x115, 0x5, 0x2, 0x119, 0x119, 0x123, 
       0x123, 0x1b1, 0x1b1, 0x4, 0x2, 0x23d, 0x23d, 0x263, 0x263, 0x4, 0x2, 
       0x19f, 0x19f, 0x1a5, 0x1a5, 0x4, 0x2, 0x141, 0x141, 0x19a, 0x19a, 
       0x4, 0x2, 0x302, 0x302, 0x304, 0x304, 0x5, 0x2, 0x6, 0x8, 0x2f, 0x2f, 
       0x31, 0x32, 0x4, 0x2, 0x6, 0x8, 0x2f, 0x2f, 0x4, 0x2, 0x6, 0x8, 0x31, 
       0x32, 0x3, 0x2, 0x2f, 0x30, 0x4, 0x2, 0xe3, 0xe3, 0x274, 0x274, 0x4, 
       0x2, 0x2d, 0x2d, 0x19b, 0x19b, 0x3, 0x2, 0x9, 0xa, 0x7, 0x2, 0xff, 
       0xff, 0x141, 0x141, 0x217, 0x217, 0x2b3, 0x2b3, 0x2c2, 0x2c2, 0x5, 
       0x2, 0xda, 0xda, 0x21f, 0x21f, 0x2eb, 0x2eb, 0x22, 0x2, 0x45, 0x45, 
       0x4f, 0x4f, 0x60, 0x61, 0x6c, 0x6c, 0x6e, 0x6e, 0x7c, 0x7c, 0x7e, 
       0x7e, 0x8b, 0x8b, 0xaa, 0xaa, 0xc0, 0xc0, 0xcc, 0xcc, 0xed, 0xee, 
       0x104, 0x104, 0x107, 0x107, 0x113, 0x113, 0x11e, 0x11e, 0x132, 0x132, 
       0x198, 0x198, 0x1c3, 0x1c3, 0x1c5, 0x1c5, 0x1eb, 0x1eb, 0x1f8, 0x1f8, 
       0x203, 0x203, 0x20c, 0x20c, 0x221, 0x221, 0x223, 0x223, 0x23f, 0x23f, 
       0x248, 0x248, 0x275, 0x275, 0x27e, 0x27f, 0x2ac, 0x2ac, 0x2c6, 0x2c6, 
       0xb, 0x2, 0xd7, 0xd7, 0xe7, 0xe7, 0x194, 0x194, 0x1cb, 0x1cb, 0x1cf, 
       0x1cf, 0x1e7, 0x1e7, 0x1ef, 0x1ef, 0x255, 0x255, 0x2e6, 0x2e6, 0x9e, 
       0x2, 0x34, 0x35, 0x37, 0x3b, 0x3e, 0x3e, 0x42, 0x42, 0x47, 0x47, 
       0x49, 0x4d, 0x53, 0x53, 0x57, 0x57, 0x5a, 0x5c, 0x5e, 0x5e, 0x64, 
       0x64, 0x67, 0x68, 0x6a, 0x6b, 0x70, 0x75, 0x77, 0x78, 0x7a, 0x7b, 
       0x7d, 0x7d, 0x7f, 0x83, 0x85, 0x86, 0x88, 0x8a, 0x8c, 0x8c, 0x91, 
       0x91, 0x96, 0x96, 0x9b, 0x9b, 0x9f, 0xa1, 0xa4, 0xa4, 0xa9, 0xa9, 
       0xaf, 0xb0, 0xb2, 0xb2, 0xb8, 0xbc, 0xc3, 0xc5, 0xc9, 0xc9, 0xcb, 
       0xcb, 0xcd, 0xcd, 0xcf, 0xd3, 0xd5, 0xd6, 0xd8, 0xd9, 0xdd, 0xe1, 
       0xe4, 0xe5, 0xe8, 0xeb, 0xf2, 0xf3, 0xf5, 0xf5, 0xf9, 0xf9, 0xfb, 
       0xfe, 0x101, 0x101, 0x105, 0x105, 0x109, 0x10a, 0x10e, 0x10f, 0x112, 
       0x112, 0x114, 0x114, 0x117, 0x117, 0x11c, 0x11d, 0x122, 0x122, 0x126, 
       0x127, 0x129, 0x12a, 0x12d, 0x12d, 0x12f, 0x12f, 0x133, 0x133, 0x135, 
       0x135, 0x138, 0x139, 0x13e, 0x13f, 0x143, 0x143, 0x145, 0x146, 0x14d, 
       0x14d, 0x14f, 0x15f, 0x161, 0x164, 0x166, 0x169, 0x16c, 0x16d, 0x172, 
       0x176, 0x178, 0x178, 0x17b, 0x17c, 0x17e, 0x17e, 0x180, 0x180, 0x182, 
       0x18a, 0x18d, 0x18e, 0x190, 0x193, 0x199, 0x199, 0x19c, 0x19c, 0x19e, 
       0x19e, 0x1a0, 0x1a0, 0x1a4, 0x1a4, 0x1a6, 0x1a7, 0x1aa, 0x1aa, 0x1b2, 
       0x1b8, 0x1ba, 0x1c1, 0x1c6, 0x1c7, 0x1c9, 0x1c9, 0x1cc, 0x1ce, 0x1d1, 
       0x1d3, 0x1d6, 0x1d6, 0x1da, 0x1db, 0x1dd, 0x1de, 0x1e1, 0x1e5, 0x1e8, 
       0x1e8, 0x1ea, 0x1ea, 0x1ec, 0x1ec, 0x1f0, 0x1f6, 0x1fa, 0x1fa, 0x1fc, 
       0x1fe, 0x200, 0x200, 0x204, 0x206, 0x208, 0x209, 0x20b, 0x20b, 0x20d, 
       0x20e, 0x210, 0x211, 0x215, 0x216, 0x218, 0x218, 0x21d, 0x21d, 0x222, 
       0x222, 0x224, 0x224, 0x226, 0x22a, 0x230, 0x232, 0x234, 0x234, 0x237, 
       0x237, 0x23a, 0x23a, 0x23c, 0x23c, 0x23e, 0x23e, 0x240, 0x243, 0x249, 
       0x249, 0x24c, 0x251, 0x256, 0x258, 0x25b, 0x25c, 0x25f, 0x262, 0x264, 
       0x265, 0x267, 0x26a, 0x270, 0x271, 0x276, 0x277, 0x279, 0x27c, 0x282, 
       0x282, 0x285, 0x285, 0x287, 0x287, 0x289, 0x28b, 0x291, 0x291, 0x293, 
       0x293, 0x296, 0x296, 0x29b, 0x29b, 0x29d, 0x2a0, 0x2a7, 0x2a9, 0x2ab, 
       0x2ab, 0x2ad, 0x2ae, 0x2b1, 0x2b1, 0x2b4, 0x2b7, 0x2b9, 0x2b9, 0x2be, 
       0x2c0, 0x2c3, 0x2c4, 0x2c9, 0x2c9, 0x2cb, 0x2cb, 0x2d2, 0x2d3, 0x2d6, 
       0x2d6, 0x2d8, 0x2d8, 0x2da, 0x2db, 0x2df, 0x2e5, 0x2e8, 0x2ea, 0x2ec, 
       0x2f6, 0x2f8, 0x2fb, 0x2fd, 0x2fd, 0x38, 0x2, 0x34, 0x34, 0x3e, 0x3e, 
       0x45, 0x45, 0x4d, 0x4d, 0x4f, 0x4f, 0x60, 0x61, 0x6c, 0x6c, 0x6e, 
       0x6e, 0x73, 0x73, 0x7c, 0x7c, 0x7e, 0x7e, 0x8b, 0x8b, 0xaa, 0xaa, 
       0xc0, 0xc0, 0xcc, 0xcc, 0xed, 0xee, 0xf2, 0xf2, 0xfb, 0xfb, 0x104, 
       0x104, 0x107, 0x107, 0x109, 0x109, 0x11e, 0x11e, 0x132, 0x132, 0x198, 
       0x198, 0x1a7, 0x1a7, 0x1aa, 0x1aa, 0x1b2, 0x1b2, 0x1b5, 0x1b5, 0x1b9, 
       0x1b9, 0x1c1, 0x1c1, 0x1c3, 0x1c3, 0x1c5, 0x1c5, 0x1e8, 0x1e8, 0x1eb, 
       0x1eb, 0x1f8, 0x1f8, 0x1fa, 0x1fa, 0x203, 0x203, 0x20c, 0x20c, 0x211, 
       0x211, 0x218, 0x218, 0x221, 0x221, 0x223, 0x223, 0x227, 0x228, 0x23f, 
       0x23f, 0x248, 0x248, 0x275, 0x275, 0x27e, 0x27f, 0x287, 0x287, 0x2a9, 
       0x2a9, 0x2ac, 0x2ac, 0x2b4, 0x2b4, 0x2b6, 0x2b7, 0x2c6, 0x2c6, 0x2f1, 
       0x2f4, 0x9b, 0x2, 0x35, 0x35, 0x37, 0x3b, 0x3f, 0x3f, 0x42, 0x42, 
       0x47, 0x4c, 0x53, 0x53, 0x57, 0x57, 0x5a, 0x5c, 0x5e, 0x5e, 0x64, 
       0x64, 0x67, 0x68, 0x6a, 0x6b, 0x70, 0x72, 0x74, 0x75, 0x77, 0x78, 
       0x7a, 0x7b, 0x7d, 0x7d, 0x7f, 0x83, 0x85, 0x86, 0x88, 0x8a, 0x8c, 
       0x8c, 0x8e, 0x8e, 0x91, 0x91, 0x96, 0x96, 0x9b, 0x9b, 0x9f, 0xa1, 
       0xa4, 0xa4, 0xa9, 0xa9, 0xaf, 0xb0, 0xb2, 0xb2, 0xb6, 0xb6, 0xb8, 
       0xbc, 0xc3, 0xc5, 0xc9, 0xc9, 0xcb, 0xcb, 0xcd, 0xcd, 0xcf, 0xd3, 
       0xd5, 0xd6, 0xd8, 0xd8, 0xdd, 0xdd, 0xdf, 0xe1, 0xe4, 0xe5, 0xe8, 
       0xeb, 0xf3, 0xf3, 0xf5, 0xf5, 0xf9, 0xf9, 0xfc, 0xff, 0x101, 0x101, 
       0x105, 0x105, 0x10a, 0x10a, 0x10e, 0x10f, 0x112, 0x112, 0x114, 0x114, 
       0x117, 0x117, 0x11c, 0x11d, 0x122, 0x122, 0x126, 0x127, 0x129, 0x12a, 
       0x12d, 0x12d, 0x12f, 0x12f, 0x133, 0x133, 0x135, 0x135, 0x138, 0x139, 
       0x13e, 0x13f, 0x141, 0x141, 0x143, 0x143, 0x145, 0x146, 0x14d, 0x14d, 
       0x14f, 0x15f, 0x161, 0x164, 0x166, 0x16a, 0x16c, 0x16d, 0x172, 0x176, 
       0x178, 0x178, 0x17b, 0x17c, 0x17e, 0x17e, 0x180, 0x180, 0x182, 0x18a, 
       0x18d, 0x18e, 0x190, 0x193, 0x199, 0x199, 0x19c, 0x19c, 0x19e, 0x19e, 
       0x1a0, 0x1a1, 0x1a3, 0x1a4, 0x1b3, 0x1b4, 0x1b6, 0x1b8, 0x1ba, 0x1c0, 
       0x1c6, 0x1c7, 0x1c9, 0x1c9, 0x1cc, 0x1ce, 0x1d1, 0x1d3, 0x1d6, 0x1d6, 
       0x1da, 0x1de, 0x1e1, 0x1e5, 0x1ea, 0x1ea, 0x1ec, 0x1ec, 0x1f0, 0x1f6, 
       0x1fc, 0x1fe, 0x200, 0x200, 0x204, 0x206, 0x208, 0x209, 0x20b, 0x20b, 
       0x20d, 0x20e, 0x210, 0x210, 0x215, 0x217, 0x21d, 0x21d, 0x222, 0x222, 
       0x224, 0x224, 0x226, 0x226, 0x229, 0x22a, 0x230, 0x232, 0x234, 0x235, 
       0x237, 0x237, 0x23a, 0x23a, 0x23c, 0x23c, 0x23e, 0x23e, 0x240, 0x243, 
       0x249, 0x249, 0x24c, 0x251, 0x255, 0x258, 0x25b, 0x25c, 0x25f, 0x262, 
       0x264, 0x265, 0x267, 0x26a, 0x270, 0x271, 0x276, 0x27c, 0x282, 0x282, 
       0x285, 0x285, 0x289, 0x28b, 0x293, 0x293, 0x296, 0x296, 0x29b, 0x29b, 
       0x29d, 0x2a0, 0x2a8, 0x2a8, 0x2ab, 0x2ab, 0x2ad, 0x2ae, 0x2b1, 0x2b1, 
       0x2b9, 0x2b9, 0x2be, 0x2c0, 0x2c3, 0x2c5, 0x2c9, 0x2c9, 0x2cb, 0x2cb, 
       0x2d2, 0x2d3, 0x2d6, 0x2d6, 0x2d8, 0x2d8, 0x2da, 0x2db, 0x2df, 0x2e5, 
       0x2e8, 0x2e9, 0x2ed, 0x2ee, 0x2f0, 0x2f0, 0x2f5, 0x2f6, 0x2f8, 0x2f9, 
       0x7, 0x2, 0x94, 0x94, 0xf7, 0xf7, 0x113, 0x113, 0x207, 0x207, 0x20a, 
       0x20a, 0x8, 0x2, 0xd9, 0xd9, 0xde, 0xde, 0x1a6, 0x1a6, 0x255, 0x255, 
       0x291, 0x291, 0x2a7, 0x2a7, 0x2, 0x24c4, 0x2, 0x4b6, 0x3, 0x2, 0x2, 
       0x2, 0x4, 0x4bf, 0x3, 0x2, 0x2, 0x2, 0x6, 0x4d0, 0x3, 0x2, 0x2, 0x2, 
       0x8, 0x4f4, 0x3, 0x2, 0x2, 0x2, 0xa, 0x4f6, 0x3, 0x2, 0x2, 0x2, 0xc, 
       0x513, 0x3, 0x2, 0x2, 0x2, 0xe, 0x522, 0x3, 0x2, 0x2, 0x2, 0x10, 
       0x548, 0x3, 0x2, 0x2, 0x2, 0x12, 0x551, 0x3, 0x2, 0x2, 0x2, 0x14, 
       0x55e, 0x3, 0x2, 0x2, 0x2, 0x16, 0x560, 0x3, 0x2, 0x2, 0x2, 0x18, 
       0x565, 0x3, 0x2, 0x2, 0x2, 0x1a, 0x57d, 0x3, 0x2, 0x2, 0x2, 0x1c, 
       0x586, 0x3, 0x2, 0x2, 0x2, 0x1e, 0x588, 0x3, 0x2, 0x2, 0x2, 0x20, 
       0x597, 0x3, 0x2, 0x2, 0x2, 0x22, 0x5fa, 0x3, 0x2, 0x2, 0x2, 0x24, 
       0x5fe, 0x3, 0x2, 0x2, 0x2, 0x26, 0x610, 0x3, 0x2, 0x2, 0x2, 0x28, 
       0x697, 0x3, 0x2, 0x2, 0x2, 0x2a, 0x69c, 0x3, 0x2, 0x2, 0x2, 0x2c, 
       0x69e, 0x3, 0x2, 0x2, 0x2, 0x2e, 0x6a0, 0x3, 0x2, 0x2, 0x2, 0x30, 
       0x6ae, 0x3, 0x2, 0x2, 0x2, 0x32, 0x6b6, 0x3, 0x2, 0x2, 0x2, 0x34, 
       0x6be, 0x3, 0x2, 0x2, 0x2, 0x36, 0x6c9, 0x3, 0x2, 0x2, 0x2, 0x38, 
       0x6cd, 0x3, 0x2, 0x2, 0x2, 0x3a, 0x6d2, 0x3, 0x2, 0x2, 0x2, 0x3c, 
       0x6d4, 0x3, 0x2, 0x2, 0x2, 0x3e, 0x6df, 0x3, 0x2, 0x2, 0x2, 0x40, 
       0x704, 0x3, 0x2, 0x2, 0x2, 0x42, 0x70c, 0x3, 0x2, 0x2, 0x2, 0x44, 
       0x716, 0x3, 0x2, 0x2, 0x2, 0x46, 0x718, 0x3, 0x2, 0x2, 0x2, 0x48, 
       0x72c, 0x3, 0x2, 0x2, 0x2, 0x4a, 0x735, 0x3, 0x2, 0x2, 0x2, 0x4c, 
       0x738, 0x3, 0x2, 0x2, 0x2, 0x4e, 0x745, 0x3, 0x2, 0x2, 0x2, 0x50, 
       0x74a, 0x3, 0x2, 0x2, 0x2, 0x52, 0x74e, 0x3, 0x2, 0x2, 0x2, 0x54, 
       0x755, 0x3, 0x2, 0x2, 0x2, 0x56, 0x76a, 0x3, 0x2, 0x2, 0x2, 0x58, 
       0x779, 0x3, 0x2, 0x2, 0x2, 0x5a, 0x77c, 0x3, 0x2, 0x2, 0x2, 0x5c, 
       0x79b, 0x3, 0x2, 0x2, 0x2, 0x5e, 0x7a5, 0x3, 0x2, 0x2, 0x2, 0x60, 
       0x7a8, 0x3, 0x2, 0x2, 0x2, 0x62, 0x7b1, 0x3, 0x2, 0x2, 0x2, 0x64, 
       0x7b3, 0x3, 0x2, 0x2, 0x2, 0x66, 0x7bf, 0x3, 0x2, 0x2, 0x2, 0x68, 
       0x7d8, 0x3, 0x2, 0x2, 0x2, 0x6a, 0x7f3, 0x3, 0x2, 0x2, 0x2, 0x6c, 
       0x801, 0x3, 0x2, 0x2, 0x2, 0x6e, 0x804, 0x3, 0x2, 0x2, 0x2, 0x70, 
       0x819, 0x3, 0x2, 0x2, 0x2, 0x72, 0x81c, 0x3, 0x2, 0x2, 0x2, 0x74, 
       0x855, 0x3, 0x2, 0x2, 0x2, 0x76, 0x857, 0x3, 0x2, 0x2, 0x2, 0x78, 
       0x85b, 0x3, 0x2, 0x2, 0x2, 0x7a, 0x864, 0x3, 0x2, 0x2, 0x2, 0x7c, 
       0x874, 0x3, 0x2, 0x2, 0x2, 0x7e, 0x876, 0x3, 0x2, 0x2, 0x2, 0x80, 
       0x87e, 0x3, 0x2, 0x2, 0x2, 0x82, 0x898, 0x3, 0x2, 0x2, 0x2, 0x84, 
       0x89a, 0x3, 0x2, 0x2, 0x2, 0x86, 0x8a6, 0x3, 0x2, 0x2, 0x2, 0x88, 
       0x8b5, 0x3, 0x2, 0x2, 0x2, 0x8a, 0x8b7, 0x3, 0x2, 0x2, 0x2, 0x8c, 
       0x8ba, 0x3, 0x2, 0x2, 0x2, 0x8e, 0x8d0, 0x3, 0x2, 0x2, 0x2, 0x90, 
       0x8d2, 0x3, 0x2, 0x2, 0x2, 0x92, 0x8d8, 0x3, 0x2, 0x2, 0x2, 0x94, 
       0x8de, 0x3, 0x2, 0x2, 0x2, 0x96, 0x8e4, 0x3, 0x2, 0x2, 0x2, 0x98, 
       0x8ea, 0x3, 0x2, 0x2, 0x2, 0x9a, 0x8f0, 0x3, 0x2, 0x2, 0x2, 0x9c, 
       0x8f7, 0x3, 0x2, 0x2, 0x2, 0x9e, 0x8ff, 0x3, 0x2, 0x2, 0x2, 0xa0, 
       0x901, 0x3, 0x2, 0x2, 0x2, 0xa2, 0x907, 0x3, 0x2, 0x2, 0x2, 0xa4, 
       0x90d, 0x3, 0x2, 0x2, 0x2, 0xa6, 0x914, 0x3, 0x2, 0x2, 0x2, 0xa8, 
       0x926, 0x3, 0x2, 0x2, 0x2, 0xaa, 0x928, 0x3, 0x2, 0x2, 0x2, 0xac, 
       0x92c, 0x3, 0x2, 0x2, 0x2, 0xae, 0x931, 0x3, 0x2, 0x2, 0x2, 0xb0, 
       0x941, 0x3, 0x2, 0x2, 0x2, 0xb2, 0x946, 0x3, 0x2, 0x2, 0x2, 0xb4, 
       0x967, 0x3, 0x2, 0x2, 0x2, 0xb6, 0x986, 0x3, 0x2, 0x2, 0x2, 0xb8, 
       0x997, 0x3, 0x2, 0x2, 0x2, 0xba, 0x999, 0x3, 0x2, 0x2, 0x2, 0xbc, 
       0x9ad, 0x3, 0x2, 0x2, 0x2, 0xbe, 0x9b3, 0x3, 0x2, 0x2, 0x2, 0xc0, 
       0x9b9, 0x3, 0x2, 0x2, 0x2, 0xc2, 0x9bf, 0x3, 0x2, 0x2, 0x2, 0xc4, 
       0x9c6, 0x3, 0x2, 0x2, 0x2, 0xc6, 0x9cf, 0x3, 0x2, 0x2, 0x2, 0xc8, 
       0x9e0, 0x3, 0x2, 0x2, 0x2, 0xca, 0x9e2, 0x3, 0x2, 0x2, 0x2, 0xcc, 
       0x9e9, 0x3, 0x2, 0x2, 0x2, 0xce, 0x9f3, 0x3, 0x2, 0x2, 0x2, 0xd0, 
       0xa01, 0x3, 0x2, 0x2, 0x2, 0xd2, 0xa07, 0x3, 0x2, 0x2, 0x2, 0xd4, 
       0xa0f, 0x3, 0x2, 0x2, 0x2, 0xd6, 0xa15, 0x3, 0x2, 0x2, 0x2, 0xd8, 
       0xa1d, 0x3, 0x2, 0x2, 0x2, 0xda, 0xa23, 0x3, 0x2, 0x2, 0x2, 0xdc, 
       0xa2d, 0x3, 0x2, 0x2, 0x2, 0xde, 0xa31, 0x3, 0x2, 0x2, 0x2, 0xe0, 
       0xa37, 0x3, 0x2, 0x2, 0x2, 0xe2, 0xa3c, 0x3, 0x2, 0x2, 0x2, 0xe4, 
       0xa47, 0x3, 0x2, 0x2, 0x2, 0xe6, 0xa72, 0x3, 0x2, 0x2, 0x2, 0xe8, 
       0xa78, 0x3, 0x2, 0x2, 0x2, 0xea, 0xa7a, 0x3, 0x2, 0x2, 0x2, 0xec, 
       0xa81, 0x3, 0x2, 0x2, 0x2, 0xee, 0xa9f, 0x3, 0x2, 0x2, 0x2, 0xf0, 
       0xaa1, 0x3, 0x2, 0x2, 0x2, 0xf2, 0xab8, 0x3, 0x2, 0x2, 0x2, 0xf4, 
       0xabf, 0x3, 0x2, 0x2, 0x2, 0xf6, 0xac3, 0x3, 0x2, 0x2, 0x2, 0xf8, 
       0xacb, 0x3, 0x2, 0x2, 0x2, 0xfa, 0xad5, 0x3, 0x2, 0x2, 0x2, 0xfc, 
       0xad7, 0x3, 0x2, 0x2, 0x2, 0xfe, 0xae9, 0x3, 0x2, 0x2, 0x2, 0x100, 
       0xaf5, 0x3, 0x2, 0x2, 0x2, 0x102, 0xafb, 0x3, 0x2, 0x2, 0x2, 0x104, 
       0xb1c, 0x3, 0x2, 0x2, 0x2, 0x106, 0xb1e, 0x3, 0x2, 0x2, 0x2, 0x108, 
       0xb26, 0x3, 0x2, 0x2, 0x2, 0x10a, 0xb2f, 0x3, 0x2, 0x2, 0x2, 0x10c, 
       0xb37, 0x3, 0x2, 0x2, 0x2, 0x10e, 0xb43, 0x3, 0x2, 0x2, 0x2, 0x110, 
       0xb57, 0x3, 0x2, 0x2, 0x2, 0x112, 0xb60, 0x3, 0x2, 0x2, 0x2, 0x114, 
       0xb84, 0x3, 0x2, 0x2, 0x2, 0x116, 0xb91, 0x3, 0x2, 0x2, 0x2, 0x118, 
       0xba1, 0x3, 0x2, 0x2, 0x2, 0x11a, 0xba8, 0x3, 0x2, 0x2, 0x2, 0x11c, 
       0xbc3, 0x3, 0x2, 0x2, 0x2, 0x11e, 0xbc5, 0x3, 0x2, 0x2, 0x2, 0x120, 
       0xbc7, 0x3, 0x2, 0x2, 0x2, 0x122, 0xbca, 0x3, 0x2, 0x2, 0x2, 0x124, 
       0xbcd, 0x3, 0x2, 0x2, 0x2, 0x126, 0xbd4, 0x3, 0x2, 0x2, 0x2, 0x128, 
       0xbd6, 0x3, 0x2, 0x2, 0x2, 0x12a, 0xbf4, 0x3, 0x2, 0x2, 0x2, 0x12c, 
       0xc00, 0x3, 0x2, 0x2, 0x2, 0x12e, 0xc03, 0x3, 0x2, 0x2, 0x2, 0x130, 
       0xc0c, 0x3, 0x2, 0x2, 0x2, 0x132, 0xc10, 0x3, 0x2, 0x2, 0x2, 0x134, 
       0xc15, 0x3, 0x2, 0x2, 0x2, 0x136, 0xc22, 0x3, 0x2, 0x2, 0x2, 0x138, 
       0xc27, 0x3, 0x2, 0x2, 0x2, 0x13a, 0xc2b, 0x3, 0x2, 0x2, 0x2, 0x13c, 
       0xc3b, 0x3, 0x2, 0x2, 0x2, 0x13e, 0xc3d, 0x3, 0x2, 0x2, 0x2, 0x140, 
       0xc4f, 0x3, 0x2, 0x2, 0x2, 0x142, 0xc51, 0x3, 0x2, 0x2, 0x2, 0x144, 
       0xc5a, 0x3, 0x2, 0x2, 0x2, 0x146, 0xc66, 0x3, 0x2, 0x2, 0x2, 0x148, 
       0xc6d, 0x3, 0x2, 0x2, 0x2, 0x14a, 0xc78, 0x3, 0x2, 0x2, 0x2, 0x14c, 
       0xc7a, 0x3, 0x2, 0x2, 0x2, 0x14e, 0xc7e, 0x3, 0x2, 0x2, 0x2, 0x150, 
       0xc80, 0x3, 0x2, 0x2, 0x2, 0x152, 0xc85, 0x3, 0x2, 0x2, 0x2, 0x154, 
       0xc95, 0x3, 0x2, 0x2, 0x2, 0x156, 0xca6, 0x3, 0x2, 0x2, 0x2, 0x158, 
       0xcab, 0x3, 0x2, 0x2, 0x2, 0x15a, 0xcb0, 0x3, 0x2, 0x2, 0x2, 0x15c, 
       0xcb4, 0x3, 0x2, 0x2, 0x2, 0x15e, 0xcc2, 0x3, 0x2, 0x2, 0x2, 0x160, 
       0xcc5, 0x3, 0x2, 0x2, 0x2, 0x162, 0xccb, 0x3, 0x2, 0x2, 0x2, 0x164, 
       0xcd8, 0x3, 0x2, 0x2, 0x2, 0x166, 0xce0, 0x3, 0x2, 0x2, 0x2, 0x168, 
       0xcfa, 0x3, 0x2, 0x2, 0x2, 0x16a, 0xd07, 0x3, 0x2, 0x2, 0x2, 0x16c, 
       0xd0e, 0x3, 0x2, 0x2, 0x2, 0x16e, 0xd10, 0x3, 0x2, 0x2, 0x2, 0x170, 
       0xd1c, 0x3, 0x2, 0x2, 0x2, 0x172, 0xd1e, 0x3, 0x2, 0x2, 0x2, 0x174, 
       0xd28, 0x3, 0x2, 0x2, 0x2, 0x176, 0xd40, 0x3, 0x2, 0x2, 0x2, 0x178, 
       0xd42, 0x3, 0x2, 0x2, 0x2, 0x17a, 0xd49, 0x3, 0x2, 0x2, 0x2, 0x17c, 
       0xd53, 0x3, 0x2, 0x2, 0x2, 0x17e, 0xd76, 0x3, 0x2, 0x2, 0x2, 0x180, 
       0xd80, 0x3, 0x2, 0x2, 0x2, 0x182, 0xd82, 0x3, 0x2, 0x2, 0x2, 0x184, 
       0xd86, 0x3, 0x2, 0x2, 0x2, 0x186, 0xd8e, 0x3, 0x2, 0x2, 0x2, 0x188, 
       0xd90, 0x3, 0x2, 0x2, 0x2, 0x18a, 0xd95, 0x3, 0x2, 0x2, 0x2, 0x18c, 
       0xd99, 0x3, 0x2, 0x2, 0x2, 0x18e, 0xdb5, 0x3, 0x2, 0x2, 0x2, 0x190, 
       0xdb7, 0x3, 0x2, 0x2, 0x2, 0x192, 0xdb9, 0x3, 0x2, 0x2, 0x2, 0x194, 
       0xdc1, 0x3, 0x2, 0x2, 0x2, 0x196, 0xdc3, 0x3, 0x2, 0x2, 0x2, 0x198, 
       0xdcb, 0x3, 0x2, 0x2, 0x2, 0x19a, 0xdd5, 0x3, 0x2, 0x2, 0x2, 0x19c, 
       0xdd9, 0x3, 0x2, 0x2, 0x2, 0x19e, 0xdf2, 0x3, 0x2, 0x2, 0x2, 0x1a0, 
       0xe0d, 0x3, 0x2, 0x2, 0x2, 0x1a2, 0xe0f, 0x3, 0x2, 0x2, 0x2, 0x1a4, 
       0xe19, 0x3, 0x2, 0x2, 0x2, 0x1a6, 0xe21, 0x3, 0x2, 0x2, 0x2, 0x1a8, 
       0xe28, 0x3, 0x2, 0x2, 0x2, 0x1aa, 0xe47, 0x3, 0x2, 0x2, 0x2, 0x1ac, 
       0xe5f, 0x3, 0x2, 0x2, 0x2, 0x1ae, 0xe61, 0x3, 0x2, 0x2, 0x2, 0x1b0, 
       0xe6f, 0x3, 0x2, 0x2, 0x2, 0x1b2, 0xe71, 0x3, 0x2, 0x2, 0x2, 0x1b4, 
       0xe94, 0x3, 0x2, 0x2, 0x2, 0x1b6, 0xe96, 0x3, 0x2, 0x2, 0x2, 0x1b8, 
       0xec0, 0x3, 0x2, 0x2, 0x2, 0x1ba, 0xed0, 0x3, 0x2, 0x2, 0x2, 0x1bc, 
       0xed2, 0x3, 0x2, 0x2, 0x2, 0x1be, 0xeda, 0x3, 0x2, 0x2, 0x2, 0x1c0, 
       0xee3, 0x3, 0x2, 0x2, 0x2, 0x1c2, 0xeea, 0x3, 0x2, 0x2, 0x2, 0x1c4, 
       0xf3b, 0x3, 0x2, 0x2, 0x2, 0x1c6, 0xf49, 0x3, 0x2, 0x2, 0x2, 0x1c8, 
       0xf4b, 0x3, 0x2, 0x2, 0x2, 0x1ca, 0xf58, 0x3, 0x2, 0x2, 0x2, 0x1cc, 
       0xf98, 0x3, 0x2, 0x2, 0x2, 0x1ce, 0xf9a, 0x3, 0x2, 0x2, 0x2, 0x1d0, 
       0xfa2, 0x3, 0x2, 0x2, 0x2, 0x1d2, 0xfaa, 0x3, 0x2, 0x2, 0x2, 0x1d4, 
       0xfb2, 0x3, 0x2, 0x2, 0x2, 0x1d6, 0xfb4, 0x3, 0x2, 0x2, 0x2, 0x1d8, 
       0xfd1, 0x3, 0x2, 0x2, 0x2, 0x1da, 0xfda, 0x3, 0x2, 0x2, 0x2, 0x1dc, 
       0xff9, 0x3, 0x2, 0x2, 0x2, 0x1de, 0xffb, 0x3, 0x2, 0x2, 0x2, 0x1e0, 
       0x1003, 0x3, 0x2, 0x2, 0x2, 0x1e2, 0x1005, 0x3, 0x2, 0x2, 0x2, 0x1e4, 
       0x1013, 0x3, 0x2, 0x2, 0x2, 0x1e6, 0x1015, 0x3, 0x2, 0x2, 0x2, 0x1e8, 
       0x101b, 0x3, 0x2, 0x2, 0x2, 0x1ea, 0x1023, 0x3, 0x2, 0x2, 0x2, 0x1ec, 
       0x1048, 0x3, 0x2, 0x2, 0x2, 0x1ee, 0x104a, 0x3, 0x2, 0x2, 0x2, 0x1f0, 
       0x105a, 0x3, 0x2, 0x2, 0x2, 0x1f2, 0x105c, 0x3, 0x2, 0x2, 0x2, 0x1f4, 
       0x1088, 0x3, 0x2, 0x2, 0x2, 0x1f6, 0x108a, 0x3, 0x2, 0x2, 0x2, 0x1f8, 
       0x10a3, 0x3, 0x2, 0x2, 0x2, 0x1fa, 0x10ac, 0x3, 0x2, 0x2, 0x2, 0x1fc, 
       0x10ae, 0x3, 0x2, 0x2, 0x2, 0x1fe, 0x10b3, 0x3, 0x2, 0x2, 
  };
  static uint16_t serializedATNSegment1[] = {
    0x2, 0x200, 0x10e1, 0x3, 0x2, 0x2, 0x2, 0x202, 0x10e3, 0x3, 0x2, 0x2, 
       0x2, 0x204, 0x10eb, 0x3, 0x2, 0x2, 0x2, 0x206, 0x111c, 0x3, 0x2, 
       0x2, 0x2, 0x208, 0x1129, 0x3, 0x2, 0x2, 0x2, 0x20a, 0x112b, 0x3, 
       0x2, 0x2, 0x2, 0x20c, 0x112e, 0x3, 0x2, 0x2, 0x2, 0x20e, 0x1139, 
       0x3, 0x2, 0x2, 0x2, 0x210, 0x113e, 0x3, 0x2, 0x2, 0x2, 0x212, 0x1141, 
       0x3, 0x2, 0x2, 0x2, 0x214, 0x1150, 0x3, 0x2, 0x2, 0x2, 0x216, 0x1182, 
       0x3, 0x2, 0x2, 0x2, 0x218, 0x1184, 0x3, 0x2, 0x2, 0x2, 0x21a, 0x1186, 
       0x3, 0x2, 0x2, 0x2, 0x21c, 0x11a3, 0x3, 0x2, 0x2, 0x2, 0x21e, 0x11d4, 
       0x3, 0x2, 0x2, 0x2, 0x220, 0x11e6, 0x3, 0x2, 0x2, 0x2, 0x222, 0x11e8, 
       0x3, 0x2, 0x2, 0x2, 0x224, 0x11f8, 0x3, 0x2, 0x2, 0x2, 0x226, 0x1204, 
       0x3, 0x2, 0x2, 0x2, 0x228, 0x121d, 0x3, 0x2, 0x2, 0x2, 0x22a, 0x121f, 
       0x3, 0x2, 0x2, 0x2, 0x22c, 0x1227, 0x3, 0x2, 0x2, 0x2, 0x22e, 0x1257, 
       0x3, 0x2, 0x2, 0x2, 0x230, 0x1266, 0x3, 0x2, 0x2, 0x2, 0x232, 0x126b, 
       0x3, 0x2, 0x2, 0x2, 0x234, 0x126d, 0x3, 0x2, 0x2, 0x2, 0x236, 0x1285, 
       0x3, 0x2, 0x2, 0x2, 0x238, 0x1287, 0x3, 0x2, 0x2, 0x2, 0x23a, 0x12b7, 
       0x3, 0x2, 0x2, 0x2, 0x23c, 0x12b9, 0x3, 0x2, 0x2, 0x2, 0x23e, 0x12bf, 
       0x3, 0x2, 0x2, 0x2, 0x240, 0x12c7, 0x3, 0x2, 0x2, 0x2, 0x242, 0x12c9, 
       0x3, 0x2, 0x2, 0x2, 0x244, 0x12d7, 0x3, 0x2, 0x2, 0x2, 0x246, 0x12d9, 
       0x3, 0x2, 0x2, 0x2, 0x248, 0x13bd, 0x3, 0x2, 0x2, 0x2, 0x24a, 0x13c4, 
       0x3, 0x2, 0x2, 0x2, 0x24c, 0x13c6, 0x3, 0x2, 0x2, 0x2, 0x24e, 0x13c8, 
       0x3, 0x2, 0x2, 0x2, 0x250, 0x13d2, 0x3, 0x2, 0x2, 0x2, 0x252, 0x13f9, 
       0x3, 0x2, 0x2, 0x2, 0x254, 0x13fd, 0x3, 0x2, 0x2, 0x2, 0x256, 0x13ff, 
       0x3, 0x2, 0x2, 0x2, 0x258, 0x1407, 0x3, 0x2, 0x2, 0x2, 0x25a, 0x140b, 
       0x3, 0x2, 0x2, 0x2, 0x25c, 0x1413, 0x3, 0x2, 0x2, 0x2, 0x25e, 0x141c, 
       0x3, 0x2, 0x2, 0x2, 0x260, 0x141e, 0x3, 0x2, 0x2, 0x2, 0x262, 0x1435, 
       0x3, 0x2, 0x2, 0x2, 0x264, 0x1437, 0x3, 0x2, 0x2, 0x2, 0x266, 0x1439, 
       0x3, 0x2, 0x2, 0x2, 0x268, 0x1449, 0x3, 0x2, 0x2, 0x2, 0x26a, 0x1455, 
       0x3, 0x2, 0x2, 0x2, 0x26c, 0x1457, 0x3, 0x2, 0x2, 0x2, 0x26e, 0x145f, 
       0x3, 0x2, 0x2, 0x2, 0x270, 0x1467, 0x3, 0x2, 0x2, 0x2, 0x272, 0x1470, 
       0x3, 0x2, 0x2, 0x2, 0x274, 0x1472, 0x3, 0x2, 0x2, 0x2, 0x276, 0x1484, 
       0x3, 0x2, 0x2, 0x2, 0x278, 0x1492, 0x3, 0x2, 0x2, 0x2, 0x27a, 0x1497, 
       0x3, 0x2, 0x2, 0x2, 0x27c, 0x149d, 0x3, 0x2, 0x2, 0x2, 0x27e, 0x149f, 
       0x3, 0x2, 0x2, 0x2, 0x280, 0x14af, 0x3, 0x2, 0x2, 0x2, 0x282, 0x14b7, 
       0x3, 0x2, 0x2, 0x2, 0x284, 0x14c1, 0x3, 0x2, 0x2, 0x2, 0x286, 0x14ce, 
       0x3, 0x2, 0x2, 0x2, 0x288, 0x14d0, 0x3, 0x2, 0x2, 0x2, 0x28a, 0x14d6, 
       0x3, 0x2, 0x2, 0x2, 0x28c, 0x14ef, 0x3, 0x2, 0x2, 0x2, 0x28e, 0x14f1, 
       0x3, 0x2, 0x2, 0x2, 0x290, 0x14f4, 0x3, 0x2, 0x2, 0x2, 0x292, 0x14f7, 
       0x3, 0x2, 0x2, 0x2, 0x294, 0x1504, 0x3, 0x2, 0x2, 0x2, 0x296, 0x1514, 
       0x3, 0x2, 0x2, 0x2, 0x298, 0x152b, 0x3, 0x2, 0x2, 0x2, 0x29a, 0x152d, 
       0x3, 0x2, 0x2, 0x2, 0x29c, 0x1552, 0x3, 0x2, 0x2, 0x2, 0x29e, 0x1554, 
       0x3, 0x2, 0x2, 0x2, 0x2a0, 0x15dc, 0x3, 0x2, 0x2, 0x2, 0x2a2, 0x15e9, 
       0x3, 0x2, 0x2, 0x2, 0x2a4, 0x15f2, 0x3, 0x2, 0x2, 0x2, 0x2a6, 0x1677, 
       0x3, 0x2, 0x2, 0x2, 0x2a8, 0x1679, 0x3, 0x2, 0x2, 0x2, 0x2aa, 0x16a8, 
       0x3, 0x2, 0x2, 0x2, 0x2ac, 0x16aa, 0x3, 0x2, 0x2, 0x2, 0x2ae, 0x16af, 
       0x3, 0x2, 0x2, 0x2, 0x2b0, 0x16b8, 0x3, 0x2, 0x2, 0x2, 0x2b2, 0x16cb, 
       0x3, 0x2, 0x2, 0x2, 0x2b4, 0x16ce, 0x3, 0x2, 0x2, 0x2, 0x2b6, 0x16d7, 
       0x3, 0x2, 0x2, 0x2, 0x2b8, 0x16d9, 0x3, 0x2, 0x2, 0x2, 0x2ba, 0x16f0, 
       0x3, 0x2, 0x2, 0x2, 0x2bc, 0x1804, 0x3, 0x2, 0x2, 0x2, 0x2be, 0x1825, 
       0x3, 0x2, 0x2, 0x2, 0x2c0, 0x1827, 0x3, 0x2, 0x2, 0x2, 0x2c2, 0x182d, 
       0x3, 0x2, 0x2, 0x2, 0x2c4, 0x1830, 0x3, 0x2, 0x2, 0x2, 0x2c6, 0x183f, 
       0x3, 0x2, 0x2, 0x2, 0x2c8, 0x1847, 0x3, 0x2, 0x2, 0x2, 0x2ca, 0x1849, 
       0x3, 0x2, 0x2, 0x2, 0x2cc, 0x1866, 0x3, 0x2, 0x2, 0x2, 0x2ce, 0x1887, 
       0x3, 0x2, 0x2, 0x2, 0x2d0, 0x1889, 0x3, 0x2, 0x2, 0x2, 0x2d2, 0x1891, 
       0x3, 0x2, 0x2, 0x2, 0x2d4, 0x189b, 0x3, 0x2, 0x2, 0x2, 0x2d6, 0x18a0, 
       0x3, 0x2, 0x2, 0x2, 0x2d8, 0x18a2, 0x3, 0x2, 0x2, 0x2, 0x2da, 0x18b8, 
       0x3, 0x2, 0x2, 0x2, 0x2dc, 0x18ba, 0x3, 0x2, 0x2, 0x2, 0x2de, 0x18bd, 
       0x3, 0x2, 0x2, 0x2, 0x2e0, 0x18c0, 0x3, 0x2, 0x2, 0x2, 0x2e2, 0x18f0, 
       0x3, 0x2, 0x2, 0x2, 0x2e4, 0x18f2, 0x3, 0x2, 0x2, 0x2, 0x2e6, 0x18fd, 
       0x3, 0x2, 0x2, 0x2, 0x2e8, 0x18ff, 0x3, 0x2, 0x2, 0x2, 0x2ea, 0x1901, 
       0x3, 0x2, 0x2, 0x2, 0x2ec, 0x1905, 0x3, 0x2, 0x2, 0x2, 0x2ee, 0x1907, 
       0x3, 0x2, 0x2, 0x2, 0x2f0, 0x1909, 0x3, 0x2, 0x2, 0x2, 0x2f2, 0x190d, 
       0x3, 0x2, 0x2, 0x2, 0x2f4, 0x1911, 0x3, 0x2, 0x2, 0x2, 0x2f6, 0x1915, 
       0x3, 0x2, 0x2, 0x2, 0x2f8, 0x191d, 0x3, 0x2, 0x2, 0x2, 0x2fa, 0x1921, 
       0x3, 0x2, 0x2, 0x2, 0x2fc, 0x1929, 0x3, 0x2, 0x2, 0x2, 0x2fe, 0x192b, 
       0x3, 0x2, 0x2, 0x2, 0x300, 0x193d, 0x3, 0x2, 0x2, 0x2, 0x302, 0x193f, 
       0x3, 0x2, 0x2, 0x2, 0x304, 0x1942, 0x3, 0x2, 0x2, 0x2, 0x306, 0x1947, 
       0x3, 0x2, 0x2, 0x2, 0x308, 0x194f, 0x3, 0x2, 0x2, 0x2, 0x30a, 0x1955, 
       0x3, 0x2, 0x2, 0x2, 0x30c, 0x1959, 0x3, 0x2, 0x2, 0x2, 0x30e, 0x196a, 
       0x3, 0x2, 0x2, 0x2, 0x310, 0x196d, 0x3, 0x2, 0x2, 0x2, 0x312, 0x1972, 
       0x3, 0x2, 0x2, 0x2, 0x314, 0x1974, 0x3, 0x2, 0x2, 0x2, 0x316, 0x1977, 
       0x3, 0x2, 0x2, 0x2, 0x318, 0x1980, 0x3, 0x2, 0x2, 0x2, 0x31a, 0x1988, 
       0x3, 0x2, 0x2, 0x2, 0x31c, 0x198a, 0x3, 0x2, 0x2, 0x2, 0x31e, 0x198f, 
       0x3, 0x2, 0x2, 0x2, 0x320, 0x1996, 0x3, 0x2, 0x2, 0x2, 0x322, 0x19a0, 
       0x3, 0x2, 0x2, 0x2, 0x324, 0x19a8, 0x3, 0x2, 0x2, 0x2, 0x326, 0x19aa, 
       0x3, 0x2, 0x2, 0x2, 0x328, 0x19b4, 0x3, 0x2, 0x2, 0x2, 0x32a, 0x19bc, 
       0x3, 0x2, 0x2, 0x2, 0x32c, 0x19be, 0x3, 0x2, 0x2, 0x2, 0x32e, 0x19c4, 
       0x3, 0x2, 0x2, 0x2, 0x330, 0x19d9, 0x3, 0x2, 0x2, 0x2, 0x332, 0x19db, 
       0x3, 0x2, 0x2, 0x2, 0x334, 0x19e1, 0x3, 0x2, 0x2, 0x2, 0x336, 0x19e4, 
       0x3, 0x2, 0x2, 0x2, 0x338, 0x19e7, 0x3, 0x2, 0x2, 0x2, 0x33a, 0x1a05, 
       0x3, 0x2, 0x2, 0x2, 0x33c, 0x1a09, 0x3, 0x2, 0x2, 0x2, 0x33e, 0x1a10, 
       0x3, 0x2, 0x2, 0x2, 0x340, 0x1a17, 0x3, 0x2, 0x2, 0x2, 0x342, 0x1a19, 
       0x3, 0x2, 0x2, 0x2, 0x344, 0x1a29, 0x3, 0x2, 0x2, 0x2, 0x346, 0x1a3c, 
       0x3, 0x2, 0x2, 0x2, 0x348, 0x1a40, 0x3, 0x2, 0x2, 0x2, 0x34a, 0x1a43, 
       0x3, 0x2, 0x2, 0x2, 0x34c, 0x1a46, 0x3, 0x2, 0x2, 0x2, 0x34e, 0x1a5e, 
       0x3, 0x2, 0x2, 0x2, 0x350, 0x1a60, 0x3, 0x2, 0x2, 0x2, 0x352, 0x1a68, 
       0x3, 0x2, 0x2, 0x2, 0x354, 0x1a6a, 0x3, 0x2, 0x2, 0x2, 0x356, 0x1a6e, 
       0x3, 0x2, 0x2, 0x2, 0x358, 0x1abd, 0x3, 0x2, 0x2, 0x2, 0x35a, 0x1abf, 
       0x3, 0x2, 0x2, 0x2, 0x35c, 0x1ac3, 0x3, 0x2, 0x2, 0x2, 0x35e, 0x1b1d, 
       0x3, 0x2, 0x2, 0x2, 0x360, 0x1b1f, 0x3, 0x2, 0x2, 0x2, 0x362, 0x1b21, 
       0x3, 0x2, 0x2, 0x2, 0x364, 0x1b31, 0x3, 0x2, 0x2, 0x2, 0x366, 0x1b33, 
       0x3, 0x2, 0x2, 0x2, 0x368, 0x1b53, 0x3, 0x2, 0x2, 0x2, 0x36a, 0x1b55, 
       0x3, 0x2, 0x2, 0x2, 0x36c, 0x1b60, 0x3, 0x2, 0x2, 0x2, 0x36e, 0x1b67, 
       0x3, 0x2, 0x2, 0x2, 0x370, 0x1b77, 0x3, 0x2, 0x2, 0x2, 0x372, 0x1b7d, 
       0x3, 0x2, 0x2, 0x2, 0x374, 0x1b7f, 0x3, 0x2, 0x2, 0x2, 0x376, 0x1b83, 
       0x3, 0x2, 0x2, 0x2, 0x378, 0x1b8f, 0x3, 0x2, 0x2, 0x2, 0x37a, 0x1b91, 
       0x3, 0x2, 0x2, 0x2, 0x37c, 0x1b93, 0x3, 0x2, 0x2, 0x2, 0x37e, 0x1b9a, 
       0x3, 0x2, 0x2, 0x2, 0x380, 0x1b9c, 0x3, 0x2, 0x2, 0x2, 0x382, 0x1b9e, 
       0x3, 0x2, 0x2, 0x2, 0x384, 0x1c34, 0x3, 0x2, 0x2, 0x2, 0x386, 0x1c39, 
       0x3, 0x2, 0x2, 0x2, 0x388, 0x1c3e, 0x3, 0x2, 0x2, 0x2, 0x38a, 0x1c4a, 
       0x3, 0x2, 0x2, 0x2, 0x38c, 0x1c51, 0x3, 0x2, 0x2, 0x2, 0x38e, 0x1c53, 
       0x3, 0x2, 0x2, 0x2, 0x390, 0x1c5b, 0x3, 0x2, 0x2, 0x2, 0x392, 0x1c6d, 
       0x3, 0x2, 0x2, 0x2, 0x394, 0x1c75, 0x3, 0x2, 0x2, 0x2, 0x396, 0x1c7d, 
       0x3, 0x2, 0x2, 0x2, 0x398, 0x1c7f, 0x3, 0x2, 0x2, 0x2, 0x39a, 0x1c83, 
       0x3, 0x2, 0x2, 0x2, 0x39c, 0x1c8c, 0x3, 0x2, 0x2, 0x2, 0x39e, 0x1c91, 
       0x3, 0x2, 0x2, 0x2, 0x3a0, 0x1c93, 0x3, 0x2, 0x2, 0x2, 0x3a2, 0x1c9e, 
       0x3, 0x2, 0x2, 0x2, 0x3a4, 0x1d24, 0x3, 0x2, 0x2, 0x2, 0x3a6, 0x1d28, 
       0x3, 0x2, 0x2, 0x2, 0x3a8, 0x1d2b, 0x3, 0x2, 0x2, 0x2, 0x3aa, 0x1d34, 
       0x3, 0x2, 0x2, 0x2, 0x3ac, 0x1d3d, 0x3, 0x2, 0x2, 0x2, 0x3ae, 0x1d45, 
       0x3, 0x2, 0x2, 0x2, 0x3b0, 0x1d73, 0x3, 0x2, 0x2, 0x2, 0x3b2, 0x1d75, 
       0x3, 0x2, 0x2, 0x2, 0x3b4, 0x1d8a, 0x3, 0x2, 0x2, 0x2, 0x3b6, 0x1d8f, 
       0x3, 0x2, 0x2, 0x2, 0x3b8, 0x1d9a, 0x3, 0x2, 0x2, 0x2, 0x3ba, 0x1dc7, 
       0x3, 0x2, 0x2, 0x2, 0x3bc, 0x1deb, 0x3, 0x2, 0x2, 0x2, 0x3be, 0x1ded, 
       0x3, 0x2, 0x2, 0x2, 0x3c0, 0x1df5, 0x3, 0x2, 0x2, 0x2, 0x3c2, 0x1e02, 
       0x3, 0x2, 0x2, 0x2, 0x3c4, 0x1e04, 0x3, 0x2, 0x2, 0x2, 0x3c6, 0x1e08, 
       0x3, 0x2, 0x2, 0x2, 0x3c8, 0x1e0b, 0x3, 0x2, 0x2, 0x2, 0x3ca, 0x1e10, 
       0x3, 0x2, 0x2, 0x2, 0x3cc, 0x1e14, 0x3, 0x2, 0x2, 0x2, 0x3ce, 0x1e17, 
       0x3, 0x2, 0x2, 0x2, 0x3d0, 0x1e1a, 0x3, 0x2, 0x2, 0x2, 0x3d2, 0x1e1e, 
       0x3, 0x2, 0x2, 0x2, 0x3d4, 0x1e24, 0x3, 0x2, 0x2, 0x2, 0x3d6, 0x1e2c, 
       0x3, 0x2, 0x2, 0x2, 0x3d8, 0x1e34, 0x3, 0x2, 0x2, 0x2, 0x3da, 0x1e3a, 
       0x3, 0x2, 0x2, 0x2, 0x3dc, 0x1e3d, 0x3, 0x2, 0x2, 0x2, 0x3de, 0x1e4f, 
       0x3, 0x2, 0x2, 0x2, 0x3e0, 0x1e51, 0x3, 0x2, 0x2, 0x2, 0x3e2, 0x1e57, 
       0x3, 0x2, 0x2, 0x2, 0x3e4, 0x1e5b, 0x3, 0x2, 0x2, 0x2, 0x3e6, 0x1e63, 
       0x3, 0x2, 0x2, 0x2, 0x3e8, 0x1e6b, 0x3, 0x2, 0x2, 0x2, 0x3ea, 0x1e73, 
       0x3, 0x2, 0x2, 0x2, 0x3ec, 0x1e8b, 0x3, 0x2, 0x2, 0x2, 0x3ee, 0x1eaa, 
       0x3, 0x2, 0x2, 0x2, 0x3f0, 0x1eae, 0x3, 0x2, 0x2, 0x2, 0x3f2, 0x1eb2, 
       0x3, 0x2, 0x2, 0x2, 0x3f4, 0x1ebf, 0x3, 0x2, 0x2, 0x2, 0x3f6, 0x1ec1, 
       0x3, 0x2, 0x2, 0x2, 0x3f8, 0x1ec6, 0x3, 0x2, 0x2, 0x2, 0x3fa, 0x1ec8, 
       0x3, 0x2, 0x2, 0x2, 0x3fc, 0x1ecb, 0x3, 0x2, 0x2, 0x2, 0x3fe, 0x1ecd, 
       0x3, 0x2, 0x2, 0x2, 0x400, 0x1ed6, 0x3, 0x2, 0x2, 0x2, 0x402, 0x1edc, 
       0x3, 0x2, 0x2, 0x2, 0x404, 0x1ede, 0x3, 0x2, 0x2, 0x2, 0x406, 0x1ee0, 
       0x3, 0x2, 0x2, 0x2, 0x408, 0x1eeb, 0x3, 0x2, 0x2, 0x2, 0x40a, 0x1eef, 
       0x3, 0x2, 0x2, 0x2, 0x40c, 0x1ef1, 0x3, 0x2, 0x2, 0x2, 0x40e, 0x1ef3, 
       0x3, 0x2, 0x2, 0x2, 0x410, 0x1ef5, 0x3, 0x2, 0x2, 0x2, 0x412, 0x1efe, 
       0x3, 0x2, 0x2, 0x2, 0x414, 0x1f00, 0x3, 0x2, 0x2, 0x2, 0x416, 0x1f02, 
       0x3, 0x2, 0x2, 0x2, 0x418, 0x1f04, 0x3, 0x2, 0x2, 0x2, 0x41a, 0x1f06, 
       0x3, 0x2, 0x2, 0x2, 0x41c, 0x1f08, 0x3, 0x2, 0x2, 0x2, 0x41e, 0x1f0a, 
       0x3, 0x2, 0x2, 0x2, 0x420, 0x1f0c, 0x3, 0x2, 0x2, 0x2, 0x422, 0x1f10, 
       0x3, 0x2, 0x2, 0x2, 0x424, 0x1f14, 0x3, 0x2, 0x2, 0x2, 0x426, 0x1f16, 
       0x3, 0x2, 0x2, 0x2, 0x428, 0x1f18, 0x3, 0x2, 0x2, 0x2, 0x42a, 0x1f1a, 
       0x3, 0x2, 0x2, 0x2, 0x42c, 0x1f1c, 0x3, 0x2, 0x2, 0x2, 0x42e, 0x1f1e, 
       0x3, 0x2, 0x2, 0x2, 0x430, 0x1f20, 0x3, 0x2, 0x2, 0x2, 0x432, 0x1f22, 
       0x3, 0x2, 0x2, 0x2, 0x434, 0x1f24, 0x3, 0x2, 0x2, 0x2, 0x436, 0x1f26, 
       0x3, 0x2, 0x2, 0x2, 0x438, 0x1f28, 0x3, 0x2, 0x2, 0x2, 0x43a, 0x1f2c, 
       0x3, 0x2, 0x2, 0x2, 0x43c, 0x1f2e, 0x3, 0x2, 0x2, 0x2, 0x43e, 0x1f31, 
       0x3, 0x2, 0x2, 0x2, 0x440, 0x1f3d, 0x3, 0x2, 0x2, 0x2, 0x442, 0x1f3f, 
       0x3, 0x2, 0x2, 0x2, 0x444, 0x1f47, 0x3, 0x2, 0x2, 0x2, 0x446, 0x1f4f, 
       0x3, 0x2, 0x2, 0x2, 0x448, 0x1f53, 0x3, 0x2, 0x2, 0x2, 0x44a, 0x1f55, 
       0x3, 0x2, 0x2, 0x2, 0x44c, 0x1f59, 0x3, 0x2, 0x2, 0x2, 0x44e, 0x1f5b, 
       0x3, 0x2, 0x2, 0x2, 0x450, 0x1f5d, 0x3, 0x2, 0x2, 0x2, 0x452, 0x1f5f, 
       0x3, 0x2, 0x2, 0x2, 0x454, 0x1f61, 0x3, 0x2, 0x2, 0x2, 0x456, 0x1f63, 
       0x3, 0x2, 0x2, 0x2, 0x458, 0x1f68, 0x3, 0x2, 0x2, 0x2, 0x45a, 0x1f6c, 
       0x3, 0x2, 0x2, 0x2, 0x45c, 0x1f6e, 0x3, 0x2, 0x2, 0x2, 0x45e, 0x1f76, 
       0x3, 0x2, 0x2, 0x2, 0x460, 0x1f7a, 0x3, 0x2, 0x2, 0x2, 0x462, 0x1f89, 
       0x3, 0x2, 0x2, 0x2, 0x464, 0x1f8b, 0x3, 0x2, 0x2, 0x2, 0x466, 0x1f8e, 
       0x3, 0x2, 0x2, 0x2, 0x468, 0x1f90, 0x3, 0x2, 0x2, 0x2, 0x46a, 0x1f92, 
       0x3, 0x2, 0x2, 0x2, 0x46c, 0x1f99, 0x3, 0x2, 0x2, 0x2, 0x46e, 0x1fa4, 
       0x3, 0x2, 0x2, 0x2, 0x470, 0x1fab, 0x3, 0x2, 0x2, 0x2, 0x472, 0x1fad, 
       0x3, 0x2, 0x2, 0x2, 0x474, 0x1fbb, 0x3, 0x2, 0x2, 0x2, 0x476, 0x1fc0, 
       0x3, 0x2, 0x2, 0x2, 0x478, 0x1fc5, 0x3, 0x2, 0x2, 0x2, 0x47a, 0x1fcc, 
       0x3, 0x2, 0x2, 0x2, 0x47c, 0x1fd4, 0x3, 0x2, 0x2, 0x2, 0x47e, 0x1fd6, 
       0x3, 0x2, 0x2, 0x2, 0x480, 0x1fde, 0x3, 0x2, 0x2, 0x2, 0x482, 0x1fe0, 
       0x3, 0x2, 0x2, 0x2, 0x484, 0x1fe2, 0x3, 0x2, 0x2, 0x2, 0x486, 0x1fea, 
       0x3, 0x2, 0x2, 0x2, 0x488, 0x1fee, 0x3, 0x2, 0x2, 0x2, 0x48a, 0x1ff0, 
       0x3, 0x2, 0x2, 0x2, 0x48c, 0x1ff2, 0x3, 0x2, 0x2, 0x2, 0x48e, 0x1ffa, 
       0x3, 0x2, 0x2, 0x2, 0x490, 0x1ffe, 0x3, 0x2, 0x2, 0x2, 0x492, 0x2002, 
       0x3, 0x2, 0x2, 0x2, 0x494, 0x2006, 0x3, 0x2, 0x2, 0x2, 0x496, 0x2008, 
       0x3, 0x2, 0x2, 0x2, 0x498, 0x200b, 0x3, 0x2, 0x2, 0x2, 0x49a, 0x200d, 
       0x3, 0x2, 0x2, 0x2, 0x49c, 0x2015, 0x3, 0x2, 0x2, 0x2, 0x49e, 0x2021, 
       0x3, 0x2, 0x2, 0x2, 0x4a0, 0x2034, 0x3, 0x2, 0x2, 0x2, 0x4a2, 0x2036, 
       0x3, 0x2, 0x2, 0x2, 0x4a4, 0x2038, 0x3, 0x2, 0x2, 0x2, 0x4a6, 0x204c, 
       0x3, 0x2, 0x2, 0x2, 0x4a8, 0x204e, 0x3, 0x2, 0x2, 0x2, 0x4aa, 0x2050, 
       0x3, 0x2, 0x2, 0x2, 0x4ac, 0x205c, 0x3, 0x2, 0x2, 0x2, 0x4ae, 0x2062, 
       0x3, 0x2, 0x2, 0x2, 0x4b0, 0x2064, 0x3, 0x2, 0x2, 0x2, 0x4b2, 0x206b, 
       0x3, 0x2, 0x2, 0x2, 0x4b4, 0x2076, 0x3, 0x2, 0x2, 0x2, 0x4b6, 0x4b7, 
       0x5, 0x4, 0x3, 0x2, 0x4b7, 0x3, 0x3, 0x2, 0x2, 0x2, 0x4b8, 0x4bb, 
       0x5, 0x8, 0x5, 0x2, 0x4b9, 0x4bb, 0x5, 0x1a2, 0xd2, 0x2, 0x4ba, 0x4b8, 
       0x3, 0x2, 0x2, 0x2, 0x4ba, 0x4b9, 0x3, 0x2, 0x2, 0x2, 0x4ba, 0x4bb, 
       0x3, 0x2, 0x2, 0x2, 0x4bb, 0x4bc, 0x3, 0x2, 0x2, 0x2, 0x4bc, 0x4be, 
       0x7, 0x21, 0x2, 0x2, 0x4bd, 0x4ba, 0x3, 0x2, 0x2, 0x2, 0x4be, 0x4c1, 
       0x3, 0x2, 0x2, 0x2, 0x4bf, 0x4bd, 0x3, 0x2, 0x2, 0x2, 0x4bf, 0x4c0, 
       0x3, 0x2, 0x2, 0x2, 0x4c0, 0x4c2, 0x3, 0x2, 0x2, 0x2, 0x4c1, 0x4bf, 
       0x3, 0x2, 0x2, 0x2, 0x4c2, 0x4c3, 0x7, 0x2, 0x2, 0x3, 0x4c3, 0x5, 
       0x3, 0x2, 0x2, 0x2, 0x4c4, 0x4d1, 0x7, 0x2, 0x2, 0x3, 0x4c5, 0x4c8, 
       0x5, 0x8, 0x5, 0x2, 0x4c6, 0x4c8, 0x5, 0x1a2, 0xd2, 0x2, 0x4c7, 0x4c5, 
       0x3, 0x2, 0x2, 0x2, 0x4c7, 0x4c6, 0x3, 0x2, 0x2, 0x2, 0x4c8, 0x4ce, 
       0x3, 0x2, 0x2, 0x2, 0x4c9, 0x4cb, 0x7, 0x21, 0x2, 0x2, 0x4ca, 0x4cc, 
       0x7, 0x2, 0x2, 0x3, 0x4cb, 0x4ca, 0x3, 0x2, 0x2, 0x2, 0x4cb, 0x4cc, 
       0x3, 0x2, 0x2, 0x2, 0x4cc, 0x4cf, 0x3, 0x2, 0x2, 0x2, 0x4cd, 0x4cf, 
       0x7, 0x2, 0x2, 0x3, 0x4ce, 0x4c9, 0x3, 0x2, 0x2, 0x2, 0x4ce, 0x4cd, 
       0x3, 0x2, 0x2, 0x2, 0x4cf, 0x4d1, 0x3, 0x2, 0x2, 0x2, 0x4d0, 0x4c4, 
       0x3, 0x2, 0x2, 0x2, 0x4d0, 0x4c7, 0x3, 0x2, 0x2, 0x2, 0x4d1, 0x7, 
       0x3, 0x2, 0x2, 0x2, 0x4d2, 0x4f5, 0x5, 0xa, 0x6, 0x2, 0x4d3, 0x4f5, 
       0x5, 0x54, 0x2b, 0x2, 0x4d4, 0x4f5, 0x5, 0xba, 0x5e, 0x2, 0x4d5, 
       0x4f5, 0x5, 0xda, 0x6e, 0x2, 0x4d6, 0x4f5, 0x5, 0xde, 0x70, 0x2, 
       0x4d7, 0x4d8, 0x6, 0x5, 0x2, 0x2, 0x4d8, 0x4f5, 0x5, 0xe0, 0x71, 
       0x2, 0x4d9, 0x4f5, 0x5, 0xe2, 0x72, 0x2, 0x4da, 0x4f5, 0x5, 0xe4, 
       0x73, 0x2, 0x4db, 0x4f5, 0x5, 0xea, 0x76, 0x2, 0x4dc, 0x4f5, 0x5, 
       0xec, 0x77, 0x2, 0x4dd, 0x4f5, 0x5, 0xf0, 0x79, 0x2, 0x4de, 0x4f5, 
       0x5, 0x102, 0x82, 0x2, 0x4df, 0x4f5, 0x5, 0x10e, 0x88, 0x2, 0x4e0, 
       0x4f5, 0x5, 0x110, 0x89, 0x2, 0x4e1, 0x4f5, 0x5, 0x19c, 0xcf, 0x2, 
       0x4e2, 0x4f5, 0x5, 0x19e, 0xd0, 0x2, 0x4e3, 0x4f5, 0x5, 0x1b8, 0xdd, 
       0x2, 0x4e4, 0x4f5, 0x5, 0x1e4, 0xf3, 0x2, 0x4e5, 0x4e6, 0x6, 0x5, 
       0x3, 0x2, 0x4e6, 0x4f5, 0x5, 0x1ea, 0xf6, 0x2, 0x4e7, 0x4f5, 0x5, 
       0x1f0, 0xf9, 0x2, 0x4e8, 0x4f5, 0x5, 0x22e, 0x118, 0x2, 0x4e9, 0x4f5, 
       0x5, 0x236, 0x11c, 0x2, 0x4ea, 0x4f5, 0x5, 0x238, 0x11d, 0x2, 0x4eb, 
       0x4f5, 0x5, 0x246, 0x124, 0x2, 0x4ec, 0x4ed, 0x6, 0x5, 0x4, 0x2, 
       0x4ed, 0x4f5, 0x5, 0x272, 0x13a, 0x2, 0x4ee, 0x4f5, 0x5, 0x252, 0x12a, 
       0x2, 0x4ef, 0x4f5, 0x5, 0x286, 0x144, 0x2, 0x4f0, 0x4f1, 0x6, 0x5, 
       0x5, 0x2, 0x4f1, 0x4f5, 0x5, 0x338, 0x19d, 0x2, 0x4f2, 0x4f5, 0x5, 
       0x342, 0x1a2, 0x2, 0x4f3, 0x4f5, 0x5, 0x344, 0x1a3, 0x2, 0x4f4, 0x4d2, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4d3, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4d4, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4d5, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4d6, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4d7, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4d9, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4da, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4db, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4dc, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4dd, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4de, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4df, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e0, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e1, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e2, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e3, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e4, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e5, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e7, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e8, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4e9, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4ea, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4eb, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4ec, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4ee, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4ef, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f0, 0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f2, 
       0x3, 0x2, 0x2, 0x2, 0x4f4, 0x4f3, 0x3, 0x2, 0x2, 0x2, 0x4f5, 0x9, 
       0x3, 0x2, 0x2, 0x2, 0x4f6, 0x511, 0x7, 0x3d, 0x2, 0x2, 0x4f7, 0x512, 
       0x5, 0x18, 0xd, 0x2, 0x4f8, 0x512, 0x5, 0xc, 0x7, 0x2, 0x4f9, 0x4fa, 
       0x7, 0x1ca, 0x2, 0x2, 0x4fa, 0x4fc, 0x5, 0x418, 0x20d, 0x2, 0x4fb, 
       0x4fd, 0x5, 0x6e, 0x38, 0x2, 0x4fc, 0x4fb, 0x3, 0x2, 0x2, 0x2, 0x4fc, 
       0x4fd, 0x3, 0x2, 0x2, 0x2, 0x4fd, 0x512, 0x3, 0x2, 0x2, 0x2, 0x4fe, 
       0x4ff, 0x7, 0xf7, 0x2, 0x2, 0x4ff, 0x501, 0x5, 0x41c, 0x20f, 0x2, 
       0x500, 0x502, 0x5, 0x6e, 0x38, 0x2, 0x501, 0x500, 0x3, 0x2, 0x2, 
       0x2, 0x501, 0x502, 0x3, 0x2, 0x2, 0x2, 0x502, 0x512, 0x3, 0x2, 0x2, 
       0x2, 0x503, 0x512, 0x5, 0x4c, 0x27, 0x2, 0x504, 0x512, 0x5, 0xe, 
       0x8, 0x2, 0x505, 0x512, 0x5, 0x3e, 0x20, 0x2, 0x506, 0x507, 0x6, 
       0x6, 0x6, 0x2, 0x507, 0x512, 0x5, 0x40, 0x21, 0x2, 0x508, 0x512, 
       0x5, 0x10, 0x9, 0x2, 0x509, 0x512, 0x5, 0x16, 0xc, 0x2, 0x50a, 0x50b, 
       0x6, 0x6, 0x7, 0x2, 0x50b, 0x50c, 0x7, 0x11d, 0x2, 0x2, 0x50c, 0x50d, 
       0x7, 0x205, 0x2, 0x2, 0x50d, 0x50e, 0x5, 0x48e, 0x248, 0x2, 0x50e, 
       0x50f, 0x7, 0x161, 0x2, 0x2, 0x50f, 0x510, 0x7, 0x130, 0x2, 0x2, 
       0x510, 0x512, 0x3, 0x2, 0x2, 0x2, 0x511, 0x4f7, 0x3, 0x2, 0x2, 0x2, 
       0x511, 0x4f8, 0x3, 0x2, 0x2, 0x2, 0x511, 0x4f9, 0x3, 0x2, 0x2, 0x2, 
       0x511, 0x4fe, 0x3, 0x2, 0x2, 0x2, 0x511, 0x503, 0x3, 0x2, 0x2, 0x2, 
       0x511, 0x504, 0x3, 0x2, 0x2, 0x2, 0x511, 0x505, 0x3, 0x2, 0x2, 0x2, 
       0x511, 0x506, 0x3, 0x2, 0x2, 0x2, 0x511, 0x508, 0x3, 0x2, 0x2, 0x2, 
       0x511, 0x509, 0x3, 0x2, 0x2, 0x2, 0x511, 0x50a, 0x3, 0x2, 0x2, 0x2, 
       0x512, 0xb, 0x3, 0x2, 0x2, 0x2, 0x513, 0x514, 0x7, 0x9d, 0x2, 0x2, 
       0x514, 0x51f, 0x5, 0x414, 0x20b, 0x2, 0x515, 0x517, 0x5, 0x58, 0x2d, 
       0x2, 0x516, 0x515, 0x3, 0x2, 0x2, 0x2, 0x517, 0x518, 0x3, 0x2, 0x2, 
       0x2, 0x518, 0x516, 0x3, 0x2, 0x2, 0x2, 0x518, 0x519, 0x3, 0x2, 0x2, 
       0x2, 0x519, 0x520, 0x3, 0x2, 0x2, 0x2, 0x51a, 0x51b, 0x6, 0x7, 0x8, 
       0x2, 0x51b, 0x51c, 0x7, 0x287, 0x2, 0x2, 0x51c, 0x51d, 0x7, 0xa0, 
       0x2, 0x2, 0x51d, 0x51e, 0x7, 0xb9, 0x2, 0x2, 0x51e, 0x520, 0x7, 0x189, 
       0x2, 0x2, 0x51f, 0x516, 0x3, 0x2, 0x2, 0x2, 0x51f, 0x51a, 0x3, 0x2, 
       0x2, 0x2, 0x520, 0xd, 0x3, 0x2, 0x2, 0x2, 0x521, 0x523, 0x5, 0x3c4, 
       0x1e3, 0x2, 0x522, 0x521, 0x3, 0x2, 0x2, 0x2, 0x522, 0x523, 0x3, 
       0x2, 0x2, 0x2, 0x523, 0x524, 0x3, 0x2, 0x2, 0x2, 0x524, 0x525, 0x7, 
       0xd7, 0x2, 0x2, 0x525, 0x529, 0x5, 0x430, 0x219, 0x2, 0x526, 0x527, 
       0x7, 0x1a2, 0x2, 0x2, 0x527, 0x528, 0x7, 0x20d, 0x2, 0x2, 0x528, 
       0x52a, 0x5, 0x34e, 0x1a8, 0x2, 0x529, 0x526, 0x3, 0x2, 0x2, 0x2, 
       0x529, 0x52a, 0x3, 0x2, 0x2, 0x2, 0x52a, 0x531, 0x3, 0x2, 0x2, 0x2, 
       0x52b, 0x52c, 0x7, 0x1a2, 0x2, 0x2, 0x52c, 0x52e, 0x7, 0x80, 0x2, 
       0x2, 0x52d, 0x52f, 0x7, 0x196, 0x2, 0x2, 0x52e, 0x52d, 0x3, 0x2, 
       0x2, 0x2, 0x52e, 0x52f, 0x3, 0x2, 0x2, 0x2, 0x52f, 0x530, 0x3, 0x2, 
       0x2, 0x2, 0x530, 0x532, 0x7, 0x1c6, 0x2, 0x2, 0x531, 0x52b, 0x3, 
       0x2, 0x2, 0x2, 0x531, 0x532, 0x3, 0x2, 0x2, 0x2, 0x532, 0x536, 0x3, 
       0x2, 0x2, 0x2, 0x533, 0x534, 0x7, 0x1e9, 0x2, 0x2, 0x534, 0x535, 
       0x7, 0x26e, 0x2, 0x2, 0x535, 0x537, 0x5, 0x45a, 0x22e, 0x2, 0x536, 
       0x533, 0x3, 0x2, 0x2, 0x2, 0x536, 0x537, 0x3, 0x2, 0x2, 0x2, 0x537, 
       0x53e, 0x3, 0x2, 0x2, 0x2, 0x538, 0x53f, 0x7, 0xc9, 0x2, 0x2, 0x539, 
       0x53c, 0x7, 0xba, 0x2, 0x2, 0x53a, 0x53b, 0x7, 0x1a2, 0x2, 0x2, 0x53b, 
       0x53d, 0x7, 0x223, 0x2, 0x2, 0x53c, 0x53a, 0x3, 0x2, 0x2, 0x2, 0x53c, 
       0x53d, 0x3, 0x2, 0x2, 0x2, 0x53d, 0x53f, 0x3, 0x2, 0x2, 0x2, 0x53e, 
       0x538, 0x3, 0x2, 0x2, 0x2, 0x53e, 0x539, 0x3, 0x2, 0x2, 0x2, 0x53e, 
       0x53f, 0x3, 0x2, 0x2, 0x2, 0x53f, 0x542, 0x3, 0x2, 0x2, 0x2, 0x540, 
       0x541, 0x7, 0x7c, 0x2, 0x2, 0x541, 0x543, 0x5, 0x47a, 0x23e, 0x2, 
       0x542, 0x540, 0x3, 0x2, 0x2, 0x2, 0x542, 0x543, 0x3, 0x2, 0x2, 0x2, 
       0x543, 0x546, 0x3, 0x2, 0x2, 0x2, 0x544, 0x545, 0x7, 0xc0, 0x2, 0x2, 
       0x545, 0x547, 0x5, 0x300, 0x181, 0x2, 0x546, 0x544, 0x3, 0x2, 0x2, 
       0x2, 0x546, 0x547, 0x3, 0x2, 0x2, 0x2, 0x547, 0xf, 0x3, 0x2, 0x2, 
       0x2, 0x548, 0x549, 0x7, 0x145, 0x2, 0x2, 0x549, 0x54a, 0x7, 0x102, 
       0x2, 0x2, 0x54a, 0x54b, 0x5, 0x42c, 0x217, 0x2, 0x54b, 0x54c, 0x7, 
       0x36, 0x2, 0x2, 0x54c, 0x54d, 0x7, 0x27b, 0x2, 0x2, 0x54d, 0x54f, 
       0x5, 0x47a, 0x23e, 0x2, 0x54e, 0x550, 0x5, 0x12, 0xa, 0x2, 0x54f, 
       0x54e, 0x3, 0x2, 0x2, 0x2, 0x54f, 0x550, 0x3, 0x2, 0x2, 0x2, 0x550, 
       0x11, 0x3, 0x2, 0x2, 0x2, 0x551, 0x558, 0x5, 0x14, 0xb, 0x2, 0x552, 
       0x554, 0x7, 0x20, 0x2, 0x2, 0x553, 0x552, 0x3, 0x2, 0x2, 0x2, 0x553, 
       0x554, 0x3, 0x2, 0x2, 0x2, 0x554, 0x555, 0x3, 0x2, 0x2, 0x2, 0x555, 
       0x557, 0x5, 0x14, 0xb, 0x2, 0x556, 0x553, 0x3, 0x2, 0x2, 0x2, 0x557, 
       0x55a, 0x3, 0x2, 0x2, 0x2, 0x558, 0x556, 0x3, 0x2, 0x2, 0x2, 0x558, 
       0x559, 0x3, 0x2, 0x2, 0x2, 0x559, 0x13, 0x3, 0x2, 0x2, 0x2, 0x55a, 
       0x558, 0x3, 0x2, 0x2, 0x2, 0x55b, 0x55f, 0x5, 0x90, 0x49, 0x2, 0x55c, 
       0x55f, 0x5, 0x9c, 0x4f, 0x2, 0x55d, 0x55f, 0x5, 0x9e, 0x50, 0x2, 
       0x55e, 0x55b, 0x3, 0x2, 0x2, 0x2, 0x55e, 0x55c, 0x3, 0x2, 0x2, 0x2, 
       0x55e, 0x55d, 0x3, 0x2, 0x2, 0x2, 0x55f, 0x15, 0x3, 0x2, 0x2, 0x2, 
       0x560, 0x561, 0x7, 0x218, 0x2, 0x2, 0x561, 0x562, 0x5, 0x436, 0x21c, 
       0x2, 0x562, 0x563, 0x5, 0x80, 0x41, 0x2, 0x563, 0x17, 0x3, 0x2, 0x2, 
       0x2, 0x564, 0x566, 0x5, 0x3fa, 0x1fe, 0x2, 0x565, 0x564, 0x3, 0x2, 
       0x2, 0x2, 0x565, 0x566, 0x3, 0x2, 0x2, 0x2, 0x566, 0x569, 0x3, 0x2, 
       0x2, 0x2, 0x567, 0x568, 0x6, 0xd, 0x9, 0x2, 0x568, 0x56a, 0x7, 0x111, 
       0x2, 0x2, 0x569, 0x567, 0x3, 0x2, 0x2, 0x2, 0x569, 0x56a, 0x3, 0x2, 
       0x2, 0x2, 0x56a, 0x56b, 0x3, 0x2, 0x2, 0x2, 0x56b, 0x56c, 0x7, 0x25e, 
       0x2, 0x2, 0x56c, 0x56e, 0x5, 0x440, 0x221, 0x2, 0x56d, 0x56f, 0x5, 
       0x1a, 0xe, 0x2, 0x56e, 0x56d, 0x3, 0x2, 0x2, 0x2, 0x56e, 0x56f, 0x3, 
       0x2, 0x2, 0x2, 0x56f, 0x19, 0x3, 0x2, 0x2, 0x2, 0x570, 0x573, 0x5, 
       0x1c, 0xf, 0x2, 0x571, 0x574, 0x5, 0x3ae, 0x1d8, 0x2, 0x572, 0x574, 
       0x5, 0x38, 0x1d, 0x2, 0x573, 0x571, 0x3, 0x2, 0x2, 0x2, 0x573, 0x572, 
       0x3, 0x2, 0x2, 0x2, 0x573, 0x574, 0x3, 0x2, 0x2, 0x2, 0x574, 0x57e, 
       0x3, 0x2, 0x2, 0x2, 0x575, 0x57e, 0x5, 0x3ae, 0x1d8, 0x2, 0x576, 
       0x57e, 0x5, 0x38, 0x1d, 0x2, 0x577, 0x578, 0x5, 0x1e, 0x10, 0x2, 
       0x578, 0x579, 0x7, 0x20, 0x2, 0x2, 0x579, 0x57b, 0x3, 0x2, 0x2, 0x2, 
       0x57a, 0x577, 0x3, 0x2, 0x2, 0x2, 0x57a, 0x57b, 0x3, 0x2, 0x2, 0x2, 
       0x57b, 0x57c, 0x3, 0x2, 0x2, 0x2, 0x57c, 0x57e, 0x5, 0x20, 0x11, 
       0x2, 0x57d, 0x570, 0x3, 0x2, 0x2, 0x2, 0x57d, 0x575, 0x3, 0x2, 0x2, 
       0x2, 0x57d, 0x576, 0x3, 0x2, 0x2, 0x2, 0x57d, 0x57a, 0x3, 0x2, 0x2, 
       0x2, 0x57e, 0x1b, 0x3, 0x2, 0x2, 0x2, 0x57f, 0x587, 0x5, 0x1e, 0x10, 
       0x2, 0x580, 0x581, 0x5, 0x1e, 0x10, 0x2, 0x581, 0x582, 0x7, 0x20, 
       0x2, 0x2, 0x582, 0x584, 0x3, 0x2, 0x2, 0x2, 0x583, 0x580, 0x3, 0x2, 
       0x2, 0x2, 0x583, 0x584, 0x3, 0x2, 0x2, 0x2, 0x584, 0x585, 0x3, 0x2, 
       0x2, 0x2, 0x585, 0x587, 0x5, 0x24, 0x13, 0x2, 0x586, 0x57f, 0x3, 
       0x2, 0x2, 0x2, 0x586, 0x583, 0x3, 0x2, 0x2, 0x2, 0x587, 0x1d, 0x3, 
       0x2, 0x2, 0x2, 0x588, 0x58d, 0x5, 0x26, 0x14, 0x2, 0x589, 0x58a, 
       0x7, 0x20, 0x2, 0x2, 0x58a, 0x58c, 0x5, 0x26, 0x14, 0x2, 0x58b, 0x589, 
       0x3, 0x2, 0x2, 0x2, 0x58c, 0x58f, 0x3, 0x2, 0x2, 0x2, 0x58d, 0x58b, 
       0x3, 0x2, 0x2, 0x2, 0x58d, 0x58e, 0x3, 0x2, 0x2, 0x2, 0x58e, 0x1f, 
       0x3, 0x2, 0x2, 0x2, 0x58f, 0x58d, 0x3, 0x2, 0x2, 0x2, 0x590, 0x591, 
       0x7, 0xbb, 0x2, 0x2, 0x591, 0x598, 0x7, 0x25c, 0x2, 0x2, 0x592, 0x593, 
       0x7, 0x113, 0x2, 0x2, 0x593, 0x598, 0x7, 0x25c, 0x2, 0x2, 0x594, 
       0x598, 0x5, 0x22, 0x12, 0x2, 0x595, 0x596, 0x6, 0x11, 0xa, 0x2, 0x596, 
       0x598, 0x9, 0x2, 0x2, 0x2, 0x597, 0x590, 0x3, 0x2, 0x2, 0x2, 0x597, 
       0x592, 0x3, 0x2, 0x2, 0x2, 0x597, 0x594, 0x3, 0x2, 0x2, 0x2, 0x597, 
       0x595, 0x3, 0x2, 0x2, 0x2, 0x598, 0x21, 0x3, 0x2, 0x2, 0x2, 0x599, 
       0x59a, 0x7, 0x36, 0x2, 0x2, 0x59a, 0x59c, 0x7, 0x1b9, 0x2, 0x2, 0x59b, 
       0x59d, 0x5, 0x3fc, 0x1ff, 0x2, 0x59c, 0x59b, 0x3, 0x2, 0x2, 0x2, 
       0x59c, 0x59d, 0x3, 0x2, 0x2, 0x2, 0x59d, 0x5a1, 0x3, 0x2, 0x2, 0x2, 
       0x59e, 0x5a2, 0x5, 0x3b6, 0x1dc, 0x2, 0x59f, 0x5a0, 0x7, 0x1b8, 0x2, 
       0x2, 0x5a0, 0x5a2, 0x5, 0x468, 0x235, 0x2, 0x5a1, 0x59e, 0x3, 0x2, 
       0x2, 0x2, 0x5a1, 0x59f, 0x3, 0x2, 0x2, 0x2, 0x5a2, 0x5fb, 0x3, 0x2, 
       0x2, 0x2, 0x5a3, 0x5a4, 0x7, 0xc1, 0x2, 0x2, 0x5a4, 0x5a5, 0x7, 0x1b9, 
       0x2, 0x2, 0x5a5, 0x5fb, 0x5, 0x45c, 0x22f, 0x2, 0x5a6, 0x5a7, 0x7, 
       0x1da, 0x2, 0x2, 0x5a7, 0x5a9, 0x7, 0x1b9, 0x2, 0x2, 0x5a8, 0x5aa, 
       0x5, 0x3fc, 0x1ff, 0x2, 0x5a9, 0x5a8, 0x3, 0x2, 0x2, 0x2, 0x5a9, 
       0x5aa, 0x3, 0x2, 0x2, 0x2, 0x5aa, 0x5ab, 0x3, 0x2, 0x2, 0x2, 0x5ab, 
       0x5fb, 0x5, 0x3a, 0x1e, 0x2, 0x5ac, 0x5ad, 0x7, 0x1a8, 0x2, 0x2, 
       0x5ad, 0x5af, 0x7, 0x1b9, 0x2, 0x2, 0x5ae, 0x5b0, 0x5, 0x3fc, 0x1ff, 
       0x2, 0x5af, 0x5ae, 0x3, 0x2, 0x2, 0x2, 0x5af, 0x5b0, 0x3, 0x2, 0x2, 
       0x2, 0x5b0, 0x5b1, 0x3, 0x2, 0x2, 0x2, 0x5b1, 0x5b3, 0x5, 0x3a, 0x1e, 
       0x2, 0x5b2, 0x5b4, 0x5, 0x3fc, 0x1ff, 0x2, 0x5b3, 0x5b2, 0x3, 0x2, 
       0x2, 0x2, 0x5b3, 0x5b4, 0x3, 0x2, 0x2, 0x2, 0x5b4, 0x5fb, 0x3, 0x2, 
       0x2, 0x2, 0x5b5, 0x5b6, 0x7, 0x40, 0x2, 0x2, 0x5b6, 0x5b8, 0x7, 0x1b9, 
       0x2, 0x2, 0x5b7, 0x5b9, 0x5, 0x3fc, 0x1ff, 0x2, 0x5b8, 0x5b7, 0x3, 
       0x2, 0x2, 0x2, 0x5b8, 0x5b9, 0x3, 0x2, 0x2, 0x2, 0x5b9, 0x5ba, 0x3, 
       0x2, 0x2, 0x2, 0x5ba, 0x5fb, 0x5, 0x3a, 0x1e, 0x2, 0x5bb, 0x5bc, 
       0x7, 0x6f, 0x2, 0x2, 0x5bc, 0x5bd, 0x7, 0x1b9, 0x2, 0x2, 0x5bd, 0x5c1, 
       0x5, 0x3a, 0x1e, 0x2, 0x5be, 0x5c0, 0x5, 0x232, 0x11a, 0x2, 0x5bf, 
       0x5be, 0x3, 0x2, 0x2, 0x2, 0x5c0, 0x5c3, 0x3, 0x2, 0x2, 0x2, 0x5c1, 
       0x5bf, 0x3, 0x2, 0x2, 0x2, 0x5c1, 0x5c2, 0x3, 0x2, 0x2, 0x2, 0x5c2, 
       0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5c3, 0x5c1, 0x3, 0x2, 0x2, 0x2, 0x5c4, 
       0x5c5, 0x7, 0x1eb, 0x2, 0x2, 0x5c5, 0x5c7, 0x7, 0x1b9, 0x2, 0x2, 
       0x5c6, 0x5c8, 0x5, 0x3fc, 0x1ff, 0x2, 0x5c7, 0x5c6, 0x3, 0x2, 0x2, 
       0x2, 0x5c7, 0x5c8, 0x3, 0x2, 0x2, 0x2, 0x5c8, 0x5c9, 0x3, 0x2, 0x2, 
       0x2, 0x5c9, 0x5cd, 0x5, 0x3a, 0x1e, 0x2, 0x5ca, 0x5cc, 0x5, 0x234, 
       0x11b, 0x2, 0x5cb, 0x5ca, 0x3, 0x2, 0x2, 0x2, 0x5cc, 0x5cf, 0x3, 
       0x2, 0x2, 0x2, 0x5cd, 0x5cb, 0x3, 0x2, 0x2, 0x2, 0x5cd, 0x5ce, 0x3, 
       0x2, 0x2, 0x2, 0x5ce, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5cf, 0x5cd, 0x3, 
       0x2, 0x2, 0x2, 0x5d0, 0x5d1, 0x7, 0x74, 0x2, 0x2, 0x5d1, 0x5d3, 0x7, 
       0x1b9, 0x2, 0x2, 0x5d2, 0x5d4, 0x5, 0x3fc, 0x1ff, 0x2, 0x5d3, 0x5d2, 
       0x3, 0x2, 0x2, 0x2, 0x5d3, 0x5d4, 0x3, 0x2, 0x2, 0x2, 0x5d4, 0x5d5, 
       0x3, 0x2, 0x2, 0x2, 0x5d5, 0x5fb, 0x5, 0x468, 0x235, 0x2, 0x5d6, 
       0x5d7, 0x7, 0x275, 0x2, 0x2, 0x5d7, 0x5d8, 0x7, 0x1b9, 0x2, 0x2, 
       0x5d8, 0x5fb, 0x5, 0x3a, 0x1e, 0x2, 0x5d9, 0x5fb, 0x5, 0x3c, 0x1f, 
       0x2, 0x5da, 0x5db, 0x7, 0x1ea, 0x2, 0x2, 0x5db, 0x5dd, 0x7, 0x1b9, 
       0x2, 0x2, 0x5dc, 0x5de, 0x5, 0x3fc, 0x1ff, 0x2, 0x5dd, 0x5dc, 0x3, 
       0x2, 0x2, 0x2, 0x5dd, 0x5de, 0x3, 0x2, 0x2, 0x2, 0x5de, 0x5e3, 0x3, 
       0x2, 0x2, 0x2, 0x5df, 0x5e0, 0x5, 0x45c, 0x22f, 0x2, 0x5e0, 0x5e1, 
       0x7, 0x120, 0x2, 0x2, 0x5e1, 0x5e2, 0x5, 0x3b6, 0x1dc, 0x2, 0x5e2, 
       0x5e4, 0x3, 0x2, 0x2, 0x2, 0x5e3, 0x5df, 0x3, 0x2, 0x2, 0x2, 0x5e3, 
       0x5e4, 0x3, 0x2, 0x2, 0x2, 0x5e4, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5e5, 
       0x5e6, 0x7, 0xd9, 0x2, 0x2, 0x5e6, 0x5e7, 0x7, 0x1b9, 0x2, 0x2, 0x5e7, 
       0x5e8, 0x5, 0x45a, 0x22e, 0x2, 0x5e8, 0x5e9, 0x7, 0x2a4, 0x2, 0x2, 
       0x5e9, 0x5ea, 0x7, 0x25e, 0x2, 0x2, 0x5ea, 0x5ec, 0x5, 0x440, 0x221, 
       0x2, 0x5eb, 0x5ed, 0x5, 0x36, 0x1c, 0x2, 0x5ec, 0x5eb, 0x3, 0x2, 
       0x2, 0x2, 0x5ec, 0x5ed, 0x3, 0x2, 0x2, 0x2, 0x5ed, 0x5fb, 0x3, 0x2, 
       0x2, 0x2, 0x5ee, 0x5ef, 0x6, 0x12, 0xb, 0x2, 0x5ef, 0x5f0, 0x7, 0xbb, 
       0x2, 0x2, 0x5f0, 0x5f1, 0x7, 0x1b9, 0x2, 0x2, 0x5f1, 0x5f2, 0x5, 
       0x3a, 0x1e, 0x2, 0x5f2, 0x5f3, 0x7, 0x25c, 0x2, 0x2, 0x5f3, 0x5fb, 
       0x3, 0x2, 0x2, 0x2, 0x5f4, 0x5f5, 0x6, 0x12, 0xc, 0x2, 0x5f5, 0x5f6, 
       0x7, 0x113, 0x2, 0x2, 0x5f6, 0x5f7, 0x7, 0x1b9, 0x2, 0x2, 0x5f7, 
       0x5f8, 0x5, 0x3a, 0x1e, 0x2, 0x5f8, 0x5f9, 0x7, 0x25c, 0x2, 0x2, 
       0x5f9, 0x5fb, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x599, 0x3, 0x2, 0x2, 0x2, 
       0x5fa, 0x5a3, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5a6, 0x3, 0x2, 0x2, 0x2, 
       0x5fa, 0x5ac, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5b5, 0x3, 0x2, 0x2, 0x2, 
       0x5fa, 0x5bb, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5c4, 0x3, 0x2, 0x2, 0x2, 
       0x5fa, 0x5d0, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5d6, 0x3, 0x2, 0x2, 0x2, 
       0x5fa, 0x5d9, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5da, 0x3, 0x2, 0x2, 0x2, 
       0x5fa, 0x5e5, 0x3, 0x2, 0x2, 0x2, 0x5fa, 0x5ee, 0x3, 0x2, 0x2, 0x2, 
       0x5fa, 0x5f4, 0x3, 0x2, 0x2, 0x2, 0x5fb, 0x23, 0x3, 0x2, 0x2, 0x2, 
       0x5fc, 0x5ff, 0x5, 0x28, 0x15, 0x2, 0x5fd, 0x5ff, 0x5, 0x3a2, 0x1d2, 
       0x2, 0x5fe, 0x5fc, 0x3, 0x2, 0x2, 0x2, 0x5fe, 0x5fd, 0x3, 0x2, 0x2, 
       0x2, 0x5ff, 0x608, 0x3, 0x2, 0x2, 0x2, 0x600, 0x604, 0x7, 0x20, 0x2, 
       0x2, 0x601, 0x605, 0x5, 0x28, 0x15, 0x2, 0x602, 0x605, 0x5, 0x26, 
       0x14, 0x2, 0x603, 0x605, 0x5, 0x3a2, 0x1d2, 0x2, 0x604, 0x601, 0x3, 
       0x2, 0x2, 0x2, 0x604, 0x602, 0x3, 0x2, 0x2, 0x2, 0x604, 0x603, 0x3, 
       0x2, 0x2, 0x2, 0x605, 0x607, 0x3, 0x2, 0x2, 0x2, 0x606, 0x600, 0x3, 
       0x2, 0x2, 0x2, 0x607, 0x60a, 0x3, 0x2, 0x2, 0x2, 0x608, 0x606, 0x3, 
       0x2, 0x2, 0x2, 0x608, 0x609, 0x3, 0x2, 0x2, 0x2, 0x609, 0x25, 0x3, 
       0x2, 0x2, 0x2, 0x60a, 0x608, 0x3, 0x2, 0x2, 0x2, 0x60b, 0x60c, 0x6, 
       0x14, 0xd, 0x2, 0x60c, 0x611, 0x5, 0x30, 0x19, 0x2, 0x60d, 0x60e, 
       0x6, 0x14, 0xe, 0x2, 0x60e, 0x611, 0x5, 0x32, 0x1a, 0x2, 0x60f, 0x611, 
       0x5, 0x36, 0x1c, 0x2, 0x610, 0x60b, 0x3, 0x2, 0x2, 0x2, 0x610, 0x60d, 
       0x3, 0x2, 0x2, 0x2, 0x610, 0x60f, 0x3, 0x2, 0x2, 0x2, 0x611, 0x27, 
       0x3, 0x2, 0x2, 0x2, 0x612, 0x614, 0x7, 0x36, 0x2, 0x2, 0x613, 0x615, 
       0x7, 0x79, 0x2, 0x2, 0x614, 0x613, 0x3, 0x2, 0x2, 0x2, 0x614, 0x615, 
       0x3, 0x2, 0x2, 0x2, 0x615, 0x622, 0x3, 0x2, 0x2, 0x2, 0x616, 0x617, 
       0x5, 0x45a, 0x22e, 0x2, 0x617, 0x619, 0x5, 0x35c, 0x1af, 0x2, 0x618, 
       0x61a, 0x5, 0x352, 0x1aa, 0x2, 0x619, 0x618, 0x3, 0x2, 0x2, 0x2, 
       0x619, 0x61a, 0x3, 0x2, 0x2, 0x2, 0x61a, 0x61c, 0x3, 0x2, 0x2, 0x2, 
       0x61b, 0x61d, 0x5, 0x2a, 0x16, 0x2, 0x61c, 0x61b, 0x3, 0x2, 0x2, 
       0x2, 0x61c, 0x61d, 0x3, 0x2, 0x2, 0x2, 0x61d, 0x623, 0x3, 0x2, 0x2, 
       0x2, 0x61e, 0x61f, 0x7, 0x23, 0x2, 0x2, 0x61f, 0x620, 0x5, 0x5c, 
       0x2f, 0x2, 0x620, 0x621, 0x7, 0x24, 0x2, 0x2, 0x621, 0x623, 0x3, 
       0x2, 0x2, 0x2, 0x622, 0x616, 0x3, 0x2, 0x2, 0x2, 0x622, 0x61e, 0x3, 
       0x2, 0x2, 0x2, 0x623, 0x698, 0x3, 0x2, 0x2, 0x2, 0x624, 0x625, 0x7, 
       0x36, 0x2, 0x2, 0x625, 0x698, 0x5, 0x358, 0x1ad, 0x2, 0x626, 0x628, 
       0x7, 0x69, 0x2, 0x2, 0x627, 0x629, 0x7, 0x79, 0x2, 0x2, 0x628, 0x627, 
       0x3, 0x2, 0x2, 0x2, 0x628, 0x629, 0x3, 0x2, 0x2, 0x2, 0x629, 0x62a, 
       0x3, 0x2, 0x2, 0x2, 0x62a, 0x62b, 0x5, 0x404, 0x203, 0x2, 0x62b, 
       0x62c, 0x5, 0x45a, 0x22e, 0x2, 0x62c, 0x62e, 0x5, 0x35c, 0x1af, 0x2, 
       0x62d, 0x62f, 0x5, 0x2a, 0x16, 0x2, 0x62e, 0x62d, 0x3, 0x2, 0x2, 
       0x2, 0x62e, 0x62f, 0x3, 0x2, 0x2, 0x2, 0x62f, 0x698, 0x3, 0x2, 0x2, 
       0x2, 0x630, 0x632, 0x7, 0x180, 0x2, 0x2, 0x631, 0x633, 0x7, 0x79, 
       0x2, 0x2, 0x632, 0x631, 0x3, 0x2, 0x2, 0x2, 0x632, 0x633, 0x3, 0x2, 
       0x2, 0x2, 0x633, 0x634, 0x3, 0x2, 0x2, 0x2, 0x634, 0x635, 0x5, 0x404, 
       0x203, 0x2, 0x635, 0x637, 0x5, 0x35c, 0x1af, 0x2, 0x636, 0x638, 0x5, 
       0x2a, 0x16, 0x2, 0x637, 0x636, 0x3, 0x2, 0x2, 0x2, 0x637, 0x638, 
       0x3, 0x2, 0x2, 0x2, 0x638, 0x698, 0x3, 0x2, 0x2, 0x2, 0x639, 0x650, 
       0x7, 0xc1, 0x2, 0x2, 0x63a, 0x63c, 0x7, 0x79, 0x2, 0x2, 0x63b, 0x63a, 
       0x3, 0x2, 0x2, 0x2, 0x63b, 0x63c, 0x3, 0x2, 0x2, 0x2, 0x63c, 0x63d, 
       0x3, 0x2, 0x2, 0x2, 0x63d, 0x63f, 0x5, 0x404, 0x203, 0x2, 0x63e, 
       0x640, 0x5, 0x2c, 0x17, 0x2, 0x63f, 0x63e, 0x3, 0x2, 0x2, 0x2, 0x63f, 
       0x640, 0x3, 0x2, 0x2, 0x2, 0x640, 0x651, 0x3, 0x2, 0x2, 0x2, 0x641, 
       0x642, 0x7, 0xf0, 0x2, 0x2, 0x642, 0x649, 0x7, 0x130, 0x2, 0x2, 0x643, 
       0x644, 0x6, 0x15, 0xf, 0x2, 0x644, 0x64a, 0x5, 0x404, 0x203, 0x2, 
       0x645, 0x647, 0x6, 0x15, 0x10, 0x2, 0x646, 0x648, 0x5, 0x404, 0x203, 
       0x2, 0x647, 0x646, 0x3, 0x2, 0x2, 0x2, 0x647, 0x648, 0x3, 0x2, 0x2, 
       0x2, 0x648, 0x64a, 0x3, 0x2, 0x2, 0x2, 0x649, 0x643, 0x3, 0x2, 0x2, 
       0x2, 0x649, 0x645, 0x3, 0x2, 0x2, 0x2, 0x64a, 0x651, 0x3, 0x2, 0x2, 
       0x2, 0x64b, 0x64c, 0x7, 0x1c8, 0x2, 0x2, 0x64c, 0x651, 0x7, 0x130, 
       0x2, 0x2, 0x64d, 0x64e, 0x5, 0x192, 0xca, 0x2, 0x64e, 0x64f, 0x5, 
       0x40e, 0x208, 0x2, 0x64f, 0x651, 0x3, 0x2, 0x2, 0x2, 0x650, 0x63b, 
       0x3, 0x2, 0x2, 0x2, 0x650, 0x641, 0x3, 0x2, 0x2, 0x2, 0x650, 0x64b, 
       0x3, 0x2, 0x2, 0x2, 0x650, 0x64d, 0x3, 0x2, 0x2, 0x2, 0x651, 0x698, 
       0x3, 0x2, 0x2, 0x2, 0x652, 0x653, 0x7, 0xba, 0x2, 0x2, 0x653, 0x698, 
       0x7, 0x12e, 0x2, 0x2, 0x654, 0x655, 0x7, 0xc9, 0x2, 0x2, 0x655, 0x698, 
       0x7, 0x12e, 0x2, 0x2, 0x656, 0x658, 0x7, 0x3d, 0x2, 0x2, 0x657, 0x659, 
       0x7, 0x79, 0x2, 0x2, 0x658, 0x657, 0x3, 0x2, 0x2, 0x2, 0x658, 0x659, 
       0x3, 0x2, 0x2, 0x2, 0x659, 0x65a, 0x3, 0x2, 0x2, 0x2, 0x65a, 0x664, 
       0x5, 0x404, 0x203, 0x2, 0x65b, 0x65c, 0x7, 0x21b, 0x2, 0x2, 0x65c, 
       0x660, 0x7, 0xae, 0x2, 0x2, 0x65d, 0x65e, 0x6, 0x15, 0x11, 0x2, 0x65e, 
       0x661, 0x5, 0x2f2, 0x17a, 0x2, 0x65f, 0x661, 0x5, 0x470, 0x239, 0x2, 
       0x660, 0x65d, 0x3, 0x2, 0x2, 0x2, 0x660, 0x65f, 0x3, 0x2, 0x2, 0x2, 
       0x661, 0x665, 0x3, 0x2, 0x2, 0x2, 0x662, 0x663, 0x7, 0xc1, 0x2, 0x2, 
       0x663, 0x665, 0x7, 0xae, 0x2, 0x2, 0x664, 0x65b, 0x3, 0x2, 0x2, 0x2, 
       0x664, 0x662, 0x3, 0x2, 0x2, 0x2, 0x665, 0x698, 0x3, 0x2, 0x2, 0x2, 
       0x666, 0x667, 0x6, 0x15, 0x12, 0x2, 0x667, 0x668, 0x7, 0x3d, 0x2, 
       0x2, 0x668, 0x669, 0x7, 0x115, 0x2, 0x2, 0x669, 0x66a, 0x5, 0x40e, 
       0x208, 0x2, 0x66a, 0x66b, 0x5, 0x37a, 0x1be, 0x2, 0x66b, 0x698, 0x3, 
       0x2, 0x2, 0x2, 0x66c, 0x66d, 0x6, 0x15, 0x13, 0x2, 0x66d, 0x66e, 
       0x7, 0x3d, 0x2, 0x2, 0x66e, 0x66f, 0x7, 0x6f, 0x2, 0x2, 0x66f, 0x670, 
       0x5, 0x45a, 0x22e, 0x2, 0x670, 0x671, 0x5, 0x356, 0x1ac, 0x2, 0x671, 
       0x698, 0x3, 0x2, 0x2, 0x2, 0x672, 0x673, 0x6, 0x15, 0x14, 0x2, 0x673, 
       0x674, 0x7, 0x1e9, 0x2, 0x2, 0x674, 0x675, 0x7, 0x79, 0x2, 0x2, 0x675, 
       0x676, 0x5, 0x404, 0x203, 0x2, 0x676, 0x677, 0x7, 0x26e, 0x2, 0x2, 
       0x677, 0x678, 0x5, 0x45a, 0x22e, 0x2, 0x678, 0x698, 0x3, 0x2, 0x2, 
       0x2, 0x679, 0x67b, 0x7, 0x1e9, 0x2, 0x2, 0x67a, 0x67c, 0x9, 0x3, 
       0x2, 0x2, 0x67b, 0x67a, 0x3, 0x2, 0x2, 0x2, 0x67b, 0x67c, 0x3, 0x2, 
       0x2, 0x2, 0x67c, 0x67d, 0x3, 0x2, 0x2, 0x2, 0x67d, 0x698, 0x5, 0x43a, 
       0x21e, 0x2, 0x67e, 0x67f, 0x6, 0x15, 0x15, 0x2, 0x67f, 0x680, 0x7, 
       0x1e9, 0x2, 0x2, 0x680, 0x681, 0x5, 0x192, 0xca, 0x2, 0x681, 0x682, 
       0x5, 0x40e, 0x208, 0x2, 0x682, 0x683, 0x7, 0x26e, 0x2, 0x2, 0x683, 
       0x684, 0x5, 0x40c, 0x207, 0x2, 0x684, 0x698, 0x3, 0x2, 0x2, 0x2, 
       0x685, 0x686, 0x7, 0x8f, 0x2, 0x2, 0x686, 0x687, 0x7, 0x26e, 0x2, 
       0x2, 0x687, 0x68b, 0x5, 0x2e6, 0x174, 0x2, 0x688, 0x689, 0x6, 0x15, 
       0x16, 0x2, 0x689, 0x68c, 0x7, 0xae, 0x2, 0x2, 0x68a, 0x68c, 0x5, 
       0x39c, 0x1cf, 0x2, 0x68b, 0x688, 0x3, 0x2, 0x2, 0x2, 0x68b, 0x68a, 
       0x3, 0x2, 0x2, 0x2, 0x68c, 0x68e, 0x3, 0x2, 0x2, 0x2, 0x68d, 0x68f, 
       0x5, 0x3ce, 0x1e8, 0x2, 0x68e, 0x68d, 0x3, 0x2, 0x2, 0x2, 0x68e, 
       0x68f, 0x3, 0x2, 0x2, 0x2, 0x68f, 0x698, 0x3, 0x2, 0x2, 0x2, 0x690, 
       0x698, 0x7, 0xef, 0x2, 0x2, 0x691, 0x692, 0x7, 0x1ad, 0x2, 0x2, 0x692, 
       0x693, 0x7, 0x5f, 0x2, 0x2, 0x693, 0x698, 0x5, 0x2e, 0x18, 0x2, 0x694, 
       0x695, 0x6, 0x15, 0x17, 0x2, 0x695, 0x696, 0x7, 0x287, 0x2, 0x2, 
       0x696, 0x698, 0x7, 0x1b7, 0x2, 0x2, 0x697, 0x612, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x624, 0x3, 0x2, 0x2, 0x2, 0x697, 0x626, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x630, 0x3, 0x2, 0x2, 0x2, 0x697, 0x639, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x652, 0x3, 0x2, 0x2, 0x2, 0x697, 0x654, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x656, 0x3, 0x2, 0x2, 0x2, 0x697, 0x666, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x66c, 0x3, 0x2, 0x2, 0x2, 0x697, 0x672, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x679, 0x3, 0x2, 0x2, 0x2, 0x697, 0x67e, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x685, 0x3, 0x2, 0x2, 0x2, 0x697, 0x690, 0x3, 0x2, 0x2, 
       0x2, 0x697, 0x691, 0x3, 0x2, 0x2, 0x2, 0x697, 0x694, 0x3, 0x2, 0x2, 
       0x2, 0x698, 0x29, 0x3, 0x2, 0x2, 0x2, 0x699, 0x69a, 0x7, 0x38, 0x2, 
       0x2, 0x69a, 0x69d, 0x5, 0x45a, 0x22e, 0x2, 0x69b, 0x69d, 0x7, 0xea, 
       0x2, 0x2, 0x69c, 0x699, 0x3, 0x2, 0x2, 0x2, 0x69c, 0x69b, 0x3, 0x2, 
       0x2, 0x2, 0x69d, 0x2b, 0x3, 0x2, 0x2, 0x2, 0x69e, 0x69f, 0x9, 0x4, 
       0x2, 0x2, 0x69f, 0x2d, 0x3, 0x2, 0x2, 0x2, 0x6a0, 0x6a2, 0x5, 0x45a, 
       0x22e, 0x2, 0x6a1, 0x6a3, 0x5, 0x14e, 0xa8, 0x2, 0x6a2, 0x6a1, 0x3, 
       0x2, 0x2, 0x2, 0x6a2, 0x6a3, 0x3, 0x2, 0x2, 0x2, 0x6a3, 0x6ab, 0x3, 
       0x2, 0x2, 0x2, 0x6a4, 0x6a5, 0x7, 0x20, 0x2, 0x2, 0x6a5, 0x6a7, 0x5, 
       0x45a, 0x22e, 0x2, 0x6a6, 0x6a8, 0x5, 0x14e, 0xa8, 0x2, 0x6a7, 0x6a6, 
       0x3, 0x2, 0x2, 0x2, 0x6a7, 0x6a8, 0x3, 0x2, 0x2, 0x2, 0x6a8, 0x6aa, 
       0x3, 0x2, 0x2, 0x2, 0x6a9, 0x6a4, 0x3, 0x2, 0x2, 0x2, 0x6aa, 0x6ad, 
       0x3, 0x2, 0x2, 0x2, 0x6ab, 0x6a9, 0x3, 0x2, 0x2, 0x2, 0x6ab, 0x6ac, 
       0x3, 0x2, 0x2, 0x2, 0x6ac, 0x2f, 0x3, 0x2, 0x2, 0x2, 0x6ad, 0x6ab, 
       0x3, 0x2, 0x2, 0x2, 0x6ae, 0x6b0, 0x7, 0x3b, 0x2, 0x2, 0x6af, 0x6b1, 
       0x7, 0x9, 0x2, 0x2, 0x6b0, 0x6af, 0x3, 0x2, 0x2, 0x2, 0x6b0, 0x6b1, 
       0x3, 0x2, 0x2, 0x2, 0x6b1, 0x6b4, 0x3, 0x2, 0x2, 0x2, 0x6b2, 0x6b5, 
       0x7, 0xae, 0x2, 0x2, 0x6b3, 0x6b5, 0x5, 0x45a, 0x22e, 0x2, 0x6b4, 
       0x6b2, 0x3, 0x2, 0x2, 0x2, 0x6b4, 0x6b3, 0x3, 0x2, 0x2, 0x2, 0x6b5, 
       0x31, 0x3, 0x2, 0x2, 0x2, 0x6b6, 0x6b8, 0x7, 0x144, 0x2, 0x2, 0x6b7, 
       0x6b9, 0x7, 0x9, 0x2, 0x2, 0x6b8, 0x6b7, 0x3, 0x2, 0x2, 0x2, 0x6b8, 
       0x6b9, 0x3, 0x2, 0x2, 0x2, 0x6b9, 0x6bc, 0x3, 0x2, 0x2, 0x2, 0x6ba, 
       0x6bd, 0x7, 0xae, 0x2, 0x2, 0x6bb, 0x6bd, 0x5, 0x45a, 0x22e, 0x2, 
       0x6bc, 0x6ba, 0x3, 0x2, 0x2, 0x2, 0x6bc, 0x6bb, 0x3, 0x2, 0x2, 0x2, 
       0x6bd, 0x33, 0x3, 0x2, 0x2, 0x2, 0x6be, 0x6c7, 0x6, 0x1b, 0x18, 0x2, 
       0x6bf, 0x6c1, 0x5, 0x30, 0x19, 0x2, 0x6c0, 0x6c2, 0x5, 0x32, 0x1a, 
       0x2, 0x6c1, 0x6c0, 0x3, 0x2, 0x2, 0x2, 0x6c1, 0x6c2, 0x3, 0x2, 0x2, 
       0x2, 0x6c2, 0x6c8, 0x3, 0x2, 0x2, 0x2, 0x6c3, 0x6c5, 0x5, 0x32, 0x1a, 
       0x2, 0x6c4, 0x6c6, 0x5, 0x30, 0x19, 0x2, 0x6c5, 0x6c4, 0x3, 0x2, 
       0x2, 0x2, 0x6c5, 0x6c6, 0x3, 0x2, 0x2, 0x2, 0x6c6, 0x6c8, 0x3, 0x2, 
       0x2, 0x2, 0x6c7, 0x6bf, 0x3, 0x2, 0x2, 0x2, 0x6c7, 0x6c3, 0x3, 0x2, 
       0x2, 0x2, 0x6c8, 0x35, 0x3, 0x2, 0x2, 0x2, 0x6c9, 0x6ca, 0x6, 0x1c, 
       0x19, 0x2, 0x6ca, 0x6cb, 0x9, 0x5, 0x2, 0x2, 0x6cb, 0x6cc, 0x7, 0x291, 
       0x2, 0x2, 0x6cc, 0x37, 0x3, 0x2, 0x2, 0x2, 0x6cd, 0x6ce, 0x7, 0x1e8, 
       0x2, 0x2, 0x6ce, 0x6cf, 0x7, 0x1b7, 0x2, 0x2, 0x6cf, 0x39, 0x3, 0x2, 
       0x2, 0x2, 0x6d0, 0x6d3, 0x7, 0x3c, 0x2, 0x2, 0x6d1, 0x6d3, 0x5, 0x45c, 
       0x22f, 0x2, 0x6d2, 0x6d0, 0x3, 0x2, 0x2, 0x2, 0x6d2, 0x6d1, 0x3, 
       0x2, 0x2, 0x2, 0x6d3, 0x3b, 0x3, 0x2, 0x2, 0x2, 0x6d4, 0x6d5, 0x7, 
       0x1ea, 0x2, 0x2, 0x6d5, 0x6d7, 0x7, 0x1b9, 0x2, 0x2, 0x6d6, 0x6d8, 
       0x5, 0x3fc, 0x1ff, 0x2, 0x6d7, 0x6d6, 0x3, 0x2, 0x2, 0x2, 0x6d7, 
       0x6d8, 0x3, 0x2, 0x2, 0x2, 0x6d8, 0x6dd, 0x3, 0x2, 0x2, 0x2, 0x6d9, 
       0x6da, 0x5, 0x45c, 0x22f, 0x2, 0x6da, 0x6db, 0x7, 0x120, 0x2, 0x2, 
       0x6db, 0x6dc, 0x5, 0x3b6, 0x1dc, 0x2, 0x6dc, 0x6de, 0x3, 0x2, 0x2, 
       0x2, 0x6dd, 0x6d9, 0x3, 0x2, 0x2, 0x2, 0x6dd, 0x6de, 0x3, 0x2, 0x2, 
       0x2, 0x6de, 0x3d, 0x3, 0x2, 0x2, 0x2, 0x6df, 0x6e0, 0x7, 0x25c, 0x2, 
       0x2, 0x6e0, 0x702, 0x5, 0x428, 0x215, 0x2, 0x6e1, 0x6e2, 0x9, 0x6, 
       0x2, 0x2, 0x6e2, 0x6e3, 0x7, 0x9f, 0x2, 0x2, 0x6e3, 0x6e5, 0x5, 0x47a, 
       0x23e, 0x2, 0x6e4, 0x6e6, 0x5, 0x46, 0x24, 0x2, 0x6e5, 0x6e4, 0x3, 
       0x2, 0x2, 0x2, 0x6e5, 0x6e6, 0x3, 0x2, 0x2, 0x2, 0x6e6, 0x703, 0x3, 
       0x2, 0x2, 0x2, 0x6e7, 0x6fb, 0x6, 0x20, 0x1a, 0x2, 0x6e8, 0x6fc, 
       0x3, 0x2, 0x2, 0x2, 0x6e9, 0x6ea, 0x7, 0x69, 0x2, 0x2, 0x6ea, 0x6eb, 
       0x7, 0x9f, 0x2, 0x2, 0x6eb, 0x6f6, 0x5, 0x47a, 0x23e, 0x2, 0x6ec, 
       0x6f3, 0x5, 0x4a, 0x26, 0x2, 0x6ed, 0x6ef, 0x7, 0x20, 0x2, 0x2, 0x6ee, 
       0x6ed, 0x3, 0x2, 0x2, 0x2, 0x6ee, 0x6ef, 0x3, 0x2, 0x2, 0x2, 0x6ef, 
       0x6f0, 0x3, 0x2, 0x2, 0x2, 0x6f0, 0x6f2, 0x5, 0x4a, 0x26, 0x2, 0x6f1, 
       0x6ee, 0x3, 0x2, 0x2, 0x2, 0x6f2, 0x6f5, 0x3, 0x2, 0x2, 0x2, 0x6f3, 
       0x6f1, 0x3, 0x2, 0x2, 0x2, 0x6f3, 0x6f4, 0x3, 0x2, 0x2, 0x2, 0x6f4, 
       0x6f7, 0x3, 0x2, 0x2, 0x2, 0x6f5, 0x6f3, 0x3, 0x2, 0x2, 0x2, 0x6f6, 
       0x6ec, 0x3, 0x2, 0x2, 0x2, 0x6f6, 0x6f7, 0x3, 0x2, 0x2, 0x2, 0x6f7, 
       0x6fc, 0x3, 0x2, 0x2, 0x2, 0x6f8, 0x6fc, 0x9, 0x7, 0x2, 0x2, 0x6f9, 
       0x6fa, 0x7, 0x196, 0x2, 0x2, 0x6fa, 0x6fc, 0x7, 0x33, 0x2, 0x2, 0x6fb, 
       0x6e8, 0x3, 0x2, 0x2, 0x2, 0x6fb, 0x6e9, 0x3, 0x2, 0x2, 0x2, 0x6fb, 
       0x6f8, 0x3, 0x2, 0x2, 0x2, 0x6fb, 0x6f9, 0x3, 0x2, 0x2, 0x2, 0x6fc, 
       0x703, 0x3, 0x2, 0x2, 0x2, 0x6fd, 0x6fe, 0x7, 0x1e9, 0x2, 0x2, 0x6fe, 
       0x6ff, 0x7, 0x26e, 0x2, 0x2, 0x6ff, 0x703, 0x5, 0x45a, 0x22e, 0x2, 
       0x700, 0x701, 0x6, 0x20, 0x1b, 0x2, 0x701, 0x703, 0x5, 0x46, 0x24, 
       0x2, 0x702, 0x6e1, 0x3, 0x2, 0x2, 0x2, 0x702, 0x6e7, 0x3, 0x2, 0x2, 
       0x2, 0x702, 0x6fd, 0x3, 0x2, 0x2, 0x2, 0x702, 0x700, 0x3, 0x2, 0x2, 
       0x2, 0x703, 0x3f, 0x3, 0x2, 0x2, 0x2, 0x704, 0x705, 0x7, 0x27d, 0x2, 
       0x2, 0x705, 0x706, 0x7, 0x25c, 0x2, 0x2, 0x706, 0x707, 0x5, 0x428, 
       0x215, 0x2, 0x707, 0x708, 0x7, 0x21b, 0x2, 0x2, 0x708, 0x70a, 0x9, 
       0x8, 0x2, 0x2, 0x709, 0x70b, 0x5, 0x42, 0x22, 0x2, 0x70a, 0x709, 
       0x3, 0x2, 0x2, 0x2, 0x70a, 0x70b, 0x3, 0x2, 0x2, 0x2, 0x70b, 0x41, 
       0x3, 0x2, 0x2, 0x2, 0x70c, 0x713, 0x5, 0x44, 0x23, 0x2, 0x70d, 0x70f, 
       0x7, 0x20, 0x2, 0x2, 0x70e, 0x70d, 0x3, 0x2, 0x2, 0x2, 0x70e, 0x70f, 
       0x3, 0x2, 0x2, 0x2, 0x70f, 0x710, 0x3, 0x2, 0x2, 0x2, 0x710, 0x712, 
       0x5, 0x44, 0x23, 0x2, 0x711, 0x70e, 0x3, 0x2, 0x2, 0x2, 0x712, 0x715, 
       0x3, 0x2, 0x2, 0x2, 0x713, 0x711, 0x3, 0x2, 0x2, 0x2, 0x713, 0x714, 
       0x3, 0x2, 0x2, 0x2, 0x714, 0x43, 0x3, 0x2, 0x2, 0x2, 0x715, 0x713, 
       0x3, 0x2, 0x2, 0x2, 0x716, 0x717, 0x5, 0x9c, 0x4f, 0x2, 0x717, 0x45, 
       0x3, 0x2, 0x2, 0x2, 0x718, 0x71f, 0x5, 0x48, 0x25, 0x2, 0x719, 0x71b, 
       0x7, 0x20, 0x2, 0x2, 0x71a, 0x719, 0x3, 0x2, 0x2, 0x2, 0x71a, 0x71b, 
       0x3, 0x2, 0x2, 0x2, 0x71b, 0x71c, 0x3, 0x2, 0x2, 0x2, 0x71c, 0x71e, 
       0x5, 0x48, 0x25, 0x2, 0x71d, 0x71a, 0x3, 0x2, 0x2, 0x2, 0x71e, 0x721, 
       0x3, 0x2, 0x2, 0x2, 0x71f, 0x71d, 0x3, 0x2, 0x2, 0x2, 0x71f, 0x720, 
       0x3, 0x2, 0x2, 0x2, 0x720, 0x47, 0x3, 0x2, 0x2, 0x2, 0x721, 0x71f, 
       0x3, 0x2, 0x2, 0x2, 0x722, 0x724, 0x7, 0x117, 0x2, 0x2, 0x723, 0x725, 
       0x7, 0x9, 0x2, 0x2, 0x724, 0x723, 0x3, 0x2, 0x2, 0x2, 0x724, 0x725, 
       0x3, 0x2, 0x2, 0x2, 0x725, 0x726, 0x3, 0x2, 0x2, 0x2, 0x726, 0x72d, 
       0x5, 0x494, 0x24b, 0x2, 0x727, 0x72d, 0x5, 0x94, 0x4b, 0x2, 0x728, 
       0x72d, 0x5, 0x96, 0x4c, 0x2, 0x729, 0x72d, 0x5, 0x9c, 0x4f, 0x2, 
       0x72a, 0x72d, 0x5, 0x9e, 0x50, 0x2, 0x72b, 0x72d, 0x5, 0xa4, 0x53, 
       0x2, 0x72c, 0x722, 0x3, 0x2, 0x2, 0x2, 0x72c, 0x727, 0x3, 0x2, 0x2, 
       0x2, 0x72c, 0x728, 0x3, 0x2, 0x2, 0x2, 0x72c, 0x729, 0x3, 0x2, 0x2, 
       0x2, 0x72c, 0x72a, 0x3, 0x2, 0x2, 0x2, 0x72c, 0x72b, 0x3, 0x2, 0x2, 
       0x2, 0x72d, 0x49, 0x3, 0x2, 0x2, 0x2, 0x72e, 0x730, 0x7, 0x117, 0x2, 
       0x2, 0x72f, 0x731, 0x7, 0x9, 0x2, 0x2, 0x730, 0x72f, 0x3, 0x2, 0x2, 
       0x2, 0x730, 0x731, 0x3, 0x2, 0x2, 0x2, 0x731, 0x732, 0x3, 0x2, 0x2, 
       0x2, 0x732, 0x736, 0x5, 0x494, 0x24b, 0x2, 0x733, 0x736, 0x5, 0x94, 
       0x4b, 0x2, 0x734, 0x736, 0x5, 0x96, 0x4c, 0x2, 0x735, 0x72e, 0x3, 
       0x2, 0x2, 0x2, 0x735, 0x733, 0x3, 0x2, 0x2, 0x2, 0x735, 0x734, 0x3, 
       0x2, 0x2, 0x2, 0x736, 0x4b, 0x3, 0x2, 0x2, 0x2, 0x737, 0x739, 0x5, 
       0xaa, 0x56, 0x2, 0x738, 0x737, 0x3, 0x2, 0x2, 0x2, 0x738, 0x739, 
       0x3, 0x2, 0x2, 0x2, 0x739, 0x73b, 0x3, 0x2, 0x2, 0x2, 0x73a, 0x73c, 
       0x5, 0x3c4, 0x1e3, 0x2, 0x73b, 0x73a, 0x3, 0x2, 0x2, 0x2, 0x73b, 
       0x73c, 0x3, 0x2, 0x2, 0x2, 0x73c, 0x73e, 0x3, 0x2, 0x2, 0x2, 0x73d, 
       0x73f, 0x5, 0xac, 0x57, 0x2, 0x73e, 0x73d, 0x3, 0x2, 0x2, 0x2, 0x73e, 
       0x73f, 0x3, 0x2, 0x2, 0x2, 0x73f, 0x740, 0x3, 0x2, 0x2, 0x2, 0x740, 
       0x741, 0x7, 0x29b, 0x2, 0x2, 0x741, 0x742, 0x5, 0x424, 0x213, 0x2, 
       0x742, 0x743, 0x5, 0x4e, 0x28, 0x2, 0x743, 0x4d, 0x3, 0x2, 0x2, 0x2, 
       0x744, 0x746, 0x5, 0x406, 0x204, 0x2, 0x745, 0x744, 0x3, 0x2, 0x2, 
       0x2, 0x745, 0x746, 0x3, 0x2, 0x2, 0x2, 0x746, 0x747, 0x3, 0x2, 0x2, 
       0x2, 0x747, 0x748, 0x7, 0x43, 0x2, 0x2, 0x748, 0x749, 0x5, 0x50, 
       0x29, 0x2, 0x749, 0x4f, 0x3, 0x2, 0x2, 0x2, 0x74a, 0x74c, 0x5, 0x62, 
       0x32, 0x2, 0x74b, 0x74d, 0x5, 0x52, 0x2a, 0x2, 0x74c, 0x74b, 0x3, 
       0x2, 0x2, 0x2, 0x74c, 0x74d, 0x3, 0x2, 0x2, 0x2, 0x74d, 0x51, 0x3, 
       0x2, 0x2, 0x2, 0x74e, 0x750, 0x7, 0x2a4, 0x2, 0x2, 0x74f, 0x751, 
       0x9, 0x9, 0x2, 0x2, 0x750, 0x74f, 0x3, 0x2, 0x2, 0x2, 0x750, 0x751, 
       0x3, 0x2, 0x2, 0x2, 0x751, 0x752, 0x3, 0x2, 0x2, 0x2, 0x752, 0x753, 
       0x7, 0x6f, 0x2, 0x2, 0x753, 0x754, 0x7, 0x1ab, 0x2, 0x2, 0x754, 0x53, 
       0x3, 0x2, 0x2, 0x2, 0x755, 0x768, 0x7, 0x92, 0x2, 0x2, 0x756, 0x769, 
       0x5, 0x56, 0x2c, 0x2, 0x757, 0x769, 0x5, 0x5a, 0x2e, 0x2, 0x758, 
       0x769, 0x5, 0x68, 0x35, 0x2, 0x759, 0x769, 0x5, 0x66, 0x34, 0x2, 
       0x75a, 0x769, 0x5, 0x6a, 0x36, 0x2, 0x75b, 0x769, 0x5, 0x78, 0x3d, 
       0x2, 0x75c, 0x769, 0x5, 0xa6, 0x54, 0x2, 0x75d, 0x769, 0x5, 0xae, 
       0x58, 0x2, 0x75e, 0x769, 0x5, 0x72, 0x3a, 0x2, 0x75f, 0x769, 0x5, 
       0x7e, 0x40, 0x2, 0x760, 0x769, 0x5, 0x84, 0x43, 0x2, 0x761, 0x769, 
       0x5, 0xb2, 0x5a, 0x2, 0x762, 0x763, 0x6, 0x2b, 0x1c, 0x2, 0x763, 
       0x769, 0x5, 0xb4, 0x5b, 0x2, 0x764, 0x765, 0x6, 0x2b, 0x1d, 0x2, 
       0x765, 0x769, 0x5, 0xb6, 0x5c, 0x2, 0x766, 0x767, 0x6, 0x2b, 0x1e, 
       0x2, 0x767, 0x769, 0x5, 0x86, 0x44, 0x2, 0x768, 0x756, 0x3, 0x2, 
       0x2, 0x2, 0x768, 0x757, 0x3, 0x2, 0x2, 0x2, 0x768, 0x758, 0x3, 0x2, 
       0x2, 0x2, 0x768, 0x759, 0x3, 0x2, 0x2, 0x2, 0x768, 0x75a, 0x3, 0x2, 
       0x2, 0x2, 0x768, 0x75b, 0x3, 0x2, 0x2, 0x2, 0x768, 0x75c, 0x3, 0x2, 
       0x2, 0x2, 0x768, 0x75d, 0x3, 0x2, 0x2, 0x2, 0x768, 0x75e, 0x3, 0x2, 
       0x2, 0x2, 0x768, 0x75f, 0x3, 0x2, 0x2, 0x2, 0x768, 0x760, 0x3, 0x2, 
       0x2, 0x2, 0x768, 0x761, 0x3, 0x2, 0x2, 0x2, 0x768, 0x762, 0x3, 0x2, 
       0x2, 0x2, 0x768, 0x764, 0x3, 0x2, 0x2, 0x2, 0x768, 0x766, 0x3, 0x2, 
       0x2, 0x2, 0x769, 0x55, 0x3, 0x2, 0x2, 0x2, 0x76a, 0x76c, 0x7, 0x9d, 
       0x2, 0x2, 0x76b, 0x76d, 0x5, 0x3c8, 0x1e5, 0x2, 0x76c, 0x76b, 0x3, 
       0x2, 0x2, 0x2, 0x76c, 0x76d, 0x3, 0x2, 0x2, 0x2, 0x76d, 0x76e, 0x3, 
       0x2, 0x2, 0x2, 0x76e, 0x772, 0x5, 0x412, 0x20a, 0x2, 0x76f, 0x771, 
       0x5, 0x58, 0x2d, 0x2, 0x770, 0x76f, 0x3, 0x2, 0x2, 0x2, 0x771, 0x774, 
       0x3, 0x2, 0x2, 0x2, 0x772, 0x770, 0x3, 0x2, 0x2, 0x2, 0x772, 0x773, 
       0x3, 0x2, 0x2, 0x2, 0x773, 0x57, 0x3, 0x2, 0x2, 0x2, 0x774, 0x772, 
       0x3, 0x2, 0x2, 0x2, 0x775, 0x77a, 0x5, 0x3ac, 0x1d7, 0x2, 0x776, 
       0x77a, 0x5, 0x3a8, 0x1d5, 0x2, 0x777, 0x778, 0x6, 0x2d, 0x1f, 0x2, 
       0x778, 0x77a, 0x5, 0x3aa, 0x1d6, 0x2, 0x779, 0x775, 0x3, 0x2, 0x2, 
       0x2, 0x779, 0x776, 0x3, 0x2, 0x2, 0x2, 0x779, 0x777, 0x3, 0x2, 0x2, 
       0x2, 0x77a, 0x59, 0x3, 0x2, 0x2, 0x2, 0x77b, 0x77d, 0x7, 0x261, 0x2, 
       0x2, 0x77c, 0x77b, 0x3, 0x2, 0x2, 0x2, 0x77c, 0x77d, 0x3, 0x2, 0x2, 
       0x2, 0x77d, 0x77e, 0x3, 0x2, 0x2, 0x2, 0x77e, 0x780, 0x7, 0x25e, 
       0x2, 0x2, 0x77f, 0x781, 0x5, 0x3c8, 0x1e5, 0x2, 0x780, 0x77f, 0x3, 
       0x2, 0x2, 0x2, 0x780, 0x781, 0x3, 0x2, 0x2, 0x2, 0x781, 0x782, 0x3, 
       0x2, 0x2, 0x2, 0x782, 0x799, 0x5, 0x43a, 0x21e, 0x2, 0x783, 0x784, 
       0x7, 0x23, 0x2, 0x2, 0x784, 0x785, 0x5, 0x5c, 0x2f, 0x2, 0x785, 0x786, 
       0x7, 0x24, 0x2, 0x2, 0x786, 0x788, 0x3, 0x2, 0x2, 0x2, 0x787, 0x783, 
       0x3, 0x2, 0x2, 0x2, 0x787, 0x788, 0x3, 0x2, 0x2, 0x2, 0x788, 0x78a, 
       0x3, 0x2, 0x2, 0x2, 0x789, 0x78b, 0x5, 0x3a0, 0x1d1, 0x2, 0x78a, 
       0x789, 0x3, 0x2, 0x2, 0x2, 0x78a, 0x78b, 0x3, 0x2, 0x2, 0x2, 0x78b, 
       0x78d, 0x3, 0x2, 0x2, 0x2, 0x78c, 0x78e, 0x5, 0x3ae, 0x1d8, 0x2, 
       0x78d, 0x78c, 0x3, 0x2, 0x2, 0x2, 0x78d, 0x78e, 0x3, 0x2, 0x2, 0x2, 
       0x78e, 0x790, 0x3, 0x2, 0x2, 0x2, 0x78f, 0x791, 0x5, 0x60, 0x31, 
       0x2, 0x790, 0x78f, 0x3, 0x2, 0x2, 0x2, 0x790, 0x791, 0x3, 0x2, 0x2, 
       0x2, 0x791, 0x79a, 0x3, 0x2, 0x2, 0x2, 0x792, 0x793, 0x7, 0x13a, 
       0x2, 0x2, 0x793, 0x79a, 0x5, 0x440, 0x221, 0x2, 0x794, 0x795, 0x7, 
       0x23, 0x2, 0x2, 0x795, 0x796, 0x7, 0x13a, 0x2, 0x2, 0x796, 0x797, 
       0x5, 0x440, 0x221, 0x2, 0x797, 0x798, 0x7, 0x24, 0x2, 0x2, 0x798, 
       0x79a, 0x3, 0x2, 0x2, 0x2, 0x799, 0x787, 0x3, 0x2, 0x2, 0x2, 0x799, 
       0x792, 0x3, 0x2, 0x2, 0x2, 0x799, 0x794, 0x3, 0x2, 0x2, 0x2, 0x79a, 
       0x5b, 0x3, 0x2, 0x2, 0x2, 0x79b, 0x7a0, 0x5, 0x5e, 0x30, 0x2, 0x79c, 
       0x79d, 0x7, 0x20, 0x2, 0x2, 0x79d, 0x79f, 0x5, 0x5e, 0x30, 0x2, 0x79e, 
       0x79c, 0x3, 0x2, 0x2, 0x2, 0x79f, 0x7a2, 0x3, 0x2, 0x2, 0x2, 0x7a0, 
       0x79e, 0x3, 0x2, 0x2, 0x2, 0x7a0, 0x7a1, 0x3, 0x2, 0x2, 0x2, 0x7a1, 
       0x5d, 0x3, 0x2, 0x2, 0x2, 0x7a2, 0x7a0, 0x3, 0x2, 0x2, 0x2, 0x7a3, 
       0x7a6, 0x5, 0x350, 0x1a9, 0x2, 0x7a4, 0x7a6, 0x5, 0x358, 0x1ad, 0x2, 
       0x7a5, 0x7a3, 0x3, 0x2, 0x2, 0x2, 0x7a5, 0x7a4, 0x3, 0x2, 0x2, 0x2, 
       0x7a6, 0x5f, 0x3, 0x2, 0x2, 0x2, 0x7a7, 0x7a9, 0x9, 0xa, 0x2, 0x2, 
       0x7a8, 0x7a7, 0x3, 0x2, 0x2, 0x2, 0x7a8, 0x7a9, 0x3, 0x2, 0x2, 0x2, 
       0x7a9, 0x7ab, 0x3, 0x2, 0x2, 0x2, 0x7aa, 0x7ac, 0x7, 0x43, 0x2, 0x2, 
       0x7ab, 0x7aa, 0x3, 0x2, 0x2, 0x2, 0x7ab, 0x7ac, 0x3, 0x2, 0x2, 0x2, 
       0x7ac, 0x7ad, 0x3, 0x2, 0x2, 0x2, 0x7ad, 0x7ae, 0x5, 0x62, 0x32, 
       0x2, 0x7ae, 0x61, 0x3, 0x2, 0x2, 0x2, 0x7af, 0x7b2, 0x5, 0x114, 0x8b, 
       0x2, 0x7b0, 0x7b2, 0x5, 0x118, 0x8d, 0x2, 0x7b1, 0x7af, 0x3, 0x2, 
       0x2, 0x2, 0x7b1, 0x7b0, 0x3, 0x2, 0x2, 0x2, 0x7b2, 0x63, 0x3, 0x2, 
       0x2, 0x2, 0x7b3, 0x7b7, 0x7, 0x92, 0x2, 0x2, 0x7b4, 0x7b8, 0x5, 0x66, 
       0x34, 0x2, 0x7b5, 0x7b8, 0x5, 0x68, 0x35, 0x2, 0x7b6, 0x7b8, 0x5, 
       0x6a, 0x36, 0x2, 0x7b7, 0x7b4, 0x3, 0x2, 0x2, 0x2, 0x7b7, 0x7b5, 
       0x3, 0x2, 0x2, 0x2, 0x7b7, 0x7b6, 0x3, 0x2, 0x2, 0x2, 0x7b8, 0x7ba, 
       0x3, 0x2, 0x2, 0x2, 0x7b9, 0x7bb, 0x7, 0x21, 0x2, 0x2, 0x7ba, 0x7b9, 
       0x3, 0x2, 0x2, 0x2, 0x7ba, 0x7bb, 0x3, 0x2, 0x2, 0x2, 0x7bb, 0x7bc, 
       0x3, 0x2, 0x2, 0x2, 0x7bc, 0x7bd, 0x7, 0x2, 0x2, 0x3, 0x7bd, 0x65, 
       0x3, 0x2, 0x2, 0x2, 0x7be, 0x7c0, 0x5, 0x3c4, 0x1e3, 0x2, 0x7bf, 
       0x7be, 0x3, 0x2, 0x2, 0x2, 0x7bf, 0x7c0, 0x3, 0x2, 0x2, 0x2, 0x7c0, 
       0x7c1, 0x3, 0x2, 0x2, 0x2, 0x7c1, 0x7c2, 0x7, 0x1ca, 0x2, 0x2, 0x7c2, 
       0x7c3, 0x5, 0x416, 0x20c, 0x2, 0x7c3, 0x7cc, 0x7, 0x23, 0x2, 0x2, 
       0x7c4, 0x7c9, 0x5, 0x3ca, 0x1e6, 0x2, 0x7c5, 0x7c6, 0x7, 0x20, 0x2, 
       0x2, 0x7c6, 0x7c8, 0x5, 0x3ca, 0x1e6, 0x2, 0x7c7, 0x7c5, 0x3, 0x2, 
       0x2, 0x2, 0x7c8, 0x7cb, 0x3, 0x2, 0x2, 0x2, 0x7c9, 0x7c7, 0x3, 0x2, 
       0x2, 0x2, 0x7c9, 0x7ca, 0x3, 0x2, 0x2, 0x2, 0x7ca, 0x7cd, 0x3, 0x2, 
       0x2, 0x2, 0x7cb, 0x7c9, 0x3, 0x2, 0x2, 0x2, 0x7cc, 0x7c4, 0x3, 0x2, 
       0x2, 0x2, 0x7cc, 0x7cd, 0x3, 0x2, 0x2, 0x2, 0x7cd, 0x7ce, 0x3, 0x2, 
       0x2, 0x2, 0x7ce, 0x7d2, 0x7, 0x24, 0x2, 0x2, 0x7cf, 0x7d1, 0x5, 0x6c, 
       0x37, 0x2, 0x7d0, 0x7cf, 0x3, 0x2, 0x2, 0x2, 0x7d1, 0x7d4, 0x3, 0x2, 
       0x2, 0x2, 0x7d2, 0x7d0, 0x3, 0x2, 0x2, 0x2, 0x7d2, 0x7d3, 0x3, 0x2, 
       0x2, 0x2, 0x7d3, 0x7d5, 0x3, 0x2, 0x2, 0x2, 0x7d4, 0x7d2, 0x3, 0x2, 
       0x2, 0x2, 0x7d5, 0x7d6, 0x5, 0x300, 0x181, 0x2, 0x7d6, 0x67, 0x3, 
       0x2, 0x2, 0x2, 0x7d7, 0x7d9, 0x5, 0x3c4, 0x1e3, 0x2, 0x7d8, 0x7d7, 
       0x3, 0x2, 0x2, 0x2, 0x7d8, 0x7d9, 0x3, 0x2, 0x2, 0x2, 0x7d9, 0x7da, 
       0x3, 0x2, 0x2, 0x2, 0x7da, 0x7db, 0x7, 0xf7, 0x2, 0x2, 0x7db, 0x7dc, 
       0x5, 0x41a, 0x20e, 0x2, 0x7dc, 0x7e5, 0x7, 0x23, 0x2, 0x2, 0x7dd, 
       0x7e2, 0x5, 0x3cc, 0x1e7, 0x2, 0x7de, 0x7df, 0x7, 0x20, 0x2, 0x2, 
       0x7df, 0x7e1, 0x5, 0x3cc, 0x1e7, 0x2, 0x7e0, 0x7de, 0x3, 0x2, 0x2, 
       0x2, 0x7e1, 0x7e4, 0x3, 0x2, 0x2, 0x2, 0x7e2, 0x7e0, 0x3, 0x2, 0x2, 
       0x2, 0x7e2, 0x7e3, 0x3, 0x2, 0x2, 0x2, 0x7e3, 0x7e6, 0x3, 0x2, 0x2, 
       0x2, 0x7e4, 0x7e2, 0x3, 0x2, 0x2, 0x2, 0x7e5, 0x7dd, 0x3, 0x2, 0x2, 
       0x2, 0x7e5, 0x7e6, 0x3, 0x2, 0x2, 0x2, 0x7e6, 0x7e7, 0x3, 0x2, 0x2, 
       0x2, 0x7e7, 0x7e8, 0x7, 0x24, 0x2, 0x2, 0x7e8, 0x7e9, 0x7, 0x1fe, 
       0x2, 0x2, 0x7e9, 0x7ed, 0x5, 0x3d0, 0x1e9, 0x2, 0x7ea, 0x7ec, 0x5, 
       0x6c, 0x37, 0x2, 0x7eb, 0x7ea, 0x3, 0x2, 0x2, 0x2, 0x7ec, 0x7ef, 
       0x3, 0x2, 0x2, 0x2, 0x7ed, 0x7eb, 0x3, 0x2, 0x2, 0x2, 0x7ed, 0x7ee, 
       0x3, 0x2, 0x2, 0x2, 0x7ee, 0x7f0, 0x3, 0x2, 0x2, 0x2, 0x7ef, 0x7ed, 
       0x3, 0x2, 0x2, 0x2, 0x7f0, 0x7f1, 0x5, 0x300, 0x181, 0x2, 0x7f1, 
       0x69, 0x3, 0x2, 0x2, 0x2, 0x7f2, 0x7f4, 0x7, 0x3a, 0x2, 0x2, 0x7f3, 
       0x7f2, 0x3, 0x2, 0x2, 0x2, 0x7f3, 0x7f4, 0x3, 0x2, 0x2, 0x2, 0x7f4, 
       0x7f5, 0x3, 0x2, 0x2, 0x2, 0x7f5, 0x7f6, 0x7, 0xf7, 0x2, 0x2, 0x7f6, 
       0x7f7, 0x5, 0x432, 0x21a, 0x2, 0x7f7, 0x7f8, 0x7, 0x1fe, 0x2, 0x2, 
       0x7f8, 0x7f9, 0x9, 0xb, 0x2, 0x2, 0x7f9, 0x7fa, 0x7, 0x228, 0x2, 
       0x2, 0x7fa, 0x7fb, 0x5, 0x47a, 0x23e, 0x2, 0x7fb, 0x6b, 0x3, 0x2, 
       0x2, 0x2, 0x7fc, 0x802, 0x5, 0x70, 0x39, 0x2, 0x7fd, 0x7ff, 0x7, 
       0x196, 0x2, 0x2, 0x7fe, 0x7fd, 0x3, 0x2, 0x2, 0x2, 0x7fe, 0x7ff, 
       0x3, 0x2, 0x2, 0x2, 0x7ff, 0x800, 0x3, 0x2, 0x2, 0x2, 0x800, 0x802, 
       0x7, 0xb7, 0x2, 0x2, 0x801, 0x7fc, 0x3, 0x2, 0x2, 0x2, 0x801, 0x7fe, 
       0x3, 0x2, 0x2, 0x2, 0x802, 0x6d, 0x3, 0x2, 0x2, 0x2, 0x803, 0x805, 
       0x5, 0x6c, 0x37, 0x2, 0x804, 0x803, 0x3, 0x2, 0x2, 0x2, 0x805, 0x806, 
       0x3, 0x2, 0x2, 0x2, 0x806, 0x804, 0x3, 0x2, 0x2, 0x2, 0x806, 0x807, 
       0x3, 0x2, 0x2, 0x2, 0x807, 0x6f, 0x3, 0x2, 0x2, 0x2, 0x808, 0x809, 
       0x7, 0x7c, 0x2, 0x2, 0x809, 0x81a, 0x5, 0x47a, 0x23e, 0x2, 0x80a, 
       0x80b, 0x7, 0x132, 0x2, 0x2, 0x80b, 0x81a, 0x7, 0x239, 0x2, 0x2, 
       0x80c, 0x80d, 0x7, 0x198, 0x2, 0x2, 0x80d, 0x81a, 0x7, 0x239, 0x2, 
       0x2, 0x80e, 0x80f, 0x7, 0x8b, 0x2, 0x2, 0x80f, 0x81a, 0x7, 0x239, 
       0x2, 0x2, 0x810, 0x811, 0x7, 0x1d5, 0x2, 0x2, 0x811, 0x812, 0x7, 
       0x239, 0x2, 0x2, 0x812, 0x81a, 0x7, 0xa0, 0x2, 0x2, 0x813, 0x814, 
       0x7, 0x17f, 0x2, 0x2, 0x814, 0x815, 0x7, 0x239, 0x2, 0x2, 0x815, 
       0x81a, 0x7, 0xa0, 0x2, 0x2, 0x816, 0x817, 0x7, 0x239, 0x2, 0x2, 0x817, 
       0x818, 0x7, 0x211, 0x2, 0x2, 0x818, 0x81a, 0x9, 0xc, 0x2, 0x2, 0x819, 
       0x808, 0x3, 0x2, 0x2, 0x2, 0x819, 0x80a, 0x3, 0x2, 0x2, 0x2, 0x819, 
       0x80c, 0x3, 0x2, 0x2, 0x2, 0x819, 0x80e, 0x3, 0x2, 0x2, 0x2, 0x819, 
       0x810, 0x3, 0x2, 0x2, 0x2, 0x819, 0x813, 0x3, 0x2, 0x2, 0x2, 0x819, 
       0x816, 0x3, 0x2, 0x2, 0x2, 0x81a, 0x71, 0x3, 0x2, 0x2, 0x2, 0x81b, 
       0x81d, 0x5, 0x3fa, 0x1fe, 0x2, 0x81c, 0x81b, 0x3, 0x2, 0x2, 0x2, 
       0x81c, 0x81d, 0x3, 0x2, 0x2, 0x2, 0x81d, 0x847, 0x3, 0x2, 0x2, 0x2, 
       0x81e, 0x820, 0x7, 0x281, 0x2, 0x2, 0x81f, 0x81e, 0x3, 0x2, 0x2, 
       0x2, 0x81f, 0x820, 0x3, 0x2, 0x2, 0x2, 0x820, 0x821, 0x3, 0x2, 0x2, 
       0x2, 0x821, 0x82a, 0x7, 0x115, 0x2, 0x2, 0x822, 0x823, 0x6, 0x3a, 
       0x20, 0x2, 0x823, 0x825, 0x5, 0x40c, 0x207, 0x2, 0x824, 0x826, 0x5, 
       0x37c, 0x1bf, 0x2, 0x825, 0x824, 0x3, 0x2, 0x2, 0x2, 0x825, 0x826, 
       0x3, 0x2, 0x2, 0x2, 0x826, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x827, 0x829, 
       0x5, 0x74, 0x3b, 0x2, 0x828, 0x827, 0x3, 0x2, 0x2, 0x2, 0x828, 0x829, 
       0x3, 0x2, 0x2, 0x2, 0x829, 0x82b, 0x3, 0x2, 0x2, 0x2, 0x82a, 0x822, 
       0x3, 0x2, 0x2, 0x2, 0x82a, 0x828, 0x3, 0x2, 0x2, 0x2, 0x82b, 0x82c, 
       0x3, 0x2, 0x2, 0x2, 0x82c, 0x830, 0x5, 0x76, 0x3c, 0x2, 0x82d, 0x82f, 
       0x5, 0x376, 0x1bc, 0x2, 0x82e, 0x82d, 0x3, 0x2, 0x2, 0x2, 0x82f, 
       0x832, 0x3, 0x2, 0x2, 0x2, 0x830, 0x82e, 0x3, 0x2, 0x2, 0x2, 0x830, 
       0x831, 0x3, 0x2, 0x2, 0x2, 0x831, 0x848, 0x3, 0x2, 0x2, 0x2, 0x832, 
       0x830, 0x3, 0x2, 0x2, 0x2, 0x833, 0x834, 0x7, 0xf6, 0x2, 0x2, 0x834, 
       0x835, 0x7, 0x115, 0x2, 0x2, 0x835, 0x836, 0x5, 0x40c, 0x207, 0x2, 
       0x836, 0x83a, 0x5, 0x76, 0x3c, 0x2, 0x837, 0x839, 0x5, 0x37e, 0x1c0, 
       0x2, 0x838, 0x837, 0x3, 0x2, 0x2, 0x2, 0x839, 0x83c, 0x3, 0x2, 0x2, 
       0x2, 0x83a, 0x838, 0x3, 0x2, 0x2, 0x2, 0x83a, 0x83b, 0x3, 0x2, 0x2, 
       0x2, 0x83b, 0x848, 0x3, 0x2, 0x2, 0x2, 0x83c, 0x83a, 0x3, 0x2, 0x2, 
       0x2, 0x83d, 0x83e, 0x7, 0x22b, 0x2, 0x2, 0x83e, 0x83f, 0x7, 0x115, 
       0x2, 0x2, 0x83f, 0x840, 0x5, 0x40c, 0x207, 0x2, 0x840, 0x844, 0x5, 
       0x76, 0x3c, 0x2, 0x841, 0x843, 0x5, 0x380, 0x1c1, 0x2, 0x842, 0x841, 
       0x3, 0x2, 0x2, 0x2, 0x843, 0x846, 0x3, 0x2, 0x2, 0x2, 0x844, 0x842, 
       0x3, 0x2, 0x2, 0x2, 0x844, 0x845, 0x3, 0x2, 0x2, 0x2, 0x845, 0x848, 
       0x3, 0x2, 0x2, 0x2, 0x846, 0x844, 0x3, 0x2, 0x2, 0x2, 0x847, 0x81f, 
       0x3, 0x2, 0x2, 0x2, 0x847, 0x833, 0x3, 0x2, 0x2, 0x2, 0x847, 0x83d, 
       0x3, 0x2, 0x2, 0x2, 0x848, 0x84a, 0x3, 0x2, 0x2, 0x2, 0x849, 0x84b, 
       0x5, 0x34, 0x1b, 0x2, 0x84a, 0x849, 0x3, 0x2, 0x2, 0x2, 0x84a, 0x84b, 
       0x3, 0x2, 0x2, 0x2, 0x84b, 0x73, 0x3, 0x2, 0x2, 0x2, 0x84c, 0x84f, 
       0x5, 0x40c, 0x207, 0x2, 0x84d, 0x84e, 0x7, 0x28d, 0x2, 0x2, 0x84e, 
       0x850, 0x5, 0x374, 0x1bb, 0x2, 0x84f, 0x84d, 0x3, 0x2, 0x2, 0x2, 
       0x84f, 0x850, 0x3, 0x2, 0x2, 0x2, 0x850, 0x856, 0x3, 0x2, 0x2, 0x2, 
       0x851, 0x852, 0x5, 0x40c, 0x207, 0x2, 0x852, 0x853, 0x7, 0x277, 0x2, 
       0x2, 0x853, 0x854, 0x5, 0x374, 0x1bb, 0x2, 0x854, 0x856, 0x3, 0x2, 
       0x2, 0x2, 0x855, 0x84c, 0x3, 0x2, 0x2, 0x2, 0x855, 0x851, 0x3, 0x2, 
       0x2, 0x2, 0x856, 0x75, 0x3, 0x2, 0x2, 0x2, 0x857, 0x858, 0x7, 0x1a2, 
       0x2, 0x2, 0x858, 0x859, 0x5, 0x440, 0x221, 0x2, 0x859, 0x85a, 0x5, 
       0x372, 0x1ba, 0x2, 0x85a, 0x77, 0x3, 0x2, 0x2, 0x2, 0x85b, 0x85c, 
       0x7, 0x145, 0x2, 0x2, 0x85c, 0x85d, 0x7, 0x102, 0x2, 0x2, 0x85d, 
       0x85e, 0x5, 0x42a, 0x216, 0x2, 0x85e, 0x85f, 0x7, 0x36, 0x2, 0x2, 
       0x85f, 0x860, 0x9, 0xd, 0x2, 0x2, 0x860, 0x862, 0x5, 0x47a, 0x23e, 
       0x2, 0x861, 0x863, 0x5, 0x7a, 0x3e, 0x2, 0x862, 0x861, 0x3, 0x2, 
       0x2, 0x2, 0x862, 0x863, 0x3, 0x2, 0x2, 0x2, 0x863, 0x79, 0x3, 0x2, 
       0x2, 0x2, 0x864, 0x86b, 0x5, 0x7c, 0x3f, 0x2, 0x865, 0x867, 0x7, 
       0x20, 0x2, 0x2, 0x866, 0x865, 0x3, 0x2, 0x2, 0x2, 0x866, 0x867, 0x3, 
       0x2, 0x2, 0x2, 0x867, 0x868, 0x3, 0x2, 0x2, 0x2, 0x868, 0x86a, 0x5, 
       0x7c, 0x3f, 0x2, 0x869, 0x866, 0x3, 0x2, 0x2, 0x2, 0x86a, 0x86d, 
       0x3, 0x2, 0x2, 0x2, 0x86b, 0x869, 0x3, 0x2, 0x2, 0x2, 0x86b, 0x86c, 
       0x3, 0x2, 0x2, 0x2, 0x86c, 0x7b, 0x3, 0x2, 0x2, 0x2, 0x86d, 0x86b, 
       0x3, 0x2, 0x2, 0x2, 0x86e, 0x875, 0x5, 0x90, 0x49, 0x2, 0x86f, 0x875, 
       0x5, 0x92, 0x4a, 0x2, 0x870, 0x875, 0x5, 0x9a, 0x4e, 0x2, 0x871, 
       0x875, 0x5, 0x9c, 0x4f, 0x2, 0x872, 0x875, 0x5, 0x9e, 0x50, 0x2, 
       0x873, 0x875, 0x5, 0xa0, 0x51, 0x2, 0x874, 0x86e, 0x3, 0x2, 0x2, 
       0x2, 0x874, 0x86f, 0x3, 0x2, 0x2, 0x2, 0x874, 0x870, 0x3, 0x2, 0x2, 
       0x2, 0x874, 0x871, 0x3, 0x2, 0x2, 0x2, 0x874, 0x872, 0x3, 0x2, 0x2, 
       0x2, 0x874, 0x873, 0x3, 0x2, 0x2, 0x2, 0x875, 0x7d, 0x3, 0x2, 0x2, 
       0x2, 0x876, 0x877, 0x7, 0x218, 0x2, 0x2, 0x877, 0x878, 0x5, 0x434, 
       0x21b, 0x2, 0x878, 0x879, 0x7, 0xf0, 0x2, 0x2, 0x879, 0x87a, 0x7, 
       0xa0, 0x2, 0x2, 0x87a, 0x87b, 0x7, 0x2a9, 0x2, 0x2, 0x87b, 0x87c, 
       0x5, 0x48e, 0x248, 0x2, 0x87c, 0x87d, 0x5, 0x80, 0x41, 0x2, 0x87d, 
       0x7f, 0x3, 0x2, 0x2, 0x2, 0x87e, 0x87f, 0x7, 0x1aa, 0x2, 0x2, 0x87f, 
       0x880, 0x7, 0x23, 0x2, 0x2, 0x880, 0x885, 0x5, 0x82, 0x42, 0x2, 0x881, 
       0x882, 0x7, 0x20, 0x2, 0x2, 0x882, 0x884, 0x5, 0x82, 0x42, 0x2, 0x883, 
       0x881, 0x3, 0x2, 0x2, 0x2, 0x884, 0x887, 0x3, 0x2, 0x2, 0x2, 0x885, 
       0x883, 0x3, 0x2, 0x2, 0x2, 0x885, 0x886, 0x3, 0x2, 0x2, 0x2, 0x886, 
       0x888, 0x3, 0x2, 0x2, 0x2, 0x887, 0x885, 0x3, 0x2, 0x2, 0x2, 0x888, 
       0x889, 0x7, 0x24, 0x2, 0x2, 0x889, 0x81, 0x3, 0x2, 0x2, 0x2, 0x88a, 
       0x88b, 0x7, 0x109, 0x2, 0x2, 0x88b, 0x899, 0x5, 0x47a, 0x23e, 0x2, 
       0x88c, 0x88d, 0x7, 0x9d, 0x2, 0x2, 0x88d, 0x899, 0x5, 0x47a, 0x23e, 
       0x2, 0x88e, 0x88f, 0x7, 0x28a, 0x2, 0x2, 0x88f, 0x899, 0x5, 0x47a, 
       0x23e, 0x2, 0x890, 0x891, 0x7, 0x1ba, 0x2, 0x2, 0x891, 0x899, 0x5, 
       0x47a, 0x23e, 0x2, 0x892, 0x893, 0x7, 0x227, 0x2, 0x2, 0x893, 0x899, 
       0x5, 0x47a, 0x23e, 0x2, 0x894, 0x895, 0x7, 0x1b2, 0x2, 0x2, 0x895, 
       0x899, 0x5, 0x47a, 0x23e, 0x2, 0x896, 0x897, 0x7, 0x1c1, 0x2, 0x2, 
       0x897, 0x899, 0x5, 0x466, 0x234, 0x2, 0x898, 0x88a, 0x3, 0x2, 0x2, 
       0x2, 0x898, 0x88c, 0x3, 0x2, 0x2, 0x2, 0x898, 0x88e, 0x3, 0x2, 0x2, 
       0x2, 0x898, 0x890, 0x3, 0x2, 0x2, 0x2, 0x898, 0x892, 0x3, 0x2, 0x2, 
       0x2, 0x898, 0x894, 0x3, 0x2, 0x2, 0x2, 0x898, 0x896, 0x3, 0x2, 0x2, 
       0x2, 0x899, 0x83, 0x3, 0x2, 0x2, 0x2, 0x89a, 0x89b, 0x7, 0x25c, 0x2, 
       0x2, 0x89b, 0x89c, 0x5, 0x426, 0x214, 0x2, 0x89c, 0x8a1, 0x5, 0x88, 
       0x45, 0x2, 0x89d, 0x89e, 0x7, 0x28c, 0x2, 0x2, 0x89e, 0x89f, 0x7, 
       0x145, 0x2, 0x2, 0x89f, 0x8a0, 0x7, 0x102, 0x2, 0x2, 0x8a0, 0x8a2, 
       0x5, 0x42c, 0x217, 0x2, 0x8a1, 0x89d, 0x3, 0x2, 0x2, 0x2, 0x8a1, 
       0x8a2, 0x3, 0x2, 0x2, 0x2, 0x8a2, 0x8a4, 0x3, 0x2, 0x2, 0x2, 0x8a3, 
       0x8a5, 0x5, 0x8c, 0x47, 0x2, 0x8a4, 0x8a3, 0x3, 0x2, 0x2, 0x2, 0x8a4, 
       0x8a5, 0x3, 0x2, 0x2, 0x2, 0x8a5, 0x85, 0x3, 0x2, 0x2, 0x2, 0x8a6, 
       0x8a7, 0x7, 0x27d, 0x2, 0x2, 0x8a7, 0x8a8, 0x7, 0x25c, 0x2, 0x2, 
       0x8a8, 0x8a9, 0x5, 0x426, 0x214, 0x2, 0x8a9, 0x8aa, 0x7, 0x36, 0x2, 
       0x2, 0x8aa, 0x8ac, 0x5, 0x8a, 0x46, 0x2, 0x8ab, 0x8ad, 0x5, 0x42, 
       0x22, 0x2, 0x8ac, 0x8ab, 0x3, 0x2, 0x2, 0x2, 0x8ac, 0x8ad, 0x3, 0x2, 
       0x2, 0x2, 0x8ad, 0x87, 0x3, 0x2, 0x2, 0x2, 0x8ae, 0x8b1, 0x6, 0x45, 
       0x21, 0x2, 0x8af, 0x8b0, 0x7, 0x36, 0x2, 0x2, 0x8b0, 0x8b2, 0x5, 
       0x8a, 0x46, 0x2, 0x8b1, 0x8af, 0x3, 0x2, 0x2, 0x2, 0x8b1, 0x8b2, 
       0x3, 0x2, 0x2, 0x2, 0x8b2, 0x8b6, 0x3, 0x2, 0x2, 0x2, 0x8b3, 0x8b4, 
       0x7, 0x36, 0x2, 0x2, 0x8b4, 0x8b6, 0x5, 0x8a, 0x46, 0x2, 0x8b5, 0x8ae, 
       0x3, 0x2, 0x2, 0x2, 0x8b5, 0x8b3, 0x3, 0x2, 0x2, 0x2, 0x8b6, 0x89, 
       0x3, 0x2, 0x2, 0x2, 0x8b7, 0x8b8, 0x7, 0x9f, 0x2, 0x2, 0x8b8, 0x8b9, 
       0x5, 0x47a, 0x23e, 0x2, 0x8b9, 0x8b, 0x3, 0x2, 0x2, 0x2, 0x8ba, 0x8c1, 
       0x5, 0x8e, 0x48, 0x2, 0x8bb, 0x8bd, 0x7, 0x20, 0x2, 0x2, 0x8bc, 0x8bb, 
       0x3, 0x2, 0x2, 0x2, 0x8bc, 0x8bd, 0x3, 0x2, 0x2, 0x2, 0x8bd, 0x8be, 
       0x3, 0x2, 0x2, 0x2, 0x8be, 0x8c0, 0x5, 0x8e, 0x48, 0x2, 0x8bf, 0x8bc, 
       0x3, 0x2, 0x2, 0x2, 0x8c0, 0x8c3, 0x3, 0x2, 0x2, 0x2, 0x8c1, 0x8bf, 
       0x3, 0x2, 0x2, 0x2, 0x8c1, 0x8c2, 0x3, 0x2, 0x2, 0x2, 0x8c2, 0x8d, 
       0x3, 0x2, 0x2, 0x2, 0x8c3, 0x8c1, 0x3, 0x2, 0x2, 0x2, 0x8c4, 0x8d1, 
       0x5, 0x90, 0x49, 0x2, 0x8c5, 0x8d1, 0x5, 0x94, 0x4b, 0x2, 0x8c6, 
       0x8d1, 0x5, 0x96, 0x4c, 0x2, 0x8c7, 0x8d1, 0x5, 0x98, 0x4d, 0x2, 
       0x8c8, 0x8d1, 0x5, 0x9a, 0x4e, 0x2, 0x8c9, 0x8d1, 0x5, 0x9c, 0x4f, 
       0x2, 0x8ca, 0x8d1, 0x5, 0x9e, 0x50, 0x2, 0x8cb, 0x8d1, 0x5, 0xa0, 
       0x51, 0x2, 0x8cc, 0x8cd, 0x6, 0x48, 0x22, 0x2, 0x8cd, 0x8d1, 0x5, 
       0xa2, 0x52, 0x2, 0x8ce, 0x8cf, 0x6, 0x48, 0x23, 0x2, 0x8cf, 0x8d1, 
       0x5, 0xa4, 0x53, 0x2, 0x8d0, 0x8c4, 0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8c5, 
       0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8c6, 0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8c7, 
       0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8c8, 0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8c9, 
       0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8ca, 0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8cb, 
       0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8cc, 0x3, 0x2, 0x2, 0x2, 0x8d0, 0x8ce, 
       0x3, 0x2, 0x2, 0x2, 0x8d1, 0x8f, 0x3, 0x2, 0x2, 0x2, 0x8d2, 0x8d4, 
       0x7, 0x117, 0x2, 0x2, 0x8d3, 0x8d5, 0x7, 0x9, 0x2, 0x2, 0x8d4, 0x8d3, 
       0x3, 0x2, 0x2, 0x2, 0x8d4, 0x8d5, 0x3, 0x2, 0x2, 0x2, 0x8d5, 0x8d6, 
       0x3, 0x2, 0x2, 0x2, 0x8d6, 0x8d7, 0x5, 0x494, 0x24b, 0x2, 0x8d7, 
       0x91, 0x3, 0x2, 0x2, 0x2, 0x8d8, 0x8da, 0x9, 0xe, 0x2, 0x2, 0x8d9, 
       0x8db, 0x7, 0x9, 0x2, 0x2, 0x8da, 0x8d9, 0x3, 0x2, 0x2, 0x2, 0x8da, 
       0x8db, 0x3, 0x2, 0x2, 0x2, 0x8db, 0x8dc, 0x3, 0x2, 0x2, 0x2, 0x8dc, 
       0x8dd, 0x5, 0x494, 0x24b, 0x2, 0x8dd, 0x93, 0x3, 0x2, 0x2, 0x2, 0x8de, 
       0x8e0, 0x7, 0x49, 0x2, 0x2, 0x8df, 0x8e1, 0x7, 0x9, 0x2, 0x2, 0x8e0, 
       0x8df, 0x3, 0x2, 0x2, 0x2, 0x8e0, 0x8e1, 0x3, 0x2, 0x2, 0x2, 0x8e1, 
       0x8e2, 0x3, 0x2, 0x2, 0x2, 0x8e2, 0x8e3, 0x5, 0x494, 0x24b, 0x2, 
       0x8e3, 0x95, 0x3, 0x2, 0x2, 0x2, 0x8e4, 0x8e6, 0x7, 0x169, 0x2, 0x2, 
       0x8e5, 0x8e7, 0x7, 0x9, 0x2, 0x2, 0x8e6, 0x8e5, 0x3, 0x2, 0x2, 0x2, 
       0x8e6, 0x8e7, 0x3, 0x2, 0x2, 0x2, 0x8e7, 0x8e8, 0x3, 0x2, 0x2, 0x2, 
       0x8e8, 0x8e9, 0x5, 0x494, 0x24b, 0x2, 0x8e9, 0x97, 0x3, 0x2, 0x2, 
       0x2, 0x8ea, 0x8ec, 0x7, 0xe1, 0x2, 0x2, 0x8eb, 0x8ed, 0x7, 0x9, 0x2, 
       0x2, 0x8ec, 0x8eb, 0x3, 0x2, 0x2, 0x2, 0x8ec, 0x8ed, 0x3, 0x2, 0x2, 
       0x2, 0x8ed, 0x8ee, 0x3, 0x2, 0x2, 0x2, 0x8ee, 0x8ef, 0x5, 0x494, 
       0x24b, 0x2, 0x8ef, 0x99, 0x3, 0x2, 0x2, 0x2, 0x8f0, 0x8f2, 0x7, 0x193, 
       0x2, 0x2, 0x8f1, 0x8f3, 0x7, 0x9, 0x2, 0x2, 0x8f2, 0x8f1, 0x3, 0x2, 
       0x2, 0x2, 0x8f2, 0x8f3, 0x3, 0x2, 0x2, 0x2, 0x8f3, 0x8f4, 0x3, 0x2, 
       0x2, 0x2, 0x8f4, 0x8f5, 0x5, 0x468, 0x235, 0x2, 0x8f5, 0x9b, 0x3, 
       0x2, 0x2, 0x2, 0x8f6, 0x8f8, 0x7, 0x249, 0x2, 0x2, 0x8f7, 0x8f6, 
       0x3, 0x2, 0x2, 0x2, 0x8f7, 0x8f8, 0x3, 0x2, 0x2, 0x2, 0x8f8, 0x8f9, 
       0x3, 0x2, 0x2, 0x2, 0x8f9, 0x8fb, 0x7, 0xd0, 0x2, 0x2, 0x8fa, 0x8fc, 
       0x7, 0x9, 0x2, 0x2, 0x8fb, 0x8fa, 0x3, 0x2, 0x2, 0x2, 0x8fb, 0x8fc, 
       0x3, 0x2, 0x2, 0x2, 0x8fc, 0x8fd, 0x3, 0x2, 0x2, 0x2, 0x8fd, 0x8fe, 
       0x5, 0x438, 0x21d, 0x2, 0x8fe, 0x9d, 0x3, 0x2, 0x2, 0x2, 0x8ff, 0x900, 
       0x9, 0xf, 0x2, 0x2, 0x900, 0x9f, 0x3, 0x2, 0x2, 0x2, 0x901, 0x903, 
       0x7, 0x7c, 0x2, 0x2, 0x902, 0x904, 0x7, 0x9, 0x2, 0x2, 0x903, 0x902, 
       0x3, 0x2, 0x2, 0x2, 0x903, 0x904, 0x3, 0x2, 0x2, 0x2, 0x904, 0x905, 
       0x3, 0x2, 0x2, 0x2, 0x905, 0x906, 0x5, 0x47a, 0x23e, 0x2, 0x906, 
       0xa1, 0x3, 0x2, 0x2, 0x2, 0x907, 0x909, 0x7, 0xe8, 0x2, 0x2, 0x908, 
       0x90a, 0x7, 0x9, 0x2, 0x2, 0x909, 0x908, 0x3, 0x2, 0x2, 0x2, 0x909, 
       0x90a, 0x3, 0x2, 0x2, 0x2, 0x90a, 0x90b, 0x3, 0x2, 0x2, 0x2, 0x90b, 
       0x90c, 0x5, 0x494, 0x24b, 0x2, 0x90c, 0xa3, 0x3, 0x2, 0x2, 0x2, 0x90d, 
       0x90f, 0x7, 0xcb, 0x2, 0x2, 0x90e, 0x910, 0x7, 0x9, 0x2, 0x2, 0x90f, 
       0x90e, 0x3, 0x2, 0x2, 0x2, 0x90f, 0x910, 0x3, 0x2, 0x2, 0x2, 0x910, 
       0x911, 0x3, 0x2, 0x2, 0x2, 0x911, 0x912, 0x5, 0x474, 0x23b, 0x2, 
       0x912, 0xa5, 0x3, 0x2, 0x2, 0x2, 0x913, 0x915, 0x5, 0xa8, 0x55, 0x2, 
       0x914, 0x913, 0x3, 0x2, 0x2, 0x2, 0x914, 0x915, 0x3, 0x2, 0x2, 0x2, 
       0x915, 0x917, 0x3, 0x2, 0x2, 0x2, 0x916, 0x918, 0x5, 0x3c4, 0x1e3, 
       0x2, 0x917, 0x916, 0x3, 0x2, 0x2, 0x2, 0x917, 0x918, 0x3, 0x2, 0x2, 
       0x2, 0x918, 0x91a, 0x3, 0x2, 0x2, 0x2, 0x919, 0x91b, 0x5, 0xac, 0x57, 
       0x2, 0x91a, 0x919, 0x3, 0x2, 0x2, 0x2, 0x91a, 0x91b, 0x3, 0x2, 0x2, 
       0x2, 0x91b, 0x91c, 0x3, 0x2, 0x2, 0x2, 0x91c, 0x91d, 0x7, 0x29b, 
       0x2, 0x2, 0x91d, 0x91e, 0x5, 0x422, 0x212, 0x2, 0x91e, 0x91f, 0x5, 
       0x4e, 0x28, 0x2, 0x91f, 0xa7, 0x3, 0x2, 0x2, 0x2, 0x920, 0x921, 0x7, 
       0x1ae, 0x2, 0x2, 0x921, 0x923, 0x7, 0x1ee, 0x2, 0x2, 0x922, 0x924, 
       0x5, 0xaa, 0x56, 0x2, 0x923, 0x922, 0x3, 0x2, 0x2, 0x2, 0x923, 0x924, 
       0x3, 0x2, 0x2, 0x2, 0x924, 0x927, 0x3, 0x2, 0x2, 0x2, 0x925, 0x927, 
       0x5, 0xaa, 0x56, 0x2, 0x926, 0x920, 0x3, 0x2, 0x2, 0x2, 0x926, 0x925, 
       0x3, 0x2, 0x2, 0x2, 0x927, 0xa9, 0x3, 0x2, 0x2, 0x2, 0x928, 0x929, 
       0x7, 0x3b, 0x2, 0x2, 0x929, 0x92a, 0x7, 0x9, 0x2, 0x2, 0x92a, 0x92b, 
       0x9, 0x10, 0x2, 0x2, 0x92b, 0xab, 0x3, 0x2, 0x2, 0x2, 0x92c, 0x92d, 
       0x7, 0x239, 0x2, 0x2, 0x92d, 0x92e, 0x7, 0x211, 0x2, 0x2, 0x92e, 
       0x92f, 0x9, 0xc, 0x2, 0x2, 0x92f, 0xad, 0x3, 0x2, 0x2, 0x2, 0x930, 
       0x932, 0x5, 0x3c4, 0x1e3, 0x2, 0x931, 0x930, 0x3, 0x2, 0x2, 0x2, 
       0x931, 0x932, 0x3, 0x2, 0x2, 0x2, 0x932, 0x933, 0x3, 0x2, 0x2, 0x2, 
       0x933, 0x934, 0x7, 0x272, 0x2, 0x2, 0x934, 0x935, 0x5, 0x41e, 0x210, 
       0x2, 0x935, 0x936, 0x9, 0x11, 0x2, 0x2, 0x936, 0x937, 0x9, 0x12, 
       0x2, 0x2, 0x937, 0x938, 0x7, 0x1a2, 0x2, 0x2, 0x938, 0x939, 0x5, 
       0x440, 0x221, 0x2, 0x939, 0x93a, 0x7, 0xf1, 0x2, 0x2, 0x93a, 0x93b, 
       0x7, 0xc6, 0x2, 0x2, 0x93b, 0x93d, 0x7, 0x20a, 0x2, 0x2, 0x93c, 0x93e, 
       0x5, 0xb0, 0x59, 0x2, 0x93d, 0x93c, 0x3, 0x2, 0x2, 0x2, 0x93d, 0x93e, 
       0x3, 0x2, 0x2, 0x2, 0x93e, 0x93f, 0x3, 0x2, 0x2, 0x2, 0x93f, 0x940, 
       0x5, 0x300, 0x181, 0x2, 0x940, 0xaf, 0x3, 0x2, 0x2, 0x2, 0x941, 0x942, 
       0x6, 0x59, 0x24, 0x2, 0x942, 0x943, 0x9, 0x13, 0x2, 0x2, 0x943, 0x944, 
       0x5, 0x48e, 0x248, 0x2, 0x944, 0xb1, 0x3, 0x2, 0x2, 0x2, 0x945, 0x947, 
       0x5, 0x3c4, 0x1e3, 0x2, 0x946, 0x945, 0x3, 0x2, 0x2, 0x2, 0x946, 
       0x947, 0x3, 0x2, 0x2, 0x2, 0x947, 0x948, 0x3, 0x2, 0x2, 0x2, 0x948, 
       0x94a, 0x7, 0xd7, 0x2, 0x2, 0x949, 0x94b, 0x5, 0x3c8, 0x1e5, 0x2, 
       0x94a, 0x949, 0x3, 0x2, 0x2, 0x2, 0x94a, 0x94b, 0x3, 0x2, 0x2, 0x2, 
       0x94b, 0x94c, 0x3, 0x2, 0x2, 0x2, 0x94c, 0x94d, 0x5, 0x42e, 0x218, 
       0x2, 0x94d, 0x94e, 0x7, 0x1a2, 0x2, 0x2, 0x94e, 0x94f, 0x7, 0x20d, 
       0x2, 0x2, 0x94f, 0x956, 0x5, 0x34e, 0x1a8, 0x2, 0x950, 0x951, 0x7, 
       0x1a2, 0x2, 0x2, 0x951, 0x953, 0x7, 0x80, 0x2, 0x2, 0x952, 0x954, 
       0x7, 0x196, 0x2, 0x2, 0x953, 0x952, 0x3, 0x2, 0x2, 0x2, 0x953, 0x954, 
       0x3, 0x2, 0x2, 0x2, 0x954, 0x955, 0x3, 0x2, 0x2, 0x2, 0x955, 0x957, 
       0x7, 0x1c6, 0x2, 0x2, 0x956, 0x950, 0x3, 0x2, 0x2, 0x2, 0x956, 0x957, 
       0x3, 0x2, 0x2, 0x2, 0x957, 0x95e, 0x3, 0x2, 0x2, 0x2, 0x958, 0x95f, 
       0x7, 0xc9, 0x2, 0x2, 0x959, 0x95c, 0x7, 0xba, 0x2, 0x2, 0x95a, 0x95b, 
       0x7, 0x1a2, 0x2, 0x2, 0x95b, 0x95d, 0x7, 0x223, 0x2, 0x2, 0x95c, 
       0x95a, 0x3, 0x2, 0x2, 0x2, 0x95c, 0x95d, 0x3, 0x2, 0x2, 0x2, 0x95d, 
       0x95f, 0x3, 0x2, 0x2, 0x2, 0x95e, 0x958, 0x3, 0x2, 0x2, 0x2, 0x95e, 
       0x959, 0x3, 0x2, 0x2, 0x2, 0x95e, 0x95f, 0x3, 0x2, 0x2, 0x2, 0x95f, 
       0x962, 0x3, 0x2, 0x2, 0x2, 0x960, 0x961, 0x7, 0x7c, 0x2, 0x2, 0x961, 
       0x963, 0x5, 0x47a, 0x23e, 0x2, 0x962, 0x960, 0x3, 0x2, 0x2, 0x2, 
       0x962, 0x963, 0x3, 0x2, 0x2, 0x2, 0x963, 0x964, 0x3, 0x2, 0x2, 0x2, 
       0x964, 0x965, 0x7, 0xc0, 0x2, 0x2, 0x965, 0x966, 0x5, 0x300, 0x181, 
       0x2, 0x966, 0xb3, 0x3, 0x2, 0x2, 0x2, 0x967, 0x969, 0x7, 0x2b4, 0x2, 
       0x2, 0x968, 0x96a, 0x5, 0x3c8, 0x1e5, 0x2, 0x969, 0x968, 0x3, 0x2, 
       0x2, 0x2, 0x969, 0x96a, 0x3, 0x2, 0x2, 0x2, 0x96a, 0x96b, 0x3, 0x2, 
       0x2, 0x2, 0x96b, 0x96c, 0x5, 0x22a, 0x116, 0x2, 0x96c, 0xb5, 0x3, 
       0x2, 0x2, 0x2, 0x96d, 0x96e, 0x7, 0x1ae, 0x2, 0x2, 0x96e, 0x96f, 
       0x7, 0x1ee, 0x2, 0x2, 0x96f, 0x970, 0x7, 0x22b, 0x2, 0x2, 0x970, 
       0x971, 0x7, 0x2ef, 0x2, 0x2, 0x971, 0x972, 0x7, 0x2e7, 0x2, 0x2, 
       0x972, 0x976, 0x5, 0x46c, 0x237, 0x2, 0x973, 0x975, 0x5, 0xb8, 0x5d, 
       0x2, 0x974, 0x973, 0x3, 0x2, 0x2, 0x2, 0x975, 0x978, 0x3, 0x2, 0x2, 
       0x2, 0x976, 0x974, 0x3, 0x2, 0x2, 0x2, 0x976, 0x977, 0x3, 0x2, 0x2, 
       0x2, 0x977, 0x987, 0x3, 0x2, 0x2, 0x2, 0x978, 0x976, 0x3, 0x2, 0x2, 
       0x2, 0x979, 0x97a, 0x7, 0x22b, 0x2, 0x2, 0x97a, 0x97b, 0x7, 0x2ef, 
       0x2, 0x2, 0x97b, 0x97d, 0x7, 0x2e7, 0x2, 0x2, 0x97c, 0x97e, 0x5, 
       0x3c8, 0x1e5, 0x2, 0x97d, 0x97c, 0x3, 0x2, 0x2, 0x2, 0x97d, 0x97e, 
       0x3, 0x2, 0x2, 0x2, 0x97e, 0x97f, 0x3, 0x2, 0x2, 0x2, 0x97f, 0x983, 
       0x5, 0x46c, 0x237, 0x2, 0x980, 0x982, 0x5, 0xb8, 0x5d, 0x2, 0x981, 
       0x980, 0x3, 0x2, 0x2, 0x2, 0x982, 0x985, 0x3, 0x2, 0x2, 0x2, 0x983, 
       0x981, 0x3, 0x2, 0x2, 0x2, 0x983, 0x984, 0x3, 0x2, 0x2, 0x2, 0x984, 
       0x987, 0x3, 0x2, 0x2, 0x2, 0x985, 0x983, 0x3, 0x2, 0x2, 0x2, 0x986, 
       0x96d, 0x3, 0x2, 0x2, 0x2, 0x986, 0x979, 0x3, 0x2, 0x2, 0x2, 0x987, 
       0xb7, 0x3, 0x2, 0x2, 0x2, 0x988, 0x989, 0x7, 0x189, 0x2, 0x2, 0x989, 
       0x98a, 0x7, 0x264, 0x2, 0x2, 0x98a, 0x998, 0x5, 0x47c, 0x23f, 0x2, 
       0x98b, 0x98c, 0x7, 0x2ec, 0x2, 0x2, 0x98c, 0x98d, 0x7, 0x264, 0x2, 
       0x2, 0x98d, 0x998, 0x5, 0x47c, 0x23f, 0x2, 0x98e, 0x98f, 0x7, 0x2ee, 
       0x2, 0x2, 0x98f, 0x990, 0x5, 0x47c, 0x23f, 0x2, 0x990, 0x991, 0x7, 
       0x10f, 0x2, 0x2, 0x991, 0x992, 0x7, 0x5f, 0x2, 0x2, 0x992, 0x993, 
       0x5, 0x46c, 0x237, 0x2, 0x993, 0x998, 0x3, 0x2, 0x2, 0x2, 0x994, 
       0x995, 0x7, 0x2ed, 0x2, 0x2, 0x995, 0x996, 0x7, 0x264, 0x2, 0x2, 
       0x996, 0x998, 0x5, 0x47c, 0x23f, 0x2, 0x997, 0x988, 0x3, 0x2, 0x2, 
       0x2, 0x997, 0x98b, 0x3, 0x2, 0x2, 0x2, 0x997, 0x98e, 0x3, 0x2, 0x2, 
       0x2, 0x997, 0x994, 0x3, 0x2, 0x2, 0x2, 0x998, 0xb9, 0x3, 0x2, 0x2, 
       0x2, 0x999, 0x9ab, 0x7, 0xc1, 0x2, 0x2, 0x99a, 0x9ac, 0x5, 0xbc, 
       0x5f, 0x2, 0x99b, 0x9ac, 0x5, 0xbe, 0x60, 0x2, 0x99c, 0x9ac, 0x5, 
       0xc0, 0x61, 0x2, 0x99d, 0x9ac, 0x5, 0xc2, 0x62, 0x2, 0x99e, 0x9ac, 
       0x5, 0xc4, 0x63, 0x2, 0x99f, 0x9ac, 0x5, 0xc6, 0x64, 0x2, 0x9a0, 
       0x9ac, 0x5, 0xca, 0x66, 0x2, 0x9a1, 0x9ac, 0x5, 0xcc, 0x67, 0x2, 
       0x9a2, 0x9ac, 0x5, 0xce, 0x68, 0x2, 0x9a3, 0x9ac, 0x5, 0xd0, 0x69, 
       0x2, 0x9a4, 0x9ac, 0x5, 0xd2, 0x6a, 0x2, 0x9a5, 0x9a6, 0x6, 0x5e, 
       0x25, 0x2, 0x9a6, 0x9ac, 0x5, 0xd4, 0x6b, 0x2, 0x9a7, 0x9a8, 0x6, 
       0x5e, 0x26, 0x2, 0x9a8, 0x9ac, 0x5, 0xd6, 0x6c, 0x2, 0x9a9, 0x9aa, 
       0x6, 0x5e, 0x27, 0x2, 0x9aa, 0x9ac, 0x5, 0xd8, 0x6d, 0x2, 0x9ab, 
       0x99a, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x99b, 0x3, 0x2, 0x2, 0x2, 0x9ab, 
       0x99c, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x99d, 0x3, 0x2, 0x2, 0x2, 0x9ab, 
       0x99e, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x99f, 0x3, 0x2, 0x2, 0x2, 0x9ab, 
       0x9a0, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9a1, 0x3, 0x2, 0x2, 0x2, 0x9ab, 
       0x9a2, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9a3, 0x3, 0x2, 0x2, 0x2, 0x9ab, 
       0x9a4, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9a5, 0x3, 0x2, 0x2, 0x2, 0x9ab, 
       0x9a7, 0x3, 0x2, 0x2, 0x2, 0x9ab, 0x9a9, 0x3, 0x2, 0x2, 0x2, 0x9ac, 
       0xbb, 0x3, 0x2, 0x2, 0x2, 0x9ad, 0x9af, 0x7, 0x9d, 0x2, 0x2, 0x9ae, 
       0x9b0, 0x5, 0x3c6, 0x1e4, 0x2, 0x9af, 0x9ae, 0x3, 0x2, 0x2, 0x2, 
       0x9af, 0x9b0, 0x3, 0x2, 0x2, 0x2, 0x9b0, 0x9b1, 0x3, 0x2, 0x2, 0x2, 
       0x9b1, 0x9b2, 0x5, 0x414, 0x20b, 0x2, 0x9b2, 0xbd, 0x3, 0x2, 0x2, 
       0x2, 0x9b3, 0x9b5, 0x7, 0xd7, 0x2, 0x2, 0x9b4, 0x9b6, 0x5, 0x3c6, 
       0x1e4, 0x2, 0x9b5, 0x9b4, 0x3, 0x2, 0x2, 0x2, 0x9b5, 0x9b6, 0x3, 
       0x2, 0x2, 0x2, 0x9b6, 0x9b7, 0x3, 0x2, 0x2, 0x2, 0x9b7, 0x9b8, 0x5, 
       0x430, 0x219, 0x2, 0x9b8, 0xbf, 0x3, 0x2, 0x2, 0x2, 0x9b9, 0x9bb, 
       0x7, 0xf7, 0x2, 0x2, 0x9ba, 0x9bc, 0x5, 0x3c6, 0x1e4, 0x2, 0x9bb, 
       0x9ba, 0x3, 0x2, 0x2, 0x2, 0x9bb, 0x9bc, 0x3, 0x2, 0x2, 0x2, 0x9bc, 
       0x9bd, 0x3, 0x2, 0x2, 0x2, 0x9bd, 0x9be, 0x5, 0x41c, 0x20f, 0x2, 
       0x9be, 0xc1, 0x3, 0x2, 0x2, 0x2, 0x9bf, 0x9c1, 0x7, 0x1ca, 0x2, 0x2, 
       0x9c0, 0x9c2, 0x5, 0x3c6, 0x1e4, 0x2, 0x9c1, 0x9c0, 0x3, 0x2, 0x2, 
       0x2, 0x9c1, 0x9c2, 0x3, 0x2, 0x2, 0x2, 0x9c2, 0x9c3, 0x3, 0x2, 0x2, 
       0x2, 0x9c3, 0x9c4, 0x5, 0x418, 0x20d, 0x2, 0x9c4, 0xc3, 0x3, 0x2, 
       0x2, 0x2, 0x9c5, 0x9c7, 0x5, 0x3fa, 0x1fe, 0x2, 0x9c6, 0x9c5, 0x3, 
       0x2, 0x2, 0x2, 0x9c6, 0x9c7, 0x3, 0x2, 0x2, 0x2, 0x9c7, 0x9c8, 0x3, 
       0x2, 0x2, 0x2, 0x9c8, 0x9c9, 0x7, 0x115, 0x2, 0x2, 0x9c9, 0x9ca, 
       0x5, 0x40e, 0x208, 0x2, 0x9ca, 0x9cb, 0x7, 0x1a2, 0x2, 0x2, 0x9cb, 
       0x9cd, 0x5, 0x440, 0x221, 0x2, 0x9cc, 0x9ce, 0x5, 0x34, 0x1b, 0x2, 
       0x9cd, 0x9cc, 0x3, 0x2, 0x2, 0x2, 0x9cd, 0x9ce, 0x3, 0x2, 0x2, 0x2, 
       0x9ce, 0xc5, 0x3, 0x2, 0x2, 0x2, 0x9cf, 0x9d0, 0x7, 0x145, 0x2, 0x2, 
       0x9d0, 0x9d1, 0x7, 0x102, 0x2, 0x2, 0x9d1, 0x9dc, 0x5, 0x42c, 0x217, 
       0x2, 0x9d2, 0x9d9, 0x5, 0xc8, 0x65, 0x2, 0x9d3, 0x9d5, 0x7, 0x20, 
       0x2, 0x2, 0x9d4, 0x9d3, 0x3, 0x2, 0x2, 0x2, 0x9d4, 0x9d5, 0x3, 0x2, 
       0x2, 0x2, 0x9d5, 0x9d6, 0x3, 0x2, 0x2, 0x2, 0x9d6, 0x9d8, 0x5, 0xc8, 
       0x65, 0x2, 0x9d7, 0x9d4, 0x3, 0x2, 0x2, 0x2, 0x9d8, 0x9db, 0x3, 0x2, 
       0x2, 0x2, 0x9d9, 0x9d7, 0x3, 0x2, 0x2, 0x2, 0x9d9, 0x9da, 0x3, 0x2, 
       0x2, 0x2, 0x9da, 0x9dd, 0x3, 0x2, 0x2, 0x2, 0x9db, 0x9d9, 0x3, 0x2, 
       0x2, 0x2, 0x9dc, 0x9d2, 0x3, 0x2, 0x2, 0x2, 0x9dc, 0x9dd, 0x3, 0x2, 
       0x2, 0x2, 0x9dd, 0xc7, 0x3, 0x2, 0x2, 0x2, 0x9de, 0x9e1, 0x5, 0x9e, 
       0x50, 0x2, 0x9df, 0x9e1, 0x5, 0x9c, 0x4f, 0x2, 0x9e0, 0x9de, 0x3, 
       0x2, 0x2, 0x2, 0x9e0, 0x9df, 0x3, 0x2, 0x2, 0x2, 0x9e1, 0xc9, 0x3, 
       0x2, 0x2, 0x2, 0x9e2, 0x9e4, 0x7, 0x218, 0x2, 0x2, 0x9e3, 0x9e5, 
       0x5, 0x3c6, 0x1e4, 0x2, 0x9e4, 0x9e3, 0x3, 0x2, 0x2, 0x2, 0x9e4, 
       0x9e5, 0x3, 0x2, 0x2, 0x2, 0x9e5, 0x9e6, 0x3, 0x2, 0x2, 0x2, 0x9e6, 
       0x9e7, 0x5, 0x436, 0x21c, 0x2, 0x9e7, 0xcb, 0x3, 0x2, 0x2, 0x2, 0x9e8, 
       0x9ea, 0x7, 0x261, 0x2, 0x2, 0x9e9, 0x9e8, 0x3, 0x2, 0x2, 0x2, 0x9e9, 
       0x9ea, 0x3, 0x2, 0x2, 0x2, 0x9ea, 0x9eb, 0x3, 0x2, 0x2, 0x2, 0x9eb, 
       0x9ed, 0x9, 0x14, 0x2, 0x2, 0x9ec, 0x9ee, 0x5, 0x3c6, 0x1e4, 0x2, 
       0x9ed, 0x9ec, 0x3, 0x2, 0x2, 0x2, 0x9ed, 0x9ee, 0x3, 0x2, 0x2, 0x2, 
       0x9ee, 0x9ef, 0x3, 0x2, 0x2, 0x2, 0x9ef, 0x9f1, 0x5, 0x442, 0x222, 
       0x2, 0x9f0, 0x9f2, 0x9, 0x4, 0x2, 0x2, 0x9f1, 0x9f0, 0x3, 0x2, 0x2, 
       0x2, 0x9f1, 0x9f2, 0x3, 0x2, 0x2, 0x2, 0x9f2, 0xcd, 0x3, 0x2, 0x2, 
       0x2, 0x9f3, 0x9f4, 0x7, 0x25c, 0x2, 0x2, 0x9f4, 0x9ff, 0x5, 0x428, 
       0x215, 0x2, 0x9f5, 0x9fc, 0x5, 0xc8, 0x65, 0x2, 0x9f6, 0x9f8, 0x7, 
       0x20, 0x2, 0x2, 0x9f7, 0x9f6, 0x3, 0x2, 0x2, 0x2, 0x9f7, 0x9f8, 0x3, 
       0x2, 0x2, 0x2, 0x9f8, 0x9f9, 0x3, 0x2, 0x2, 0x2, 0x9f9, 0x9fb, 0x5, 
       0xc8, 0x65, 0x2, 0x9fa, 0x9f7, 0x3, 0x2, 0x2, 0x2, 0x9fb, 0x9fe, 
       0x3, 0x2, 0x2, 0x2, 0x9fc, 0x9fa, 0x3, 0x2, 0x2, 0x2, 0x9fc, 0x9fd, 
       0x3, 0x2, 0x2, 0x2, 0x9fd, 0xa00, 0x3, 0x2, 0x2, 0x2, 0x9fe, 0x9fc, 
       0x3, 0x2, 0x2, 0x2, 0x9ff, 0x9f5, 0x3, 0x2, 0x2, 0x2, 0x9ff, 0xa00, 
       0x3, 0x2, 0x2, 0x2, 0xa00, 0xcf, 0x3, 0x2, 0x2, 0x2, 0xa01, 0xa03, 
       0x7, 0x272, 0x2, 0x2, 0xa02, 0xa04, 0x5, 0x3c6, 0x1e4, 0x2, 0xa03, 
       0xa02, 0x3, 0x2, 0x2, 0x2, 0xa03, 0xa04, 0x3, 0x2, 0x2, 0x2, 0xa04, 
       0xa05, 0x3, 0x2, 0x2, 0x2, 0xa05, 0xa06, 0x5, 0x420, 0x211, 0x2, 
       0xa06, 0xd1, 0x3, 0x2, 0x2, 0x2, 0xa07, 0xa09, 0x7, 0x29b, 0x2, 0x2, 
       0xa08, 0xa0a, 0x5, 0x3c6, 0x1e4, 0x2, 0xa09, 0xa08, 0x3, 0x2, 0x2, 
       0x2, 0xa09, 0xa0a, 0x3, 0x2, 0x2, 0x2, 0xa0a, 0xa0b, 0x3, 0x2, 0x2, 
       0x2, 0xa0b, 0xa0d, 0x5, 0x3d4, 0x1eb, 0x2, 0xa0c, 0xa0e, 0x9, 0x4, 
       0x2, 0x2, 0xa0d, 0xa0c, 0x3, 0x2, 0x2, 0x2, 0xa0d, 0xa0e, 0x3, 0x2, 
       0x2, 0x2, 0xa0e, 0xd3, 0x3, 0x2, 0x2, 0x2, 0xa0f, 0xa11, 0x7, 0x2b4, 
       0x2, 0x2, 0xa10, 0xa12, 0x5, 0x3c6, 0x1e4, 0x2, 0xa11, 0xa10, 0x3, 
       0x2, 0x2, 0x2, 0xa11, 0xa12, 0x3, 0x2, 0x2, 0x2, 0xa12, 0xa13, 0x3, 
       0x2, 0x2, 0x2, 0xa13, 0xa14, 0x5, 0x22a, 0x116, 0x2, 0xa14, 0xd5, 
       0x3, 0x2, 0x2, 0x2, 0xa15, 0xa16, 0x7, 0x22b, 0x2, 0x2, 0xa16, 0xa17, 
       0x7, 0x2ef, 0x2, 0x2, 0xa17, 0xa19, 0x7, 0x2e7, 0x2, 0x2, 0xa18, 
       0xa1a, 0x5, 0x3c6, 0x1e4, 0x2, 0xa19, 0xa18, 0x3, 0x2, 0x2, 0x2, 
       0xa19, 0xa1a, 0x3, 0x2, 0x2, 0x2, 0xa1a, 0xa1b, 0x3, 0x2, 0x2, 0x2, 
       0xa1b, 0xa1c, 0x5, 0x46c, 0x237, 0x2, 0xa1c, 0xd7, 0x3, 0x2, 0x2, 
       0x2, 0xa1d, 0xa1e, 0x7, 0x27d, 0x2, 0x2, 0xa1e, 0xa1f, 0x7, 0x25c, 
       0x2, 0x2, 0xa1f, 0xa21, 0x5, 0x428, 0x215, 0x2, 0xa20, 0xa22, 0x5, 
       0x42, 0x22, 0x2, 0xa21, 0xa20, 0x3, 0x2, 0x2, 0x2, 0xa21, 0xa22, 
       0x3, 0x2, 0x2, 0x2, 0xa22, 0xd9, 0x3, 0x2, 0x2, 0x2, 0xa23, 0xa24, 
       0x7, 0x1e9, 0x2, 0x2, 0xa24, 0xa25, 0x9, 0x14, 0x2, 0x2, 0xa25, 0xa2a, 
       0x5, 0xdc, 0x6f, 0x2, 0xa26, 0xa27, 0x7, 0x20, 0x2, 0x2, 0xa27, 0xa29, 
       0x5, 0xdc, 0x6f, 0x2, 0xa28, 0xa26, 0x3, 0x2, 0x2, 0x2, 0xa29, 0xa2c, 
       0x3, 0x2, 0x2, 0x2, 0xa2a, 0xa28, 0x3, 0x2, 0x2, 0x2, 0xa2a, 0xa2b, 
       0x3, 0x2, 0x2, 0x2, 0xa2b, 0xdb, 0x3, 0x2, 0x2, 0x2, 0xa2c, 0xa2a, 
       0x3, 0x2, 0x2, 0x2, 0xa2d, 0xa2e, 0x5, 0x440, 0x221, 0x2, 0xa2e, 
       0xa2f, 0x7, 0x26e, 0x2, 0x2, 0xa2f, 0xa30, 0x5, 0x43a, 0x21e, 0x2, 
       0xa30, 0xdd, 0x3, 0x2, 0x2, 0x2, 0xa31, 0xa33, 0x7, 0x275, 0x2, 0x2, 
       0xa32, 0xa34, 0x7, 0x25e, 0x2, 0x2, 0xa33, 0xa32, 0x3, 0x2, 0x2, 
       0x2, 0xa33, 0xa34, 0x3, 0x2, 0x2, 0x2, 0xa34, 0xa35, 0x3, 0x2, 0x2, 
       0x2, 0xa35, 0xa36, 0x5, 0x440, 0x221, 0x2, 0xa36, 0xdf, 0x3, 0x2, 
       0x2, 0x2, 0xa37, 0xa38, 0x7, 0x113, 0x2, 0x2, 0xa38, 0xa39, 0x7, 
       0x25e, 0x2, 0x2, 0xa39, 0xa3a, 0x7, 0xf4, 0x2, 0x2, 0xa3a, 0xa3b, 
       0x5, 0x47e, 0x240, 0x2, 0xa3b, 0xe1, 0x3, 0x2, 0x2, 0x2, 0xa3c, 0xa3d, 
       0x7, 0x62, 0x2, 0x2, 0xa3d, 0xa43, 0x5, 0x418, 0x20d, 0x2, 0xa3e, 
       0xa40, 0x7, 0x23, 0x2, 0x2, 0xa3f, 0xa41, 0x5, 0x2e4, 0x173, 0x2, 
       0xa40, 0xa3f, 0x3, 0x2, 0x2, 0x2, 0xa40, 0xa41, 0x3, 0x2, 0x2, 0x2, 
       0xa41, 0xa42, 0x3, 0x2, 0x2, 0x2, 0xa42, 0xa44, 0x7, 0x24, 0x2, 0x2, 
       0xa43, 0xa3e, 0x3, 0x2, 0x2, 0x2, 0xa43, 0xa44, 0x3, 0x2, 0x2, 0x2, 
       0xa44, 0xe3, 0x3, 0x2, 0x2, 0x2, 0xa45, 0xa46, 0x6, 0x73, 0x28, 0x2, 
       0xa46, 0xa48, 0x5, 0x144, 0xa3, 0x2, 0xa47, 0xa45, 0x3, 0x2, 0x2, 
       0x2, 0xa47, 0xa48, 0x3, 0x2, 0x2, 0x2, 0xa48, 0xa49, 0x3, 0x2, 0x2, 
       0x2, 0xa49, 0xa4d, 0x7, 0xb3, 0x2, 0x2, 0xa4a, 0xa4c, 0x5, 0xe8, 
       0x75, 0x2, 0xa4b, 0xa4a, 0x3, 0x2, 0x2, 0x2, 0xa4c, 0xa4f, 0x3, 0x2, 
       0x2, 0x2, 0xa4d, 0xa4b, 0x3, 0x2, 0x2, 0x2, 0xa4d, 0xa4e, 0x3, 0x2, 
       0x2, 0x2, 0xa4e, 0xa70, 0x3, 0x2, 0x2, 0x2, 0xa4f, 0xa4d, 0x3, 0x2, 
       0x2, 0x2, 0xa50, 0xa68, 0x7, 0xf4, 0x2, 0x2, 0xa51, 0xa52, 0x5, 0x444, 
       0x223, 0x2, 0xa52, 0xa53, 0x7, 0x28d, 0x2, 0x2, 0xa53, 0xa55, 0x5, 
       0x152, 0xaa, 0x2, 0xa54, 0xa56, 0x5, 0x162, 0xb2, 0x2, 0xa55, 0xa54, 
       0x3, 0x2, 0x2, 0x2, 0xa55, 0xa56, 0x3, 0x2, 0x2, 0x2, 0xa56, 0xa69, 
       0x3, 0x2, 0x2, 0x2, 0xa57, 0xa5a, 0x5, 0x440, 0x221, 0x2, 0xa58, 
       0xa59, 0x6, 0x73, 0x29, 0x2, 0xa59, 0xa5b, 0x5, 0x18a, 0xc6, 0x2, 
       0xa5a, 0xa58, 0x3, 0x2, 0x2, 0x2, 0xa5a, 0xa5b, 0x3, 0x2, 0x2, 0x2, 
       0xa5b, 0xa5d, 0x3, 0x2, 0x2, 0x2, 0xa5c, 0xa5e, 0x5, 0xe6, 0x74, 
       0x2, 0xa5d, 0xa5c, 0x3, 0x2, 0x2, 0x2, 0xa5d, 0xa5e, 0x3, 0x2, 0x2, 
       0x2, 0xa5e, 0xa60, 0x3, 0x2, 0x2, 0x2, 0xa5f, 0xa61, 0x5, 0x162, 
       0xb2, 0x2, 0xa60, 0xa5f, 0x3, 0x2, 0x2, 0x2, 0xa60, 0xa61, 0x3, 0x2, 
       0x2, 0x2, 0xa61, 0xa63, 0x3, 0x2, 0x2, 0x2, 0xa62, 0xa64, 0x5, 0x14c, 
       0xa7, 0x2, 0xa63, 0xa62, 0x3, 0x2, 0x2, 0x2, 0xa63, 0xa64, 0x3, 0x2, 
       0x2, 0x2, 0xa64, 0xa66, 0x3, 0x2, 0x2, 0x2, 0xa65, 0xa67, 0x5, 0x122, 
       0x92, 0x2, 0xa66, 0xa65, 0x3, 0x2, 0x2, 0x2, 0xa66, 0xa67, 0x3, 0x2, 
       0x2, 0x2, 0xa67, 0xa69, 0x3, 0x2, 0x2, 0x2, 0xa68, 0xa51, 0x3, 0x2, 
       0x2, 0x2, 0xa68, 0xa57, 0x3, 0x2, 0x2, 0x2, 0xa69, 0xa71, 0x3, 0x2, 
       0x2, 0x2, 0xa6a, 0xa6b, 0x5, 0x444, 0x223, 0x2, 0xa6b, 0xa6c, 0x7, 
       0xf4, 0x2, 0x2, 0xa6c, 0xa6e, 0x5, 0x152, 0xaa, 0x2, 0xa6d, 0xa6f, 
       0x5, 0x162, 0xb2, 0x2, 0xa6e, 0xa6d, 0x3, 0x2, 0x2, 0x2, 0xa6e, 0xa6f, 
       0x3, 0x2, 0x2, 0x2, 0xa6f, 0xa71, 0x3, 0x2, 0x2, 0x2, 0xa70, 0xa50, 
       0x3, 0x2, 0x2, 0x2, 0xa70, 0xa6a, 0x3, 0x2, 0x2, 0x2, 0xa71, 0xe5, 
       0x3, 0x2, 0x2, 0x2, 0xa72, 0xa73, 0x6, 0x74, 0x2a, 0x2, 0xa73, 0xa74, 
       0x7, 0x1b9, 0x2, 0x2, 0xa74, 0xa75, 0x7, 0x23, 0x2, 0x2, 0xa75, 0xa76, 
       0x5, 0x45c, 0x22f, 0x2, 0xa76, 0xa77, 0x7, 0x24, 0x2, 0x2, 0xa77, 
       0xe7, 0x3, 0x2, 0x2, 0x2, 0xa78, 0xa79, 0x9, 0x15, 0x2, 0x2, 0xa79, 
       0xe9, 0x3, 0x2, 0x2, 0x2, 0xa7a, 0xa7f, 0x7, 0xc0, 0x2, 0x2, 0xa7b, 
       0xa7c, 0x6, 0x76, 0x2b, 0x2, 0xa7c, 0xa80, 0x5, 0x2e4, 0x173, 0x2, 
       0xa7d, 0xa7e, 0x6, 0x76, 0x2c, 0x2, 0xa7e, 0xa80, 0x5, 0x15c, 0xaf, 
       0x2, 0xa7f, 0xa7b, 0x3, 0x2, 0x2, 0x2, 0xa7f, 0xa7d, 0x3, 0x2, 0x2, 
       0x2, 0xa80, 0xeb, 0x3, 0x2, 0x2, 0x2, 0xa81, 0xa93, 0x7, 0x104, 0x2, 
       0x2, 0xa82, 0xa83, 0x5, 0x440, 0x221, 0x2, 0xa83, 0xa85, 0x7, 0x1a7, 
       0x2, 0x2, 0xa84, 0xa86, 0x5, 0x18a, 0xc6, 0x2, 0xa85, 0xa84, 0x3, 
       0x2, 0x2, 0x2, 0xa85, 0xa86, 0x3, 0x2, 0x2, 0x2, 0xa86, 0xa94, 0x3, 
       0x2, 0x2, 0x2, 0xa87, 0xa91, 0x5, 0x45a, 0x22e, 0x2, 0xa88, 0xa92, 
       0x7, 0x73, 0x2, 0x2, 0xa89, 0xa8a, 0x7, 0x1d7, 0x2, 0x2, 0xa8a, 0xa8c, 
       0x5, 0xee, 0x78, 0x2, 0xa8b, 0xa8d, 0x5, 0x162, 0xb2, 0x2, 0xa8c, 
       0xa8b, 0x3, 0x2, 0x2, 0x2, 0xa8c, 0xa8d, 0x3, 0x2, 0x2, 0x2, 0xa8d, 
       0xa8f, 0x3, 0x2, 0x2, 0x2, 0xa8e, 0xa90, 0x5, 0x120, 0x91, 0x2, 0xa8f, 
       0xa8e, 0x3, 0x2, 0x2, 0x2, 0xa8f, 0xa90, 0x3, 0x2, 0x2, 0x2, 0xa90, 
       0xa92, 0x3, 0x2, 0x2, 0x2, 0xa91, 0xa88, 0x3, 0x2, 0x2, 0x2, 0xa91, 
       0xa89, 0x3, 0x2, 0x2, 0x2, 0xa92, 0xa94, 0x3, 0x2, 0x2, 0x2, 0xa93, 
       0xa82, 0x3, 0x2, 0x2, 0x2, 0xa93, 0xa87, 0x3, 0x2, 0x2, 0x2, 0xa94, 
       0xed, 0x3, 0x2, 0x2, 0x2, 0xa95, 0xaa0, 0x9, 0x16, 0x2, 0x2, 0xa96, 
       0xa9d, 0x5, 0x45a, 0x22e, 0x2, 0xa97, 0xa9e, 0x9, 0x17, 0x2, 0x2, 
       0xa98, 0xa99, 0x9, 0x18, 0x2, 0x2, 0xa99, 0xa9a, 0x7, 0x23, 0x2, 
       0x2, 0xa9a, 0xa9b, 0x5, 0xfe, 0x80, 0x2, 0xa9b, 0xa9c, 0x7, 0x24, 
       0x2, 0x2, 0xa9c, 0xa9e, 0x3, 0x2, 0x2, 0x2, 0xa9d, 0xa97, 0x3, 0x2, 
       0x2, 0x2, 0xa9d, 0xa98, 0x3, 0x2, 0x2, 0x2, 0xa9e, 0xaa0, 0x3, 0x2, 
       0x2, 0x2, 0xa9f, 0xa95, 0x3, 0x2, 0x2, 0x2, 0xa9f, 0xa96, 0x3, 0x2, 
       0x2, 0x2, 0xaa0, 0xef, 0x3, 0x2, 0x2, 0x2, 0xaa1, 0xaa3, 0x7, 0x11b, 
       0x2, 0x2, 0xaa2, 0xaa4, 0x5, 0xf2, 0x7a, 0x2, 0xaa3, 0xaa2, 0x3, 
       0x2, 0x2, 0x2, 0xaa3, 0xaa4, 0x3, 0x2, 0x2, 0x2, 0xaa4, 0xaa6, 0x3, 
       0x2, 0x2, 0x2, 0xaa5, 0xaa7, 0x7, 0x111, 0x2, 0x2, 0xaa6, 0xaa5, 
       0x3, 0x2, 0x2, 0x2, 0xaa6, 0xaa7, 0x3, 0x2, 0x2, 0x2, 0xaa7, 0xaa9, 
       0x3, 0x2, 0x2, 0x2, 0xaa8, 0xaaa, 0x7, 0x120, 0x2, 0x2, 0xaa9, 0xaa8, 
       0x3, 0x2, 0x2, 0x2, 0xaa9, 0xaaa, 0x3, 0x2, 0x2, 0x2, 0xaaa, 0xaab, 
       0x3, 0x2, 0x2, 0x2, 0xaab, 0xaad, 0x5, 0x440, 0x221, 0x2, 0xaac, 
       0xaae, 0x5, 0x3fe, 0x200, 0x2, 0xaad, 0xaac, 0x3, 0x2, 0x2, 0x2, 
       0xaad, 0xaae, 0x3, 0x2, 0x2, 0x2, 0xaae, 0xab3, 0x3, 0x2, 0x2, 0x2, 
       0xaaf, 0xab4, 0x5, 0xf4, 0x7b, 0x2, 0xab0, 0xab1, 0x7, 0x21b, 0x2, 
       0x2, 0xab1, 0xab4, 0x5, 0x3d6, 0x1ec, 0x2, 0xab2, 0xab4, 0x5, 0xfa, 
       0x7e, 0x2, 0xab3, 0xaaf, 0x3, 0x2, 0x2, 0x2, 0xab3, 0xab0, 0x3, 0x2, 
       0x2, 0x2, 0xab3, 0xab2, 0x3, 0x2, 0x2, 0x2, 0xab4, 0xab6, 0x3, 0x2, 
       0x2, 0x2, 0xab5, 0xab7, 0x5, 0x100, 0x81, 0x2, 0xab6, 0xab5, 0x3, 
       0x2, 0x2, 0x2, 0xab6, 0xab7, 0x3, 0x2, 0x2, 0x2, 0xab7, 0xf1, 0x3, 
       0x2, 0x2, 0x2, 0xab8, 0xab9, 0x9, 0x19, 0x2, 0x2, 0xab9, 0xf3, 0x3, 
       0x2, 0x2, 0x2, 0xaba, 0xabc, 0x7, 0x23, 0x2, 0x2, 0xabb, 0xabd, 0x5, 
       0xf6, 0x7c, 0x2, 0xabc, 0xabb, 0x3, 0x2, 0x2, 0x2, 0xabc, 0xabd, 
       0x3, 0x2, 0x2, 0x2, 0xabd, 0xabe, 0x3, 0x2, 0x2, 0x2, 0xabe, 0xac0, 
       0x7, 0x24, 0x2, 0x2, 0xabf, 0xaba, 0x3, 0x2, 0x2, 0x2, 0xabf, 0xac0, 
       0x3, 0x2, 0x2, 0x2, 0xac0, 0xac1, 0x3, 0x2, 0x2, 0x2, 0xac1, 0xac2, 
       0x5, 0xf8, 0x7d, 0x2, 0xac2, 0xf5, 0x3, 0x2, 0x2, 0x2, 0xac3, 0xac8, 
       0x5, 0x40a, 0x206, 0x2, 0xac4, 0xac5, 0x7, 0x20, 0x2, 0x2, 0xac5, 
       0xac7, 0x5, 0x40a, 0x206, 0x2, 0xac6, 0xac4, 0x3, 0x2, 0x2, 0x2, 
       0xac7, 0xaca, 0x3, 0x2, 0x2, 0x2, 0xac8, 0xac6, 0x3, 0x2, 0x2, 0x2, 
       0xac8, 0xac9, 0x3, 0x2, 0x2, 0x2, 0xac9, 0xf7, 0x3, 0x2, 0x2, 0x2, 
       0xaca, 0xac8, 0x3, 0x2, 0x2, 0x2, 0xacb, 0xacc, 0x9, 0x1a, 0x2, 0x2, 
       0xacc, 0xacd, 0x5, 0xfc, 0x7f, 0x2, 0xacd, 0xf9, 0x3, 0x2, 0x2, 0x2, 
       0xace, 0xad6, 0x5, 0x62, 0x32, 0x2, 0xacf, 0xad1, 0x7, 0x23, 0x2, 
       0x2, 0xad0, 0xad2, 0x5, 0xf6, 0x7c, 0x2, 0xad1, 0xad0, 0x3, 0x2, 
       0x2, 0x2, 0xad1, 0xad2, 0x3, 0x2, 0x2, 0x2, 0xad2, 0xad3, 0x3, 0x2, 
       0x2, 0x2, 0xad3, 0xad4, 0x7, 0x24, 0x2, 0x2, 0xad4, 0xad6, 0x5, 0x62, 
       0x32, 0x2, 0xad5, 0xace, 0x3, 0x2, 0x2, 0x2, 0xad5, 0xacf, 0x3, 0x2, 
       0x2, 0x2, 0xad6, 0xfb, 0x3, 0x2, 0x2, 0x2, 0xad7, 0xad9, 0x7, 0x23, 
       0x2, 0x2, 0xad8, 0xada, 0x5, 0xfe, 0x80, 0x2, 0xad9, 0xad8, 0x3, 
       0x2, 0x2, 0x2, 0xad9, 0xada, 0x3, 0x2, 0x2, 0x2, 0xada, 0xadb, 0x3, 
       0x2, 0x2, 0x2, 0xadb, 0xae4, 0x7, 0x24, 0x2, 0x2, 0xadc, 0xadd, 0x7, 
       0x20, 0x2, 0x2, 0xadd, 0xadf, 0x7, 0x23, 0x2, 0x2, 0xade, 0xae0, 
       0x5, 0xfe, 0x80, 0x2, 0xadf, 0xade, 0x3, 0x2, 0x2, 0x2, 0xadf, 0xae0, 
       0x3, 0x2, 0x2, 0x2, 0xae0, 0xae1, 0x3, 0x2, 0x2, 0x2, 0xae1, 0xae3, 
       0x7, 0x24, 0x2, 0x2, 0xae2, 0xadc, 0x3, 0x2, 0x2, 0x2, 0xae3, 0xae6, 
       0x3, 0x2, 0x2, 0x2, 0xae4, 0xae2, 0x3, 0x2, 0x2, 0x2, 0xae4, 0xae5, 
       0x3, 0x2, 0x2, 0x2, 0xae5, 0xfd, 0x3, 0x2, 0x2, 0x2, 0xae6, 0xae4, 
       0x3, 0x2, 0x2, 0x2, 0xae7, 0xaea, 0x5, 0x294, 0x14b, 0x2, 0xae8, 
       0xaea, 0x7, 0xae, 0x2, 0x2, 0xae9, 0xae7, 0x3, 0x2, 0x2, 0x2, 0xae9, 
       0xae8, 0x3, 0x2, 0x2, 0x2, 0xaea, 0xaf2, 0x3, 0x2, 0x2, 0x2, 0xaeb, 
       0xaee, 0x7, 0x20, 0x2, 0x2, 0xaec, 0xaef, 0x5, 0x294, 0x14b, 0x2, 
       0xaed, 0xaef, 0x7, 0xae, 0x2, 0x2, 0xaee, 0xaec, 0x3, 0x2, 0x2, 0x2, 
       0xaee, 0xaed, 0x3, 0x2, 0x2, 0x2, 0xaef, 0xaf1, 0x3, 0x2, 0x2, 0x2, 
       0xaf0, 0xaeb, 0x3, 0x2, 0x2, 0x2, 0xaf1, 0xaf4, 0x3, 0x2, 0x2, 0x2, 
       0xaf2, 0xaf0, 0x3, 0x2, 0x2, 0x2, 0xaf2, 0xaf3, 0x3, 0x2, 0x2, 0x2, 
       0xaf3, 0xff, 0x3, 0x2, 0x2, 0x2, 0xaf4, 0xaf2, 0x3, 0x2, 0x2, 0x2, 
       0xaf5, 0xaf6, 0x7, 0x1a2, 0x2, 0x2, 0xaf6, 0xaf7, 0x7, 0xc4, 0x2, 
       0x2, 0xaf7, 0xaf8, 0x7, 0x130, 0x2, 0x2, 0xaf8, 0xaf9, 0x7, 0x286, 
       0x2, 0x2, 0xaf9, 0xafa, 0x5, 0x3d6, 0x1ec, 0x2, 0xafa, 0x101, 0x3, 
       0x2, 0x2, 0x2, 0xafb, 0xafc, 0x7, 0x140, 0x2, 0x2, 0xafc, 0xafe, 
       0x5, 0x104, 0x83, 0x2, 0xafd, 0xaff, 0x9, 0x1b, 0x2, 0x2, 0xafe, 
       0xafd, 0x3, 0x2, 0x2, 0x2, 0xafe, 0xaff, 0x3, 0x2, 0x2, 0x2, 0xaff, 
       0xb01, 0x3, 0x2, 0x2, 0x2, 0xb00, 0xb02, 0x7, 0x141, 0x2, 0x2, 0xb01, 
       0xb00, 0x3, 0x2, 0x2, 0x2, 0xb01, 0xb02, 0x3, 0x2, 0x2, 0x2, 0xb02, 
       0xb03, 0x3, 0x2, 0x2, 0x2, 0xb03, 0xb04, 0x7, 0x116, 0x2, 0x2, 0xb04, 
       0xb06, 0x5, 0x47a, 0x23e, 0x2, 0xb05, 0xb07, 0x9, 0xa, 0x2, 0x2, 
       0xb06, 0xb05, 0x3, 0x2, 0x2, 0x2, 0xb06, 0xb07, 0x3, 0x2, 0x2, 0x2, 
       0xb07, 0xb08, 0x3, 0x2, 0x2, 0x2, 0xb08, 0xb09, 0x7, 0x120, 0x2, 
       0x2, 0xb09, 0xb0a, 0x7, 0x25e, 0x2, 0x2, 0xb0a, 0xb0c, 0x5, 0x440, 
       0x221, 0x2, 0xb0b, 0xb0d, 0x5, 0x3fe, 0x200, 0x2, 0xb0c, 0xb0b, 0x3, 
       0x2, 0x2, 0x2, 0xb0c, 0xb0d, 0x3, 0x2, 0x2, 0x2, 0xb0d, 0xb0f, 0x3, 
       0x2, 0x2, 0x2, 0xb0e, 0xb10, 0x5, 0x3da, 0x1ee, 0x2, 0xb0f, 0xb0e, 
       0x3, 0x2, 0x2, 0x2, 0xb0f, 0xb10, 0x3, 0x2, 0x2, 0x2, 0xb10, 0xb12, 
       0x3, 0x2, 0x2, 0x2, 0xb11, 0xb13, 0x5, 0x106, 0x84, 0x2, 0xb12, 0xb11, 
       0x3, 0x2, 0x2, 0x2, 0xb12, 0xb13, 0x3, 0x2, 0x2, 0x2, 0xb13, 0xb15, 
       0x3, 0x2, 0x2, 0x2, 0xb14, 0xb16, 0x5, 0x3dc, 0x1ef, 0x2, 0xb15, 
       0xb14, 0x3, 0x2, 0x2, 0x2, 0xb15, 0xb16, 0x3, 0x2, 0x2, 0x2, 0xb16, 
       0xb18, 0x3, 0x2, 0x2, 0x2, 0xb17, 0xb19, 0x5, 0x3e0, 0x1f1, 0x2, 
       0xb18, 0xb17, 0x3, 0x2, 0x2, 0x2, 0xb18, 0xb19, 0x3, 0x2, 0x2, 0x2, 
       0xb19, 0xb1a, 0x3, 0x2, 0x2, 0x2, 0xb1a, 0xb1b, 0x5, 0x108, 0x85, 
       0x2, 0xb1b, 0x103, 0x3, 0x2, 0x2, 0x2, 0xb1c, 0xb1d, 0x9, 0x1c, 0x2, 
       0x2, 0xb1d, 0x105, 0x3, 0x2, 0x2, 0x2, 0xb1e, 0xb1f, 0x7, 0x207, 
       0x2, 0x2, 0xb1f, 0xb20, 0x7, 0x10f, 0x2, 0x2, 0xb20, 0xb21, 0x7, 
       0x5f, 0x2, 0x2, 0xb21, 0xb22, 0x5, 0x476, 0x23c, 0x2, 0xb22, 0x107, 
       0x3, 0x2, 0x2, 0x2, 0xb23, 0xb24, 0x7, 0x111, 0x2, 0x2, 0xb24, 0xb25, 
       0x7, 0x6, 0x2, 0x2, 0xb25, 0xb27, 0x9, 0x1d, 0x2, 0x2, 0xb26, 0xb23, 
       0x3, 0x2, 0x2, 0x2, 0xb26, 0xb27, 0x3, 0x2, 0x2, 0x2, 0xb27, 0xb29, 
       0x3, 0x2, 0x2, 0x2, 0xb28, 0xb2a, 0x5, 0x10a, 0x86, 0x2, 0xb29, 0xb28, 
       0x3, 0x2, 0x2, 0x2, 0xb29, 0xb2a, 0x3, 0x2, 0x2, 0x2, 0xb2a, 0xb2d, 
       0x3, 0x2, 0x2, 0x2, 0xb2b, 0xb2c, 0x7, 0x21b, 0x2, 0x2, 0xb2c, 0xb2e, 
       0x5, 0x3d6, 0x1ec, 0x2, 0xb2d, 0xb2b, 0x3, 0x2, 0x2, 0x2, 0xb2d, 
       0xb2e, 0x3, 0x2, 0x2, 0x2, 0xb2e, 0x109, 0x3, 0x2, 0x2, 0x2, 0xb2f, 
       0xb31, 0x7, 0x23, 0x2, 0x2, 0xb30, 0xb32, 0x5, 0x10c, 0x87, 0x2, 
       0xb31, 0xb30, 0x3, 0x2, 0x2, 0x2, 0xb31, 0xb32, 0x3, 0x2, 0x2, 0x2, 
       0xb32, 0xb33, 0x3, 0x2, 0x2, 0x2, 0xb33, 0xb34, 0x7, 0x24, 0x2, 0x2, 
       0xb34, 0x10b, 0x3, 0x2, 0x2, 0x2, 0xb35, 0xb38, 0x5, 0x408, 0x205, 
       0x2, 0xb36, 0xb38, 0x5, 0x2d6, 0x16c, 0x2, 0xb37, 0xb35, 0x3, 0x2, 
       0x2, 0x2, 0xb37, 0xb36, 0x3, 0x2, 0x2, 0x2, 0xb38, 0xb40, 0x3, 0x2, 
       0x2, 0x2, 0xb39, 0xb3c, 0x7, 0x20, 0x2, 0x2, 0xb3a, 0xb3d, 0x5, 0x408, 
       0x205, 0x2, 0xb3b, 0xb3d, 0x5, 0x2d6, 0x16c, 0x2, 0xb3c, 0xb3a, 0x3, 
       0x2, 0x2, 0x2, 0xb3c, 0xb3b, 0x3, 0x2, 0x2, 0x2, 0xb3d, 0xb3f, 0x3, 
       0x2, 0x2, 0x2, 0xb3e, 0xb39, 0x3, 0x2, 0x2, 0x2, 0xb3f, 0xb42, 0x3, 
       0x2, 0x2, 0x2, 0xb40, 0xb3e, 0x3, 0x2, 0x2, 0x2, 0xb40, 0xb41, 0x3, 
       0x2, 0x2, 0x2, 0xb41, 0x10d, 0x3, 0x2, 0x2, 0x2, 0xb42, 0xb40, 0x3, 
       0x2, 0x2, 0x2, 0xb43, 0xb45, 0x7, 0x1ee, 0x2, 0x2, 0xb44, 0xb46, 
       0x9, 0x1e, 0x2, 0x2, 0xb45, 0xb44, 0x3, 0x2, 0x2, 0x2, 0xb45, 0xb46, 
       0x3, 0x2, 0x2, 0x2, 0xb46, 0xb48, 0x3, 0x2, 0x2, 0x2, 0xb47, 0xb49, 
       0x7, 0x120, 0x2, 0x2, 0xb48, 0xb47, 0x3, 0x2, 0x2, 0x2, 0xb48, 0xb49, 
       0x3, 0x2, 0x2, 0x2, 0xb49, 0xb4a, 0x3, 0x2, 0x2, 0x2, 0xb4a, 0xb4c, 
       0x5, 0x440, 0x221, 0x2, 0xb4b, 0xb4d, 0x5, 0x3fe, 0x200, 0x2, 0xb4c, 
       0xb4b, 0x3, 0x2, 0x2, 0x2, 0xb4c, 0xb4d, 0x3, 0x2, 0x2, 0x2, 0xb4d, 
       0xb52, 0x3, 0x2, 0x2, 0x2, 0xb4e, 0xb53, 0x5, 0xf4, 0x7b, 0x2, 0xb4f, 
       0xb50, 0x7, 0x21b, 0x2, 0x2, 0xb50, 0xb53, 0x5, 0x3d6, 0x1ec, 0x2, 
       0xb51, 0xb53, 0x5, 0xfa, 0x7e, 0x2, 0xb52, 0xb4e, 0x3, 0x2, 0x2, 
       0x2, 0xb52, 0xb4f, 0x3, 0x2, 0x2, 0x2, 0xb52, 0xb51, 0x3, 0x2, 0x2, 
       0x2, 0xb53, 0x10f, 0x3, 0x2, 0x2, 0x2, 0xb54, 0xb58, 0x5, 0x114, 
       0x8b, 0x2, 0xb55, 0xb58, 0x5, 0x118, 0x8d, 0x2, 0xb56, 0xb58, 0x5, 
       0x112, 0x8a, 0x2, 0xb57, 0xb54, 0x3, 0x2, 0x2, 0x2, 0xb57, 0xb55, 
       0x3, 0x2, 0x2, 0x2, 0xb57, 0xb56, 0x3, 0x2, 0x2, 0x2, 0xb58, 0x111, 
       0x3, 0x2, 0x2, 0x2, 0xb59, 0xb5a, 0x7, 0x23, 0x2, 0x2, 0xb5a, 0xb5b, 
       0x5, 0x112, 0x8a, 0x2, 0xb5b, 0xb5c, 0x7, 0x24, 0x2, 0x2, 0xb5c, 
       0xb61, 0x3, 0x2, 0x2, 0x2, 0xb5d, 0xb5e, 0x5, 0x114, 0x8b, 0x2, 0xb5e, 
       0xb5f, 0x5, 0x128, 0x95, 0x2, 0xb5f, 0xb61, 0x3, 0x2, 0x2, 0x2, 0xb60, 
       0xb59, 0x3, 0x2, 0x2, 0x2, 0xb60, 0xb5d, 0x3, 0x2, 0x2, 0x2, 0xb61, 
       0x113, 0x3, 0x2, 0x2, 0x2, 0xb62, 0xb63, 0x6, 0x8b, 0x2d, 0x2, 0xb63, 
       0xb65, 0x5, 0x144, 0xa3, 0x2, 0xb64, 0xb62, 0x3, 0x2, 0x2, 0x2, 0xb64, 
       0xb65, 0x3, 0x2, 0x2, 0x2, 0xb65, 0xb75, 0x3, 0x2, 0x2, 0x2, 0xb66, 
       0xb68, 0x5, 0x116, 0x8c, 0x2, 0xb67, 0xb69, 0x5, 0x14c, 0xa7, 0x2, 
       0xb68, 0xb67, 0x3, 0x2, 0x2, 0x2, 0xb68, 0xb69, 0x3, 0x2, 0x2, 0x2, 
       0xb69, 0xb6b, 0x3, 0x2, 0x2, 0x2, 0xb6a, 0xb6c, 0x5, 0x120, 0x91, 
       0x2, 0xb6b, 0xb6a, 0x3, 0x2, 0x2, 0x2, 0xb6b, 0xb6c, 0x3, 0x2, 0x2, 
       0x2, 0xb6c, 0xb76, 0x3, 0x2, 0x2, 0x2, 0xb6d, 0xb73, 0x5, 0x118, 
       0x8d, 0x2, 0xb6e, 0xb70, 0x5, 0x14c, 0xa7, 0x2, 0xb6f, 0xb71, 0x5, 
       0x120, 0x91, 0x2, 0xb70, 0xb6f, 0x3, 0x2, 0x2, 0x2, 0xb70, 0xb71, 
       0x3, 0x2, 0x2, 0x2, 0xb71, 0xb74, 0x3, 0x2, 0x2, 0x2, 0xb72, 0xb74, 
       0x5, 0x120, 0x91, 0x2, 0xb73, 0xb6e, 0x3, 0x2, 0x2, 0x2, 0xb73, 0xb72, 
       0x3, 0x2, 0x2, 0x2, 0xb74, 0xb76, 0x3, 0x2, 0x2, 0x2, 0xb75, 0xb66, 
       0x3, 0x2, 0x2, 0x2, 0xb75, 0xb6d, 0x3, 0x2, 0x2, 0x2, 0xb76, 0xb79, 
       0x3, 0x2, 0x2, 0x2, 0xb77, 0xb78, 0x6, 0x8b, 0x2e, 0x2, 0xb78, 0xb7a, 
       0x5, 0x12a, 0x96, 0x2, 0xb79, 0xb77, 0x3, 0x2, 0x2, 0x2, 0xb79, 0xb7a, 
       0x3, 0x2, 0x2, 0x2, 0xb7a, 0xb7c, 0x3, 0x2, 0x2, 0x2, 0xb7b, 0xb7d, 
       0x5, 0x156, 0xac, 0x2, 0xb7c, 0xb7b, 0x3, 0x2, 0x2, 0x2, 0xb7c, 0xb7d, 
       0x3, 0x2, 0x2, 0x2, 0xb7d, 0xb85, 0x3, 0x2, 0x2, 0x2, 0xb7e, 0xb7f, 
       0x6, 0x8b, 0x2f, 0x2, 0xb7f, 0xb80, 0x5, 0x144, 0xa3, 0x2, 0xb80, 
       0xb82, 0x5, 0x118, 0x8d, 0x2, 0xb81, 0xb83, 0x5, 0x156, 0xac, 0x2, 
       0xb82, 0xb81, 0x3, 0x2, 0x2, 0x2, 0xb82, 0xb83, 0x3, 0x2, 0x2, 0x2, 
       0xb83, 0xb85, 0x3, 0x2, 0x2, 0x2, 0xb84, 0xb64, 0x3, 0x2, 0x2, 0x2, 
       0xb84, 0xb7e, 0x3, 0x2, 0x2, 0x2, 0xb85, 0x115, 0x3, 0x2, 0x2, 0x2, 
       0xb86, 0xb87, 0x8, 0x8c, 0x1, 0x2, 0xb87, 0xb92, 0x5, 0x11a, 0x8e, 
       0x2, 0xb88, 0xb89, 0x5, 0x118, 0x8d, 0x2, 0xb89, 0xb8b, 0x7, 0x280, 
       0x2, 0x2, 0xb8a, 0xb8c, 0x5, 0x188, 0xc5, 0x2, 0xb8b, 0xb8a, 0x3, 
       0x2, 0x2, 0x2, 0xb8b, 0xb8c, 0x3, 0x2, 0x2, 0x2, 0xb8c, 0xb8f, 0x3, 
       0x2, 0x2, 0x2, 0xb8d, 0xb90, 0x5, 0x11a, 0x8e, 0x2, 0xb8e, 0xb90, 
       0x5, 0x118, 0x8d, 0x2, 0xb8f, 0xb8d, 0x3, 0x2, 0x2, 0x2, 0xb8f, 0xb8e, 
       0x3, 0x2, 0x2, 0x2, 0xb90, 0xb92, 0x3, 0x2, 0x2, 0x2, 0xb91, 0xb86, 
       0x3, 0x2, 0x2, 0x2, 0xb91, 0xb88, 0x3, 0x2, 0x2, 0x2, 0xb92, 0xb9e, 
       0x3, 0x2, 0x2, 0x2, 0xb93, 0xb94, 0xc, 0x4, 0x2, 0x2, 0xb94, 0xb96, 
       0x7, 0x280, 0x2, 0x2, 0xb95, 0xb97, 0x5, 0x188, 0xc5, 0x2, 0xb96, 
       0xb95, 0x3, 0x2, 0x2, 0x2, 0xb96, 0xb97, 0x3, 0x2, 0x2, 0x2, 0xb97, 
       0xb9a, 0x3, 0x2, 0x2, 0x2, 0xb98, 0xb9b, 0x5, 0x11a, 0x8e, 0x2, 0xb99, 
       0xb9b, 0x5, 0x118, 0x8d, 0x2, 0xb9a, 0xb98, 0x3, 0x2, 0x2, 0x2, 0xb9a, 
       0xb99, 0x3, 0x2, 0x2, 0x2, 0xb9b, 0xb9d, 0x3, 0x2, 0x2, 0x2, 0xb9c, 
       0xb93, 0x3, 0x2, 0x2, 0x2, 0xb9d, 0xba0, 0x3, 0x2, 0x2, 0x2, 0xb9e, 
       0xb9c, 0x3, 0x2, 0x2, 0x2, 0xb9e, 0xb9f, 0x3, 0x2, 0x2, 0x2, 0xb9f, 
       0x117, 0x3, 0x2, 0x2, 0x2, 0xba0, 0xb9e, 0x3, 0x2, 0x2, 0x2, 0xba1, 
       0xba4, 0x7, 0x23, 0x2, 0x2, 0xba2, 0xba5, 0x5, 0x118, 0x8d, 0x2, 
       0xba3, 0xba5, 0x5, 0x114, 0x8b, 0x2, 0xba4, 0xba2, 0x3, 0x2, 0x2, 
       0x2, 0xba4, 0xba3, 0x3, 0x2, 0x2, 0x2, 0xba5, 0xba6, 0x3, 0x2, 0x2, 
       0x2, 0xba6, 0xba7, 0x7, 0x24, 0x2, 0x2, 0xba7, 0x119, 0x3, 0x2, 0x2, 
       0x2, 0xba8, 0xbac, 0x7, 0x212, 0x2, 0x2, 0xba9, 0xbab, 0x5, 0x154, 
       0xab, 0x2, 0xbaa, 0xba9, 0x3, 0x2, 0x2, 0x2, 0xbab, 0xbae, 0x3, 0x2, 
       0x2, 0x2, 0xbac, 0xbaa, 0x3, 0x2, 0x2, 0x2, 0xbac, 0xbad, 0x3, 0x2, 
       0x2, 0x2, 0xbad, 0xbaf, 0x3, 0x2, 0x2, 0x2, 0xbae, 0xbac, 0x3, 0x2, 
       0x2, 0x2, 0xbaf, 0xbb1, 0x5, 0x15c, 0xaf, 0x2, 0xbb0, 0xbb2, 0x5, 
       0x128, 0x95, 0x2, 0xbb1, 0xbb0, 0x3, 0x2, 0x2, 0x2, 0xbb1, 0xbb2, 
       0x3, 0x2, 0x2, 0x2, 0xbb2, 0xbb4, 0x3, 0x2, 0x2, 0x2, 0xbb3, 0xbb5, 
       0x5, 0x150, 0xa9, 0x2, 0xbb4, 0xbb3, 0x3, 0x2, 0x2, 0x2, 0xbb4, 0xbb5, 
       0x3, 0x2, 0x2, 0x2, 0xbb5, 0xbb7, 0x3, 0x2, 0x2, 0x2, 0xbb6, 0xbb8, 
       0x5, 0x162, 0xb2, 0x2, 0xbb7, 0xbb6, 0x3, 0x2, 0x2, 0x2, 0xbb7, 0xbb8, 
       0x3, 0x2, 0x2, 0x2, 0xbb8, 0xbba, 0x3, 0x2, 0x2, 0x2, 0xbb9, 0xbbb, 
       0x5, 0x148, 0xa5, 0x2, 0xbba, 0xbb9, 0x3, 0x2, 0x2, 0x2, 0xbba, 0xbbb, 
       0x3, 0x2, 0x2, 0x2, 0xbbb, 0xbbd, 0x3, 0x2, 0x2, 0x2, 0xbbc, 0xbbe, 
       0x5, 0x12c, 0x97, 0x2, 0xbbd, 0xbbc, 0x3, 0x2, 0x2, 0x2, 0xbbd, 0xbbe, 
       0x3, 0x2, 0x2, 0x2, 0xbbe, 0xbc1, 0x3, 0x2, 0x2, 0x2, 0xbbf, 0xbc0, 
       0x6, 0x8e, 0x31, 0x2, 0xbc0, 0xbc2, 0x5, 0x12e, 0x98, 0x2, 0xbc1, 
       0xbbf, 0x3, 0x2, 0x2, 0x2, 0xbc1, 0xbc2, 0x3, 0x2, 0x2, 0x2, 0xbc2, 
       0x11b, 0x3, 0x2, 0x2, 0x2, 0xbc3, 0xbc4, 0x5, 0x118, 0x8d, 0x2, 0xbc4, 
       0x11d, 0x3, 0x2, 0x2, 0x2, 0xbc5, 0xbc6, 0x9, 0x1f, 0x2, 0x2, 0xbc6, 
       0x11f, 0x3, 0x2, 0x2, 0x2, 0xbc7, 0xbc8, 0x7, 0x13b, 0x2, 0x2, 0xbc8, 
       0xbc9, 0x5, 0x124, 0x93, 0x2, 0xbc9, 0x121, 0x3, 0x2, 0x2, 0x2, 0xbca, 
       0xbcb, 0x7, 0x13b, 0x2, 0x2, 0xbcb, 0xbcc, 0x5, 0x126, 0x94, 0x2, 
       0xbcc, 0x123, 0x3, 0x2, 0x2, 0x2, 0xbcd, 0xbd0, 0x5, 0x126, 0x94, 
       0x2, 0xbce, 0xbcf, 0x9, 0x20, 0x2, 0x2, 0xbcf, 0xbd1, 0x5, 0x126, 
       0x94, 0x2, 0xbd0, 0xbce, 0x3, 0x2, 0x2, 0x2, 0xbd0, 0xbd1, 0x3, 0x2, 
       0x2, 0x2, 0xbd1, 0x125, 0x3, 0x2, 0x2, 0x2, 0xbd2, 0xbd5, 0x5, 0x45a, 
       0x22e, 0x2, 0xbd3, 0xbd5, 0x9, 0x21, 0x2, 0x2, 0xbd4, 0xbd2, 0x3, 
       0x2, 0x2, 0x2, 0xbd4, 0xbd3, 0x3, 0x2, 0x2, 0x2, 0xbd5, 0x127, 0x3, 
       0x2, 0x2, 0x2, 0xbd6, 0xbf2, 0x7, 0x120, 0x2, 0x2, 0xbd7, 0xbd8, 
       0x7, 0x1b0, 0x2, 0x2, 0xbd8, 0xbda, 0x5, 0x474, 0x23b, 0x2, 0xbd9, 
       0xbdb, 0x5, 0x3da, 0x1ee, 0x2, 0xbda, 0xbd9, 0x3, 0x2, 0x2, 0x2, 
       0xbda, 0xbdb, 0x3, 0x2, 0x2, 0x2, 0xbdb, 0xbdd, 0x3, 0x2, 0x2, 0x2, 
       0xbdc, 0xbde, 0x5, 0x3dc, 0x1ef, 0x2, 0xbdd, 0xbdc, 0x3, 0x2, 0x2, 
       0x2, 0xbdd, 0xbde, 0x3, 0x2, 0x2, 0x2, 0xbde, 0xbe0, 0x3, 0x2, 0x2, 
       0x2, 0xbdf, 0xbe1, 0x5, 0x3e0, 0x1f1, 0x2, 0xbe0, 0xbdf, 0x3, 0x2, 
       0x2, 0x2, 0xbe0, 0xbe1, 0x3, 0x2, 0x2, 0x2, 0xbe1, 0xbf3, 0x3, 0x2, 
       0x2, 0x2, 0xbe2, 0xbe3, 0x7, 0xc3, 0x2, 0x2, 0xbe3, 0xbf3, 0x5, 0x474, 
       0x23b, 0x2, 0xbe4, 0xbe7, 0x5, 0x48e, 0x248, 0x2, 0xbe5, 0xbe7, 0x5, 
       0x2d6, 0x16c, 0x2, 0xbe6, 0xbe4, 0x3, 0x2, 0x2, 0x2, 0xbe6, 0xbe5, 
       0x3, 0x2, 0x2, 0x2, 0xbe7, 0xbef, 0x3, 0x2, 0x2, 0x2, 0xbe8, 0xbeb, 
       0x7, 0x20, 0x2, 0x2, 0xbe9, 0xbec, 0x5, 0x48e, 0x248, 0x2, 0xbea, 
       0xbec, 0x5, 0x2d6, 0x16c, 0x2, 0xbeb, 0xbe9, 0x3, 0x2, 0x2, 0x2, 
       0xbeb, 0xbea, 0x3, 0x2, 0x2, 0x2, 0xbec, 0xbee, 0x3, 0x2, 0x2, 0x2, 
       0xbed, 0xbe8, 0x3, 0x2, 0x2, 0x2, 0xbee, 0xbf1, 0x3, 0x2, 0x2, 0x2, 
       0xbef, 0xbed, 0x3, 0x2, 0x2, 0x2, 0xbef, 0xbf0, 0x3, 0x2, 0x2, 0x2, 
       0xbf0, 0xbf3, 0x3, 0x2, 0x2, 0x2, 0xbf1, 0xbef, 0x3, 0x2, 0x2, 0x2, 
       0xbf2, 0xbd7, 0x3, 0x2, 0x2, 0x2, 0xbf2, 0xbe2, 0x3, 0x2, 0x2, 0x2, 
       0xbf2, 0xbe6, 0x3, 0x2, 0x2, 0x2, 0xbf3, 0x129, 0x3, 0x2, 0x2, 0x2, 
       0xbf4, 0xbf5, 0x7, 0x1ca, 0x2, 0x2, 0xbf5, 0xbf6, 0x7, 0x3f, 0x2, 
       0x2, 0xbf6, 0xbfc, 0x7, 0x23, 0x2, 0x2, 0xbf7, 0xbfa, 0x7, 0x6, 0x2, 
       0x2, 0xbf8, 0xbf9, 0x7, 0x20, 0x2, 0x2, 0xbf9, 0xbfb, 0x7, 0x6, 0x2, 
       0x2, 0xbfa, 0xbf8, 0x3, 0x2, 0x2, 0x2, 0xbfa, 0xbfb, 0x3, 0x2, 0x2, 
       0x2, 0xbfb, 0xbfd, 0x3, 0x2, 0x2, 0x2, 0xbfc, 0xbf7, 0x3, 0x2, 0x2, 
       0x2, 0xbfc, 0xbfd, 0x3, 0x2, 0x2, 0x2, 0xbfd, 0xbfe, 0x3, 0x2, 0x2, 
       0x2, 0xbfe, 0xbff, 0x7, 0x24, 0x2, 0x2, 0xbff, 0x12b, 0x3, 0x2, 0x2, 
       0x2, 0xc00, 0xc01, 0x7, 0x106, 0x2, 0x2, 0xc01, 0xc02, 0x5, 0x294, 
       0x14b, 0x2, 0xc02, 0x12d, 0x3, 0x2, 0x2, 0x2, 0xc03, 0xc04, 0x7, 
       0x2dc, 0x2, 0x2, 0xc04, 0xc09, 0x5, 0x130, 0x99, 0x2, 0xc05, 0xc06, 
       0x7, 0x20, 0x2, 0x2, 0xc06, 0xc08, 0x5, 0x130, 0x99, 0x2, 0xc07, 
       0xc05, 0x3, 0x2, 0x2, 0x2, 0xc08, 0xc0b, 0x3, 0x2, 0x2, 0x2, 0xc09, 
       0xc07, 0x3, 0x2, 0x2, 0x2, 0xc09, 0xc0a, 0x3, 0x2, 0x2, 0x2, 0xc0a, 
       0x12f, 0x3, 0x2, 0x2, 0x2, 0xc0b, 0xc09, 0x3, 0x2, 0x2, 0x2, 0xc0c, 
       0xc0d, 0x5, 0x456, 0x22c, 0x2, 0xc0d, 0xc0e, 0x7, 0x43, 0x2, 0x2, 
       0xc0e, 0xc0f, 0x5, 0x132, 0x9a, 0x2, 0xc0f, 0x131, 0x3, 0x2, 0x2, 
       0x2, 0xc10, 0xc11, 0x7, 0x23, 0x2, 0x2, 0xc11, 0xc12, 0x5, 0x134, 
       0x9b, 0x2, 0xc12, 0xc13, 0x7, 0x24, 0x2, 0x2, 0xc13, 0x133, 0x3, 
       0x2, 0x2, 0x2, 0xc14, 0xc16, 0x5, 0x456, 0x22c, 0x2, 0xc15, 0xc14, 
       0x3, 0x2, 0x2, 0x2, 0xc15, 0xc16, 0x3, 0x2, 0x2, 0x2, 0xc16, 0xc1a, 
       0x3, 0x2, 0x2, 0x2, 0xc17, 0xc18, 0x7, 0x1b9, 0x2, 0x2, 0xc18, 0xc19, 
       0x7, 0x5f, 0x2, 0x2, 0xc19, 0xc1b, 0x5, 0x2f6, 0x17c, 0x2, 0xc1a, 
       0xc17, 0x3, 0x2, 0x2, 0x2, 0xc1a, 0xc1b, 0x3, 0x2, 0x2, 0x2, 0xc1b, 
       0xc1d, 0x3, 0x2, 0x2, 0x2, 0xc1c, 0xc1e, 0x5, 0x14c, 0xa7, 0x2, 0xc1d, 
       0xc1c, 0x3, 0x2, 0x2, 0x2, 0xc1d, 0xc1e, 0x3, 0x2, 0x2, 0x2, 0xc1e, 
       0xc20, 0x3, 0x2, 0x2, 0x2, 0xc1f, 0xc21, 0x5, 0x136, 0x9c, 0x2, 0xc20, 
       0xc1f, 0x3, 0x2, 0x2, 0x2, 0xc20, 0xc21, 0x3, 0x2, 0x2, 0x2, 0xc21, 
       0x135, 0x3, 0x2, 0x2, 0x2, 0xc22, 0xc23, 0x5, 0x138, 0x9d, 0x2, 0xc23, 
       0xc25, 0x5, 0x13a, 0x9e, 0x2, 0xc24, 0xc26, 0x5, 0x142, 0xa2, 0x2, 
       0xc25, 0xc24, 0x3, 0x2, 0x2, 0x2, 0xc25, 0xc26, 0x3, 0x2, 0x2, 0x2, 
       0xc26, 0x137, 0x3, 0x2, 0x2, 0x2, 0xc27, 0xc28, 0x9, 0x22, 0x2, 0x2, 
       0xc28, 0x139, 0x3, 0x2, 0x2, 0x2, 0xc29, 0xc2c, 0x5, 0x13c, 0x9f, 
       0x2, 0xc2a, 0xc2c, 0x5, 0x13e, 0xa0, 0x2, 0xc2b, 0xc29, 0x3, 0x2, 
       0x2, 0x2, 0xc2b, 0xc2a, 0x3, 0x2, 0x2, 0x2, 0xc2c, 0x13b, 0x3, 0x2, 
       0x2, 0x2, 0xc2d, 0xc2e, 0x7, 0x2db, 0x2, 0x2, 0xc2e, 0xc3c, 0x7, 
       0x2d6, 0x2, 0x2, 0xc2f, 0xc30, 0x5, 0x46a, 0x236, 0x2, 0xc30, 0xc31, 
       0x7, 0x2d6, 0x2, 0x2, 0xc31, 0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc32, 0xc33, 
       0x7, 0x2e, 0x2, 0x2, 0xc33, 0xc3c, 0x7, 0x2d6, 0x2, 0x2, 0xc34, 0xc35, 
       0x7, 0x11f, 0x2, 0x2, 0xc35, 0xc36, 0x5, 0x294, 0x14b, 0x2, 0xc36, 
       0xc37, 0x5, 0x2ec, 0x177, 0x2, 0xc37, 0xc38, 0x7, 0x2d6, 0x2, 0x2, 
       0xc38, 0xc3c, 0x3, 0x2, 0x2, 0x2, 0xc39, 0xc3a, 0x7, 0x96, 0x2, 0x2, 
       0xc3a, 0xc3c, 0x7, 0x20a, 0x2, 0x2, 0xc3b, 0xc2d, 0x3, 0x2, 0x2, 
       0x2, 0xc3b, 0xc2f, 0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc32, 0x3, 0x2, 0x2, 
       0x2, 0xc3b, 0xc34, 0x3, 0x2, 0x2, 0x2, 0xc3b, 0xc39, 0x3, 0x2, 0x2, 
       0x2, 0xc3c, 0x13d, 0x3, 0x2, 0x2, 0x2, 0xc3d, 0xc3e, 0x7, 0x50, 0x2, 
       0x2, 0xc3e, 0xc3f, 0x5, 0x140, 0xa1, 0x2, 0xc3f, 0xc40, 0x7, 0x41, 
       0x2, 0x2, 0xc40, 0xc41, 0x5, 0x140, 0xa1, 0x2, 0xc41, 0x13f, 0x3, 
       0x2, 0x2, 0x2, 0xc42, 0xc50, 0x5, 0x13c, 0x9f, 0x2, 0xc43, 0xc44, 
       0x7, 0x2db, 0x2, 0x2, 0xc44, 0xc50, 0x7, 0x2cb, 0x2, 0x2, 0xc45, 
       0xc46, 0x5, 0x46a, 0x236, 0x2, 0xc46, 0xc47, 0x7, 0x2cb, 0x2, 0x2, 
       0xc47, 0xc50, 0x3, 0x2, 0x2, 0x2, 0xc48, 0xc49, 0x7, 0x2e, 0x2, 0x2, 
       0xc49, 0xc50, 0x7, 0x2cb, 0x2, 0x2, 0xc4a, 0xc4b, 0x7, 0x11f, 0x2, 
       0x2, 0xc4b, 0xc4c, 0x5, 0x294, 0x14b, 0x2, 0xc4c, 0xc4d, 0x5, 0x2ec, 
       0x177, 0x2, 0xc4d, 0xc4e, 0x7, 0x2cb, 0x2, 0x2, 0xc4e, 0xc50, 0x3, 
       0x2, 0x2, 0x2, 0xc4f, 0xc42, 0x3, 0x2, 0x2, 0x2, 0xc4f, 0xc43, 0x3, 
       0x2, 0x2, 0x2, 0xc4f, 0xc45, 0x3, 0x2, 0x2, 0x2, 0xc4f, 0xc48, 0x3, 
       0x2, 0x2, 0x2, 0xc4f, 0xc4a, 0x3, 0x2, 0x2, 0x2, 0xc50, 0x141, 0x3, 
       0x2, 0x2, 0x2, 0xc51, 0xc58, 0x7, 0x2c9, 0x2, 0x2, 0xc52, 0xc53, 
       0x7, 0x96, 0x2, 0x2, 0xc53, 0xc59, 0x7, 0x20a, 0x2, 0x2, 0xc54, 0xc59, 
       0x7, 0x102, 0x2, 0x2, 0xc55, 0xc59, 0x7, 0x2da, 0x2, 0x2, 0xc56, 
       0xc57, 0x7, 0x198, 0x2, 0x2, 0xc57, 0xc59, 0x7, 0x2d3, 0x2, 0x2, 
       0xc58, 0xc52, 0x3, 0x2, 0x2, 0x2, 0xc58, 0xc54, 0x3, 0x2, 0x2, 0x2, 
       0xc58, 0xc55, 0x3, 0x2, 0x2, 0x2, 0xc58, 0xc56, 0x3, 0x2, 0x2, 0x2, 
       0xc59, 0x143, 0x3, 0x2, 0x2, 0x2, 0xc5a, 0xc5c, 0x7, 0x2a4, 0x2, 
       0x2, 0xc5b, 0xc5d, 0x7, 0x2ba, 0x2, 0x2, 0xc5c, 0xc5b, 0x3, 0x2, 
       0x2, 0x2, 0xc5c, 0xc5d, 0x3, 0x2, 0x2, 0x2, 0xc5d, 0xc5e, 0x3, 0x2, 
       0x2, 0x2, 0xc5e, 0xc63, 0x5, 0x146, 0xa4, 0x2, 0xc5f, 0xc60, 0x7, 
       0x20, 0x2, 0x2, 0xc60, 0xc62, 0x5, 0x146, 0xa4, 0x2, 0xc61, 0xc5f, 
       0x3, 0x2, 0x2, 0x2, 0xc62, 0xc65, 0x3, 0x2, 0x2, 0x2, 0xc63, 0xc61, 
       0x3, 0x2, 0x2, 0x2, 0xc63, 0xc64, 0x3, 0x2, 0x2, 0x2, 0xc64, 0x145, 
       0x3, 0x2, 0x2, 0x2, 0xc65, 0xc63, 0x3, 0x2, 0x2, 0x2, 0xc66, 0xc68, 
       0x5, 0x45a, 0x22e, 0x2, 0xc67, 0xc69, 0x5, 0x406, 0x204, 0x2, 0xc68, 
       0xc67, 0x3, 0x2, 0x2, 0x2, 0xc68, 0xc69, 0x3, 0x2, 0x2, 0x2, 0xc69, 
       0xc6a, 0x3, 0x2, 0x2, 0x2, 0xc6a, 0xc6b, 0x7, 0x43, 0x2, 0x2, 0xc6b, 
       0xc6c, 0x5, 0x11c, 0x8f, 0x2, 0xc6c, 0x147, 0x3, 0x2, 0x2, 0x2, 0xc6d, 
       0xc6e, 0x7, 0x102, 0x2, 0x2, 0xc6e, 0xc6f, 0x7, 0x5f, 0x2, 0x2, 0xc6f, 
       0xc71, 0x5, 0x2f6, 0x17c, 0x2, 0xc70, 0xc72, 0x5, 0x14a, 0xa6, 0x2, 
       0xc71, 0xc70, 0x3, 0x2, 0x2, 0x2, 0xc71, 0xc72, 0x3, 0x2, 0x2, 0x2, 
       0xc72, 0x149, 0x3, 0x2, 0x2, 0x2, 0xc73, 0xc74, 0x7, 0x2a4, 0x2, 
       0x2, 0xc74, 0xc79, 0x7, 0x204, 0x2, 0x2, 0xc75, 0xc76, 0x6, 0xa6, 
       0x32, 0x2, 0xc76, 0xc77, 0x7, 0x2a4, 0x2, 0x2, 0xc77, 0xc79, 0x7, 
       0x94, 0x2, 0x2, 0xc78, 0xc73, 0x3, 0x2, 0x2, 0x2, 0xc78, 0xc75, 0x3, 
       0x2, 0x2, 0x2, 0xc79, 0x14b, 0x3, 0x2, 0x2, 0x2, 0xc7a, 0xc7b, 0x7, 
       0x1ad, 0x2, 0x2, 0xc7b, 0xc7c, 0x7, 0x5f, 0x2, 0x2, 0xc7c, 0xc7d, 
       0x5, 0x2f6, 0x17c, 0x2, 0xc7d, 0x14d, 0x3, 0x2, 0x2, 0x2, 0xc7e, 
       0xc7f, 0x9, 0x23, 0x2, 0x2, 0xc7f, 0x14f, 0x3, 0x2, 0x2, 0x2, 0xc80, 
       0xc83, 0x7, 0xf4, 0x2, 0x2, 0xc81, 0xc84, 0x7, 0xc2, 0x2, 0x2, 0xc82, 
       0xc84, 0x5, 0x152, 0xaa, 0x2, 0xc83, 0xc81, 0x3, 0x2, 0x2, 0x2, 0xc83, 
       0xc82, 0x3, 0x2, 0x2, 0x2, 0xc84, 0x151, 0x3, 0x2, 0x2, 0x2, 0xc85, 
       0xc8a, 0x5, 0x164, 0xb3, 0x2, 0xc86, 0xc87, 0x7, 0x20, 0x2, 0x2, 
       0xc87, 0xc89, 0x5, 0x164, 0xb3, 0x2, 0xc88, 0xc86, 0x3, 0x2, 0x2, 
       0x2, 0xc89, 0xc8c, 0x3, 0x2, 0x2, 0x2, 0xc8a, 0xc88, 0x3, 0x2, 0x2, 
       0x2, 0xc8a, 0xc8b, 0x3, 0x2, 0x2, 0x2, 0xc8b, 0x153, 0x3, 0x2, 0x2, 
       0x2, 0xc8c, 0xc8a, 0x3, 0x2, 0x2, 0x2, 0xc8d, 0xc96, 0x5, 0x11e, 
       0x90, 0x2, 0xc8e, 0xc96, 0x7, 0x237, 0x2, 0x2, 0xc8f, 0xc90, 0x6, 
       0xab, 0x33, 0x2, 0xc90, 0xc96, 0x7, 0x235, 0x2, 0x2, 0xc91, 0xc92, 
       0x6, 0xab, 0x34, 0x2, 0xc92, 0xc93, 0x7, 0x16a, 0x2, 0x2, 0xc93, 
       0xc94, 0x7, 0x9, 0x2, 0x2, 0xc94, 0xc96, 0x5, 0x468, 0x235, 0x2, 
       0xc95, 0xc8d, 0x3, 0x2, 0x2, 0x2, 0xc95, 0xc8e, 0x3, 0x2, 0x2, 0x2, 
       0xc95, 0xc8f, 0x3, 0x2, 0x2, 0x2, 0xc95, 0xc91, 0x3, 0x2, 0x2, 0x2, 
       0xc96, 0x155, 0x3, 0x2, 0x2, 0x2, 0xc97, 0xc98, 0x7, 0xf1, 0x2, 0x2, 
       0xc98, 0xc9c, 0x5, 0x158, 0xad, 0x2, 0xc99, 0xc9a, 0x6, 0xac, 0x35, 
       0x2, 0xc9a, 0xc9b, 0x7, 0x2bd, 0x2, 0x2, 0xc9b, 0xc9d, 0x5, 0x444, 
       0x223, 0x2, 0xc9c, 0xc99, 0x3, 0x2, 0x2, 0x2, 0xc9c, 0xc9d, 0x3, 
       0x2, 0x2, 0x2, 0xc9d, 0xca0, 0x3, 0x2, 0x2, 0x2, 0xc9e, 0xc9f, 0x6, 
       0xac, 0x36, 0x2, 0xc9f, 0xca1, 0x5, 0x15a, 0xae, 0x2, 0xca0, 0xc9e, 
       0x3, 0x2, 0x2, 0x2, 0xca0, 0xca1, 0x3, 0x2, 0x2, 0x2, 0xca1, 0xca7, 
       0x3, 0x2, 0x2, 0x2, 0xca2, 0xca3, 0x7, 0x144, 0x2, 0x2, 0xca3, 0xca4, 
       0x7, 0x123, 0x2, 0x2, 0xca4, 0xca5, 0x7, 0x21d, 0x2, 0x2, 0xca5, 
       0xca7, 0x7, 0x17e, 0x2, 0x2, 0xca6, 0xc97, 0x3, 0x2, 0x2, 0x2, 0xca6, 
       0xca2, 0x3, 0x2, 0x2, 0x2, 0xca7, 0x157, 0x3, 0x2, 0x2, 0x2, 0xca8, 
       0xcac, 0x7, 0x286, 0x2, 0x2, 0xca9, 0xcaa, 0x6, 0xad, 0x37, 0x2, 
       0xcaa, 0xcac, 0x7, 0x21d, 0x2, 0x2, 0xcab, 0xca8, 0x3, 0x2, 0x2, 
       0x2, 0xcab, 0xca9, 0x3, 0x2, 0x2, 0x2, 0xcac, 0x159, 0x3, 0x2, 0x2, 
       0x2, 0xcad, 0xcae, 0x7, 0x2be, 0x2, 0x2, 0xcae, 0xcb1, 0x7, 0x2bf, 
       0x2, 0x2, 0xcaf, 0xcb1, 0x7, 0x2c0, 0x2, 0x2, 0xcb0, 0xcad, 0x3, 
       0x2, 0x2, 0x2, 0xcb0, 0xcaf, 0x3, 0x2, 0x2, 0x2, 0xcb1, 0x15b, 0x3, 
       0x2, 0x2, 0x2, 0xcb2, 0xcb5, 0x5, 0x15e, 0xb0, 0x2, 0xcb3, 0xcb5, 
       0x7, 0x13, 0x2, 0x2, 0xcb4, 0xcb2, 0x3, 0x2, 0x2, 0x2, 0xcb4, 0xcb3, 
       0x3, 0x2, 0x2, 0x2, 0xcb5, 0xcba, 0x3, 0x2, 0x2, 0x2, 0xcb6, 0xcb7, 
       0x7, 0x20, 0x2, 0x2, 0xcb7, 0xcb9, 0x5, 0x15e, 0xb0, 0x2, 0xcb8, 
       0xcb6, 0x3, 0x2, 0x2, 0x2, 0xcb9, 0xcbc, 0x3, 0x2, 0x2, 0x2, 0xcba, 
       0xcb8, 0x3, 0x2, 0x2, 0x2, 0xcba, 0xcbb, 0x3, 0x2, 0x2, 0x2, 0xcbb, 
       0x15d, 0x3, 0x2, 0x2, 0x2, 0xcbc, 0xcba, 0x3, 0x2, 0x2, 0x2, 0xcbd, 
       0xcc3, 0x5, 0x410, 0x209, 0x2, 0xcbe, 0xcc0, 0x5, 0x294, 0x14b, 0x2, 
       0xcbf, 0xcc1, 0x5, 0x160, 0xb1, 0x2, 0xcc0, 0xcbf, 0x3, 0x2, 0x2, 
       0x2, 0xcc0, 0xcc1, 0x3, 0x2, 0x2, 0x2, 0xcc1, 0xcc3, 0x3, 0x2, 0x2, 
       0x2, 0xcc2, 0xcbd, 0x3, 0x2, 0x2, 0x2, 0xcc2, 0xcbe, 0x3, 0x2, 0x2, 
       0x2, 0xcc3, 0x15f, 0x3, 0x2, 0x2, 0x2, 0xcc4, 0xcc6, 0x7, 0x43, 0x2, 
       0x2, 0xcc5, 0xcc4, 0x3, 0x2, 0x2, 0x2, 0xcc5, 0xcc6, 0x3, 0x2, 0x2, 
       0x2, 0xcc6, 0xcc9, 0x3, 0x2, 0x2, 0x2, 0xcc7, 0xcca, 0x5, 0x45a, 
       0x22e, 0x2, 0xcc8, 0xcca, 0x5, 0x474, 0x23b, 0x2, 0xcc9, 0xcc7, 0x3, 
       0x2, 0x2, 0x2, 0xcc9, 0xcc8, 0x3, 0x2, 0x2, 0x2, 0xcca, 0x161, 0x3, 
       0x2, 0x2, 0x2, 0xccb, 0xccc, 0x7, 0x2a2, 0x2, 0x2, 0xccc, 0xccd, 
       0x5, 0x294, 0x14b, 0x2, 0xccd, 0x163, 0x3, 0x2, 0x2, 0x2, 0xcce, 
       0xcd9, 0x5, 0x170, 0xb9, 0x2, 0xccf, 0xcd3, 0x7, 0x25, 0x2, 0x2, 
       0xcd0, 0xcd1, 0x6, 0xb3, 0x38, 0x2, 0xcd1, 0xcd4, 0x5, 0x45a, 0x22e, 
       0x2, 0xcd2, 0xcd4, 0x7, 0x2fd, 0x2, 0x2, 0xcd3, 0xcd0, 0x3, 0x2, 
       0x2, 0x2, 0xcd3, 0xcd2, 0x3, 0x2, 0x2, 0x2, 0xcd4, 0xcd5, 0x3, 0x2, 
       0x2, 0x2, 0xcd5, 0xcd6, 0x5, 0x166, 0xb4, 0x2, 0xcd6, 0xcd7, 0x7, 
       0x26, 0x2, 0x2, 0xcd7, 0xcd9, 0x3, 0x2, 0x2, 0x2, 0xcd8, 0xcce, 0x3, 
       0x2, 0x2, 0x2, 0xcd8, 0xccf, 0x3, 0x2, 0x2, 0x2, 0xcd9, 0xcdd, 0x3, 
       0x2, 0x2, 0x2, 0xcda, 0xcdc, 0x5, 0x168, 0xb5, 0x2, 0xcdb, 0xcda, 
       0x3, 0x2, 0x2, 0x2, 0xcdc, 0xcdf, 0x3, 0x2, 0x2, 0x2, 0xcdd, 0xcdb, 
       0x3, 0x2, 0x2, 0x2, 0xcdd, 0xcde, 0x3, 0x2, 0x2, 0x2, 0xcde, 0x165, 
       0x3, 0x2, 0x2, 0x2, 0xcdf, 0xcdd, 0x3, 0x2, 0x2, 0x2, 0xce0, 0xce4, 
       0x5, 0x170, 0xb9, 0x2, 0xce1, 0xce3, 0x5, 0x168, 0xb5, 0x2, 0xce2, 
       0xce1, 0x3, 0x2, 0x2, 0x2, 0xce3, 0xce6, 0x3, 0x2, 0x2, 0x2, 0xce4, 
       0xce2, 0x3, 0x2, 0x2, 0x2, 0xce4, 0xce5, 0x3, 0x2, 0x2, 0x2, 0xce5, 
       0x167, 0x3, 0x2, 0x2, 0x2, 0xce6, 0xce4, 0x3, 0x2, 0x2, 0x2, 0xce7, 
       0xce8, 0x5, 0x16c, 0xb7, 0x2, 0xce8, 0xced, 0x5, 0x164, 0xb3, 0x2, 
       0xce9, 0xcea, 0x7, 0x1a2, 0x2, 0x2, 0xcea, 0xcee, 0x5, 0x294, 0x14b, 
       0x2, 0xceb, 0xcec, 0x7, 0x28d, 0x2, 0x2, 0xcec, 0xcee, 0x5, 0x45e, 
       0x230, 0x2, 0xced, 0xce9, 0x3, 0x2, 0x2, 0x2, 0xced, 0xceb, 0x3, 
       0x2, 0x2, 0x2, 0xced, 0xcee, 0x3, 0x2, 0x2, 0x2, 0xcee, 0xcfb, 0x3, 
       0x2, 0x2, 0x2, 0xcef, 0xcf0, 0x5, 0x16e, 0xb8, 0x2, 0xcf0, 0xcf5, 
       0x5, 0x164, 0xb3, 0x2, 0xcf1, 0xcf2, 0x7, 0x1a2, 0x2, 0x2, 0xcf2, 
       0xcf6, 0x5, 0x294, 0x14b, 0x2, 0xcf3, 0xcf4, 0x7, 0x28d, 0x2, 0x2, 
       0xcf4, 0xcf6, 0x5, 0x45e, 0x230, 0x2, 0xcf5, 0xcf1, 0x3, 0x2, 0x2, 
       0x2, 0xcf5, 0xcf3, 0x3, 0x2, 0x2, 0x2, 0xcf6, 0xcfb, 0x3, 0x2, 0x2, 
       0x2, 0xcf7, 0xcf8, 0x5, 0x16a, 0xb6, 0x2, 0xcf8, 0xcf9, 0x5, 0x170, 
       0xb9, 0x2, 0xcf9, 0xcfb, 0x3, 0x2, 0x2, 0x2, 0xcfa, 0xce7, 0x3, 0x2, 
       0x2, 0x2, 0xcfa, 0xcef, 0x3, 0x2, 0x2, 0x2, 0xcfa, 0xcf7, 0x3, 0x2, 
       0x2, 0x2, 0xcfb, 0x169, 0x3, 0x2, 0x2, 0x2, 0xcfc, 0xcfe, 0x7, 0x18b, 
       0x2, 0x2, 0xcfd, 0xcff, 0x7, 0x118, 0x2, 0x2, 0xcfe, 0xcfd, 0x3, 
       0x2, 0x2, 0x2, 0xcfe, 0xcff, 0x3, 0x2, 0x2, 0x2, 0xcff, 0xd00, 0x3, 
       0x2, 0x2, 0x2, 0xd00, 0xd08, 0x7, 0x12c, 0x2, 0x2, 0xd01, 0xd02, 
       0x7, 0x18b, 0x2, 0x2, 0xd02, 0xd04, 0x9, 0x24, 0x2, 0x2, 0xd03, 0xd05, 
       0x7, 0x1af, 0x2, 0x2, 0xd04, 0xd03, 0x3, 0x2, 0x2, 0x2, 0xd04, 0xd05, 
       0x3, 0x2, 0x2, 0x2, 0xd05, 0xd06, 0x3, 0x2, 0x2, 0x2, 0xd06, 0xd08, 
       0x7, 0x12c, 0x2, 0x2, 0xd07, 0xcfc, 0x3, 0x2, 0x2, 0x2, 0xd07, 0xd01, 
       0x3, 0x2, 0x2, 0x2, 0xd08, 0x16b, 0x3, 0x2, 0x2, 0x2, 0xd09, 0xd0b, 
       0x9, 0x25, 0x2, 0x2, 0xd0a, 0xd09, 0x3, 0x2, 0x2, 0x2, 0xd0a, 0xd0b, 
       0x3, 0x2, 0x2, 0x2, 0xd0b, 0xd0c, 0x3, 0x2, 0x2, 0x2, 0xd0c, 0xd0f, 
       0x7, 0x12c, 0x2, 0x2, 0xd0d, 0xd0f, 0x7, 0x24b, 0x2, 0x2, 0xd0e, 
       0xd0a, 0x3, 0x2, 0x2, 0x2, 0xd0e, 0xd0d, 0x3, 0x2, 0x2, 0x2, 0xd0f, 
       0x16d, 0x3, 0x2, 0x2, 0x2, 0xd10, 0xd12, 0x9, 0x24, 0x2, 0x2, 0xd11, 
       0xd13, 0x7, 0x1af, 0x2, 0x2, 0xd12, 0xd11, 0x3, 0x2, 0x2, 0x2, 0xd12, 
       0xd13, 0x3, 0x2, 0x2, 0x2, 0xd13, 0xd14, 0x3, 0x2, 0x2, 0x2, 0xd14, 
       0xd15, 0x7, 0x12c, 0x2, 0x2, 0xd15, 0x16f, 0x3, 0x2, 0x2, 0x2, 0xd16, 
       0xd1d, 0x5, 0x172, 0xba, 0x2, 0xd17, 0xd1d, 0x5, 0x174, 0xbb, 0x2, 
       0xd18, 0xd1d, 0x5, 0x176, 0xbc, 0x2, 0xd19, 0xd1d, 0x5, 0x178, 0xbd, 
       0x2, 0xd1a, 0xd1b, 0x6, 0xb9, 0x39, 0x2, 0xd1b, 0xd1d, 0x5, 0x17a, 
       0xbe, 0x2, 0xd1c, 0xd16, 0x3, 0x2, 0x2, 0x2, 0xd1c, 0xd17, 0x3, 0x2, 
       0x2, 0x2, 0xd1c, 0xd18, 0x3, 0x2, 0x2, 0x2, 0xd1c, 0xd19, 0x3, 0x2, 
       0x2, 0x2, 0xd1c, 0xd1a, 0x3, 0x2, 0x2, 0x2, 0xd1d, 0x171, 0x3, 0x2, 
       0x2, 0x2, 0xd1e, 0xd20, 0x5, 0x440, 0x221, 0x2, 0xd1f, 0xd21, 0x5, 
       0x3fe, 0x200, 0x2, 0xd20, 0xd1f, 0x3, 0x2, 0x2, 0x2, 0xd20, 0xd21, 
       0x3, 0x2, 0x2, 0x2, 0xd21, 0xd23, 0x3, 0x2, 0x2, 0x2, 0xd22, 0xd24, 
       0x5, 0x18a, 0xc6, 0x2, 0xd23, 0xd22, 0x3, 0x2, 0x2, 0x2, 0xd23, 0xd24, 
       0x3, 0x2, 0x2, 0x2, 0xd24, 0xd26, 0x3, 0x2, 0x2, 0x2, 0xd25, 0xd27, 
       0x5, 0x18c, 0xc7, 0x2, 0xd26, 0xd25, 0x3, 0x2, 0x2, 0x2, 0xd26, 0xd27, 
       0x3, 0x2, 0x2, 0x2, 0xd27, 0x173, 0x3, 0x2, 0x2, 0x2, 0xd28, 0xd2b, 
       0x7, 0x23, 0x2, 0x2, 0xd29, 0xd2c, 0x5, 0x172, 0xba, 0x2, 0xd2a, 
       0xd2c, 0x5, 0x174, 0xbb, 0x2, 0xd2b, 0xd29, 0x3, 0x2, 0x2, 0x2, 0xd2b, 
       0xd2a, 0x3, 0x2, 0x2, 0x2, 0xd2c, 0xd2d, 0x3, 0x2, 0x2, 0x2, 0xd2d, 
       0xd2e, 0x7, 0x24, 0x2, 0x2, 0xd2e, 0x175, 0x3, 0x2, 0x2, 0x2, 0xd2f, 
       0xd31, 0x5, 0x11c, 0x8f, 0x2, 0xd30, 0xd32, 0x5, 0x18a, 0xc6, 0x2, 
       0xd31, 0xd30, 0x3, 0x2, 0x2, 0x2, 0xd31, 0xd32, 0x3, 0x2, 0x2, 0x2, 
       0xd32, 0xd35, 0x3, 0x2, 0x2, 0x2, 0xd33, 0xd34, 0x6, 0xbc, 0x3a, 
       0x2, 0xd34, 0xd36, 0x5, 0x406, 0x204, 0x2, 0xd35, 0xd33, 0x3, 0x2, 
       0x2, 0x2, 0xd35, 0xd36, 0x3, 0x2, 0x2, 0x2, 0xd36, 0xd41, 0x3, 0x2, 
       0x2, 0x2, 0xd37, 0xd38, 0x6, 0xbc, 0x3b, 0x2, 0xd38, 0xd39, 0x7, 
       0x2f7, 0x2, 0x2, 0xd39, 0xd3b, 0x5, 0x11c, 0x8f, 0x2, 0xd3a, 0xd3c, 
       0x5, 0x18a, 0xc6, 0x2, 0xd3b, 0xd3a, 0x3, 0x2, 0x2, 0x2, 0xd3b, 0xd3c, 
       0x3, 0x2, 0x2, 0x2, 0xd3c, 0xd3e, 0x3, 0x2, 0x2, 0x2, 0xd3d, 0xd3f, 
       0x5, 0x406, 0x204, 0x2, 0xd3e, 0xd3d, 0x3, 0x2, 0x2, 0x2, 0xd3e, 
       0xd3f, 0x3, 0x2, 0x2, 0x2, 0xd3f, 0xd41, 0x3, 0x2, 0x2, 0x2, 0xd40, 
       0xd2f, 0x3, 0x2, 0x2, 0x2, 0xd40, 0xd37, 0x3, 0x2, 0x2, 0x2, 0xd41, 
       0x177, 0x3, 0x2, 0x2, 0x2, 0xd42, 0xd45, 0x7, 0x23, 0x2, 0x2, 0xd43, 
       0xd46, 0x5, 0x152, 0xaa, 0x2, 0xd44, 0xd46, 0x5, 0x178, 0xbd, 0x2, 
       0xd45, 0xd43, 0x3, 0x2, 0x2, 0x2, 0xd45, 0xd44, 0x3, 0x2, 0x2, 0x2, 
       0xd46, 0xd47, 0x3, 0x2, 0x2, 0x2, 0xd47, 0xd48, 0x7, 0x24, 0x2, 0x2, 
       0xd48, 0x179, 0x3, 0x2, 0x2, 0x2, 0xd49, 0xd4a, 0x7, 0x2de, 0x2, 
       0x2, 0xd4a, 0xd4b, 0x7, 0x23, 0x2, 0x2, 0xd4b, 0xd4c, 0x5, 0x294, 
       0x14b, 0x2, 0xd4c, 0xd4d, 0x7, 0x20, 0x2, 0x2, 0xd4d, 0xd4e, 0x5, 
       0x474, 0x23b, 0x2, 0xd4e, 0xd4f, 0x5, 0x17c, 0xbf, 0x2, 0xd4f, 0xd51, 
       0x7, 0x24, 0x2, 0x2, 0xd50, 0xd52, 0x5, 0x18a, 0xc6, 0x2, 0xd51, 
       0xd50, 0x3, 0x2, 0x2, 0x2, 0xd51, 0xd52, 0x3, 0x2, 0x2, 0x2, 0xd52, 
       0x17b, 0x3, 0x2, 0x2, 0x2, 0xd53, 0xd54, 0x7, 0x78, 0x2, 0x2, 0xd54, 
       0xd55, 0x7, 0x23, 0x2, 0x2, 0xd55, 0xd5a, 0x5, 0x17e, 0xc0, 0x2, 
       0xd56, 0xd57, 0x7, 0x20, 0x2, 0x2, 0xd57, 0xd59, 0x5, 0x17e, 0xc0, 
       0x2, 0xd58, 0xd56, 0x3, 0x2, 0x2, 0x2, 0xd59, 0xd5c, 0x3, 0x2, 0x2, 
       0x2, 0xd5a, 0xd58, 0x3, 0x2, 0x2, 0x2, 0xd5a, 0xd5b, 0x3, 0x2, 0x2, 
       0x2, 0xd5b, 0xd5d, 0x3, 0x2, 0x2, 0x2, 0xd5c, 0xd5a, 0x3, 0x2, 0x2, 
       0x2, 0xd5d, 0xd5e, 0x7, 0x24, 0x2, 0x2, 0xd5e, 0x17d, 0x3, 0x2, 0x2, 
       0x2, 0xd5f, 0xd60, 0x5, 0x45a, 0x22e, 0x2, 0xd60, 0xd61, 0x7, 0xf1, 
       0x2, 0x2, 0xd61, 0xd62, 0x7, 0x2e0, 0x2, 0x2, 0xd62, 0xd77, 0x3, 
       0x2, 0x2, 0x2, 0xd63, 0xd64, 0x5, 0x45a, 0x22e, 0x2, 0xd64, 0xd67, 
       0x5, 0x384, 0x1c3, 0x2, 0xd65, 0xd66, 0x6, 0xc0, 0x3c, 0x2, 0xd66, 
       0xd68, 0x5, 0x3ce, 0x1e8, 0x2, 0xd67, 0xd65, 0x3, 0x2, 0x2, 0x2, 
       0xd67, 0xd68, 0x3, 0x2, 0x2, 0x2, 0xd68, 0xd6a, 0x3, 0x2, 0x2, 0x2, 
       0xd69, 0xd6b, 0x7, 0xdb, 0x2, 0x2, 0xd6a, 0xd69, 0x3, 0x2, 0x2, 0x2, 
       0xd6a, 0xd6b, 0x3, 0x2, 0x2, 0x2, 0xd6b, 0xd6c, 0x3, 0x2, 0x2, 0x2, 
       0xd6c, 0xd6d, 0x7, 0x2e1, 0x2, 0x2, 0xd6d, 0xd6f, 0x5, 0x474, 0x23b, 
       0x2, 0xd6e, 0xd70, 0x5, 0x180, 0xc1, 0x2, 0xd6f, 0xd6e, 0x3, 0x2, 
       0x2, 0x2, 0xd6f, 0xd70, 0x3, 0x2, 0x2, 0x2, 0xd70, 0xd77, 0x3, 0x2, 
       0x2, 0x2, 0xd71, 0xd72, 0x7, 0x2df, 0x2, 0x2, 0xd72, 0xd73, 0x7, 
       0x2e1, 0x2, 0x2, 0xd73, 0xd74, 0x5, 0x474, 0x23b, 0x2, 0xd74, 0xd75, 
       0x5, 0x17c, 0xbf, 0x2, 0xd75, 0xd77, 0x3, 0x2, 0x2, 0x2, 0xd76, 0xd5f, 
       0x3, 0x2, 0x2, 0x2, 0xd76, 0xd63, 0x3, 0x2, 0x2, 0x2, 0xd76, 0xd71, 
       0x3, 0x2, 0x2, 0x2, 0xd77, 0x17f, 0x3, 0x2, 0x2, 0x2, 0xd78, 0xd7a, 
       0x5, 0x182, 0xc2, 0x2, 0xd79, 0xd7b, 0x5, 0x184, 0xc3, 0x2, 0xd7a, 
       0xd79, 0x3, 0x2, 0x2, 0x2, 0xd7a, 0xd7b, 0x3, 0x2, 0x2, 0x2, 0xd7b, 
       0xd81, 0x3, 0x2, 0x2, 0x2, 0xd7c, 0xd7e, 0x5, 0x184, 0xc3, 0x2, 0xd7d, 
       0xd7f, 0x5, 0x182, 0xc2, 0x2, 0xd7e, 0xd7d, 0x3, 0x2, 0x2, 0x2, 0xd7e, 
       0xd7f, 0x3, 0x2, 0x2, 0x2, 0xd7f, 0xd81, 0x3, 0x2, 0x2, 0x2, 0xd80, 
       0xd78, 0x3, 0x2, 0x2, 0x2, 0xd80, 0xd7c, 0x3, 0x2, 0x2, 0x2, 0xd81, 
       0x181, 0x3, 0x2, 0x2, 0x2, 0xd82, 0xd83, 0x5, 0x186, 0xc4, 0x2, 0xd83, 
       0xd84, 0x7, 0x1a2, 0x2, 0x2, 0xd84, 0xd85, 0x7, 0x2dd, 0x2, 0x2, 
       0xd85, 0x183, 0x3, 0x2, 0x2, 0x2, 0xd86, 0xd87, 0x5, 0x186, 0xc4, 
       0x2, 0xd87, 0xd88, 0x7, 0x1a2, 0x2, 0x2, 0xd88, 0xd89, 0x7, 0xd2, 
       0x2, 0x2, 0xd89, 0x185, 0x3, 0x2, 0x2, 0x2, 0xd8a, 0xd8f, 0x7, 0xd2, 
       0x2, 0x2, 0xd8b, 0xd8f, 0x7, 0x19b, 0x2, 0x2, 0xd8c, 0xd8d, 0x7, 
       0xae, 0x2, 0x2, 0xd8d, 0xd8f, 0x5, 0x474, 0x23b, 0x2, 0xd8e, 0xd8a, 
       0x3, 0x2, 0x2, 0x2, 0xd8e, 0xd8b, 0x3, 0x2, 0x2, 0x2, 0xd8e, 0xd8c, 
       0x3, 0x2, 0x2, 0x2, 0xd8f, 0x187, 0x3, 0x2, 0x2, 0x2, 0xd90, 0xd91, 
       0x9, 0x26, 0x2, 0x2, 0xd91, 0x189, 0x3, 0x2, 0x2, 0x2, 0xd92, 0xd96, 
       0x7, 0x43, 0x2, 0x2, 0xd93, 0xd94, 0x6, 0xc6, 0x3d, 0x2, 0xd94, 0xd96, 
       0x7, 0x9, 0x2, 0x2, 0xd95, 0xd92, 0x3, 0x2, 0x2, 0x2, 0xd95, 0xd93, 
       0x3, 0x2, 0x2, 0x2, 0xd95, 0xd96, 0x3, 0x2, 0x2, 0x2, 0xd96, 0xd97, 
       0x3, 0x2, 0x2, 0x2, 0xd97, 0xd98, 0x5, 0x45a, 0x22e, 0x2, 0xd98, 
       0x18b, 0x3, 0x2, 0x2, 0x2, 0xd99, 0xd9e, 0x5, 0x18e, 0xc8, 0x2, 0xd9a, 
       0xd9b, 0x7, 0x20, 0x2, 0x2, 0xd9b, 0xd9d, 0x5, 0x18e, 0xc8, 0x2, 
       0xd9c, 0xd9a, 0x3, 0x2, 0x2, 0x2, 0xd9d, 0xda0, 0x3, 0x2, 0x2, 0x2, 
       0xd9e, 0xd9c, 0x3, 0x2, 0x2, 0x2, 0xd9e, 0xd9f, 0x3, 0x2, 0x2, 0x2, 
       0xd9f, 0x18d, 0x3, 0x2, 0x2, 0x2, 0xda0, 0xd9e, 0x3, 0x2, 0x2, 0x2, 
       0xda1, 0xda2, 0x5, 0x190, 0xc9, 0x2, 0xda2, 0xda4, 0x5, 0x192, 0xca, 
       0x2, 0xda3, 0xda5, 0x5, 0x196, 0xcc, 0x2, 0xda4, 0xda3, 0x3, 0x2, 
       0x2, 0x2, 0xda4, 0xda5, 0x3, 0x2, 0x2, 0x2, 0xda5, 0xda6, 0x3, 0x2, 
       0x2, 0x2, 0xda6, 0xda7, 0x7, 0x23, 0x2, 0x2, 0xda7, 0xda8, 0x5, 0x198, 
       0xcd, 0x2, 0xda8, 0xda9, 0x7, 0x24, 0x2, 0x2, 0xda9, 0xdb6, 0x3, 
       0x2, 0x2, 0x2, 0xdaa, 0xdab, 0x7, 0x28c, 0x2, 0x2, 0xdab, 0xdad, 
       0x5, 0x192, 0xca, 0x2, 0xdac, 0xdae, 0x5, 0x196, 0xcc, 0x2, 0xdad, 
       0xdac, 0x3, 0x2, 0x2, 0x2, 0xdad, 0xdae, 0x3, 0x2, 0x2, 0x2, 0xdae, 
       0xdaf, 0x3, 0x2, 0x2, 0x2, 0xdaf, 0xdb1, 0x7, 0x23, 0x2, 0x2, 0xdb0, 
       0xdb2, 0x5, 0x198, 0xcd, 0x2, 0xdb1, 0xdb0, 0x3, 0x2, 0x2, 0x2, 0xdb1, 
       0xdb2, 0x3, 0x2, 0x2, 0x2, 0xdb2, 0xdb3, 0x3, 0x2, 0x2, 0x2, 0xdb3, 
       0xdb4, 0x7, 0x24, 0x2, 0x2, 0xdb4, 0xdb6, 0x3, 0x2, 0x2, 0x2, 0xdb5, 
       0xda1, 0x3, 0x2, 0x2, 0x2, 0xdb5, 0xdaa, 0x3, 0x2, 0x2, 0x2, 0xdb6, 
       0x18f, 0x3, 0x2, 0x2, 0x2, 0xdb7, 0xdb8, 0x9, 0x27, 0x2, 0x2, 0xdb8, 
       0x191, 0x3, 0x2, 0x2, 0x2, 0xdb9, 0xdba, 0x9, 0x28, 0x2, 0x2, 0xdba, 
       0x193, 0x3, 0x2, 0x2, 0x2, 0xdbb, 0xdbc, 0x7, 0x1c8, 0x2, 0x2, 0xdbc, 
       0xdc2, 0x7, 0x130, 0x2, 0x2, 0xdbd, 0xdbf, 0x7, 0x281, 0x2, 0x2, 
       0xdbe, 0xdc0, 0x5, 0x192, 0xca, 0x2, 0xdbf, 0xdbe, 0x3, 0x2, 0x2, 
       0x2, 0xdbf, 0xdc0, 0x3, 0x2, 0x2, 0x2, 0xdc0, 0xdc2, 0x3, 0x2, 0x2, 
       0x2, 0xdc1, 0xdbb, 0x3, 0x2, 0x2, 0x2, 0xdc1, 0xdbd, 0x3, 0x2, 0x2, 
       0x2, 0xdc2, 0x195, 0x3, 0x2, 0x2, 0x2, 0xdc3, 0xdc9, 0x7, 0xf1, 0x2, 
       0x2, 0xdc4, 0xdca, 0x7, 0x12c, 0x2, 0x2, 0xdc5, 0xdc6, 0x7, 0x1ad, 
       0x2, 0x2, 0xdc6, 0xdca, 0x7, 0x5f, 0x2, 0x2, 0xdc7, 0xdc8, 0x7, 0x102, 
       0x2, 0x2, 0xdc8, 0xdca, 0x7, 0x5f, 0x2, 0x2, 0xdc9, 0xdc4, 0x3, 0x2, 
       0x2, 0x2, 0xdc9, 0xdc5, 0x3, 0x2, 0x2, 0x2, 0xdc9, 0xdc7, 0x3, 0x2, 
       0x2, 0x2, 0xdca, 0x197, 0x3, 0x2, 0x2, 0x2, 0xdcb, 0xdd0, 0x5, 0x19a, 
       0xce, 0x2, 0xdcc, 0xdcd, 0x7, 0x20, 0x2, 0x2, 0xdcd, 0xdcf, 0x5, 
       0x19a, 0xce, 0x2, 0xdce, 0xdcc, 0x3, 0x2, 0x2, 0x2, 0xdcf, 0xdd2, 
       0x3, 0x2, 0x2, 0x2, 0xdd0, 0xdce, 0x3, 0x2, 0x2, 0x2, 0xdd0, 0xdd1, 
       0x3, 0x2, 0x2, 0x2, 0xdd1, 0x199, 0x3, 0x2, 0x2, 0x2, 0xdd2, 0xdd0, 
       0x3, 0x2, 0x2, 0x2, 0xdd3, 0xdd6, 0x5, 0x45a, 0x22e, 0x2, 0xdd4, 
       0xdd6, 0x7, 0x1c8, 0x2, 0x2, 0xdd5, 0xdd3, 0x3, 0x2, 0x2, 0x2, 0xdd5, 
       0xdd4, 0x3, 0x2, 0x2, 0x2, 0xdd6, 0x19b, 0x3, 0x2, 0x2, 0x2, 0xdd7, 
       0xdd8, 0x6, 0xcf, 0x3e, 0x2, 0xdd8, 0xdda, 0x5, 0x144, 0xa3, 0x2, 
       0xdd9, 0xdd7, 0x3, 0x2, 0x2, 0x2, 0xdd9, 0xdda, 0x3, 0x2, 0x2, 0x2, 
       0xdda, 0xddb, 0x3, 0x2, 0x2, 0x2, 0xddb, 0xddd, 0x7, 0x286, 0x2, 
       0x2, 0xddc, 0xdde, 0x7, 0x14c, 0x2, 0x2, 0xddd, 0xddc, 0x3, 0x2, 
       0x2, 0x2, 0xddd, 0xdde, 0x3, 0x2, 0x2, 0x2, 0xdde, 0xde0, 0x3, 0x2, 
       0x2, 0x2, 0xddf, 0xde1, 0x7, 0x111, 0x2, 0x2, 0xde0, 0xddf, 0x3, 
       0x2, 0x2, 0x2, 0xde0, 0xde1, 0x3, 0x2, 0x2, 0x2, 0xde1, 0xde2, 0x3, 
       0x2, 0x2, 0x2, 0xde2, 0xde3, 0x5, 0x152, 0xaa, 0x2, 0xde3, 0xde4, 
       0x7, 0x21b, 0x2, 0x2, 0xde4, 0xde6, 0x5, 0x3d6, 0x1ec, 0x2, 0xde5, 
       0xde7, 0x5, 0x162, 0xb2, 0x2, 0xde6, 0xde5, 0x3, 0x2, 0x2, 0x2, 0xde6, 
       0xde7, 0x3, 0x2, 0x2, 0x2, 0xde7, 0xde9, 0x3, 0x2, 0x2, 0x2, 0xde8, 
       0xdea, 0x5, 0x14c, 0xa7, 0x2, 0xde9, 0xde8, 0x3, 0x2, 0x2, 0x2, 0xde9, 
       0xdea, 0x3, 0x2, 0x2, 0x2, 0xdea, 0xdec, 0x3, 0x2, 0x2, 0x2, 0xdeb, 
       0xded, 0x5, 0x122, 0x92, 0x2, 0xdec, 0xdeb, 0x3, 0x2, 0x2, 0x2, 0xdec, 
       0xded, 0x3, 0x2, 0x2, 0x2, 0xded, 0x19d, 0x3, 0x2, 0x2, 0x2, 0xdee, 
       0xdf3, 0x5, 0x1a0, 0xd1, 0x2, 0xdef, 0xdf3, 0x5, 0x1aa, 0xd6, 0x2, 
       0xdf0, 0xdf3, 0x5, 0x1ac, 0xd7, 0x2, 0xdf1, 0xdf3, 0x5, 0x1b2, 0xda, 
       0x2, 0xdf2, 0xdee, 0x3, 0x2, 0x2, 0x2, 0xdf2, 0xdef, 0x3, 0x2, 0x2, 
       0x2, 0xdf2, 0xdf0, 0x3, 0x2, 0x2, 0x2, 0xdf2, 0xdf1, 0x3, 0x2, 0x2, 
       0x2, 0xdf3, 0x19f, 0x3, 0x2, 0x2, 0x2, 0xdf4, 0xdf5, 0x7, 0x23f, 
       0x2, 0x2, 0xdf5, 0xdf9, 0x7, 0x270, 0x2, 0x2, 0xdf6, 0xdf8, 0x5, 
       0x1a4, 0xd3, 0x2, 0xdf7, 0xdf6, 0x3, 0x2, 0x2, 0x2, 0xdf8, 0xdfb, 
       0x3, 0x2, 0x2, 0x2, 0xdf9, 0xdf7, 0x3, 0x2, 0x2, 0x2, 0xdf9, 0xdfa, 
       0x3, 0x2, 0x2, 0x2, 0xdfa, 0xe0e, 0x3, 0x2, 0x2, 0x2, 0xdfb, 0xdf9, 
       0x3, 0x2, 0x2, 0x2, 0xdfc, 0xdfe, 0x7, 0x7e, 0x2, 0x2, 0xdfd, 0xdff, 
       0x7, 0x2a8, 0x2, 0x2, 0xdfe, 0xdfd, 0x3, 0x2, 0x2, 0x2, 0xdfe, 0xdff, 
       0x3, 0x2, 0x2, 0x2, 0xdff, 0xe05, 0x3, 0x2, 0x2, 0x2, 0xe00, 0xe02, 
       0x7, 0x41, 0x2, 0x2, 0xe01, 0xe03, 0x7, 0x198, 0x2, 0x2, 0xe02, 0xe01, 
       0x3, 0x2, 0x2, 0x2, 0xe02, 0xe03, 0x3, 0x2, 0x2, 0x2, 0xe03, 0xe04, 
       0x3, 0x2, 0x2, 0x2, 0xe04, 0xe06, 0x7, 0x68, 0x2, 0x2, 0xe05, 0xe00, 
       0x3, 0x2, 0x2, 0x2, 0xe05, 0xe06, 0x3, 0x2, 0x2, 0x2, 0xe06, 0xe0b, 
       0x3, 0x2, 0x2, 0x2, 0xe07, 0xe09, 0x7, 0x198, 0x2, 0x2, 0xe08, 0xe07, 
       0x3, 0x2, 0x2, 0x2, 0xe08, 0xe09, 0x3, 0x2, 0x2, 0x2, 0xe09, 0xe0a, 
       0x3, 0x2, 0x2, 0x2, 0xe0a, 0xe0c, 0x7, 0x1e6, 0x2, 0x2, 0xe0b, 0xe08, 
       0x3, 0x2, 0x2, 0x2, 0xe0b, 0xe0c, 0x3, 0x2, 0x2, 0x2, 0xe0c, 0xe0e, 
       0x3, 0x2, 0x2, 0x2, 0xe0d, 0xdf4, 0x3, 0x2, 0x2, 0x2, 0xe0d, 0xdfc, 
       0x3, 0x2, 0x2, 0x2, 0xe0e, 0x1a1, 0x3, 0x2, 0x2, 0x2, 0xe0f, 0xe11, 
       0x7, 0x4f, 0x2, 0x2, 0xe10, 0xe12, 0x7, 0x2a8, 0x2, 0x2, 0xe11, 0xe10, 
       0x3, 0x2, 0x2, 0x2, 0xe11, 0xe12, 0x3, 0x2, 0x2, 0x2, 0xe12, 0x1a3, 
       0x3, 0x2, 0x2, 0x2, 0xe13, 0xe14, 0x7, 0x2a4, 0x2, 0x2, 0xe14, 0xe15, 
       0x7, 0x86, 0x2, 0x2, 0xe15, 0xe1a, 0x7, 0x226, 0x2, 0x2, 0xe16, 0xe17, 
       0x6, 0xd3, 0x3f, 0x2, 0xe17, 0xe18, 0x7, 0x1d7, 0x2, 0x2, 0xe18, 
       0xe1a, 0x9, 0x29, 0x2, 0x2, 0xe19, 0xe13, 0x3, 0x2, 0x2, 0x2, 0xe19, 
       0xe16, 0x3, 0x2, 0x2, 0x2, 0xe1a, 0x1a5, 0x3, 0x2, 0x2, 0x2, 0xe1b, 
       0xe1c, 0x7, 0x129, 0x2, 0x2, 0xe1c, 0xe1d, 0x7, 0x139, 0x2, 0x2, 
       0xe1d, 0xe22, 0x5, 0x1a8, 0xd5, 0x2, 0xe1e, 0xe1f, 0x6, 0xd4, 0x40, 
       0x2, 0xe1f, 0xe20, 0x7, 0x1d7, 0x2, 0x2, 0xe20, 0xe22, 0x9, 0x29, 
       0x2, 0x2, 0xe21, 0xe1b, 0x3, 0x2, 0x2, 0x2, 0xe21, 0xe1e, 0x3, 0x2, 
       0x2, 0x2, 0xe22, 0x1a7, 0x3, 0x2, 0x2, 0x2, 0xe23, 0xe24, 0x7, 0x1ec, 
       0x2, 0x2, 0xe24, 0xe29, 0x7, 0x1d7, 0x2, 0x2, 0xe25, 0xe26, 0x7, 
       0x1d7, 0x2, 0x2, 0xe26, 0xe29, 0x9, 0x2a, 0x2, 0x2, 0xe27, 0xe29, 
       0x7, 0x215, 0x2, 0x2, 0xe28, 0xe23, 0x3, 0x2, 0x2, 0x2, 0xe28, 0xe25, 
       0x3, 0x2, 0x2, 0x2, 0xe28, 0xe27, 0x3, 0x2, 0x2, 0x2, 0xe29, 0x1a9, 
       0x3, 0x2, 0x2, 0x2, 0xe2a, 0xe2b, 0x7, 0x20c, 0x2, 0x2, 0xe2b, 0xe48, 
       0x5, 0x45a, 0x22e, 0x2, 0xe2c, 0xe2e, 0x7, 0x203, 0x2, 0x2, 0xe2d, 
       0xe2f, 0x7, 0x2a8, 0x2, 0x2, 0xe2e, 0xe2d, 0x3, 0x2, 0x2, 0x2, 0xe2e, 
       0xe2f, 0x3, 0x2, 0x2, 0x2, 0xe2f, 0xe42, 0x3, 0x2, 0x2, 0x2, 0xe30, 
       0xe32, 0x7, 0x26e, 0x2, 0x2, 0xe31, 0xe33, 0x7, 0x20c, 0x2, 0x2, 
       0xe32, 0xe31, 0x3, 0x2, 0x2, 0x2, 0xe32, 0xe33, 0x3, 0x2, 0x2, 0x2, 
       0xe33, 0xe34, 0x3, 0x2, 0x2, 0x2, 0xe34, 0xe43, 0x5, 0x45a, 0x22e, 
       0x2, 0xe35, 0xe37, 0x7, 0x41, 0x2, 0x2, 0xe36, 0xe38, 0x7, 0x198, 
       0x2, 0x2, 0xe37, 0xe36, 0x3, 0x2, 0x2, 0x2, 0xe37, 0xe38, 0x3, 0x2, 
       0x2, 0x2, 0xe38, 0xe39, 0x3, 0x2, 0x2, 0x2, 0xe39, 0xe3b, 0x7, 0x68, 
       0x2, 0x2, 0xe3a, 0xe35, 0x3, 0x2, 0x2, 0x2, 0xe3a, 0xe3b, 0x3, 0x2, 
       0x2, 0x2, 0xe3b, 0xe40, 0x3, 0x2, 0x2, 0x2, 0xe3c, 0xe3e, 0x7, 0x198, 
       0x2, 0x2, 0xe3d, 0xe3c, 0x3, 0x2, 0x2, 0x2, 0xe3d, 0xe3e, 0x3, 0x2, 
       0x2, 0x2, 0xe3e, 0xe3f, 0x3, 0x2, 0x2, 0x2, 0xe3f, 0xe41, 0x7, 0x1e6, 
       0x2, 0x2, 0xe40, 0xe3d, 0x3, 0x2, 0x2, 0x2, 0xe40, 0xe41, 0x3, 0x2, 
       0x2, 0x2, 0xe41, 0xe43, 0x3, 0x2, 0x2, 0x2, 0xe42, 0xe30, 0x3, 0x2, 
       0x2, 0x2, 0xe42, 0xe3a, 0x3, 0x2, 0x2, 0x2, 0xe43, 0xe48, 0x3, 0x2, 
       0x2, 0x2, 0xe44, 0xe45, 0x7, 0x1e6, 0x2, 0x2, 0xe45, 0xe46, 0x7, 
       0x20c, 0x2, 0x2, 0xe46, 0xe48, 0x5, 0x45a, 0x22e, 0x2, 0xe47, 0xe2a, 
       0x3, 0x2, 0x2, 0x2, 0xe47, 0xe2c, 0x3, 0x2, 0x2, 0x2, 0xe47, 0xe44, 
       0x3, 0x2, 0x2, 0x2, 0xe48, 0x1ab, 0x3, 0x2, 0x2, 0x2, 0xe49, 0xe4a, 
       0x7, 0x144, 0x2, 0x2, 0xe4a, 0xe4b, 0x9, 0x14, 0x2, 0x2, 0xe4b, 0xe50, 
       0x5, 0x1ae, 0xd8, 0x2, 0xe4c, 0xe4d, 0x7, 0x20, 0x2, 0x2, 0xe4d, 
       0xe4f, 0x5, 0x1ae, 0xd8, 0x2, 0xe4e, 0xe4c, 0x3, 0x2, 0x2, 0x2, 0xe4f, 
       0xe52, 0x3, 0x2, 0x2, 0x2, 0xe50, 0xe4e, 0x3, 0x2, 0x2, 0x2, 0xe50, 
       0xe51, 0x3, 0x2, 0x2, 0x2, 0xe51, 0xe60, 0x3, 0x2, 0x2, 0x2, 0xe52, 
       0xe50, 0x3, 0x2, 0x2, 0x2, 0xe53, 0xe54, 0x6, 0xd7, 0x41, 0x2, 0xe54, 
       0xe55, 0x7, 0x144, 0x2, 0x2, 0xe55, 0xe56, 0x7, 0x11d, 0x2, 0x2, 
       0xe56, 0xe57, 0x7, 0xf1, 0x2, 0x2, 0xe57, 0xe60, 0x7, 0x4d, 0x2, 
       0x2, 0xe58, 0xe5d, 0x7, 0x283, 0x2, 0x2, 0xe59, 0xe5e, 0x7, 0x25b, 
       0x2, 0x2, 0xe5a, 0xe5e, 0x7, 0x25e, 0x2, 0x2, 0xe5b, 0xe5c, 0x6, 
       0xd7, 0x42, 0x2, 0xe5c, 0xe5e, 0x7, 0x11d, 0x2, 0x2, 0xe5d, 0xe59, 
       0x3, 0x2, 0x2, 0x2, 0xe5d, 0xe5a, 0x3, 0x2, 0x2, 0x2, 0xe5d, 0xe5b, 
       0x3, 0x2, 0x2, 0x2, 0xe5e, 0xe60, 0x3, 0x2, 0x2, 0x2, 0xe5f, 0xe49, 
       0x3, 0x2, 0x2, 0x2, 0xe5f, 0xe53, 0x3, 0x2, 0x2, 0x2, 0xe5f, 0xe58, 
       0x3, 0x2, 0x2, 0x2, 0xe60, 0x1ad, 0x3, 0x2, 0x2, 0x2, 0xe61, 0xe63, 
       0x5, 0x440, 0x221, 0x2, 0xe62, 0xe64, 0x5, 0x18a, 0xc6, 0x2, 0xe63, 
       0xe62, 0x3, 0x2, 0x2, 0x2, 0xe63, 0xe64, 0x3, 0x2, 0x2, 0x2, 0xe64, 
       0xe65, 0x3, 0x2, 0x2, 0x2, 0xe65, 0xe66, 0x5, 0x1b0, 0xd9, 0x2, 0xe66, 
       0x1af, 0x3, 0x2, 0x2, 0x2, 0xe67, 0xe69, 0x7, 0x1d7, 0x2, 0x2, 0xe68, 
       0xe6a, 0x7, 0x141, 0x2, 0x2, 0xe69, 0xe68, 0x3, 0x2, 0x2, 0x2, 0xe69, 
       0xe6a, 0x3, 0x2, 0x2, 0x2, 0xe6a, 0xe70, 0x3, 0x2, 0x2, 0x2, 0xe6b, 
       0xe6d, 0x7, 0x14c, 0x2, 0x2, 0xe6c, 0xe6b, 0x3, 0x2, 0x2, 0x2, 0xe6c, 
       0xe6d, 0x3, 0x2, 0x2, 0x2, 0xe6d, 0xe6e, 0x3, 0x2, 0x2, 0x2, 0xe6e, 
       0xe70, 0x7, 0x2aa, 0x2, 0x2, 0xe6f, 0xe67, 0x3, 0x2, 0x2, 0x2, 0xe6f, 
       0xe6c, 0x3, 0x2, 0x2, 0x2, 0xe70, 0x1b1, 0x3, 0x2, 0x2, 0x2, 0xe71, 
       0xe8c, 0x7, 0x2ac, 0x2, 0x2, 0xe72, 0xe73, 0x9, 0x2b, 0x2, 0x2, 0xe73, 
       0xe75, 0x5, 0x1b6, 0xdc, 0x2, 0xe74, 0xe76, 0x9, 0x2c, 0x2, 0x2, 
       0xe75, 0xe74, 0x3, 0x2, 0x2, 0x2, 0xe75, 0xe76, 0x3, 0x2, 0x2, 0x2, 
       0xe76, 0xe8d, 0x3, 0x2, 0x2, 0x2, 0xe77, 0xe78, 0x7, 0xcc, 0x2, 0x2, 
       0xe78, 0xe7e, 0x5, 0x1b6, 0xdc, 0x2, 0xe79, 0xe7c, 0x7, 0x256, 0x2, 
       0x2, 0xe7a, 0xe7b, 0x7, 0xf1, 0x2, 0x2, 0xe7b, 0xe7d, 0x7, 0x178, 
       0x2, 0x2, 0xe7c, 0xe7a, 0x3, 0x2, 0x2, 0x2, 0xe7c, 0xe7d, 0x3, 0x2, 
       0x2, 0x2, 0xe7d, 0xe7f, 0x3, 0x2, 0x2, 0x2, 0xe7e, 0xe79, 0x3, 0x2, 
       0x2, 0x2, 0xe7e, 0xe7f, 0x3, 0x2, 0x2, 0x2, 0xe7f, 0xe8d, 0x3, 0x2, 
       0x2, 0x2, 0xe80, 0xe81, 0x7, 0x1c5, 0x2, 0x2, 0xe81, 0xe8d, 0x5, 
       0x1b6, 0xdc, 0x2, 0xe82, 0xe83, 0x7, 0x7e, 0x2, 0x2, 0xe83, 0xe86, 
       0x5, 0x1b6, 0xdc, 0x2, 0xe84, 0xe85, 0x7, 0x1a4, 0x2, 0x2, 0xe85, 
       0xe87, 0x7, 0x1bb, 0x2, 0x2, 0xe86, 0xe84, 0x3, 0x2, 0x2, 0x2, 0xe86, 
       0xe87, 0x3, 0x2, 0x2, 0x2, 0xe87, 0xe8d, 0x3, 0x2, 0x2, 0x2, 0xe88, 
       0xe89, 0x7, 0x203, 0x2, 0x2, 0xe89, 0xe8d, 0x5, 0x1b6, 0xdc, 0x2, 
       0xe8a, 0xe8b, 0x7, 0x1db, 0x2, 0x2, 0xe8b, 0xe8d, 0x5, 0x1b4, 0xdb, 
       0x2, 0xe8c, 0xe72, 0x3, 0x2, 0x2, 0x2, 0xe8c, 0xe77, 0x3, 0x2, 0x2, 
       0x2, 0xe8c, 0xe80, 0x3, 0x2, 0x2, 0x2, 0xe8c, 0xe82, 0x3, 0x2, 0x2, 
       0x2, 0xe8c, 0xe88, 0x3, 0x2, 0x2, 0x2, 0xe8c, 0xe8a, 0x3, 0x2, 0x2, 
       0x2, 0xe8d, 0x1b3, 0x3, 0x2, 0x2, 0x2, 0xe8e, 0xe91, 0x6, 0xdb, 0x43, 
       0x2, 0xe8f, 0xe90, 0x7, 0x8f, 0x2, 0x2, 0xe90, 0xe92, 0x7, 0x2ad, 
       0x2, 0x2, 0xe91, 0xe8f, 0x3, 0x2, 0x2, 0x2, 0xe91, 0xe92, 0x3, 0x2, 
       0x2, 0x2, 0xe92, 0xe95, 0x3, 0x2, 0x2, 0x2, 0xe93, 0xe95, 0x3, 0x2, 
       0x2, 0x2, 0xe94, 0xe8e, 0x3, 0x2, 0x2, 0x2, 0xe94, 0xe93, 0x3, 0x2, 
       0x2, 0x2, 0xe95, 0x1b5, 0x3, 0x2, 0x2, 0x2, 0xe96, 0xe9d, 0x5, 0x476, 
       0x23c, 0x2, 0xe97, 0xe98, 0x7, 0x20, 0x2, 0x2, 0xe98, 0xe9b, 0x5, 
       0x476, 0x23c, 0x2, 0xe99, 0xe9a, 0x7, 0x20, 0x2, 0x2, 0xe9a, 0xe9c, 
       0x5, 0x466, 0x234, 0x2, 0xe9b, 0xe99, 0x3, 0x2, 0x2, 0x2, 0xe9b, 
       0xe9c, 0x3, 0x2, 0x2, 0x2, 0xe9c, 0xe9e, 0x3, 0x2, 0x2, 0x2, 0xe9d, 
       0xe97, 0x3, 0x2, 0x2, 0x2, 0xe9d, 0xe9e, 0x3, 0x2, 0x2, 0x2, 0xe9e, 
       0x1b7, 0x3, 0x2, 0x2, 0x2, 0xe9f, 0xea0, 0x7, 0x1d0, 0x2, 0x2, 0xea0, 
       0xea1, 0x9, 0x2d, 0x2, 0x2, 0xea1, 0xea6, 0x7, 0x146, 0x2, 0x2, 0xea2, 
       0xea3, 0x7, 0x26e, 0x2, 0x2, 0xea3, 0xea7, 0x5, 0x47a, 0x23e, 0x2, 
       0xea4, 0xea5, 0x7, 0x4e, 0x2, 0x2, 0xea5, 0xea7, 0x5, 0x294, 0x14b, 
       0x2, 0xea6, 0xea2, 0x3, 0x2, 0x2, 0x2, 0xea6, 0xea4, 0x3, 0x2, 0x2, 
       0x2, 0xea7, 0xec1, 0x3, 0x2, 0x2, 0x2, 0xea8, 0xec1, 0x5, 0x1c0, 
       0xe1, 0x2, 0xea9, 0xeaa, 0x7, 0x1f8, 0x2, 0x2, 0xeaa, 0xeaf, 0x5, 
       0x1ba, 0xde, 0x2, 0xeab, 0xeac, 0x7, 0x20, 0x2, 0x2, 0xeac, 0xeae, 
       0x5, 0x1ba, 0xde, 0x2, 0xead, 0xeab, 0x3, 0x2, 0x2, 0x2, 0xeae, 0xeb1, 
       0x3, 0x2, 0x2, 0x2, 0xeaf, 0xead, 0x3, 0x2, 0x2, 0x2, 0xeaf, 0xeb0, 
       0x3, 0x2, 0x2, 0x2, 0xeb0, 0xec1, 0x3, 0x2, 0x2, 0x2, 0xeb1, 0xeaf, 
       0x3, 0x2, 0x2, 0x2, 0xeb2, 0xeb3, 0x6, 0xdd, 0x44, 0x2, 0xeb3, 0xeb4, 
       0x7, 0x1f8, 0x2, 0x2, 0xeb4, 0xeb8, 0x7, 0x2b3, 0x2, 0x2, 0xeb5, 
       0xeb6, 0x5, 0x3c6, 0x1e4, 0x2, 0xeb6, 0xeb7, 0x5, 0x45a, 0x22e, 0x2, 
       0xeb7, 0xeb9, 0x3, 0x2, 0x2, 0x2, 0xeb8, 0xeb5, 0x3, 0x2, 0x2, 0x2, 
       0xeb8, 0xeb9, 0x3, 0x2, 0x2, 0x2, 0xeb9, 0xec1, 0x3, 0x2, 0x2, 0x2, 
       0xeba, 0xec1, 0x5, 0x1d8, 0xed, 0x2, 0xebb, 0xebc, 0x6, 0xdd, 0x45, 
       0x2, 0xebc, 0xec1, 0x5, 0x1ca, 0xe6, 0x2, 0xebd, 0xec1, 0x5, 0x1be, 
       0xe0, 0x2, 0xebe, 0xebf, 0x6, 0xdd, 0x46, 0x2, 0xebf, 0xec1, 0x5, 
       0x1e2, 0xf2, 0x2, 0xec0, 0xe9f, 0x3, 0x2, 0x2, 0x2, 0xec0, 0xea8, 
       0x3, 0x2, 0x2, 0x2, 0xec0, 0xea9, 0x3, 0x2, 0x2, 0x2, 0xec0, 0xeb2, 
       0x3, 0x2, 0x2, 0x2, 0xec0, 0xeba, 0x3, 0x2, 0x2, 0x2, 0xec0, 0xebb, 
       0x3, 0x2, 0x2, 0x2, 0xec0, 0xebd, 0x3, 0x2, 0x2, 0x2, 0xec0, 0xebe, 
       0x3, 0x2, 0x2, 0x2, 0xec1, 0x1b9, 0x3, 0x2, 0x2, 0x2, 0xec2, 0xec4, 
       0x7, 0x161, 0x2, 0x2, 0xec3, 0xec5, 0x5, 0x1bc, 0xdf, 0x2, 0xec4, 
       0xec3, 0x3, 0x2, 0x2, 0x2, 0xec4, 0xec5, 0x3, 0x2, 0x2, 0x2, 0xec5, 
       0xed1, 0x3, 0x2, 0x2, 0x2, 0xec6, 0xec7, 0x6, 0xde, 0x47, 0x2, 0xec7, 
       0xec8, 0x7, 0x1d2, 0x2, 0x2, 0xec8, 0xed1, 0x7, 0x61, 0x2, 0x2, 0xec9, 
       0xecb, 0x7, 0x223, 0x2, 0x2, 0xeca, 0xecc, 0x7, 0x3c, 0x2, 0x2, 0xecb, 
       0xeca, 0x3, 0x2, 0x2, 0x2, 0xecb, 0xecc, 0x3, 0x2, 0x2, 0x2, 0xecc, 
       0xece, 0x3, 0x2, 0x2, 0x2, 0xecd, 0xecf, 0x5, 0x2fe, 0x180, 0x2, 
       0xece, 0xecd, 0x3, 0x2, 0x2, 0x2, 0xece, 0xecf, 0x3, 0x2, 0x2, 0x2, 
       0xecf, 0xed1, 0x3, 0x2, 0x2, 0x2, 0xed0, 0xec2, 0x3, 0x2, 0x2, 0x2, 
       0xed0, 0xec6, 0x3, 0x2, 0x2, 0x2, 0xed0, 0xec9, 0x3, 0x2, 0x2, 0x2, 
       0xed1, 0x1bb, 0x3, 0x2, 0x2, 0x2, 0xed2, 0xed3, 0x6, 0xdf, 0x48, 
       0x2, 0xed3, 0xed8, 0x7, 0x26e, 0x2, 0x2, 0xed4, 0xed5, 0x6, 0xdf, 
       0x49, 0x2, 0xed5, 0xed9, 0x5, 0x468, 0x235, 0x2, 0xed6, 0xed7, 0x6, 
       0xdf, 0x4a, 0x2, 0xed7, 0xed9, 0x5, 0x46c, 0x237, 0x2, 0xed8, 0xed4, 
       0x3, 0x2, 0x2, 0x2, 0xed8, 0xed6, 0x3, 0x2, 0x2, 0x2, 0xed9, 0x1bd, 
       0x3, 0x2, 0x2, 0x2, 0xeda, 0xede, 0x7, 0x140, 0x2, 0x2, 0xedb, 0xedf, 
       0x7, 0xa0, 0x2, 0x2, 0xedc, 0xedd, 0x7, 0x25e, 0x2, 0x2, 0xedd, 0xedf, 
       0x5, 0x440, 0x221, 0x2, 0xede, 0xedb, 0x3, 0x2, 0x2, 0x2, 0xede, 
       0xedc, 0x3, 0x2, 0x2, 0x2, 0xedf, 0xee0, 0x3, 0x2, 0x2, 0x2, 0xee0, 
       0xee1, 0x7, 0xf4, 0x2, 0x2, 0xee1, 0xee2, 0x7, 0x161, 0x2, 0x2, 0xee2, 
       0x1bf, 0x3, 0x2, 0x2, 0x2, 0xee3, 0xee4, 0x7, 0x69, 0x2, 0x2, 0xee4, 
       0xee5, 0x7, 0x161, 0x2, 0x2, 0xee5, 0xee6, 0x7, 0x26e, 0x2, 0x2, 
       0xee6, 0xee8, 0x5, 0x1c2, 0xe2, 0x2, 0xee7, 0xee9, 0x5, 0x2fe, 0x180, 
       0x2, 0xee8, 0xee7, 0x3, 0x2, 0x2, 0x2, 0xee8, 0xee9, 0x3, 0x2, 0x2, 
       0x2, 0xee9, 0x1c1, 0x3, 0x2, 0x2, 0x2, 0xeea, 0xeef, 0x5, 0x1c4, 
       0xe3, 0x2, 0xeeb, 0xeec, 0x7, 0x20, 0x2, 0x2, 0xeec, 0xeee, 0x5, 
       0x1c4, 0xe3, 0x2, 0xeed, 0xeeb, 0x3, 0x2, 0x2, 0x2, 0xeee, 0xef1, 
       0x3, 0x2, 0x2, 0x2, 0xeef, 0xeed, 0x3, 0x2, 0x2, 0x2, 0xeef, 0xef0, 
       0x3, 0x2, 0x2, 0x2, 0xef0, 0x1c3, 0x3, 0x2, 0x2, 0x2, 0xef1, 0xeef, 
       0x3, 0x2, 0x2, 0x2, 0xef2, 0xef3, 0x7, 0x151, 0x2, 0x2, 0xef3, 0xef4, 
       0x7, 0x9, 0x2, 0x2, 0xef4, 0xf3c, 0x5, 0x47c, 0x23f, 0x2, 0xef5, 
       0xef6, 0x7, 0x2fa, 0x2, 0x2, 0xef6, 0xef7, 0x7, 0x9, 0x2, 0x2, 0xef7, 
       0xf3c, 0x5, 0x47c, 0x23f, 0x2, 0xef8, 0xef9, 0x7, 0x14e, 0x2, 0x2, 
       0xef9, 0xefa, 0x7, 0x9, 0x2, 0x2, 0xefa, 0xf3c, 0x5, 0x47c, 0x23f, 
       0x2, 0xefb, 0xefc, 0x7, 0x163, 0x2, 0x2, 0xefc, 0xefd, 0x7, 0x9, 
       0x2, 0x2, 0xefd, 0xf3c, 0x5, 0x47c, 0x23f, 0x2, 0xefe, 0xeff, 0x7, 
       0x154, 0x2, 0x2, 0xeff, 0xf00, 0x7, 0x9, 0x2, 0x2, 0xf00, 0xf3c, 
       0x5, 0x47c, 0x23f, 0x2, 0xf01, 0xf02, 0x7, 0x155, 0x2, 0x2, 0xf02, 
       0xf03, 0x7, 0x9, 0x2, 0x2, 0xf03, 0xf3c, 0x5, 0x466, 0x234, 0x2, 
       0xf04, 0xf05, 0x7, 0x14f, 0x2, 0x2, 0xf05, 0xf06, 0x7, 0x9, 0x2, 
       0x2, 0xf06, 0xf3c, 0x5, 0x466, 0x234, 0x2, 0xf07, 0xf08, 0x7, 0x156, 
       0x2, 0x2, 0xf08, 0xf09, 0x7, 0x9, 0x2, 0x2, 0xf09, 0xf3c, 0x5, 0x466, 
       0x234, 0x2, 0xf0a, 0xf0b, 0x7, 0x150, 0x2, 0x2, 0xf0b, 0xf0c, 0x7, 
       0x9, 0x2, 0x2, 0xf0c, 0xf3c, 0x5, 0x466, 0x234, 0x2, 0xf0d, 0xf0e, 
       0x7, 0x15f, 0x2, 0x2, 0xf0e, 0xf0f, 0x7, 0x9, 0x2, 0x2, 0xf0f, 0xf3c, 
       0x5, 0x466, 0x234, 0x2, 0xf10, 0xf11, 0x7, 0x159, 0x2, 0x2, 0xf11, 
       0xf12, 0x7, 0x9, 0x2, 0x2, 0xf12, 0xf3c, 0x5, 0x47c, 0x23f, 0x2, 
       0xf13, 0xf14, 0x7, 0x162, 0x2, 0x2, 0xf14, 0xf15, 0x7, 0x9, 0x2, 
       0x2, 0xf15, 0xf3c, 0x5, 0x47c, 0x23f, 0x2, 0xf16, 0xf17, 0x7, 0x158, 
       0x2, 0x2, 0xf17, 0xf18, 0x7, 0x9, 0x2, 0x2, 0xf18, 0xf3c, 0x5, 0x47c, 
       0x23f, 0x2, 0xf19, 0xf1a, 0x7, 0x15a, 0x2, 0x2, 0xf1a, 0xf1b, 0x7, 
       0x9, 0x2, 0x2, 0xf1b, 0xf3c, 0x5, 0x47c, 0x23f, 0x2, 0xf1c, 0xf1d, 
       0x7, 0x15b, 0x2, 0x2, 0xf1d, 0xf1e, 0x7, 0x9, 0x2, 0x2, 0xf1e, 0xf3c, 
       0x5, 0x47c, 0x23f, 0x2, 0xf1f, 0xf20, 0x7, 0x15e, 0x2, 0x2, 0xf20, 
       0xf21, 0x7, 0x9, 0x2, 0x2, 0xf21, 0xf3c, 0x5, 0x47c, 0x23f, 0x2, 
       0xf22, 0xf23, 0x7, 0x160, 0x2, 0x2, 0xf23, 0xf24, 0x7, 0x9, 0x2, 
       0x2, 0xf24, 0xf3c, 0x5, 0x466, 
  };
  static uint16_t serializedATNSegment2[] = {
    0x234, 0x2, 0xf25, 0xf26, 0x7, 0x15c, 0x2, 0x2, 0xf26, 0xf27, 0x7, 0x9, 
       0x2, 0x2, 0xf27, 0xf3c, 0x5, 0x47a, 0x23e, 0x2, 0xf28, 0xf29, 0x7, 
       0x15d, 0x2, 0x2, 0xf29, 0xf2a, 0x7, 0x9, 0x2, 0x2, 0xf2a, 0xf3c, 
       0x5, 0x47c, 0x23f, 0x2, 0xf2b, 0xf2c, 0x7, 0x2e9, 0x2, 0x2, 0xf2c, 
       0xf2d, 0x7, 0x9, 0x2, 0x2, 0xf2d, 0xf3c, 0x5, 0x47c, 0x23f, 0x2, 
       0xf2e, 0xf2f, 0x7, 0x2ea, 0x2, 0x2, 0xf2f, 0xf30, 0x7, 0x9, 0x2, 
       0x2, 0xf30, 0xf3c, 0x5, 0x466, 0x234, 0x2, 0xf31, 0xf32, 0x7, 0x164, 
       0x2, 0x2, 0xf32, 0xf33, 0x7, 0x9, 0x2, 0x2, 0xf33, 0xf3c, 0x5, 0x466, 
       0x234, 0x2, 0xf34, 0xf35, 0x7, 0x112, 0x2, 0x2, 0xf35, 0xf36, 0x7, 
       0x9, 0x2, 0x2, 0xf36, 0xf3c, 0x5, 0x1c8, 0xe5, 0x2, 0xf37, 0xf38, 
       0x7, 0x14d, 0x2, 0x2, 0xf38, 0xf39, 0x7, 0x9, 0x2, 0x2, 0xf39, 0xf3c, 
       0x5, 0x466, 0x234, 0x2, 0xf3a, 0xf3c, 0x5, 0x1c6, 0xe4, 0x2, 0xf3b, 
       0xef2, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xef5, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xef8, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xefb, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xefe, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf01, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf04, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf07, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf0a, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf0d, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf10, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf13, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf16, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf19, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf1c, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf1f, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf22, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf25, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf28, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf2b, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf2e, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf31, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf34, 0x3, 0x2, 0x2, 0x2, 0xf3b, 0xf37, 0x3, 0x2, 0x2, 0x2, 0xf3b, 
       0xf3a, 0x3, 0x2, 0x2, 0x2, 0xf3c, 0x1c5, 0x3, 0x2, 0x2, 0x2, 0xf3d, 
       0xf3e, 0x7, 0x152, 0x2, 0x2, 0xf3e, 0xf3f, 0x7, 0x9, 0x2, 0x2, 0xf3f, 
       0xf4a, 0x5, 0x47c, 0x23f, 0x2, 0xf40, 0xf41, 0x7, 0x153, 0x2, 0x2, 
       0xf41, 0xf42, 0x7, 0x9, 0x2, 0x2, 0xf42, 0xf4a, 0x5, 0x46a, 0x236, 
       0x2, 0xf43, 0xf44, 0x7, 0x1e3, 0x2, 0x2, 0xf44, 0xf45, 0x7, 0x9, 
       0x2, 0x2, 0xf45, 0xf4a, 0x5, 0x47c, 0x23f, 0x2, 0xf46, 0xf47, 0x7, 
       0x1e4, 0x2, 0x2, 0xf47, 0xf48, 0x7, 0x9, 0x2, 0x2, 0xf48, 0xf4a, 
       0x5, 0x466, 0x234, 0x2, 0xf49, 0xf3d, 0x3, 0x2, 0x2, 0x2, 0xf49, 
       0xf40, 0x3, 0x2, 0x2, 0x2, 0xf49, 0xf43, 0x3, 0x2, 0x2, 0x2, 0xf49, 
       0xf46, 0x3, 0x2, 0x2, 0x2, 0xf4a, 0x1c7, 0x3, 0x2, 0x2, 0x2, 0xf4b, 
       0xf54, 0x7, 0x23, 0x2, 0x2, 0xf4c, 0xf51, 0x5, 0x466, 0x234, 0x2, 
       0xf4d, 0xf4e, 0x7, 0x20, 0x2, 0x2, 0xf4e, 0xf50, 0x5, 0x466, 0x234, 
       0x2, 0xf4f, 0xf4d, 0x3, 0x2, 0x2, 0x2, 0xf50, 0xf53, 0x3, 0x2, 0x2, 
       0x2, 0xf51, 0xf4f, 0x3, 0x2, 0x2, 0x2, 0xf51, 0xf52, 0x3, 0x2, 0x2, 
       0x2, 0xf52, 0xf55, 0x3, 0x2, 0x2, 0x2, 0xf53, 0xf51, 0x3, 0x2, 0x2, 
       0x2, 0xf54, 0xf4c, 0x3, 0x2, 0x2, 0x2, 0xf54, 0xf55, 0x3, 0x2, 0x2, 
       0x2, 0xf55, 0xf56, 0x3, 0x2, 0x2, 0x2, 0xf56, 0xf57, 0x7, 0x24, 0x2, 
       0x2, 0xf57, 0x1c9, 0x3, 0x2, 0x2, 0x2, 0xf58, 0xf59, 0x7, 0x69, 0x2, 
       0x2, 0xf59, 0xf5a, 0x7, 0x1ef, 0x2, 0x2, 0xf5a, 0xf5b, 0x7, 0xe9, 
       0x2, 0x2, 0xf5b, 0xf60, 0x5, 0x1cc, 0xe7, 0x2, 0xf5c, 0xf5d, 0x7, 
       0x20, 0x2, 0x2, 0xf5d, 0xf5f, 0x5, 0x1cc, 0xe7, 0x2, 0xf5e, 0xf5c, 
       0x3, 0x2, 0x2, 0x2, 0xf5f, 0xf62, 0x3, 0x2, 0x2, 0x2, 0xf60, 0xf5e, 
       0x3, 0x2, 0x2, 0x2, 0xf60, 0xf61, 0x3, 0x2, 0x2, 0x2, 0xf61, 0xf65, 
       0x3, 0x2, 0x2, 0x2, 0xf62, 0xf60, 0x3, 0x2, 0x2, 0x2, 0xf63, 0xf64, 
       0x6, 0xe6, 0x4b, 0x2, 0xf64, 0xf66, 0x5, 0x2fe, 0x180, 0x2, 0xf65, 
       0xf63, 0x3, 0x2, 0x2, 0x2, 0xf65, 0xf66, 0x3, 0x2, 0x2, 0x2, 0xf66, 
       0x1cb, 0x3, 0x2, 0x2, 0x2, 0xf67, 0xf68, 0x7, 0x1f0, 0x2, 0x2, 0xf68, 
       0xf69, 0x7, 0x9, 0x2, 0x2, 0xf69, 0xf6b, 0x7, 0x23, 0x2, 0x2, 0xf6a, 
       0xf6c, 0x5, 0x1ce, 0xe8, 0x2, 0xf6b, 0xf6a, 0x3, 0x2, 0x2, 0x2, 0xf6b, 
       0xf6c, 0x3, 0x2, 0x2, 0x2, 0xf6c, 0xf6d, 0x3, 0x2, 0x2, 0x2, 0xf6d, 
       0xf99, 0x7, 0x24, 0x2, 0x2, 0xf6e, 0xf6f, 0x7, 0x1f1, 0x2, 0x2, 0xf6f, 
       0xf70, 0x7, 0x9, 0x2, 0x2, 0xf70, 0xf72, 0x7, 0x23, 0x2, 0x2, 0xf71, 
       0xf73, 0x5, 0x1ce, 0xe8, 0x2, 0xf72, 0xf71, 0x3, 0x2, 0x2, 0x2, 0xf72, 
       0xf73, 0x3, 0x2, 0x2, 0x2, 0xf73, 0xf74, 0x3, 0x2, 0x2, 0x2, 0xf74, 
       0xf99, 0x7, 0x24, 0x2, 0x2, 0xf75, 0xf76, 0x7, 0x1f2, 0x2, 0x2, 0xf76, 
       0xf77, 0x7, 0x9, 0x2, 0x2, 0xf77, 0xf79, 0x7, 0x23, 0x2, 0x2, 0xf78, 
       0xf7a, 0x5, 0x1d0, 0xe9, 0x2, 0xf79, 0xf78, 0x3, 0x2, 0x2, 0x2, 0xf79, 
       0xf7a, 0x3, 0x2, 0x2, 0x2, 0xf7a, 0xf7b, 0x3, 0x2, 0x2, 0x2, 0xf7b, 
       0xf99, 0x7, 0x24, 0x2, 0x2, 0xf7c, 0xf7d, 0x7, 0x1f3, 0x2, 0x2, 0xf7d, 
       0xf7e, 0x7, 0x9, 0x2, 0x2, 0xf7e, 0xf80, 0x7, 0x23, 0x2, 0x2, 0xf7f, 
       0xf81, 0x5, 0x1d0, 0xe9, 0x2, 0xf80, 0xf7f, 0x3, 0x2, 0x2, 0x2, 0xf80, 
       0xf81, 0x3, 0x2, 0x2, 0x2, 0xf81, 0xf82, 0x3, 0x2, 0x2, 0x2, 0xf82, 
       0xf99, 0x7, 0x24, 0x2, 0x2, 0xf83, 0xf84, 0x7, 0x1f4, 0x2, 0x2, 0xf84, 
       0xf85, 0x7, 0x9, 0x2, 0x2, 0xf85, 0xf87, 0x7, 0x23, 0x2, 0x2, 0xf86, 
       0xf88, 0x5, 0x1d2, 0xea, 0x2, 0xf87, 0xf86, 0x3, 0x2, 0x2, 0x2, 0xf87, 
       0xf88, 0x3, 0x2, 0x2, 0x2, 0xf88, 0xf89, 0x3, 0x2, 0x2, 0x2, 0xf89, 
       0xf99, 0x7, 0x24, 0x2, 0x2, 0xf8a, 0xf8b, 0x7, 0x1f5, 0x2, 0x2, 0xf8b, 
       0xf8c, 0x7, 0x9, 0x2, 0x2, 0xf8c, 0xf8e, 0x7, 0x23, 0x2, 0x2, 0xf8d, 
       0xf8f, 0x5, 0x1d2, 0xea, 0x2, 0xf8e, 0xf8d, 0x3, 0x2, 0x2, 0x2, 0xf8e, 
       0xf8f, 0x3, 0x2, 0x2, 0x2, 0xf8f, 0xf90, 0x3, 0x2, 0x2, 0x2, 0xf90, 
       0xf99, 0x7, 0x24, 0x2, 0x2, 0xf91, 0xf92, 0x7, 0x1f6, 0x2, 0x2, 0xf92, 
       0xf93, 0x7, 0x9, 0x2, 0x2, 0xf93, 0xf95, 0x7, 0x23, 0x2, 0x2, 0xf94, 
       0xf96, 0x5, 0x1d6, 0xec, 0x2, 0xf95, 0xf94, 0x3, 0x2, 0x2, 0x2, 0xf95, 
       0xf96, 0x3, 0x2, 0x2, 0x2, 0xf96, 0xf97, 0x3, 0x2, 0x2, 0x2, 0xf97, 
       0xf99, 0x7, 0x24, 0x2, 0x2, 0xf98, 0xf67, 0x3, 0x2, 0x2, 0x2, 0xf98, 
       0xf6e, 0x3, 0x2, 0x2, 0x2, 0xf98, 0xf75, 0x3, 0x2, 0x2, 0x2, 0xf98, 
       0xf7c, 0x3, 0x2, 0x2, 0x2, 0xf98, 0xf83, 0x3, 0x2, 0x2, 0x2, 0xf98, 
       0xf8a, 0x3, 0x2, 0x2, 0x2, 0xf98, 0xf91, 0x3, 0x2, 0x2, 0x2, 0xf99, 
       0x1cd, 0x3, 0x2, 0x2, 0x2, 0xf9a, 0xf9f, 0x5, 0x414, 0x20b, 0x2, 
       0xf9b, 0xf9c, 0x7, 0x20, 0x2, 0x2, 0xf9c, 0xf9e, 0x5, 0x414, 0x20b, 
       0x2, 0xf9d, 0xf9b, 0x3, 0x2, 0x2, 0x2, 0xf9e, 0xfa1, 0x3, 0x2, 0x2, 
       0x2, 0xf9f, 0xf9d, 0x3, 0x2, 0x2, 0x2, 0xf9f, 0xfa0, 0x3, 0x2, 0x2, 
       0x2, 0xfa0, 0x1cf, 0x3, 0x2, 0x2, 0x2, 0xfa1, 0xf9f, 0x3, 0x2, 0x2, 
       0x2, 0xfa2, 0xfa7, 0x5, 0x43c, 0x21f, 0x2, 0xfa3, 0xfa4, 0x7, 0x20, 
       0x2, 0x2, 0xfa4, 0xfa6, 0x5, 0x43c, 0x21f, 0x2, 0xfa5, 0xfa3, 0x3, 
       0x2, 0x2, 0x2, 0xfa6, 0xfa9, 0x3, 0x2, 0x2, 0x2, 0xfa7, 0xfa5, 0x3, 
       0x2, 0x2, 0x2, 0xfa7, 0xfa8, 0x3, 0x2, 0x2, 0x2, 0xfa8, 0x1d1, 0x3, 
       0x2, 0x2, 0x2, 0xfa9, 0xfa7, 0x3, 0x2, 0x2, 0x2, 0xfaa, 0xfaf, 0x5, 
       0x1d4, 0xeb, 0x2, 0xfab, 0xfac, 0x7, 0x20, 0x2, 0x2, 0xfac, 0xfae, 
       0x5, 0x1d4, 0xeb, 0x2, 0xfad, 0xfab, 0x3, 0x2, 0x2, 0x2, 0xfae, 0xfb1, 
       0x3, 0x2, 0x2, 0x2, 0xfaf, 0xfad, 0x3, 0x2, 0x2, 0x2, 0xfaf, 0xfb0, 
       0x3, 0x2, 0x2, 0x2, 0xfb0, 0x1d3, 0x3, 0x2, 0x2, 0x2, 0xfb1, 0xfaf, 
       0x3, 0x2, 0x2, 0x2, 0xfb2, 0xfb3, 0x5, 0x47c, 0x23f, 0x2, 0xfb3, 
       0x1d5, 0x3, 0x2, 0x2, 0x2, 0xfb4, 0xfb9, 0x5, 0x3d2, 0x1ea, 0x2, 
       0xfb5, 0xfb6, 0x7, 0x20, 0x2, 0x2, 0xfb6, 0xfb8, 0x5, 0x3d2, 0x1ea, 
       0x2, 0xfb7, 0xfb5, 0x3, 0x2, 0x2, 0x2, 0xfb8, 0xfbb, 0x3, 0x2, 0x2, 
       0x2, 0xfb9, 0xfb7, 0x3, 0x2, 0x2, 0x2, 0xfb9, 0xfba, 0x3, 0x2, 0x2, 
       0x2, 0xfba, 0x1d7, 0x3, 0x2, 0x2, 0x2, 0xfbb, 0xfb9, 0x3, 0x2, 0x2, 
       0x2, 0xfbc, 0xfbd, 0x7, 0x23f, 0x2, 0x2, 0xfbd, 0xfbf, 0x7, 0x223, 
       0x2, 0x2, 0xfbe, 0xfc0, 0x5, 0x1de, 0xf0, 0x2, 0xfbf, 0xfbe, 0x3, 
       0x2, 0x2, 0x2, 0xfbf, 0xfc0, 0x3, 0x2, 0x2, 0x2, 0xfc0, 0xfc3, 0x3, 
       0x2, 0x2, 0x2, 0xfc1, 0xfc2, 0x7, 0x285, 0x2, 0x2, 0xfc2, 0xfc4, 
       0x5, 0x1da, 0xee, 0x2, 0xfc3, 0xfc1, 0x3, 0x2, 0x2, 0x2, 0xfc3, 0xfc4, 
       0x3, 0x2, 0x2, 0x2, 0xfc4, 0xfc5, 0x3, 0x2, 0x2, 0x2, 0xfc5, 0xfc7, 
       0x5, 0x1dc, 0xef, 0x2, 0xfc6, 0xfc8, 0x5, 0x2fe, 0x180, 0x2, 0xfc7, 
       0xfc6, 0x3, 0x2, 0x2, 0x2, 0xfc7, 0xfc8, 0x3, 0x2, 0x2, 0x2, 0xfc8, 
       0xfd2, 0x3, 0x2, 0x2, 0x2, 0xfc9, 0xfca, 0x7, 0x248, 0x2, 0x2, 0xfca, 
       0xfcc, 0x7, 0x223, 0x2, 0x2, 0xfcb, 0xfcd, 0x5, 0x1de, 0xf0, 0x2, 
       0xfcc, 0xfcb, 0x3, 0x2, 0x2, 0x2, 0xfcc, 0xfcd, 0x3, 0x2, 0x2, 0x2, 
       0xfcd, 0xfcf, 0x3, 0x2, 0x2, 0x2, 0xfce, 0xfd0, 0x5, 0x2fe, 0x180, 
       0x2, 0xfcf, 0xfce, 0x3, 0x2, 0x2, 0x2, 0xfcf, 0xfd0, 0x3, 0x2, 0x2, 
       0x2, 0xfd0, 0xfd2, 0x3, 0x2, 0x2, 0x2, 0xfd1, 0xfbc, 0x3, 0x2, 0x2, 
       0x2, 0xfd1, 0xfc9, 0x3, 0x2, 0x2, 0x2, 0xfd2, 0x1d9, 0x3, 0x2, 0x2, 
       0x2, 0xfd3, 0xfdb, 0x5, 0x1c6, 0xe4, 0x2, 0xfd4, 0xfd5, 0x6, 0xee, 
       0x4c, 0x2, 0xfd5, 0xfd6, 0x9, 0x2e, 0x2, 0x2, 0xfd6, 0xfd7, 0x7, 
       0x9, 0x2, 0x2, 0xfd7, 0xfdb, 0x5, 0x476, 0x23c, 0x2, 0xfd8, 0xfd9, 
       0x6, 0xee, 0x4d, 0x2, 0xfd9, 0xfdb, 0x7, 0x231, 0x2, 0x2, 0xfda, 
       0xfd3, 0x3, 0x2, 0x2, 0x2, 0xfda, 0xfd4, 0x3, 0x2, 0x2, 0x2, 0xfda, 
       0xfd8, 0x3, 0x2, 0x2, 0x2, 0xfdb, 0xfe0, 0x3, 0x2, 0x2, 0x2, 0xfdc, 
       0xfdd, 0x7, 0x20, 0x2, 0x2, 0xfdd, 0xfdf, 0x5, 0x1c6, 0xe4, 0x2, 
       0xfde, 0xfdc, 0x3, 0x2, 0x2, 0x2, 0xfdf, 0xfe2, 0x3, 0x2, 0x2, 0x2, 
       0xfe0, 0xfde, 0x3, 0x2, 0x2, 0x2, 0xfe0, 0xfe1, 0x3, 0x2, 0x2, 0x2, 
       0xfe1, 0x1db, 0x3, 0x2, 0x2, 0x2, 0xfe2, 0xfe0, 0x3, 0x2, 0x2, 0x2, 
       0xfe3, 0xfe7, 0x6, 0xef, 0x4e, 0x2, 0xfe4, 0xfe5, 0x7, 0x28a, 0x2, 
       0x2, 0xfe5, 0xfe6, 0x7, 0x9, 0x2, 0x2, 0xfe6, 0xfe8, 0x5, 0x476, 
       0x23c, 0x2, 0xfe7, 0xfe4, 0x3, 0x2, 0x2, 0x2, 0xfe7, 0xfe8, 0x3, 
       0x2, 0x2, 0x2, 0xfe8, 0xfec, 0x3, 0x2, 0x2, 0x2, 0xfe9, 0xfea, 0x7, 
       0x1ba, 0x2, 0x2, 0xfea, 0xfeb, 0x7, 0x9, 0x2, 0x2, 0xfeb, 0xfed, 
       0x5, 0x476, 0x23c, 0x2, 0xfec, 0xfe9, 0x3, 0x2, 0x2, 0x2, 0xfec, 
       0xfed, 0x3, 0x2, 0x2, 0x2, 0xfed, 0xff1, 0x3, 0x2, 0x2, 0x2, 0xfee, 
       0xfef, 0x7, 0xaf, 0x2, 0x2, 0xfef, 0xff0, 0x7, 0x9, 0x2, 0x2, 0xff0, 
       0xff2, 0x5, 0x476, 0x23c, 0x2, 0xff1, 0xfee, 0x3, 0x2, 0x2, 0x2, 
       0xff1, 0xff2, 0x3, 0x2, 0x2, 0x2, 0xff2, 0xff6, 0x3, 0x2, 0x2, 0x2, 
       0xff3, 0xff4, 0x7, 0x1bd, 0x2, 0x2, 0xff4, 0xff5, 0x7, 0x9, 0x2, 
       0x2, 0xff5, 0xff7, 0x5, 0x476, 0x23c, 0x2, 0xff6, 0xff3, 0x3, 0x2, 
       0x2, 0x2, 0xff6, 0xff7, 0x3, 0x2, 0x2, 0x2, 0xff7, 0xffa, 0x3, 0x2, 
       0x2, 0x2, 0xff8, 0xffa, 0x3, 0x2, 0x2, 0x2, 0xff9, 0xfe3, 0x3, 0x2, 
       0x2, 0x2, 0xff9, 0xff8, 0x3, 0x2, 0x2, 0x2, 0xffa, 0x1dd, 0x3, 0x2, 
       0x2, 0x2, 0xffb, 0x1000, 0x5, 0x1e0, 0xf1, 0x2, 0xffc, 0xffd, 0x7, 
       0x20, 0x2, 0x2, 0xffd, 0xfff, 0x5, 0x1e0, 0xf1, 0x2, 0xffe, 0xffc, 
       0x3, 0x2, 0x2, 0x2, 0xfff, 0x1002, 0x3, 0x2, 0x2, 0x2, 0x1000, 0xffe, 
       0x3, 0x2, 0x2, 0x2, 0x1000, 0x1001, 0x3, 0x2, 0x2, 0x2, 0x1001, 0x1df, 
       0x3, 0x2, 0x2, 0x2, 0x1002, 0x1000, 0x3, 0x2, 0x2, 0x2, 0x1003, 0x1004, 
       0x9, 0x2f, 0x2, 0x2, 0x1004, 0x1e1, 0x3, 0x2, 0x2, 0x2, 0x1005, 0x1006, 
       0x9, 0x30, 0x2, 0x2, 0x1006, 0x1007, 0x7, 0xfb, 0x2, 0x2, 0x1007, 
       0x1e3, 0x3, 0x2, 0x2, 0x2, 0x1008, 0x1009, 0x7, 0x1c5, 0x2, 0x2, 
       0x1009, 0x100a, 0x5, 0x45a, 0x22e, 0x2, 0x100a, 0x100d, 0x7, 0xf4, 
       0x2, 0x2, 0x100b, 0x100e, 0x5, 0x47a, 0x23e, 0x2, 0x100c, 0x100e, 
       0x5, 0x2d6, 0x16c, 0x2, 0x100d, 0x100b, 0x3, 0x2, 0x2, 0x2, 0x100d, 
       0x100c, 0x3, 0x2, 0x2, 0x2, 0x100e, 0x1014, 0x3, 0x2, 0x2, 0x2, 0x100f, 
       0x1014, 0x5, 0x1e6, 0xf4, 0x2, 0x1010, 0x1011, 0x9, 0x31, 0x2, 0x2, 
       0x1011, 0x1012, 0x7, 0x1c5, 0x2, 0x2, 0x1012, 0x1014, 0x5, 0x45a, 
       0x22e, 0x2, 0x1013, 0x1008, 0x3, 0x2, 0x2, 0x2, 0x1013, 0x100f, 0x3, 
       0x2, 0x2, 0x2, 0x1013, 0x1010, 0x3, 0x2, 0x2, 0x2, 0x1014, 0x1e5, 
       0x3, 0x2, 0x2, 0x2, 0x1015, 0x1016, 0x7, 0xda, 0x2, 0x2, 0x1016, 
       0x1019, 0x5, 0x45a, 0x22e, 0x2, 0x1017, 0x1018, 0x7, 0x28d, 0x2, 
       0x2, 0x1018, 0x101a, 0x5, 0x1e8, 0xf5, 0x2, 0x1019, 0x1017, 0x3, 
       0x2, 0x2, 0x2, 0x1019, 0x101a, 0x3, 0x2, 0x2, 0x2, 0x101a, 0x1e7, 
       0x3, 0x2, 0x2, 0x2, 0x101b, 0x1020, 0x5, 0x2d6, 0x16c, 0x2, 0x101c, 
       0x101d, 0x7, 0x20, 0x2, 0x2, 0x101d, 0x101f, 0x5, 0x2d6, 0x16c, 0x2, 
       0x101e, 0x101c, 0x3, 0x2, 0x2, 0x2, 0x101f, 0x1022, 0x3, 0x2, 0x2, 
       0x2, 0x1020, 0x101e, 0x3, 0x2, 0x2, 0x2, 0x1020, 0x1021, 0x3, 0x2, 
       0x2, 0x2, 0x1021, 0x1e9, 0x3, 0x2, 0x2, 0x2, 0x1022, 0x1020, 0x3, 
       0x2, 0x2, 0x2, 0x1023, 0x103c, 0x7, 0x2c6, 0x2, 0x2, 0x1024, 0x1025, 
       0x7, 0x141, 0x2, 0x2, 0x1025, 0x1026, 0x7, 0xa0, 0x2, 0x2, 0x1026, 
       0x1028, 0x7, 0xb9, 0x2, 0x2, 0x1027, 0x1029, 0x5, 0x498, 0x24d, 0x2, 
       0x1028, 0x1027, 0x3, 0x2, 0x2, 0x2, 0x1028, 0x1029, 0x3, 0x2, 0x2, 
       0x2, 0x1029, 0x102a, 0x3, 0x2, 0x2, 0x2, 0x102a, 0x103d, 0x5, 0x474, 
       0x23b, 0x2, 0x102b, 0x102e, 0x7, 0x2c5, 0x2, 0x2, 0x102c, 0x102d, 
       0x7, 0xf1, 0x2, 0x2, 0x102d, 0x102f, 0x7, 0x1ef, 0x2, 0x2, 0x102e, 
       0x102c, 0x3, 0x2, 0x2, 0x2, 0x102e, 0x102f, 0x3, 0x2, 0x2, 0x2, 0x102f, 
       0x103d, 0x3, 0x2, 0x2, 0x2, 0x1030, 0x1031, 0x6, 0xf6, 0x4f, 0x2, 
       0x1031, 0x1032, 0x7, 0x11d, 0x2, 0x2, 0x1032, 0x1033, 0x7, 0xf4, 
       0x2, 0x2, 0x1033, 0x1034, 0x5, 0x3f4, 0x1fb, 0x2, 0x1034, 0x1035, 
       0x7, 0x22, 0x2, 0x2, 0x1035, 0x1036, 0x5, 0x466, 0x234, 0x2, 0x1036, 
       0x1037, 0x7, 0x10f, 0x2, 0x2, 0x1037, 0x1038, 0x7, 0x5f, 0x2, 0x2, 
       0x1038, 0x103a, 0x5, 0x474, 0x23b, 0x2, 0x1039, 0x103b, 0x5, 0x1ec, 
       0xf7, 0x2, 0x103a, 0x1039, 0x3, 0x2, 0x2, 0x2, 0x103a, 0x103b, 0x3, 
       0x2, 0x2, 0x2, 0x103b, 0x103d, 0x3, 0x2, 0x2, 0x2, 0x103c, 0x1024, 
       0x3, 0x2, 0x2, 0x2, 0x103c, 0x102b, 0x3, 0x2, 0x2, 0x2, 0x103c, 0x1030, 
       0x3, 0x2, 0x2, 0x2, 0x103d, 0x1eb, 0x3, 0x2, 0x2, 0x2, 0x103e, 0x1049, 
       0x5, 0x1ee, 0xf8, 0x2, 0x103f, 0x1040, 0x7, 0xa0, 0x2, 0x2, 0x1040, 
       0x1042, 0x7, 0xb9, 0x2, 0x2, 0x1041, 0x1043, 0x5, 0x498, 0x24d, 0x2, 
       0x1042, 0x1041, 0x3, 0x2, 0x2, 0x2, 0x1042, 0x1043, 0x3, 0x2, 0x2, 
       0x2, 0x1043, 0x1044, 0x3, 0x2, 0x2, 0x2, 0x1044, 0x1046, 0x5, 0x474, 
       0x23b, 0x2, 0x1045, 0x1047, 0x5, 0x1ee, 0xf8, 0x2, 0x1046, 0x1045, 
       0x3, 0x2, 0x2, 0x2, 0x1046, 0x1047, 0x3, 0x2, 0x2, 0x2, 0x1047, 0x1049, 
       0x3, 0x2, 0x2, 0x2, 0x1048, 0x103e, 0x3, 0x2, 0x2, 0x2, 0x1048, 0x103f, 
       0x3, 0x2, 0x2, 0x2, 0x1049, 0x1ed, 0x3, 0x2, 0x2, 0x2, 0x104a, 0x104c, 
       0x7, 0x1f7, 0x2, 0x2, 0x104b, 0x104d, 0x7, 0x198, 0x2, 0x2, 0x104c, 
       0x104b, 0x3, 0x2, 0x2, 0x2, 0x104c, 0x104d, 0x3, 0x2, 0x2, 0x2, 0x104d, 
       0x104e, 0x3, 0x2, 0x2, 0x2, 0x104e, 0x104f, 0x7, 0x23b, 0x2, 0x2, 
       0x104f, 0x1ef, 0x3, 0x2, 0x2, 0x2, 0x1050, 0x1051, 0x6, 0xf9, 0x50, 
       0x2, 0x1051, 0x105b, 0x5, 0x1f2, 0xfa, 0x2, 0x1052, 0x105b, 0x5, 
       0x1f6, 0xfc, 0x2, 0x1053, 0x105b, 0x5, 0x202, 0x102, 0x2, 0x1054, 
       0x105b, 0x5, 0x204, 0x103, 0x2, 0x1055, 0x105b, 0x5, 0x212, 0x10a, 
       0x2, 0x1056, 0x105b, 0x5, 0x214, 0x10b, 0x2, 0x1057, 0x105b, 0x5, 
       0x21a, 0x10e, 0x2, 0x1058, 0x1059, 0x6, 0xf9, 0x51, 0x2, 0x1059, 
       0x105b, 0x5, 0x228, 0x115, 0x2, 0x105a, 0x1050, 0x3, 0x2, 0x2, 0x2, 
       0x105a, 0x1052, 0x3, 0x2, 0x2, 0x2, 0x105a, 0x1053, 0x3, 0x2, 0x2, 
       0x2, 0x105a, 0x1054, 0x3, 0x2, 0x2, 0x2, 0x105a, 0x1055, 0x3, 0x2, 
       0x2, 0x2, 0x105a, 0x1056, 0x3, 0x2, 0x2, 0x2, 0x105a, 0x1057, 0x3, 
       0x2, 0x2, 0x2, 0x105a, 0x1058, 0x3, 0x2, 0x2, 0x2, 0x105b, 0x1f1, 
       0x3, 0x2, 0x2, 0x2, 0x105c, 0x105d, 0x7, 0x3d, 0x2, 0x2, 0x105d, 
       0x1060, 0x7, 0x28a, 0x2, 0x2, 0x105e, 0x105f, 0x6, 0xfa, 0x52, 0x2, 
       0x105f, 0x1061, 0x5, 0x3c6, 0x1e4, 0x2, 0x1060, 0x105e, 0x3, 0x2, 
       0x2, 0x2, 0x1060, 0x1061, 0x3, 0x2, 0x2, 0x2, 0x1061, 0x1062, 0x3, 
       0x2, 0x2, 0x2, 0x1062, 0x1063, 0x5, 0x1f4, 0xfb, 0x2, 0x1063, 0x1f3, 
       0x3, 0x2, 0x2, 0x2, 0x1064, 0x1065, 0x6, 0xfb, 0x53, 0x2, 0x1065, 
       0x1069, 0x5, 0x3e6, 0x1f4, 0x2, 0x1066, 0x1067, 0x6, 0xfb, 0x54, 
       0x2, 0x1067, 0x1069, 0x5, 0x3e8, 0x1f5, 0x2, 0x1068, 0x1064, 0x3, 
       0x2, 0x2, 0x2, 0x1068, 0x1066, 0x3, 0x2, 0x2, 0x2, 0x1069, 0x106a, 
       0x3, 0x2, 0x2, 0x2, 0x106a, 0x106b, 0x5, 0x1f8, 0xfd, 0x2, 0x106b, 
       0x1089, 0x3, 0x2, 0x2, 0x2, 0x106c, 0x106d, 0x6, 0xfb, 0x55, 0x2, 
       0x106d, 0x106e, 0x7, 0x28a, 0x2, 0x2, 0x106e, 0x106f, 0x5, 0x496, 
       0x24c, 0x2, 0x106f, 0x1070, 0x7, 0x10f, 0x2, 0x2, 0x1070, 0x1071, 
       0x7, 0x5f, 0x2, 0x2, 0x1071, 0x1074, 0x5, 0x476, 0x23c, 0x2, 0x1072, 
       0x1073, 0x6, 0xfb, 0x56, 0x2, 0x1073, 0x1075, 0x5, 0x3f2, 0x1fa, 
       0x2, 0x1074, 0x1072, 0x3, 0x2, 0x2, 0x2, 0x1074, 0x1075, 0x3, 0x2, 
       0x2, 0x2, 0x1075, 0x1078, 0x3, 0x2, 0x2, 0x2, 0x1076, 0x1077, 0x6, 
       0xfb, 0x57, 0x2, 0x1077, 0x1079, 0x5, 0x3ee, 0x1f8, 0x2, 0x1078, 
       0x1076, 0x3, 0x2, 0x2, 0x2, 0x1078, 0x1079, 0x3, 0x2, 0x2, 0x2, 0x1079, 
       0x1089, 0x3, 0x2, 0x2, 0x2, 0x107a, 0x107b, 0x6, 0xfb, 0x58, 0x2, 
       0x107b, 0x107c, 0x7, 0x28a, 0x2, 0x2, 0x107c, 0x107d, 0x5, 0x496, 
       0x24c, 0x2, 0x107d, 0x107e, 0x5, 0x3f0, 0x1f9, 0x2, 0x107e, 0x1089, 
       0x3, 0x2, 0x2, 0x2, 0x107f, 0x1080, 0x6, 0xfb, 0x59, 0x2, 0x1080, 
       0x1081, 0x5, 0x3f4, 0x1fb, 0x2, 0x1081, 0x1082, 0x7, 0xae, 0x2, 0x2, 
       0x1082, 0x1086, 0x7, 0x2b4, 0x2, 0x2, 0x1083, 0x1087, 0x7, 0x3c, 
       0x2, 0x2, 0x1084, 0x1087, 0x7, 0x194, 0x2, 0x2, 0x1085, 0x1087, 0x5, 
       0x22a, 0x116, 0x2, 0x1086, 0x1083, 0x3, 0x2, 0x2, 0x2, 0x1086, 0x1084, 
       0x3, 0x2, 0x2, 0x2, 0x1086, 0x1085, 0x3, 0x2, 0x2, 0x2, 0x1087, 0x1089, 
       0x3, 0x2, 0x2, 0x2, 0x1088, 0x1068, 0x3, 0x2, 0x2, 0x2, 0x1088, 0x106c, 
       0x3, 0x2, 0x2, 0x2, 0x1088, 0x107a, 0x3, 0x2, 0x2, 0x2, 0x1088, 0x107f, 
       0x3, 0x2, 0x2, 0x2, 0x1089, 0x1f5, 0x3, 0x2, 0x2, 0x2, 0x108a, 0x108b, 
       0x7, 0x92, 0x2, 0x2, 0x108b, 0x108f, 0x7, 0x28a, 0x2, 0x2, 0x108c, 
       0x108d, 0x6, 0xfc, 0x5a, 0x2, 0x108d, 0x1090, 0x5, 0x3c8, 0x1e5, 
       0x2, 0x108e, 0x1090, 0x3, 0x2, 0x2, 0x2, 0x108f, 0x108c, 0x3, 0x2, 
       0x2, 0x2, 0x108f, 0x108e, 0x3, 0x2, 0x2, 0x2, 0x1090, 0x1091, 0x3, 
       0x2, 0x2, 0x2, 0x1091, 0x1092, 0x5, 0x3e6, 0x1f4, 0x2, 0x1092, 0x1093, 
       0x5, 0x1fa, 0xfe, 0x2, 0x1093, 0x1094, 0x5, 0x1f8, 0xfd, 0x2, 0x1094, 
       0x1f7, 0x3, 0x2, 0x2, 0x2, 0x1095, 0x1097, 0x6, 0xfd, 0x5b, 0x2, 
       0x1096, 0x1098, 0x5, 0x1fc, 0xff, 0x2, 0x1097, 0x1096, 0x3, 0x2, 
       0x2, 0x2, 0x1097, 0x1098, 0x3, 0x2, 0x2, 0x2, 0x1098, 0x109a, 0x3, 
       0x2, 0x2, 0x2, 0x1099, 0x109b, 0x5, 0x1fe, 0x100, 0x2, 0x109a, 0x1099, 
       0x3, 0x2, 0x2, 0x2, 0x109a, 0x109b, 0x3, 0x2, 0x2, 0x2, 0x109b, 0x109f, 
       0x3, 0x2, 0x2, 0x2, 0x109c, 0x109e, 0x5, 0x200, 0x101, 0x2, 0x109d, 
       0x109c, 0x3, 0x2, 0x2, 0x2, 0x109e, 0x10a1, 0x3, 0x2, 0x2, 0x2, 0x109f, 
       0x109d, 0x3, 0x2, 0x2, 0x2, 0x109f, 0x10a0, 0x3, 0x2, 0x2, 0x2, 0x10a0, 
       0x10a4, 0x3, 0x2, 0x2, 0x2, 0x10a1, 0x109f, 0x3, 0x2, 0x2, 0x2, 0x10a2, 
       0x10a4, 0x3, 0x2, 0x2, 0x2, 0x10a3, 0x1095, 0x3, 0x2, 0x2, 0x2, 0x10a3, 
       0x10a2, 0x3, 0x2, 0x2, 0x2, 0x10a4, 0x1f9, 0x3, 0x2, 0x2, 0x2, 0x10a5, 
       0x10a9, 0x6, 0xfe, 0x5c, 0x2, 0x10a6, 0x10a7, 0x7, 0xae, 0x2, 0x2, 
       0x10a7, 0x10a8, 0x7, 0x2b4, 0x2, 0x2, 0x10a8, 0x10aa, 0x5, 0x22a, 
       0x116, 0x2, 0x10a9, 0x10a6, 0x3, 0x2, 0x2, 0x2, 0x10a9, 0x10aa, 0x3, 
       0x2, 0x2, 0x2, 0x10aa, 0x10ad, 0x3, 0x2, 0x2, 0x2, 0x10ab, 0x10ad, 
       0x3, 0x2, 0x2, 0x2, 0x10ac, 0x10a5, 0x3, 0x2, 0x2, 0x2, 0x10ac, 0x10ab, 
       0x3, 0x2, 0x2, 0x2, 0x10ad, 0x1fb, 0x3, 0x2, 0x2, 0x2, 0x10ae, 0x10b1, 
       0x7, 0x1f7, 0x2, 0x2, 0x10af, 0x10b2, 0x5, 0x222, 0x112, 0x2, 0x10b0, 
       0x10b2, 0x9, 0x32, 0x2, 0x2, 0x10b1, 0x10af, 0x3, 0x2, 0x2, 0x2, 
       0x10b1, 0x10b0, 0x3, 0x2, 0x2, 0x2, 0x10b2, 0x1fd, 0x3, 0x2, 0x2, 
       0x2, 0x10b3, 0x10bc, 0x7, 0x2a4, 0x2, 0x2, 0x10b4, 0x10b5, 0x7, 0x167, 
       0x2, 0x2, 0x10b5, 0x10bd, 0x5, 0x466, 0x234, 0x2, 0x10b6, 0x10b7, 
       0x7, 0x16c, 0x2, 0x2, 0x10b7, 0x10bd, 0x5, 0x466, 0x234, 0x2, 0x10b8, 
       0x10b9, 0x7, 0x166, 0x2, 0x2, 0x10b9, 0x10bd, 0x5, 0x466, 0x234, 
       0x2, 0x10ba, 0x10bb, 0x7, 0x16d, 0x2, 0x2, 0x10bb, 0x10bd, 0x5, 0x466, 
       0x234, 0x2, 0x10bc, 0x10b4, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10b6, 0x3, 
       0x2, 0x2, 0x2, 0x10bc, 0x10b8, 0x3, 0x2, 0x2, 0x2, 0x10bc, 0x10ba, 
       0x3, 0x2, 0x2, 0x2, 0x10bd, 0x10be, 0x3, 0x2, 0x2, 0x2, 0x10be, 0x10bc, 
       0x3, 0x2, 0x2, 0x2, 0x10be, 0x10bf, 0x3, 0x2, 0x2, 0x2, 0x10bf, 0x1ff, 
       0x3, 0x2, 0x2, 0x2, 0x10c0, 0x10c1, 0x7, 0x34, 0x2, 0x2, 0x10c1, 
       0x10e2, 0x9, 0x33, 0x2, 0x2, 0x10c2, 0x10df, 0x7, 0x1ba, 0x2, 0x2, 
       0x10c3, 0x10ca, 0x7, 0xde, 0x2, 0x2, 0x10c4, 0x10c5, 0x7, 0x11f, 
       0x2, 0x2, 0x10c5, 0x10c6, 0x5, 0x468, 0x235, 0x2, 0x10c6, 0x10c7, 
       0x7, 0xa9, 0x2, 0x2, 0x10c7, 0x10cb, 0x3, 0x2, 0x2, 0x2, 0x10c8, 
       0x10cb, 0x7, 0x190, 0x2, 0x2, 0x10c9, 0x10cb, 0x7, 0xae, 0x2, 0x2, 
       0x10ca, 0x10c4, 0x3, 0x2, 0x2, 0x2, 0x10ca, 0x10c8, 0x3, 0x2, 0x2, 
       0x2, 0x10ca, 0x10c9, 0x3, 0x2, 0x2, 0x2, 0x10ca, 0x10cb, 0x3, 0x2, 
       0x2, 0x2, 0x10cb, 0x10e0, 0x3, 0x2, 0x2, 0x2, 0x10cc, 0x10cf, 0x7, 
       0x2e2, 0x2, 0x2, 0x10cd, 0x10d0, 0x5, 0x468, 0x235, 0x2, 0x10ce, 
       0x10d0, 0x7, 0xae, 0x2, 0x2, 0x10cf, 0x10cd, 0x3, 0x2, 0x2, 0x2, 
       0x10cf, 0x10ce, 0x3, 0x2, 0x2, 0x2, 0x10d0, 0x10e0, 0x3, 0x2, 0x2, 
       0x2, 0x10d1, 0x10d2, 0x7, 0x2e3, 0x2, 0x2, 0x10d2, 0x10d7, 0x7, 0x11f, 
       0x2, 0x2, 0x10d3, 0x10d4, 0x5, 0x468, 0x235, 0x2, 0x10d4, 0x10d5, 
       0x7, 0xa9, 0x2, 0x2, 0x10d5, 0x10d8, 0x3, 0x2, 0x2, 0x2, 0x10d6, 
       0x10d8, 0x7, 0xae, 0x2, 0x2, 0x10d7, 0x10d3, 0x3, 0x2, 0x2, 0x2, 
       0x10d7, 0x10d6, 0x3, 0x2, 0x2, 0x2, 0x10d8, 0x10e0, 0x3, 0x2, 0x2, 
       0x2, 0x10d9, 0x10da, 0x6, 0x101, 0x5d, 0x2, 0x10da, 0x10db, 0x7, 
       0x1f7, 0x2, 0x2, 0x10db, 0x10dd, 0x7, 0x96, 0x2, 0x2, 0x10dc, 0x10de, 
       0x9, 0x34, 0x2, 0x2, 0x10dd, 0x10dc, 0x3, 0x2, 0x2, 0x2, 0x10dd, 
       0x10de, 0x3, 0x2, 0x2, 0x2, 0x10de, 0x10e0, 0x3, 0x2, 0x2, 0x2, 0x10df, 
       0x10c3, 0x3, 0x2, 0x2, 0x2, 0x10df, 0x10cc, 0x3, 0x2, 0x2, 0x2, 0x10df, 
       0x10d1, 0x3, 0x2, 0x2, 0x2, 0x10df, 0x10d9, 0x3, 0x2, 0x2, 0x2, 0x10e0, 
       0x10e2, 0x3, 0x2, 0x2, 0x2, 0x10e1, 0x10c0, 0x3, 0x2, 0x2, 0x2, 0x10e1, 
       0x10c2, 0x3, 0x2, 0x2, 0x2, 0x10e2, 0x201, 0x3, 0x2, 0x2, 0x2, 0x10e3, 
       0x10e4, 0x7, 0xc1, 0x2, 0x2, 0x10e4, 0x10e7, 0x7, 0x28a, 0x2, 0x2, 
       0x10e5, 0x10e6, 0x6, 0x102, 0x5e, 0x2, 0x10e6, 0x10e8, 0x5, 0x3c6, 
       0x1e4, 0x2, 0x10e7, 0x10e5, 0x3, 0x2, 0x2, 0x2, 0x10e7, 0x10e8, 0x3, 
       0x2, 0x2, 0x2, 0x10e8, 0x10e9, 0x3, 0x2, 0x2, 0x2, 0x10e9, 0x10ea, 
       0x5, 0x3e4, 0x1f3, 0x2, 0x10ea, 0x203, 0x3, 0x2, 0x2, 0x2, 0x10eb, 
       0x1116, 0x7, 0x100, 0x2, 0x2, 0x10ec, 0x10ed, 0x6, 0x103, 0x5f, 0x2, 
       0x10ed, 0x10ee, 0x5, 0x21c, 0x10f, 0x2, 0x10ee, 0x10ef, 0x7, 0x26e, 
       0x2, 0x2, 0x10ef, 0x10f3, 0x5, 0x3e4, 0x1f3, 0x2, 0x10f0, 0x10f1, 
       0x7, 0x2a4, 0x2, 0x2, 0x10f1, 0x10f2, 0x7, 0x2b5, 0x2, 0x2, 0x10f2, 
       0x10f4, 0x7, 0x1ab, 0x2, 0x2, 0x10f3, 0x10f0, 0x3, 0x2, 0x2, 0x2, 
       0x10f3, 0x10f4, 0x3, 0x2, 0x2, 0x2, 0x10f4, 0x1117, 0x3, 0x2, 0x2, 
       0x2, 0x10f5, 0x10fb, 0x5, 0x21c, 0x10f, 0x2, 0x10f6, 0x10f8, 0x7, 
       0x3c, 0x2, 0x2, 0x10f7, 0x10f9, 0x7, 0x1c9, 0x2, 0x2, 0x10f8, 0x10f7, 
       0x3, 0x2, 0x2, 0x2, 0x10f8, 0x10f9, 0x3, 0x2, 0x2, 0x2, 0x10f9, 0x10fb, 
       0x3, 0x2, 0x2, 0x2, 0x10fa, 0x10f5, 0x3, 0x2, 0x2, 0x2, 0x10fa, 0x10f6, 
       0x3, 0x2, 0x2, 0x2, 0x10fb, 0x10fc, 0x3, 0x2, 0x2, 0x2, 0x10fc, 0x10fe, 
       0x7, 0x1a2, 0x2, 0x2, 0x10fd, 0x10ff, 0x5, 0x218, 0x10d, 0x2, 0x10fe, 
       0x10fd, 0x3, 0x2, 0x2, 0x2, 0x10fe, 0x10ff, 0x3, 0x2, 0x2, 0x2, 0x10ff, 
       0x1100, 0x3, 0x2, 0x2, 0x2, 0x1100, 0x1101, 0x5, 0x220, 0x111, 0x2, 
       0x1101, 0x1102, 0x7, 0x26e, 0x2, 0x2, 0x1102, 0x1104, 0x5, 0x206, 
       0x104, 0x2, 0x1103, 0x1105, 0x5, 0x210, 0x109, 0x2, 0x1104, 0x1103, 
       0x3, 0x2, 0x2, 0x2, 0x1104, 0x1105, 0x3, 0x2, 0x2, 0x2, 0x1105, 0x1107, 
       0x3, 0x2, 0x2, 0x2, 0x1106, 0x1108, 0x5, 0x208, 0x105, 0x2, 0x1107, 
       0x1106, 0x3, 0x2, 0x2, 0x2, 0x1107, 0x1108, 0x3, 0x2, 0x2, 0x2, 0x1108, 
       0x110a, 0x3, 0x2, 0x2, 0x2, 0x1109, 0x110b, 0x5, 0x20e, 0x108, 0x2, 
       0x110a, 0x1109, 0x3, 0x2, 0x2, 0x2, 0x110a, 0x110b, 0x3, 0x2, 0x2, 
       0x2, 0x110b, 0x1117, 0x3, 0x2, 0x2, 0x2, 0x110c, 0x110d, 0x7, 0x1cf, 
       0x2, 0x2, 0x110d, 0x110e, 0x7, 0x1a2, 0x2, 0x2, 0x110e, 0x110f, 0x5, 
       0x3f4, 0x1fb, 0x2, 0x110f, 0x1110, 0x7, 0x26e, 0x2, 0x2, 0x1110, 
       0x1114, 0x5, 0x206, 0x104, 0x2, 0x1111, 0x1112, 0x7, 0x2a4, 0x2, 
       0x2, 0x1112, 0x1113, 0x7, 0x100, 0x2, 0x2, 0x1113, 0x1115, 0x7, 0x1ab, 
       0x2, 0x2, 0x1114, 0x1111, 0x3, 0x2, 0x2, 0x2, 0x1114, 0x1115, 0x3, 
       0x2, 0x2, 0x2, 0x1115, 0x1117, 0x3, 0x2, 0x2, 0x2, 0x1116, 0x10ec, 
       0x3, 0x2, 0x2, 0x2, 0x1116, 0x10fa, 0x3, 0x2, 0x2, 0x2, 0x1116, 0x110c, 
       0x3, 0x2, 0x2, 0x2, 0x1117, 0x205, 0x3, 0x2, 0x2, 0x2, 0x1118, 0x1119, 
       0x6, 0x104, 0x60, 0x2, 0x1119, 0x111d, 0x5, 0x3e6, 0x1f4, 0x2, 0x111a, 
       0x111b, 0x6, 0x104, 0x61, 0x2, 0x111b, 0x111d, 0x5, 0x3e4, 0x1f3, 
       0x2, 0x111c, 0x1118, 0x3, 0x2, 0x2, 0x2, 0x111c, 0x111a, 0x3, 0x2, 
       0x2, 0x2, 0x111d, 0x207, 0x3, 0x2, 0x2, 0x2, 0x111e, 0x111f, 0x6, 
       0x105, 0x62, 0x2, 0x111f, 0x1121, 0x7, 0x2a4, 0x2, 0x2, 0x1120, 0x1122, 
       0x5, 0x226, 0x114, 0x2, 0x1121, 0x1120, 0x3, 0x2, 0x2, 0x2, 0x1122, 
       0x1123, 0x3, 0x2, 0x2, 0x2, 0x1123, 0x1121, 0x3, 0x2, 0x2, 0x2, 0x1123, 
       0x1124, 0x3, 0x2, 0x2, 0x2, 0x1124, 0x112a, 0x3, 0x2, 0x2, 0x2, 0x1125, 
       0x1126, 0x6, 0x105, 0x63, 0x2, 0x1126, 0x1127, 0x7, 0x2a4, 0x2, 0x2, 
       0x1127, 0x1128, 0x7, 0x100, 0x2, 0x2, 0x1128, 0x112a, 0x7, 0x1ab, 
       0x2, 0x2, 0x1129, 0x111e, 0x3, 0x2, 0x2, 0x2, 0x1129, 0x1125, 0x3, 
       0x2, 0x2, 0x2, 0x112a, 0x209, 0x3, 0x2, 0x2, 0x2, 0x112b, 0x112c, 
       0x7, 0x2b8, 0x2, 0x2, 0x112c, 0x112d, 0x5, 0x22a, 0x116, 0x2, 0x112d, 
       0x20b, 0x3, 0x2, 0x2, 0x2, 0x112e, 0x112f, 0x7, 0x2a4, 0x2, 0x2, 
       0x112f, 0x1137, 0x7, 0x2b4, 0x2, 0x2, 0x1130, 0x1138, 0x5, 0x22a, 
       0x116, 0x2, 0x1131, 0x1133, 0x7, 0x3c, 0x2, 0x2, 0x1132, 0x1134, 
       0x5, 0x20a, 0x106, 0x2, 0x1133, 0x1132, 0x3, 0x2, 0x2, 0x2, 0x1133, 
       0x1134, 0x3, 0x2, 0x2, 0x2, 0x1134, 0x1138, 0x3, 0x2, 0x2, 0x2, 0x1135, 
       0x1138, 0x7, 0x194, 0x2, 0x2, 0x1136, 0x1138, 0x7, 0xae, 0x2, 0x2, 
       0x1137, 0x1130, 0x3, 0x2, 0x2, 0x2, 0x1137, 0x1131, 0x3, 0x2, 0x2, 
       0x2, 0x1137, 0x1135, 0x3, 0x2, 0x2, 0x2, 0x1137, 0x1136, 0x3, 0x2, 
       0x2, 0x2, 0x1138, 0x20d, 0x3, 0x2, 0x2, 0x2, 0x1139, 0x113a, 0x7, 
       0x43, 0x2, 0x2, 0x113a, 0x113c, 0x7, 0x28a, 0x2, 0x2, 0x113b, 0x113d, 
       0x5, 0x20c, 0x107, 0x2, 0x113c, 0x113b, 0x3, 0x2, 0x2, 0x2, 0x113c, 
       0x113d, 0x3, 0x2, 0x2, 0x2, 0x113d, 0x20f, 0x3, 0x2, 0x2, 0x2, 0x113e, 
       0x113f, 0x6, 0x109, 0x64, 0x2, 0x113f, 0x1140, 0x5, 0x1fc, 0xff, 
       0x2, 0x1140, 0x211, 0x3, 0x2, 0x2, 0x2, 0x1141, 0x1142, 0x7, 0x1e9, 
       0x2, 0x2, 0x1142, 0x1143, 0x7, 0x28a, 0x2, 0x2, 0x1143, 0x1144, 0x5, 
       0x3f4, 0x1fb, 0x2, 0x1144, 0x1145, 0x7, 0x26e, 0x2, 0x2, 0x1145, 
       0x114d, 0x5, 0x3f4, 0x1fb, 0x2, 0x1146, 0x1147, 0x7, 0x20, 0x2, 0x2, 
       0x1147, 0x1148, 0x5, 0x3f4, 0x1fb, 0x2, 0x1148, 0x1149, 0x7, 0x26e, 
       0x2, 0x2, 0x1149, 0x114a, 0x5, 0x3f4, 0x1fb, 0x2, 0x114a, 0x114c, 
       0x3, 0x2, 0x2, 0x2, 0x114b, 0x1146, 0x3, 0x2, 0x2, 0x2, 0x114c, 0x114f, 
       0x3, 0x2, 0x2, 0x2, 0x114d, 0x114b, 0x3, 0x2, 0x2, 0x2, 0x114d, 0x114e, 
       0x3, 0x2, 0x2, 0x2, 0x114e, 0x213, 0x3, 0x2, 0x2, 0x2, 0x114f, 0x114d, 
       0x3, 0x2, 0x2, 0x2, 0x1150, 0x1172, 0x7, 0x201, 0x2, 0x2, 0x1151, 
       0x1152, 0x6, 0x10b, 0x65, 0x2, 0x1152, 0x1153, 0x5, 0x21c, 0x10f, 
       0x2, 0x1153, 0x1154, 0x7, 0xf4, 0x2, 0x2, 0x1154, 0x1155, 0x5, 0x3e4, 
       0x1f3, 0x2, 0x1155, 0x1173, 0x3, 0x2, 0x2, 0x2, 0x1156, 0x1157, 0x5, 
       0x21c, 0x10f, 0x2, 0x1157, 0x1158, 0x5, 0x216, 0x10c, 0x2, 0x1158, 
       0x1159, 0x7, 0xf4, 0x2, 0x2, 0x1159, 0x115a, 0x5, 0x3e4, 0x1f3, 0x2, 
       0x115a, 0x1173, 0x3, 0x2, 0x2, 0x2, 0x115b, 0x115d, 0x7, 0x3c, 0x2, 
       0x2, 0x115c, 0x115e, 0x7, 0x1c9, 0x2, 0x2, 0x115d, 0x115c, 0x3, 0x2, 
       0x2, 0x2, 0x115d, 0x115e, 0x3, 0x2, 0x2, 0x2, 0x115e, 0x116a, 0x3, 
       0x2, 0x2, 0x2, 0x115f, 0x1160, 0x6, 0x10b, 0x66, 0x2, 0x1160, 0x1162, 
       0x7, 0x1a2, 0x2, 0x2, 0x1161, 0x1163, 0x5, 0x218, 0x10d, 0x2, 0x1162, 
       0x1161, 0x3, 0x2, 0x2, 0x2, 0x1162, 0x1163, 0x3, 0x2, 0x2, 0x2, 0x1163, 
       0x1164, 0x3, 0x2, 0x2, 0x2, 0x1164, 0x116b, 0x5, 0x220, 0x111, 0x2, 
       0x1165, 0x1166, 0x7, 0x20, 0x2, 0x2, 0x1166, 0x1167, 0x7, 0x100, 
       0x2, 0x2, 0x1167, 0x1168, 0x7, 0x1ab, 0x2, 0x2, 0x1168, 0x1169, 0x7, 
       0xf4, 0x2, 0x2, 0x1169, 0x116b, 0x5, 0x3e4, 0x1f3, 0x2, 0x116a, 0x115f, 
       0x3, 0x2, 0x2, 0x2, 0x116a, 0x1165, 0x3, 0x2, 0x2, 0x2, 0x116b, 0x1173, 
       0x3, 0x2, 0x2, 0x2, 0x116c, 0x116d, 0x7, 0x1cf, 0x2, 0x2, 0x116d, 
       0x116e, 0x7, 0x1a2, 0x2, 0x2, 0x116e, 0x116f, 0x5, 0x3f4, 0x1fb, 
       0x2, 0x116f, 0x1170, 0x7, 0xf4, 0x2, 0x2, 0x1170, 0x1171, 0x5, 0x3e4, 
       0x1f3, 0x2, 0x1171, 0x1173, 0x3, 0x2, 0x2, 0x2, 0x1172, 0x1151, 0x3, 
       0x2, 0x2, 0x2, 0x1172, 0x1156, 0x3, 0x2, 0x2, 0x2, 0x1172, 0x115b, 
       0x3, 0x2, 0x2, 0x2, 0x1172, 0x116c, 0x3, 0x2, 0x2, 0x2, 0x1173, 0x215, 
       0x3, 0x2, 0x2, 0x2, 0x1174, 0x1175, 0x6, 0x10c, 0x67, 0x2, 0x1175, 
       0x1177, 0x7, 0x1a2, 0x2, 0x2, 0x1176, 0x1178, 0x5, 0x218, 0x10d, 
       0x2, 0x1177, 0x1176, 0x3, 0x2, 0x2, 0x2, 0x1177, 0x1178, 0x3, 0x2, 
       0x2, 0x2, 0x1178, 0x1179, 0x3, 0x2, 0x2, 0x2, 0x1179, 0x1183, 0x5, 
       0x220, 0x111, 0x2, 0x117a, 0x1180, 0x6, 0x10c, 0x68, 0x2, 0x117b, 
       0x117d, 0x7, 0x1a2, 0x2, 0x2, 0x117c, 0x117e, 0x5, 0x218, 0x10d, 
       0x2, 0x117d, 0x117c, 0x3, 0x2, 0x2, 0x2, 0x117d, 0x117e, 0x3, 0x2, 
       0x2, 0x2, 0x117e, 0x117f, 0x3, 0x2, 0x2, 0x2, 0x117f, 0x1181, 0x5, 
       0x220, 0x111, 0x2, 0x1180, 0x117b, 0x3, 0x2, 0x2, 0x2, 0x1180, 0x1181, 
       0x3, 0x2, 0x2, 0x2, 0x1181, 0x1183, 0x3, 0x2, 0x2, 0x2, 0x1182, 0x1174, 
       0x3, 0x2, 0x2, 0x2, 0x1182, 0x117a, 0x3, 0x2, 0x2, 0x2, 0x1183, 0x217, 
       0x3, 0x2, 0x2, 0x2, 0x1184, 0x1185, 0x9, 0x35, 0x2, 0x2, 0x1185, 
       0x219, 0x3, 0x2, 0x2, 0x2, 0x1186, 0x1187, 0x7, 0x21b, 0x2, 0x2, 
       0x1187, 0x118a, 0x7, 0x1ba, 0x2, 0x2, 0x1188, 0x1189, 0x7, 0xf1, 
       0x2, 0x2, 0x1189, 0x118b, 0x5, 0x3f4, 0x1fb, 0x2, 0x118a, 0x1188, 
       0x3, 0x2, 0x2, 0x2, 0x118a, 0x118b, 0x3, 0x2, 0x2, 0x2, 0x118b, 0x118c, 
       0x3, 0x2, 0x2, 0x2, 0x118c, 0x1199, 0x5, 0x498, 0x24d, 0x2, 0x118d, 
       0x118e, 0x7, 0x1ba, 0x2, 0x2, 0x118e, 0x118f, 0x7, 0x23, 0x2, 0x2, 
       0x118f, 0x1190, 0x5, 0x476, 0x23c, 0x2, 0x1190, 0x1191, 0x7, 0x24, 
       0x2, 0x2, 0x1191, 0x119a, 0x3, 0x2, 0x2, 0x2, 0x1192, 0x1193, 0x6, 
       0x10e, 0x69, 0x2, 0x1193, 0x1194, 0x7, 0x1a1, 0x2, 0x2, 0x1194, 0x1195, 
       0x7, 0x23, 0x2, 0x2, 0x1195, 0x1196, 0x5, 0x476, 0x23c, 0x2, 0x1196, 
       0x1197, 0x7, 0x24, 0x2, 0x2, 0x1197, 0x119a, 0x3, 0x2, 0x2, 0x2, 
       0x1198, 0x119a, 0x5, 0x476, 0x23c, 0x2, 0x1199, 0x118d, 0x3, 0x2, 
       0x2, 0x2, 0x1199, 0x1192, 0x3, 0x2, 0x2, 0x2, 0x1199, 0x1198, 0x3, 
       0x2, 0x2, 0x2, 0x119a, 0x119d, 0x3, 0x2, 0x2, 0x2, 0x119b, 0x119c, 
       0x6, 0x10e, 0x6a, 0x2, 0x119c, 0x119e, 0x5, 0x3f2, 0x1fa, 0x2, 0x119d, 
       0x119b, 0x3, 0x2, 0x2, 0x2, 0x119d, 0x119e, 0x3, 0x2, 0x2, 0x2, 0x119e, 
       0x11a1, 0x3, 0x2, 0x2, 0x2, 0x119f, 0x11a0, 0x6, 0x10e, 0x6b, 0x2, 
       0x11a0, 0x11a2, 0x5, 0x3ee, 0x1f8, 0x2, 0x11a1, 0x119f, 0x3, 0x2, 
       0x2, 0x2, 0x11a1, 0x11a2, 0x3, 0x2, 0x2, 0x2, 0x11a2, 0x21b, 0x3, 
       0x2, 0x2, 0x2, 0x11a3, 0x11a8, 0x5, 0x21e, 0x110, 0x2, 0x11a4, 0x11a5, 
       0x7, 0x20, 0x2, 0x2, 0x11a5, 0x11a7, 0x5, 0x21e, 0x110, 0x2, 0x11a6, 
       0x11a4, 0x3, 0x2, 0x2, 0x2, 0x11a7, 0x11aa, 0x3, 0x2, 0x2, 0x2, 0x11a8, 
       0x11a6, 0x3, 0x2, 0x2, 0x2, 0x11a8, 0x11a9, 0x3, 0x2, 0x2, 0x2, 0x11a9, 
       0x21d, 0x3, 0x2, 0x2, 0x2, 0x11aa, 0x11a8, 0x3, 0x2, 0x2, 0x2, 0x11ab, 
       0x11b6, 0x6, 0x110, 0x6c, 0x2, 0x11ac, 0x11ae, 0x5, 0x492, 0x24a, 
       0x2, 0x11ad, 0x11af, 0x5, 0x406, 0x204, 0x2, 0x11ae, 0x11ad, 0x3, 
       0x2, 0x2, 0x2, 0x11ae, 0x11af, 0x3, 0x2, 0x2, 0x2, 0x11af, 0x11b7, 
       0x3, 0x2, 0x2, 0x2, 0x11b0, 0x11b4, 0x5, 0x492, 0x24a, 0x2, 0x11b1, 
       0x11b5, 0x7, 0x2b, 0x2, 0x2, 0x11b2, 0x11b3, 0x7, 0x2a, 0x2, 0x2, 
       0x11b3, 0x11b5, 0x5, 0x48e, 0x248, 0x2, 0x11b4, 0x11b1, 0x3, 0x2, 
       0x2, 0x2, 0x11b4, 0x11b2, 0x3, 0x2, 0x2, 0x2, 0x11b5, 0x11b7, 0x3, 
       0x2, 0x2, 0x2, 0x11b6, 0x11ac, 0x3, 0x2, 0x2, 0x2, 0x11b6, 0x11b0, 
       0x3, 0x2, 0x2, 0x2, 0x11b7, 0x11d5, 0x3, 0x2, 0x2, 0x2, 0x11b8, 0x11ba, 
       0x9, 0x36, 0x2, 0x2, 0x11b9, 0x11bb, 0x5, 0x406, 0x204, 0x2, 0x11ba, 
       0x11b9, 0x3, 0x2, 0x2, 0x2, 0x11ba, 0x11bb, 0x3, 0x2, 0x2, 0x2, 0x11bb, 
       0x11d5, 0x3, 0x2, 0x2, 0x2, 0x11bc, 0x11d5, 0x9, 0x37, 0x2, 0x2, 
       0x11bd, 0x11be, 0x7, 0x100, 0x2, 0x2, 0x11be, 0x11d5, 0x7, 0x1ab, 
       0x2, 0x2, 0x11bf, 0x11c0, 0x7, 0x21e, 0x2, 0x2, 0x11c0, 0x11d5, 0x7, 
       0x9e, 0x2, 0x2, 0x11c1, 0x11c5, 0x7, 0x92, 0x2, 0x2, 0x11c2, 0x11c3, 
       0x7, 0x261, 0x2, 0x2, 0x11c3, 0x11c6, 0x7, 0x25b, 0x2, 0x2, 0x11c4, 
       0x11c6, 0x9, 0x38, 0x2, 0x2, 0x11c5, 0x11c2, 0x3, 0x2, 0x2, 0x2, 
       0x11c5, 0x11c4, 0x3, 0x2, 0x2, 0x2, 0x11c5, 0x11c6, 0x3, 0x2, 0x2, 
       0x2, 0x11c6, 0x11d5, 0x3, 0x2, 0x2, 0x2, 0x11c7, 0x11c8, 0x7, 0x144, 
       0x2, 0x2, 0x11c8, 0x11d5, 0x7, 0x25b, 0x2, 0x2, 0x11c9, 0x11ca, 0x7, 
       0x1ef, 0x2, 0x2, 0x11ca, 0x11d5, 0x9, 0x39, 0x2, 0x2, 0x11cb, 0x11cc, 
       0x7, 0x21e, 0x2, 0x2, 0x11cc, 0x11d5, 0x7, 0x29b, 0x2, 0x2, 0x11cd, 
       0x11cf, 0x7, 0x3d, 0x2, 0x2, 0x11ce, 0x11d0, 0x7, 0x206, 0x2, 0x2, 
       0x11cf, 0x11ce, 0x3, 0x2, 0x2, 0x2, 0x11cf, 0x11d0, 0x3, 0x2, 0x2, 
       0x2, 0x11d0, 0x11d5, 0x3, 0x2, 0x2, 0x2, 0x11d1, 0x11d2, 0x6, 0x110, 
       0x6d, 0x2, 0x11d2, 0x11d3, 0x9, 0x3a, 0x2, 0x2, 0x11d3, 0x11d5, 0x7, 
       0x2b4, 0x2, 0x2, 0x11d4, 0x11ab, 0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11b8, 
       0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11bc, 0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11bd, 
       0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11bf, 0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11c1, 
       0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11c7, 0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11c9, 
       0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11cb, 0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11cd, 
       0x3, 0x2, 0x2, 0x2, 0x11d4, 0x11d1, 0x3, 0x2, 0x2, 0x2, 0x11d5, 0x21f, 
       0x3, 0x2, 0x2, 0x2, 0x11d6, 0x11d9, 0x7, 0x13, 0x2, 0x2, 0x11d7, 
       0x11d8, 0x7, 0x1f, 0x2, 0x2, 0x11d8, 0x11da, 0x7, 0x13, 0x2, 0x2, 
       0x11d9, 0x11d7, 0x3, 0x2, 0x2, 0x2, 0x11d9, 0x11da, 0x3, 0x2, 0x2, 
       0x2, 0x11da, 0x11e7, 0x3, 0x2, 0x2, 0x2, 0x11db, 0x11de, 0x5, 0x414, 
       0x20b, 0x2, 0x11dc, 0x11dd, 0x7, 0x1f, 0x2, 0x2, 0x11dd, 0x11df, 
       0x7, 0x13, 0x2, 0x2, 0x11de, 0x11dc, 0x3, 0x2, 0x2, 0x2, 0x11de, 
       0x11df, 0x3, 0x2, 0x2, 0x2, 0x11df, 0x11e7, 0x3, 0x2, 0x2, 0x2, 0x11e0, 
       0x11e7, 0x5, 0x440, 0x221, 0x2, 0x11e1, 0x11e2, 0x6, 0x111, 0x6e, 
       0x2, 0x11e2, 0x11e3, 0x5, 0x414, 0x20b, 0x2, 0x11e3, 0x11e4, 0x7, 
       0x1f, 0x2, 0x2, 0x11e4, 0x11e5, 0x5, 0x440, 0x221, 0x2, 0x11e5, 0x11e7, 
       0x3, 0x2, 0x2, 0x2, 0x11e6, 0x11d6, 0x3, 0x2, 0x2, 0x2, 0x11e6, 0x11db, 
       0x3, 0x2, 0x2, 0x2, 0x11e6, 0x11e0, 0x3, 0x2, 0x2, 0x2, 0x11e6, 0x11e1, 
       0x3, 0x2, 0x2, 0x2, 0x11e7, 0x221, 0x3, 0x2, 0x2, 0x2, 0x11e8, 0x11ef, 
       0x5, 0x224, 0x113, 0x2, 0x11e9, 0x11eb, 0x7, 0x41, 0x2, 0x2, 0x11ea, 
       0x11e9, 0x3, 0x2, 0x2, 0x2, 0x11ea, 0x11eb, 0x3, 0x2, 0x2, 0x2, 0x11eb, 
       0x11ec, 0x3, 0x2, 0x2, 0x2, 0x11ec, 0x11ee, 0x5, 0x224, 0x113, 0x2, 
       0x11ed, 0x11ea, 0x3, 0x2, 0x2, 0x2, 0x11ee, 0x11f1, 0x3, 0x2, 0x2, 
       0x2, 0x11ef, 0x11ed, 0x3, 0x2, 0x2, 0x2, 0x11ef, 0x11f0, 0x3, 0x2, 
       0x2, 0x2, 0x11f0, 0x223, 0x3, 0x2, 0x2, 0x2, 0x11f1, 0x11ef, 0x3, 
       0x2, 0x2, 0x2, 0x11f2, 0x11f3, 0x7, 0x70, 0x2, 0x2, 0x11f3, 0x11f9, 
       0x5, 0x476, 0x23c, 0x2, 0x11f4, 0x11f5, 0x7, 0x12a, 0x2, 0x2, 0x11f5, 
       0x11f9, 0x5, 0x476, 0x23c, 0x2, 0x11f6, 0x11f7, 0x7, 0x24f, 0x2, 
       0x2, 0x11f7, 0x11f9, 0x5, 0x476, 0x23c, 0x2, 0x11f8, 0x11f2, 0x3, 
       0x2, 0x2, 0x2, 0x11f8, 0x11f4, 0x3, 0x2, 0x2, 0x2, 0x11f8, 0x11f6, 
       0x3, 0x2, 0x2, 0x2, 0x11f9, 0x225, 0x3, 0x2, 0x2, 0x2, 0x11fa, 0x11fb, 
       0x7, 0x100, 0x2, 0x2, 0x11fb, 0x1205, 0x7, 0x1ab, 0x2, 0x2, 0x11fc, 
       0x11fd, 0x7, 0x167, 0x2, 0x2, 0x11fd, 0x1205, 0x5, 0x466, 0x234, 
       0x2, 0x11fe, 0x11ff, 0x7, 0x16c, 0x2, 0x2, 0x11ff, 0x1205, 0x5, 0x466, 
       0x234, 0x2, 0x1200, 0x1201, 0x7, 0x166, 0x2, 0x2, 0x1201, 0x1205, 
       0x5, 0x466, 0x234, 0x2, 0x1202, 0x1203, 0x7, 0x16d, 0x2, 0x2, 0x1203, 
       0x1205, 0x5, 0x466, 0x234, 0x2, 0x1204, 0x11fa, 0x3, 0x2, 0x2, 0x2, 
       0x1204, 0x11fc, 0x3, 0x2, 0x2, 0x2, 0x1204, 0x11fe, 0x3, 0x2, 0x2, 
       0x2, 0x1204, 0x1200, 0x3, 0x2, 0x2, 0x2, 0x1204, 0x1202, 0x3, 0x2, 
       0x2, 0x2, 0x1205, 0x227, 0x3, 0x2, 0x2, 0x2, 0x1206, 0x1207, 0x7, 
       0x21b, 0x2, 0x2, 0x1207, 0x1208, 0x7, 0x2b4, 0x2, 0x2, 0x1208, 0x121e, 
       0x5, 0x22a, 0x116, 0x2, 0x1209, 0x120a, 0x7, 0x21b, 0x2, 0x2, 0x120a, 
       0x120b, 0x7, 0x2b4, 0x2, 0x2, 0x120b, 0x121e, 0x9, 0x3b, 0x2, 0x2, 
       0x120c, 0x120d, 0x7, 0x21b, 0x2, 0x2, 0x120d, 0x120e, 0x7, 0xae, 
       0x2, 0x2, 0x120e, 0x1212, 0x7, 0x2b4, 0x2, 0x2, 0x120f, 0x1213, 0x5, 
       0x22a, 0x116, 0x2, 0x1210, 0x1213, 0x7, 0x194, 0x2, 0x2, 0x1211, 
       0x1213, 0x7, 0x3c, 0x2, 0x2, 0x1212, 0x120f, 0x3, 0x2, 0x2, 0x2, 
       0x1212, 0x1210, 0x3, 0x2, 0x2, 0x2, 0x1212, 0x1211, 0x3, 0x2, 0x2, 
       0x2, 0x1213, 0x1214, 0x3, 0x2, 0x2, 0x2, 0x1214, 0x1215, 0x7, 0x26e, 
       0x2, 0x2, 0x1215, 0x121e, 0x5, 0x22a, 0x116, 0x2, 0x1216, 0x1217, 
       0x7, 0x21b, 0x2, 0x2, 0x1217, 0x1218, 0x7, 0x2b4, 0x2, 0x2, 0x1218, 
       0x121b, 0x7, 0x3c, 0x2, 0x2, 0x1219, 0x121a, 0x7, 0x2b8, 0x2, 0x2, 
       0x121a, 0x121c, 0x5, 0x22a, 0x116, 0x2, 0x121b, 0x1219, 0x3, 0x2, 
       0x2, 0x2, 0x121b, 0x121c, 0x3, 0x2, 0x2, 0x2, 0x121c, 0x121e, 0x3, 
       0x2, 0x2, 0x2, 0x121d, 0x1206, 0x3, 0x2, 0x2, 0x2, 0x121d, 0x1209, 
       0x3, 0x2, 0x2, 0x2, 0x121d, 0x120c, 0x3, 0x2, 0x2, 0x2, 0x121d, 0x1216, 
       0x3, 0x2, 0x2, 0x2, 0x121e, 0x229, 0x3, 0x2, 0x2, 0x2, 0x121f, 0x1224, 
       0x5, 0x22c, 0x117, 0x2, 0x1220, 0x1221, 0x7, 0x20, 0x2, 0x2, 0x1221, 
       0x1223, 0x5, 0x22c, 0x117, 0x2, 0x1222, 0x1220, 0x3, 0x2, 0x2, 0x2, 
       0x1223, 0x1226, 0x3, 0x2, 0x2, 0x2, 0x1224, 0x1222, 0x3, 0x2, 0x2, 
       0x2, 0x1224, 0x1225, 0x3, 0x2, 0x2, 0x2, 0x1225, 0x22b, 0x3, 0x2, 
       0x2, 0x2, 0x1226, 0x1224, 0x3, 0x2, 0x2, 0x2, 0x1227, 0x122a, 0x5, 
       0x492, 0x24a, 0x2, 0x1228, 0x1229, 0x7, 0x2a, 0x2, 0x2, 0x1229, 0x122b, 
       0x5, 0x48e, 0x248, 0x2, 0x122a, 0x1228, 0x3, 0x2, 0x2, 0x2, 0x122a, 
       0x122b, 0x3, 0x2, 0x2, 0x2, 0x122b, 0x22d, 0x3, 0x2, 0x2, 0x2, 0x122c, 
       0x122e, 0x7, 0x40, 0x2, 0x2, 0x122d, 0x122f, 0x5, 0x3fc, 0x1ff, 0x2, 
       0x122e, 0x122d, 0x3, 0x2, 0x2, 0x2, 0x122e, 0x122f, 0x3, 0x2, 0x2, 
       0x2, 0x122f, 0x1230, 0x3, 0x2, 0x2, 0x2, 0x1230, 0x1231, 0x7, 0x25e, 
       0x2, 0x2, 0x1231, 0x1258, 0x5, 0x442, 0x222, 0x2, 0x1232, 0x1233, 
       0x7, 0x6f, 0x2, 0x2, 0x1233, 0x1234, 0x7, 0x25e, 0x2, 0x2, 0x1234, 
       0x1238, 0x5, 0x442, 0x222, 0x2, 0x1235, 0x1237, 0x5, 0x232, 0x11a, 
       0x2, 0x1236, 0x1235, 0x3, 0x2, 0x2, 0x2, 0x1237, 0x123a, 0x3, 0x2, 
       0x2, 0x2, 0x1238, 0x1236, 0x3, 0x2, 0x2, 0x2, 0x1238, 0x1239, 0x3, 
       0x2, 0x2, 0x2, 0x1239, 0x1258, 0x3, 0x2, 0x2, 0x2, 0x123a, 0x1238, 
       0x3, 0x2, 0x2, 0x2, 0x123b, 0x123c, 0x7, 0x6e, 0x2, 0x2, 0x123c, 
       0x123d, 0x7, 0x25e, 0x2, 0x2, 0x123d, 0x123f, 0x5, 0x442, 0x222, 
       0x2, 0x123e, 0x1240, 0x9, 0x3c, 0x2, 0x2, 0x123f, 0x123e, 0x3, 0x2, 
       0x2, 0x2, 0x123f, 0x1240, 0x3, 0x2, 0x2, 0x2, 0x1240, 0x1258, 0x3, 
       0x2, 0x2, 0x2, 0x1241, 0x1243, 0x7, 0x1a8, 0x2, 0x2, 0x1242, 0x1244, 
       0x5, 0x3fc, 0x1ff, 0x2, 0x1243, 0x1242, 0x3, 0x2, 0x2, 0x2, 0x1243, 
       0x1244, 0x3, 0x2, 0x2, 0x2, 0x1244, 0x1245, 0x3, 0x2, 0x2, 0x2, 0x1245, 
       0x1246, 0x7, 0x25e, 0x2, 0x2, 0x1246, 0x1249, 0x5, 0x442, 0x222, 
       0x2, 0x1247, 0x1248, 0x6, 0x118, 0x6f, 0x2, 0x1248, 0x124a, 0x5, 
       0x230, 0x119, 0x2, 0x1249, 0x1247, 0x3, 0x2, 0x2, 0x2, 0x1249, 0x124a, 
       0x3, 0x2, 0x2, 0x2, 0x124a, 0x1258, 0x3, 0x2, 0x2, 0x2, 0x124b, 0x124d, 
       0x7, 0x1eb, 0x2, 0x2, 0x124c, 0x124e, 0x5, 0x3fc, 0x1ff, 0x2, 0x124d, 
       0x124c, 0x3, 0x2, 0x2, 0x2, 0x124d, 0x124e, 0x3, 0x2, 0x2, 0x2, 0x124e, 
       0x124f, 0x3, 0x2, 0x2, 0x2, 0x124f, 0x1250, 0x7, 0x25e, 0x2, 0x2, 
       0x1250, 0x1254, 0x5, 0x442, 0x222, 0x2, 0x1251, 0x1253, 0x5, 0x234, 
       0x11b, 0x2, 0x1252, 0x1251, 0x3, 0x2, 0x2, 0x2, 0x1253, 0x1256, 0x3, 
       0x2, 0x2, 0x2, 0x1254, 0x1252, 0x3, 0x2, 0x2, 0x2, 0x1254, 0x1255, 
       0x3, 0x2, 0x2, 0x2, 0x1255, 0x1258, 0x3, 0x2, 0x2, 0x2, 0x1256, 0x1254, 
       0x3, 0x2, 0x2, 0x2, 0x1257, 0x122c, 0x3, 0x2, 0x2, 0x2, 0x1257, 0x1232, 
       0x3, 0x2, 0x2, 0x2, 0x1257, 0x123b, 0x3, 0x2, 0x2, 0x2, 0x1257, 0x1241, 
       0x3, 0x2, 0x2, 0x2, 0x1257, 0x124b, 0x3, 0x2, 0x2, 0x2, 0x1258, 0x22f, 
       0x3, 0x2, 0x2, 0x2, 0x1259, 0x125a, 0x7, 0x286, 0x2, 0x2, 0x125a, 
       0x125b, 0x7, 0x2c3, 0x2, 0x2, 0x125b, 0x125c, 0x7, 0x1a2, 0x2, 0x2, 
       0x125c, 0x1260, 0x5, 0x45c, 0x22f, 0x2, 0x125d, 0x125e, 0x7, 0x2a4, 
       0x2, 0x2, 0x125e, 0x125f, 0x7, 0x6, 0x2, 0x2, 0x125f, 0x1261, 0x7, 
       0x2c4, 0x2, 0x2, 0x1260, 0x125d, 0x3, 0x2, 0x2, 0x2, 0x1260, 0x1261, 
       0x3, 0x2, 0x2, 0x2, 0x1261, 0x1267, 0x3, 0x2, 0x2, 0x2, 0x1262, 0x1263, 
       0x7, 0xc1, 0x2, 0x2, 0x1263, 0x1264, 0x7, 0x2c3, 0x2, 0x2, 0x1264, 
       0x1265, 0x7, 0x1a2, 0x2, 0x2, 0x1265, 0x1267, 0x5, 0x45c, 0x22f, 
       0x2, 0x1266, 0x1259, 0x3, 0x2, 0x2, 0x2, 0x1266, 0x1262, 0x3, 0x2, 
       0x2, 0x2, 0x1267, 0x231, 0x3, 0x2, 0x2, 0x2, 0x1268, 0x1269, 0x7, 
       0xf1, 0x2, 0x2, 0x1269, 0x126c, 0x7, 0x287, 0x2, 0x2, 0x126a, 0x126c, 
       0x9, 0x3d, 0x2, 0x2, 0x126b, 0x1268, 0x3, 0x2, 0x2, 0x2, 0x126b, 
       0x126a, 0x3, 0x2, 0x2, 0x2, 0x126c, 0x233, 0x3, 0x2, 0x2, 0x2, 0x126d, 
       0x126e, 0x9, 0x3e, 0x2, 0x2, 0x126e, 0x235, 0x3, 0x2, 0x2, 0x2, 0x126f, 
       0x1270, 0x7, 0x11e, 0x2, 0x2, 0x1270, 0x1271, 0x7, 0x1be, 0x2, 0x2, 
       0x1271, 0x1272, 0x5, 0x45a, 0x22e, 0x2, 0x1272, 0x1273, 0x7, 0x228, 
       0x2, 0x2, 0x1273, 0x1274, 0x5, 0x474, 0x23b, 0x2, 0x1274, 0x1286, 
       0x3, 0x2, 0x2, 0x2, 0x1275, 0x1276, 0x7, 0x11e, 0x2, 0x2, 0x1276, 
       0x1277, 0x7, 0x2b9, 0x2, 0x2, 0x1277, 0x1286, 0x5, 0x47e, 0x240, 
       0x2, 0x1278, 0x1279, 0x7, 0x27f, 0x2, 0x2, 0x1279, 0x127a, 0x7, 0x1be, 
       0x2, 0x2, 0x127a, 0x1286, 0x5, 0x450, 0x229, 0x2, 0x127b, 0x127c, 
       0x7, 0x27f, 0x2, 0x2, 0x127c, 0x127d, 0x7, 0x2b9, 0x2, 0x2, 0x127d, 
       0x1282, 0x5, 0x452, 0x22a, 0x2, 0x127e, 0x127f, 0x7, 0x20, 0x2, 0x2, 
       0x127f, 0x1281, 0x5, 0x452, 0x22a, 0x2, 0x1280, 0x127e, 0x3, 0x2, 
       0x2, 0x2, 0x1281, 0x1284, 0x3, 0x2, 0x2, 0x2, 0x1282, 0x1280, 0x3, 
       0x2, 0x2, 0x2, 0x1282, 0x1283, 0x3, 0x2, 0x2, 0x2, 0x1283, 0x1286, 
       0x3, 0x2, 0x2, 0x2, 0x1284, 0x1282, 0x3, 0x2, 0x2, 0x2, 0x1285, 0x126f, 
       0x3, 0x2, 0x2, 0x2, 0x1285, 0x1275, 0x3, 0x2, 0x2, 0x2, 0x1285, 0x1278, 
       0x3, 0x2, 0x2, 0x2, 0x1285, 0x127b, 0x3, 0x2, 0x2, 0x2, 0x1286, 0x237, 
       0x3, 0x2, 0x2, 0x2, 0x1287, 0x129c, 0x7, 0x21b, 0x2, 0x2, 0x1288, 
       0x128a, 0x5, 0x49a, 0x24e, 0x2, 0x1289, 0x1288, 0x3, 0x2, 0x2, 0x2, 
       0x1289, 0x128a, 0x3, 0x2, 0x2, 0x2, 0x128a, 0x1292, 0x3, 0x2, 0x2, 
       0x2, 0x128b, 0x128c, 0x7, 0x270, 0x2, 0x2, 0x128c, 0x1293, 0x5, 0x1a6, 
       0xd4, 0x2, 0x128d, 0x1290, 0x5, 0x23e, 0x120, 0x2, 0x128e, 0x128f, 
       0x7, 0x20, 0x2, 0x2, 0x128f, 0x1291, 0x5, 0x242, 0x122, 0x2, 0x1290, 
       0x128e, 0x3, 0x2, 0x2, 0x2, 0x1290, 0x1291, 0x3, 0x2, 0x2, 0x2, 0x1291, 
       0x1293, 0x3, 0x2, 0x2, 0x2, 0x1292, 0x128b, 0x3, 0x2, 0x2, 0x2, 0x1292, 
       0x128d, 0x3, 0x2, 0x2, 0x2, 0x1293, 0x129d, 0x3, 0x2, 0x2, 0x2, 0x1294, 
       0x1296, 0x7, 0x1a3, 0x2, 0x2, 0x1295, 0x1294, 0x3, 0x2, 0x2, 0x2, 
       0x1295, 0x1296, 0x3, 0x2, 0x2, 0x2, 0x1296, 0x1297, 0x3, 0x2, 0x2, 
       0x2, 0x1297, 0x129a, 0x5, 0x23a, 0x11e, 0x2, 0x1298, 0x1299, 0x7, 
       0x20, 0x2, 0x2, 0x1299, 0x129b, 0x5, 0x242, 0x122, 0x2, 0x129a, 0x1298, 
       0x3, 0x2, 0x2, 0x2, 0x129a, 0x129b, 0x3, 0x2, 0x2, 0x2, 0x129b, 0x129d, 
       0x3, 0x2, 0x2, 0x2, 0x129c, 0x1289, 0x3, 0x2, 0x2, 0x2, 0x129c, 0x1295, 
       0x3, 0x2, 0x2, 0x2, 0x129d, 0x239, 0x3, 0x2, 0x2, 0x2, 0x129e, 0x129f, 
       0x5, 0x2da, 0x16e, 0x2, 0x129f, 0x12a0, 0x5, 0x498, 0x24d, 0x2, 0x12a0, 
       0x12a1, 0x5, 0x240, 0x121, 0x2, 0x12a1, 0x12b8, 0x3, 0x2, 0x2, 0x2, 
       0x12a2, 0x12b8, 0x5, 0x3da, 0x1ee, 0x2, 0x12a3, 0x12a4, 0x5, 0x2d6, 
       0x16c, 0x2, 0x12a4, 0x12a5, 0x5, 0x498, 0x24d, 0x2, 0x12a5, 0x12a6, 
       0x5, 0x294, 0x14b, 0x2, 0x12a6, 0x12b8, 0x3, 0x2, 0x2, 0x2, 0x12a7, 
       0x12a8, 0x5, 0x23c, 0x11f, 0x2, 0x12a8, 0x12a9, 0x5, 0x498, 0x24d, 
       0x2, 0x12a9, 0x12aa, 0x5, 0x240, 0x121, 0x2, 0x12aa, 0x12b8, 0x3, 
       0x2, 0x2, 0x2, 0x12ab, 0x12b5, 0x7, 0x188, 0x2, 0x2, 0x12ac, 0x12ad, 
       0x5, 0x498, 0x24d, 0x2, 0x12ad, 0x12ae, 0x5, 0x294, 0x14b, 0x2, 0x12ae, 
       0x12b6, 0x3, 0x2, 0x2, 0x2, 0x12af, 0x12b1, 0x5, 0x39c, 0x1cf, 0x2, 
       0x12b0, 0x12b2, 0x5, 0x3ce, 0x1e8, 0x2, 0x12b1, 0x12b0, 0x3, 0x2, 
       0x2, 0x2, 0x12b1, 0x12b2, 0x3, 0x2, 0x2, 0x2, 0x12b2, 0x12b6, 0x3, 
       0x2, 0x2, 0x2, 0x12b3, 0x12b4, 0x6, 0x11e, 0x70, 0x2, 0x12b4, 0x12b6, 
       0x7, 0xae, 0x2, 0x2, 0x12b5, 0x12ac, 0x3, 0x2, 0x2, 0x2, 0x12b5, 
       0x12af, 0x3, 0x2, 0x2, 0x2, 0x12b5, 0x12b3, 0x3, 0x2, 0x2, 0x2, 0x12b6, 
       0x12b8, 0x3, 0x2, 0x2, 0x2, 0x12b7, 0x129e, 0x3, 0x2, 0x2, 0x2, 0x12b7, 
       0x12a2, 0x3, 0x2, 0x2, 0x2, 0x12b7, 0x12a3, 0x3, 0x2, 0x2, 0x2, 0x12b7, 
       0x12a7, 0x3, 0x2, 0x2, 0x2, 0x12b7, 0x12ab, 0x3, 0x2, 0x2, 0x2, 0x12b8, 
       0x23b, 0x3, 0x2, 0x2, 0x2, 0x12b9, 0x12bb, 0x7, 0x2c, 0x2, 0x2, 0x12ba, 
       0x12bc, 0x5, 0x49e, 0x250, 0x2, 0x12bb, 0x12ba, 0x3, 0x2, 0x2, 0x2, 
       0x12bb, 0x12bc, 0x3, 0x2, 0x2, 0x2, 0x12bc, 0x12bd, 0x3, 0x2, 0x2, 
       0x2, 0x12bd, 0x12be, 0x5, 0x2da, 0x16e, 0x2, 0x12be, 0x23d, 0x3, 
       0x2, 0x2, 0x2, 0x12bf, 0x12c0, 0x5, 0x2da, 0x16e, 0x2, 0x12c0, 0x12c1, 
       0x5, 0x498, 0x24d, 0x2, 0x12c1, 0x12c2, 0x5, 0x240, 0x121, 0x2, 0x12c2, 
       0x23f, 0x3, 0x2, 0x2, 0x2, 0x12c3, 0x12c8, 0x5, 0x294, 0x14b, 0x2, 
       0x12c4, 0x12c8, 0x9, 0x3f, 0x2, 0x2, 0x12c5, 0x12c6, 0x6, 0x121, 
       0x71, 0x2, 0x12c6, 0x12c8, 0x9, 0x40, 0x2, 0x2, 0x12c7, 0x12c3, 0x3, 
       0x2, 0x2, 0x2, 0x12c7, 0x12c4, 0x3, 0x2, 0x2, 0x2, 0x12c7, 0x12c5, 
       0x3, 0x2, 0x2, 0x2, 0x12c8, 0x241, 0x3, 0x2, 0x2, 0x2, 0x12c9, 0x12ce, 
       0x5, 0x244, 0x123, 0x2, 0x12ca, 0x12cb, 0x7, 0x20, 0x2, 0x2, 0x12cb, 
       0x12cd, 0x5, 0x244, 0x123, 0x2, 0x12cc, 0x12ca, 0x3, 0x2, 0x2, 0x2, 
       0x12cd, 0x12d0, 0x3, 0x2, 0x2, 0x2, 0x12ce, 0x12cc, 0x3, 0x2, 0x2, 
       0x2, 0x12ce, 0x12cf, 0x3, 0x2, 0x2, 0x2, 0x12cf, 0x243, 0x3, 0x2, 
       0x2, 0x2, 0x12d0, 0x12ce, 0x3, 0x2, 0x2, 0x2, 0x12d1, 0x12d2, 0x5, 
       0x49a, 0x24e, 0x2, 0x12d2, 0x12d3, 0x5, 0x2da, 0x16e, 0x2, 0x12d3, 
       0x12d4, 0x5, 0x498, 0x24d, 0x2, 0x12d4, 0x12d5, 0x5, 0x240, 0x121, 
       0x2, 0x12d5, 0x12d8, 0x3, 0x2, 0x2, 0x2, 0x12d6, 0x12d8, 0x5, 0x23a, 
       0x11e, 0x2, 0x12d7, 0x12d1, 0x3, 0x2, 0x2, 0x2, 0x12d7, 0x12d6, 0x3, 
       0x2, 0x2, 0x2, 0x12d8, 0x245, 0x3, 0x2, 0x2, 0x2, 0x12d9, 0x13b5, 
       0x7, 0x21e, 0x2, 0x2, 0x12da, 0x12db, 0x6, 0x124, 0x72, 0x2, 0x12db, 
       0x13b6, 0x7, 0x48, 0x2, 0x2, 0x12dc, 0x12de, 0x7, 0x9e, 0x2, 0x2, 
       0x12dd, 0x12df, 0x5, 0x3f8, 0x1fd, 0x2, 0x12de, 0x12dd, 0x3, 0x2, 
       0x2, 0x2, 0x12de, 0x12df, 0x3, 0x2, 0x2, 0x2, 0x12df, 0x13b6, 0x3, 
       0x2, 0x2, 0x2, 0x12e0, 0x12e2, 0x5, 0x248, 0x125, 0x2, 0x12e1, 0x12e0, 
       0x3, 0x2, 0x2, 0x2, 0x12e1, 0x12e2, 0x3, 0x2, 0x2, 0x2, 0x12e2, 0x12e3, 
       0x3, 0x2, 0x2, 0x2, 0x12e3, 0x12e5, 0x7, 0x25b, 0x2, 0x2, 0x12e4, 
       0x12e6, 0x5, 0x24e, 0x128, 0x2, 0x12e5, 0x12e4, 0x3, 0x2, 0x2, 0x2, 
       0x12e5, 0x12e6, 0x3, 0x2, 0x2, 0x2, 0x12e6, 0x12e8, 0x3, 0x2, 0x2, 
       0x2, 0x12e7, 0x12e9, 0x5, 0x3f8, 0x1fd, 0x2, 0x12e8, 0x12e7, 0x3, 
       0x2, 0x2, 0x2, 0x12e8, 0x12e9, 0x3, 0x2, 0x2, 0x2, 0x12e9, 0x13b6, 
       0x3, 0x2, 0x2, 0x2, 0x12ea, 0x12ec, 0x7, 0xf5, 0x2, 0x2, 0x12eb, 
       0x12ea, 0x3, 0x2, 0x2, 0x2, 0x12eb, 0x12ec, 0x3, 0x2, 0x2, 0x2, 0x12ec, 
       0x12ed, 0x3, 0x2, 0x2, 0x2, 0x12ed, 0x12ef, 0x7, 0x271, 0x2, 0x2, 
       0x12ee, 0x12f0, 0x5, 0x24e, 0x128, 0x2, 0x12ef, 0x12ee, 0x3, 0x2, 
       0x2, 0x2, 0x12ef, 0x12f0, 0x3, 0x2, 0x2, 0x2, 0x12f0, 0x12f2, 0x3, 
       0x2, 0x2, 0x2, 0x12f1, 0x12f3, 0x5, 0x3f8, 0x1fd, 0x2, 0x12f2, 0x12f1, 
       0x3, 0x2, 0x2, 0x2, 0x12f2, 0x12f3, 0x3, 0x2, 0x2, 0x2, 0x12f3, 0x13b6, 
       0x3, 0x2, 0x2, 0x2, 0x12f4, 0x12f6, 0x7, 0xd6, 0x2, 0x2, 0x12f5, 
       0x12f7, 0x5, 0x24e, 0x128, 0x2, 0x12f6, 0x12f5, 0x3, 0x2, 0x2, 0x2, 
       0x12f6, 0x12f7, 0x3, 0x2, 0x2, 0x2, 0x12f7, 0x12f9, 0x3, 0x2, 0x2, 
       0x2, 0x12f8, 0x12fa, 0x5, 0x3f8, 0x1fd, 0x2, 0x12f9, 0x12f8, 0x3, 
       0x2, 0x2, 0x2, 0x12f9, 0x12fa, 0x3, 0x2, 0x2, 0x2, 0x12fa, 0x13b6, 
       0x3, 0x2, 0x2, 0x2, 0x12fb, 0x12fc, 0x7, 0x25e, 0x2, 0x2, 0x12fc, 
       0x12fe, 0x7, 0x243, 0x2, 0x2, 0x12fd, 0x12ff, 0x5, 0x24e, 0x128, 
       0x2, 0x12fe, 0x12fd, 0x3, 0x2, 0x2, 0x2, 0x12fe, 0x12ff, 0x3, 0x2, 
       0x2, 0x2, 0x12ff, 0x1301, 0x3, 0x2, 0x2, 0x2, 0x1300, 0x1302, 0x5, 
       0x3f8, 0x1fd, 0x2, 0x1301, 0x1300, 0x3, 0x2, 0x2, 0x2, 0x1301, 0x1302, 
       0x3, 0x2, 0x2, 0x2, 0x1302, 0x13b6, 0x3, 0x2, 0x2, 0x2, 0x1303, 0x1304, 
       0x7, 0x1a7, 0x2, 0x2, 0x1304, 0x1306, 0x7, 0x25b, 0x2, 0x2, 0x1305, 
       0x1307, 0x5, 0x24e, 0x128, 0x2, 0x1306, 0x1305, 0x3, 0x2, 0x2, 0x2, 
       0x1306, 0x1307, 0x3, 0x2, 0x2, 0x2, 0x1307, 0x1309, 0x3, 0x2, 0x2, 
       0x2, 0x1308, 0x130a, 0x5, 0x3f8, 0x1fd, 0x2, 0x1309, 0x1308, 0x3, 
       0x2, 0x2, 0x2, 0x1309, 0x130a, 0x3, 0x2, 0x2, 0x2, 0x130a, 0x13b6, 
       0x3, 0x2, 0x2, 0x2, 0x130b, 0x13b6, 0x7, 0x1bc, 0x2, 0x2, 0x130c, 
       0x130f, 0x7, 0xd0, 0x2, 0x2, 0x130d, 0x1310, 0x5, 0x438, 0x21d, 0x2, 
       0x130e, 0x1310, 0x7, 0x3c, 0x2, 0x2, 0x130f, 0x130d, 0x3, 0x2, 0x2, 
       0x2, 0x130f, 0x130e, 0x3, 0x2, 0x2, 0x2, 0x1310, 0x1311, 0x3, 0x2, 
       0x2, 0x2, 0x1311, 0x13b6, 0x9, 0x41, 0x2, 0x2, 0x1312, 0x1314, 0x5, 
       0x248, 0x125, 0x2, 0x1313, 0x1312, 0x3, 0x2, 0x2, 0x2, 0x1313, 0x1314, 
       0x3, 0x2, 0x2, 0x2, 0x1314, 0x1315, 0x3, 0x2, 0x2, 0x2, 0x1315, 0x1316, 
       0x7, 0x78, 0x2, 0x2, 0x1316, 0x1317, 0x9, 0x42, 0x2, 0x2, 0x1317, 
       0x1319, 0x5, 0x440, 0x221, 0x2, 0x1318, 0x131a, 0x5, 0x24e, 0x128, 
       0x2, 0x1319, 0x1318, 0x3, 0x2, 0x2, 0x2, 0x1319, 0x131a, 0x3, 0x2, 
       0x2, 0x2, 0x131a, 0x131c, 0x3, 0x2, 0x2, 0x2, 0x131b, 0x131d, 0x5, 
       0x3f8, 0x1fd, 0x2, 0x131c, 0x131b, 0x3, 0x2, 0x2, 0x2, 0x131c, 0x131d, 
       0x3, 0x2, 0x2, 0x2, 0x131d, 0x13b6, 0x3, 0x2, 0x2, 0x2, 0x131e, 0x131f, 
       0x9, 0x2d, 0x2, 0x2, 0x131f, 0x13b6, 0x7, 0x146, 0x2, 0x2, 0x1320, 
       0x1327, 0x7, 0x223, 0x2, 0x2, 0x1321, 0x1328, 0x7, 0x10a, 0x2, 0x2, 
       0x1322, 0x1323, 0x7, 0x243, 0x2, 0x2, 0x1323, 0x1325, 0x5, 0x24a, 
       0x126, 0x2, 0x1324, 0x1326, 0x5, 0x2fe, 0x180, 0x2, 0x1325, 0x1324, 
       0x3, 0x2, 0x2, 0x2, 0x1325, 0x1326, 0x3, 0x2, 0x2, 0x2, 0x1326, 0x1328, 
       0x3, 0x2, 0x2, 0x2, 0x1327, 0x1321, 0x3, 0x2, 0x2, 0x2, 0x1327, 0x1322, 
       0x3, 0x2, 0x2, 0x2, 0x1328, 0x13b6, 0x3, 0x2, 0x2, 0x2, 0x1329, 0x132a, 
       0x9, 0x43, 0x2, 0x2, 0x132a, 0x132d, 0x7, 0xd6, 0x2, 0x2, 0x132b, 
       0x132c, 0x7, 0x123, 0x2, 0x2, 0x132c, 0x132e, 0x5, 0x476, 0x23c, 
       0x2, 0x132d, 0x132b, 0x3, 0x2, 0x2, 0x2, 0x132d, 0x132e, 0x3, 0x2, 
       0x2, 0x2, 0x132e, 0x1331, 0x3, 0x2, 0x2, 0x2, 0x132f, 0x1330, 0x7, 
       0xf4, 0x2, 0x2, 0x1330, 0x1332, 0x5, 0x46a, 0x236, 0x2, 0x1331, 0x132f, 
       0x3, 0x2, 0x2, 0x2, 0x1331, 0x1332, 0x3, 0x2, 0x2, 0x2, 0x1332, 0x1334, 
       0x3, 0x2, 0x2, 0x2, 0x1333, 0x1335, 0x5, 0x120, 0x91, 0x2, 0x1334, 
       0x1333, 0x3, 0x2, 0x2, 0x2, 0x1334, 0x1335, 0x3, 0x2, 0x2, 0x2, 0x1335, 
       0x1337, 0x3, 0x2, 0x2, 0x2, 0x1336, 0x1338, 0x5, 0x2fe, 0x180, 0x2, 
       0x1337, 0x1336, 0x3, 0x2, 0x2, 0x2, 0x1337, 0x1338, 0x3, 0x2, 0x2, 
       0x2, 0x1338, 0x13b6, 0x3, 0x2, 0x2, 0x2, 0x1339, 0x133a, 0x6, 0x124, 
       0x73, 0x2, 0x133a, 0x133c, 0x7, 0xe0, 0x2, 0x2, 0x133b, 0x1339, 0x3, 
       0x2, 0x2, 0x2, 0x133b, 0x133c, 0x3, 0x2, 0x2, 0x2, 0x133c, 0x133d, 
       0x3, 0x2, 0x2, 0x2, 0x133d, 0x133e, 0x9, 0x44, 0x2, 0x2, 0x133e, 
       0x133f, 0x5, 0x24c, 0x127, 0x2, 0x133f, 0x1341, 0x5, 0x440, 0x221, 
       0x2, 0x1340, 0x1342, 0x5, 0x24e, 0x128, 0x2, 0x1341, 0x1340, 0x3, 
       0x2, 0x2, 0x2, 0x1341, 0x1342, 0x3, 0x2, 0x2, 0x2, 0x1342, 0x1344, 
       0x3, 0x2, 0x2, 0x2, 0x1343, 0x1345, 0x5, 0x162, 0xb2, 0x2, 0x1344, 
       0x1343, 0x3, 0x2, 0x2, 0x2, 0x1344, 0x1345, 0x3, 0x2, 0x2, 0x2, 0x1345, 
       0x13b6, 0x3, 0x2, 0x2, 0x2, 0x1346, 0x1348, 0x7, 0x249, 0x2, 0x2, 
       0x1347, 0x1346, 0x3, 0x2, 0x2, 0x2, 0x1347, 0x1348, 0x3, 0x2, 0x2, 
       0x2, 0x1348, 0x1349, 0x3, 0x2, 0x2, 0x2, 0x1349, 0x13b6, 0x7, 0xcf, 
       0x2, 0x2, 0x134a, 0x134b, 0x7, 0x90, 0x2, 0x2, 0x134b, 0x134c, 0x7, 
       0x23, 0x2, 0x2, 0x134c, 0x134d, 0x7, 0x13, 0x2, 0x2, 0x134d, 0x134e, 
       0x7, 0x24, 0x2, 0x2, 0x134e, 0x13b6, 0x9, 0x45, 0x2, 0x2, 0x134f, 
       0x1351, 0x7, 0x29e, 0x2, 0x2, 0x1350, 0x1352, 0x5, 0x120, 0x91, 0x2, 
       0x1351, 0x1350, 0x3, 0x2, 0x2, 0x2, 0x1351, 0x1352, 0x3, 0x2, 0x2, 
       0x2, 0x1352, 0x13b6, 0x3, 0x2, 0x2, 0x2, 0x1353, 0x1355, 0x7, 0xd3, 
       0x2, 0x2, 0x1354, 0x1356, 0x5, 0x120, 0x91, 0x2, 0x1355, 0x1354, 
       0x3, 0x2, 0x2, 0x2, 0x1355, 0x1356, 0x3, 0x2, 0x2, 0x2, 0x1356, 0x13b6, 
       0x3, 0x2, 0x2, 0x2, 0x1357, 0x13b6, 0x7, 0x1ce, 0x2, 0x2, 0x1358, 
       0x1361, 0x7, 0x1cd, 0x2, 0x2, 0x1359, 0x135e, 0x5, 0x250, 0x129, 
       0x2, 0x135a, 0x135b, 0x7, 0x20, 0x2, 0x2, 0x135b, 0x135d, 0x5, 0x250, 
       0x129, 0x2, 0x135c, 0x135a, 0x3, 0x2, 0x2, 0x2, 0x135d, 0x1360, 0x3, 
       0x2, 0x2, 0x2, 0x135e, 0x135c, 0x3, 0x2, 0x2, 0x2, 0x135e, 0x135f, 
       0x3, 0x2, 0x2, 0x2, 0x135f, 0x1362, 0x3, 0x2, 0x2, 0x2, 0x1360, 0x135e, 
       0x3, 0x2, 0x2, 0x2, 0x1361, 0x1359, 0x3, 0x2, 0x2, 0x2, 0x1361, 0x1362, 
       0x3, 0x2, 0x2, 0x2, 0x1362, 0x1366, 0x3, 0x2, 0x2, 0x2, 0x1363, 0x1364, 
       0x7, 0xf1, 0x2, 0x2, 0x1364, 0x1365, 0x7, 0x1d2, 0x2, 0x2, 0x1365, 
       0x1367, 0x7, 0x6, 0x2, 0x2, 0x1366, 0x1363, 0x3, 0x2, 0x2, 0x2, 0x1366, 
       0x1367, 0x3, 0x2, 0x2, 0x2, 0x1367, 0x1369, 0x3, 0x2, 0x2, 0x2, 0x1368, 
       0x136a, 0x5, 0x120, 0x91, 0x2, 0x1369, 0x1368, 0x3, 0x2, 0x2, 0x2, 
       0x1369, 0x136a, 0x3, 0x2, 0x2, 0x2, 0x136a, 0x13b6, 0x3, 0x2, 0x2, 
       0x2, 0x136b, 0x136d, 0x5, 0x49a, 0x24e, 0x2, 0x136c, 0x136b, 0x3, 
       0x2, 0x2, 0x2, 0x136c, 0x136d, 0x3, 0x2, 0x2, 0x2, 0x136d, 0x136e, 
       0x3, 0x2, 0x2, 0x2, 0x136e, 0x1370, 0x9, 0x46, 0x2, 0x2, 0x136f, 
       0x1371, 0x5, 0x3f8, 0x1fd, 0x2, 0x1370, 0x136f, 0x3, 0x2, 0x2, 0x2, 
       0x1370, 0x1371, 0x3, 0x2, 0x2, 0x2, 0x1371, 0x13b6, 0x3, 0x2, 0x2, 
       0x2, 0x1372, 0x1374, 0x7, 0xf5, 0x2, 0x2, 0x1373, 0x1372, 0x3, 0x2, 
       0x2, 0x2, 0x1373, 0x1374, 0x3, 0x2, 0x2, 0x2, 0x1374, 0x1375, 0x3, 
       0x2, 0x2, 0x2, 0x1375, 0x13b6, 0x7, 0x1cc, 0x2, 0x2, 0x1376, 0x1378, 
       0x5, 0x2e6, 0x174, 0x2, 0x1377, 0x1379, 0x5, 0x3f8, 0x1fd, 0x2, 0x1378, 
       0x1377, 0x3, 0x2, 0x2, 0x2, 0x1378, 0x1379, 0x3, 0x2, 0x2, 0x2, 0x1379, 
       0x13b6, 0x3, 0x2, 0x2, 0x2, 0x137a, 0x137c, 0x7, 0x77, 0x2, 0x2, 
       0x137b, 0x137d, 0x5, 0x3f8, 0x1fd, 0x2, 0x137c, 0x137b, 0x3, 0x2, 
       0x2, 0x2, 0x137c, 0x137d, 0x3, 0x2, 0x2, 0x2, 0x137d, 0x13b6, 0x3, 
       0x2, 0x2, 0x2, 0x137e, 0x137f, 0x6, 0x124, 0x74, 0x2, 0x137f, 0x13b6, 
       0x7, 0x8e, 0x2, 0x2, 0x1380, 0x13b6, 0x7, 0x1c9, 0x2, 0x2, 0x1381, 
       0x1384, 0x7, 0x101, 0x2, 0x2, 0x1382, 0x1383, 0x7, 0xf1, 0x2, 0x2, 
       0x1383, 0x1385, 0x5, 0x3f4, 0x1fb, 0x2, 0x1384, 0x1382, 0x3, 0x2, 
       0x2, 0x2, 0x1384, 0x1385, 0x3, 0x2, 0x2, 0x2, 0x1385, 0x13b6, 0x3, 
       0x2, 0x2, 0x2, 0x1386, 0x1387, 0x7, 0x101, 0x2, 0x2, 0x1387, 0x1388, 
       0x7, 0xf1, 0x2, 0x2, 0x1388, 0x1389, 0x5, 0x3f4, 0x1fb, 0x2, 0x1389, 
       0x138a, 0x7, 0x28d, 0x2, 0x2, 0x138a, 0x138b, 0x5, 0x3e4, 0x1f3, 
       0x2, 0x138b, 0x13b6, 0x3, 0x2, 0x2, 0x2, 0x138c, 0x138d, 0x7, 0x161, 
       0x2, 0x2, 0x138d, 0x13b6, 0x7, 0x243, 0x2, 0x2, 0x138e, 0x13a3, 0x7, 
       0x92, 0x2, 0x2, 0x138f, 0x1391, 0x7, 0x9d, 0x2, 0x2, 0x1390, 0x1392, 
       0x5, 0x3c8, 0x1e5, 0x2, 0x1391, 0x1390, 0x3, 0x2, 0x2, 0x2, 0x1391, 
       0x1392, 0x3, 0x2, 0x2, 0x2, 0x1392, 0x1393, 0x3, 0x2, 0x2, 0x2, 0x1393, 
       0x13a4, 0x5, 0x414, 0x20b, 0x2, 0x1394, 0x1395, 0x7, 0xd7, 0x2, 0x2, 
       0x1395, 0x13a4, 0x5, 0x430, 0x219, 0x2, 0x1396, 0x1397, 0x7, 0xf7, 
       0x2, 0x2, 0x1397, 0x13a4, 0x5, 0x41c, 0x20f, 0x2, 0x1398, 0x1399, 
       0x7, 0x1ca, 0x2, 0x2, 0x1399, 0x13a4, 0x5, 0x418, 0x20d, 0x2, 0x139a, 
       0x139b, 0x7, 0x25e, 0x2, 0x2, 0x139b, 0x13a4, 0x5, 0x440, 0x221, 
       0x2, 0x139c, 0x139d, 0x7, 0x272, 0x2, 0x2, 0x139d, 0x13a4, 0x5, 0x420, 
       0x211, 0x2, 0x139e, 0x139f, 0x7, 0x29b, 0x2, 0x2, 0x139f, 0x13a4, 
       0x5, 0x424, 0x213, 0x2, 0x13a0, 0x13a1, 0x6, 0x124, 0x75, 0x2, 0x13a1, 
       0x13a2, 0x7, 0x28a, 0x2, 0x2, 0x13a2, 0x13a4, 0x5, 0x3f4, 0x1fb, 
       0x2, 0x13a3, 0x138f, 0x3, 0x2, 0x2, 0x2, 0x13a3, 0x1394, 0x3, 0x2, 
       0x2, 0x2, 0x13a3, 0x1396, 0x3, 0x2, 0x2, 0x2, 0x13a3, 0x1398, 0x3, 
       0x2, 0x2, 0x2, 0x13a3, 0x139a, 0x3, 0x2, 0x2, 0x2, 0x13a3, 0x139c, 
       0x3, 0x2, 0x2, 0x2, 0x13a3, 0x139e, 0x3, 0x2, 0x2, 0x2, 0x13a3, 0x13a0, 
       0x3, 0x2, 0x2, 0x2, 0x13a4, 0x13b6, 0x3, 0x2, 0x2, 0x2, 0x13a5, 0x13a6, 
       0x7, 0x1ca, 0x2, 0x2, 0x13a6, 0x13a8, 0x7, 0x243, 0x2, 0x2, 0x13a7, 
       0x13a9, 0x5, 0x3f8, 0x1fd, 0x2, 0x13a8, 0x13a7, 0x3, 0x2, 0x2, 0x2, 
       0x13a8, 0x13a9, 0x3, 0x2, 0x2, 0x2, 0x13a9, 0x13b6, 0x3, 0x2, 0x2, 
       0x2, 0x13aa, 0x13ab, 0x7, 0xf7, 0x2, 0x2, 0x13ab, 0x13ad, 0x7, 0x243, 
       0x2, 0x2, 0x13ac, 0x13ae, 0x5, 0x3f8, 0x1fd, 0x2, 0x13ad, 0x13ac, 
       0x3, 0x2, 0x2, 0x2, 0x13ad, 0x13ae, 0x3, 0x2, 0x2, 0x2, 0x13ae, 0x13b6, 
       0x3, 0x2, 0x2, 0x2, 0x13af, 0x13b0, 0x7, 0x1ca, 0x2, 0x2, 0x13b0, 
       0x13b1, 0x7, 0x75, 0x2, 0x2, 0x13b1, 0x13b6, 0x5, 0x418, 0x20d, 0x2, 
       0x13b2, 0x13b3, 0x7, 0xf7, 0x2, 0x2, 0x13b3, 0x13b4, 0x7, 0x75, 0x2, 
       0x2, 0x13b4, 0x13b6, 0x5, 0x41c, 0x20f, 0x2, 0x13b5, 0x12da, 0x3, 
       0x2, 0x2, 0x2, 0x13b5, 0x12dc, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x12e1, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x12eb, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x12f4, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x12fb, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1303, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x130b, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x130c, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1313, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x131e, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1320, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1329, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x133b, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1347, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x134a, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x134f, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1353, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1357, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1358, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x136c, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1373, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1376, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x137a, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x137e, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1380, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1381, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x1386, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x138c, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x138e, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x13a5, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x13aa, 0x3, 0x2, 0x2, 0x2, 0x13b5, 0x13af, 
       0x3, 0x2, 0x2, 0x2, 0x13b5, 0x13b2, 0x3, 0x2, 0x2, 0x2, 0x13b6, 0x247, 
       0x3, 0x2, 0x2, 0x2, 0x13b7, 0x13be, 0x7, 0xf5, 0x2, 0x2, 0x13b8, 
       0x13b9, 0x6, 0x125, 0x76, 0x2, 0x13b9, 0x13bb, 0x7, 0xe0, 0x2, 0x2, 
       0x13ba, 0x13bc, 0x7, 0xf5, 0x2, 0x2, 0x13bb, 0x13ba, 0x3, 0x2, 0x2, 
       0x2, 0x13bb, 0x13bc, 0x3, 0x2, 0x2, 0x2, 0x13bc, 0x13be, 0x3, 0x2, 
       0x2, 0x2, 0x13bd, 0x13b7, 0x3, 0x2, 0x2, 0x2, 0x13bd, 0x13b8, 0x3, 
       0x2, 0x2, 0x2, 0x13be, 0x249, 0x3, 0x2, 0x2, 0x2, 0x13bf, 0x13c1, 
       0x6, 0x126, 0x77, 0x2, 0x13c0, 0x13c2, 0x7, 0x195, 0x2, 0x2, 0x13c1, 
       0x13c0, 0x3, 0x2, 0x2, 0x2, 0x13c1, 0x13c2, 0x3, 0x2, 0x2, 0x2, 0x13c2, 
       0x13c5, 0x3, 0x2, 0x2, 0x2, 0x13c3, 0x13c5, 0x3, 0x2, 0x2, 0x2, 0x13c4, 
       0x13bf, 0x3, 0x2, 0x2, 0x2, 0x13c4, 0x13c3, 0x3, 0x2, 0x2, 0x2, 0x13c5, 
       0x24b, 0x3, 0x2, 0x2, 0x2, 0x13c6, 0x13c7, 0x9, 0x42, 0x2, 0x2, 0x13c7, 
       0x24d, 0x3, 0x2, 0x2, 0x2, 0x13c8, 0x13c9, 0x5, 0x24c, 0x127, 0x2, 
       0x13c9, 0x13ca, 0x5, 0x45a, 0x22e, 0x2, 0x13ca, 0x24f, 0x3, 0x2, 
       0x2, 0x2, 0x13cb, 0x13cc, 0x7, 0x5a, 0x2, 0x2, 0x13cc, 0x13d3, 0x7, 
       0x126, 0x2, 0x2, 0x13cd, 0x13ce, 0x7, 0x8c, 0x2, 0x2, 0x13ce, 0x13d3, 
       0x7, 0x258, 0x2, 0x2, 0x13cf, 0x13d0, 0x7, 0x1b4, 0x2, 0x2, 0x13d0, 
       0x13d3, 0x7, 0xe5, 0x2, 0x2, 0x13d1, 0x13d3, 0x9, 0x47, 0x2, 0x2, 
       0x13d2, 0x13cb, 0x3, 0x2, 0x2, 0x2, 0x13d2, 0x13cd, 0x3, 0x2, 0x2, 
       0x2, 0x13d2, 0x13cf, 0x3, 0x2, 0x2, 0x2, 0x13d2, 0x13d1, 0x3, 0x2, 
       0x2, 0x2, 0x13d3, 0x251, 0x3, 0x2, 0x2, 0x2, 0x13d4, 0x13d5, 0x7, 
       0x53, 0x2, 0x2, 0x13d5, 0x13fa, 0x5, 0x47a, 0x23e, 0x2, 0x13d6, 0x13d7, 
       0x7, 0x61, 0x2, 0x2, 0x13d7, 0x13d8, 0x7, 0x115, 0x2, 0x2, 0x13d8, 
       0x13d9, 0x5, 0x254, 0x12b, 0x2, 0x13d9, 0x13dc, 0x7, 0x123, 0x2, 
       0x2, 0x13da, 0x13dd, 0x5, 0x45a, 0x22e, 0x2, 0x13db, 0x13dd, 0x7, 
       0xae, 0x2, 0x2, 0x13dc, 0x13da, 0x3, 0x2, 0x2, 0x2, 0x13dc, 0x13db, 
       0x3, 0x2, 0x2, 0x2, 0x13dd, 0x13fa, 0x3, 0x2, 0x2, 0x2, 0x13de, 0x13e0, 
       0x7, 0xed, 0x2, 0x2, 0x13df, 0x13e1, 0x5, 0x3fc, 0x1ff, 0x2, 0x13e0, 
       0x13df, 0x3, 0x2, 0x2, 0x2, 0x13e0, 0x13e1, 0x3, 0x2, 0x2, 0x2, 0x13e1, 
       0x13eb, 0x3, 0x2, 0x2, 0x2, 0x13e2, 0x13ec, 0x5, 0x266, 0x134, 0x2, 
       0x13e3, 0x13e8, 0x5, 0x262, 0x132, 0x2, 0x13e4, 0x13e5, 0x7, 0x20, 
       0x2, 0x2, 0x13e5, 0x13e7, 0x5, 0x262, 0x132, 0x2, 0x13e6, 0x13e4, 
       0x3, 0x2, 0x2, 0x2, 0x13e7, 0x13ea, 0x3, 0x2, 0x2, 0x2, 0x13e8, 0x13e6, 
       0x3, 0x2, 0x2, 0x2, 0x13e8, 0x13e9, 0x3, 0x2, 0x2, 0x2, 0x13e9, 0x13ec, 
       0x3, 0x2, 0x2, 0x2, 0x13ea, 0x13e8, 0x3, 0x2, 0x2, 0x2, 0x13eb, 0x13e2, 
       0x3, 0x2, 0x2, 0x2, 0x13eb, 0x13e3, 0x3, 0x2, 0x2, 0x2, 0x13ec, 0x13fa, 
       0x3, 0x2, 0x2, 0x2, 0x13ed, 0x13ef, 0x7, 0x131, 0x2, 0x2, 0x13ee, 
       0x13f0, 0x9, 0x48, 0x2, 0x2, 0x13ef, 0x13ee, 0x3, 0x2, 0x2, 0x2, 
       0x13ef, 0x13f0, 0x3, 0x2, 0x2, 0x2, 0x13f0, 0x13f1, 0x3, 0x2, 0x2, 
       0x2, 0x13f1, 0x13fa, 0x5, 0x294, 0x14b, 0x2, 0x13f2, 0x13f3, 0x7, 
       0x140, 0x2, 0x2, 0x13f3, 0x13f4, 0x7, 0x115, 0x2, 0x2, 0x13f4, 0x13f5, 
       0x7, 0x120, 0x2, 0x2, 0x13f5, 0x13f6, 0x7, 0x61, 0x2, 0x2, 0x13f6, 
       0x13fa, 0x5, 0x26a, 0x136, 0x2, 0x13f7, 0x13f8, 0x6, 0x12a, 0x78, 
       0x2, 0x13f8, 0x13fa, 0x7, 0x21f, 0x2, 0x2, 0x13f9, 0x13d4, 0x3, 0x2, 
       0x2, 0x2, 0x13f9, 0x13d6, 0x3, 0x2, 0x2, 0x2, 0x13f9, 0x13de, 0x3, 
       0x2, 0x2, 0x2, 0x13f9, 0x13ed, 0x3, 0x2, 0x2, 0x2, 0x13f9, 0x13f2, 
       0x3, 0x2, 0x2, 0x2, 0x13f9, 0x13f7, 0x3, 0x2, 0x2, 0x2, 0x13fa, 0x253, 
       0x3, 0x2, 0x2, 0x2, 0x13fb, 0x13fe, 0x5, 0x256, 0x12c, 0x2, 0x13fc, 
       0x13fe, 0x5, 0x25a, 0x12e, 0x2, 0x13fd, 0x13fb, 0x3, 0x2, 0x2, 0x2, 
       0x13fd, 0x13fc, 0x3, 0x2, 0x2, 0x2, 0x13fe, 0x255, 0x3, 0x2, 0x2, 
       0x2, 0x13ff, 0x1404, 0x5, 0x258, 0x12d, 0x2, 0x1400, 0x1401, 0x7, 
       0x20, 0x2, 0x2, 0x1401, 0x1403, 0x5, 0x258, 0x12d, 0x2, 0x1402, 0x1400, 
       0x3, 0x2, 0x2, 0x2, 0x1403, 0x1406, 0x3, 0x2, 0x2, 0x2, 0x1404, 0x1402, 
       0x3, 0x2, 0x2, 0x2, 0x1404, 0x1405, 0x3, 0x2, 0x2, 0x2, 0x1405, 0x257, 
       0x3, 0x2, 0x2, 0x2, 0x1406, 0x1404, 0x3, 0x2, 0x2, 0x2, 0x1407, 0x1409, 
       0x5, 0x440, 0x221, 0x2, 0x1408, 0x140a, 0x5, 0x25c, 0x12f, 0x2, 0x1409, 
       0x1408, 0x3, 0x2, 0x2, 0x2, 0x1409, 0x140a, 0x3, 0x2, 0x2, 0x2, 0x140a, 
       0x259, 0x3, 0x2, 0x2, 0x2, 0x140b, 0x140c, 0x5, 0x440, 0x221, 0x2, 
       0x140c, 0x140d, 0x7, 0x1b9, 0x2, 0x2, 0x140d, 0x140e, 0x7, 0x23, 
       0x2, 0x2, 0x140e, 0x140f, 0x5, 0x3a, 0x1e, 0x2, 0x140f, 0x1411, 0x7, 
       0x24, 0x2, 0x2, 0x1410, 0x1412, 0x5, 0x25c, 0x12f, 0x2, 0x1411, 0x1410, 
       0x3, 0x2, 0x2, 0x2, 0x1411, 0x1412, 0x3, 0x2, 0x2, 0x2, 0x1412, 0x25b, 
       0x3, 0x2, 0x2, 0x2, 0x1413, 0x1414, 0x5, 0x192, 0xca, 0x2, 0x1414, 
       0x1416, 0x7, 0x23, 0x2, 0x2, 0x1415, 0x1417, 0x5, 0x260, 0x131, 0x2, 
       0x1416, 0x1415, 0x3, 0x2, 0x2, 0x2, 0x1416, 0x1417, 0x3, 0x2, 0x2, 
       0x2, 0x1417, 0x1418, 0x3, 0x2, 0x2, 0x2, 0x1418, 0x1419, 0x7, 0x24, 
       0x2, 0x2, 0x1419, 0x25d, 0x3, 0x2, 0x2, 0x2, 0x141a, 0x141d, 0x5, 
       0x45a, 0x22e, 0x2, 0x141b, 0x141d, 0x7, 0x1c8, 0x2, 0x2, 0x141c, 
       0x141a, 0x3, 0x2, 0x2, 0x2, 0x141c, 0x141b, 0x3, 0x2, 0x2, 0x2, 0x141d, 
       0x25f, 0x3, 0x2, 0x2, 0x2, 0x141e, 0x1423, 0x5, 0x25e, 0x130, 0x2, 
       0x141f, 0x1420, 0x7, 0x20, 0x2, 0x2, 0x1420, 0x1422, 0x5, 0x25e, 
       0x130, 0x2, 0x1421, 0x141f, 0x3, 0x2, 0x2, 0x2, 0x1422, 0x1425, 0x3, 
       0x2, 0x2, 0x2, 0x1423, 0x1421, 0x3, 0x2, 0x2, 0x2, 0x1423, 0x1424, 
       0x3, 0x2, 0x2, 0x2, 0x1424, 0x261, 0x3, 0x2, 0x2, 0x2, 0x1425, 0x1423, 
       0x3, 0x2, 0x2, 0x2, 0x1426, 0x1436, 0x9, 0x49, 0x2, 0x2, 0x1427, 
       0x1429, 0x5, 0x264, 0x133, 0x2, 0x1428, 0x1427, 0x3, 0x2, 0x2, 0x2, 
       0x1428, 0x1429, 0x3, 0x2, 0x2, 0x2, 0x1429, 0x142a, 0x3, 0x2, 0x2, 
       0x2, 0x142a, 0x1436, 0x7, 0x146, 0x2, 0x2, 0x142b, 0x142c, 0x7, 0x1e1, 
       0x2, 0x2, 0x142c, 0x142e, 0x7, 0x146, 0x2, 0x2, 0x142d, 0x142f, 0x5, 
       0x2fe, 0x180, 0x2, 0x142e, 0x142d, 0x3, 0x2, 0x2, 0x2, 0x142e, 0x142f, 
       0x3, 0x2, 0x2, 0x2, 0x142f, 0x1436, 0x3, 0x2, 0x2, 0x2, 0x1430, 0x1431, 
       0x6, 0x132, 0x79, 0x2, 0x1431, 0x1432, 0x7, 0x1d2, 0x2, 0x2, 0x1432, 
       0x1436, 0x7, 0x61, 0x2, 0x2, 0x1433, 0x1434, 0x6, 0x132, 0x7a, 0x2, 
       0x1434, 0x1436, 0x7, 0x1a9, 0x2, 0x2, 0x1435, 0x1426, 0x3, 0x2, 0x2, 
       0x2, 0x1435, 0x1428, 0x3, 0x2, 0x2, 0x2, 0x1435, 0x142b, 0x3, 0x2, 
       0x2, 0x2, 0x1435, 0x1430, 0x3, 0x2, 0x2, 0x2, 0x1435, 0x1433, 0x3, 
       0x2, 0x2, 0x2, 0x1436, 0x263, 0x3, 0x2, 0x2, 0x2, 0x1437, 0x1438, 
       0x9, 0x4a, 0x2, 0x2, 0x1438, 0x265, 0x3, 0x2, 0x2, 0x2, 0x1439, 0x1441, 
       0x9, 0x14, 0x2, 0x2, 0x143a, 0x143b, 0x7, 0x2a4, 0x2, 0x2, 0x143b, 
       0x143c, 0x7, 0x1d7, 0x2, 0x2, 0x143c, 0x1442, 0x7, 0x144, 0x2, 0x2, 
       0x143d, 0x143f, 0x5, 0x45c, 0x22f, 0x2, 0x143e, 0x1440, 0x5, 0x268, 
       0x135, 0x2, 0x143f, 0x143e, 0x3, 0x2, 0x2, 0x2, 0x143f, 0x1440, 0x3, 
       0x2, 0x2, 0x2, 0x1440, 0x1442, 0x3, 0x2, 0x2, 0x2, 0x1441, 0x143a, 
       0x3, 0x2, 0x2, 0x2, 0x1441, 0x143d, 0x3, 0x2, 0x2, 0x2, 0x1441, 0x1442, 
       0x3, 0x2, 0x2, 0x2, 0x1442, 0x267, 0x3, 0x2, 0x2, 0x2, 0x1443, 0x1444, 
       0x6, 0x135, 0x7b, 0x2, 0x1444, 0x1445, 0x7, 0xf1, 0x2, 0x2, 0x1445, 
       0x144a, 0x7, 0xdf, 0x2, 0x2, 0x1446, 0x1447, 0x7, 0x2a4, 0x2, 0x2, 
       0x1447, 0x1448, 0x7, 0x1d7, 0x2, 0x2, 0x1448, 0x144a, 0x7, 0x144, 
       0x2, 0x2, 0x1449, 0x1443, 0x3, 0x2, 0x2, 0x2, 0x1449, 0x1446, 0x3, 
       0x2, 0x2, 0x2, 0x144a, 0x269, 0x3, 0x2, 0x2, 0x2, 0x144b, 0x144c, 
       0x5, 0x440, 0x221, 0x2, 0x144c, 0x144e, 0x5, 0x270, 0x139, 0x2, 0x144d, 
       0x144f, 0x5, 0x25c, 0x12f, 0x2, 0x144e, 0x144d, 0x3, 0x2, 0x2, 0x2, 
       0x144e, 0x144f, 0x3, 0x2, 0x2, 0x2, 0x144f, 0x1452, 0x3, 0x2, 0x2, 
       0x2, 0x1450, 0x1451, 0x7, 0x111, 0x2, 0x2, 0x1451, 0x1453, 0x7, 0x135, 
       0x2, 0x2, 0x1452, 0x1450, 0x3, 0x2, 0x2, 0x2, 0x1452, 0x1453, 0x3, 
       0x2, 0x2, 0x2, 0x1453, 0x1456, 0x3, 0x2, 0x2, 0x2, 0x1454, 0x1456, 
       0x5, 0x26c, 0x137, 0x2, 0x1455, 0x144b, 0x3, 0x2, 0x2, 0x2, 0x1455, 
       0x1454, 0x3, 0x2, 0x2, 0x2, 0x1456, 0x26b, 0x3, 0x2, 0x2, 0x2, 0x1457, 
       0x145c, 0x5, 0x26e, 0x138, 0x2, 0x1458, 0x1459, 0x7, 0x20, 0x2, 0x2, 
       0x1459, 0x145b, 0x5, 0x26e, 0x138, 0x2, 0x145a, 0x1458, 0x3, 0x2, 
       0x2, 0x2, 0x145b, 0x145e, 0x3, 0x2, 0x2, 0x2, 0x145c, 0x145a, 0x3, 
       0x2, 0x2, 0x2, 0x145c, 0x145d, 0x3, 0x2, 0x2, 0x2, 0x145d, 0x26d, 
       0x3, 0x2, 0x2, 0x2, 0x145e, 0x145c, 0x3, 0x2, 0x2, 0x2, 0x145f, 0x1461, 
       0x5, 0x440, 0x221, 0x2, 0x1460, 0x1462, 0x5, 0x25c, 0x12f, 0x2, 0x1461, 
       0x1460, 0x3, 0x2, 0x2, 0x2, 0x1461, 0x1462, 0x3, 0x2, 0x2, 0x2, 0x1462, 
       0x1465, 0x3, 0x2, 0x2, 0x2, 0x1463, 0x1464, 0x7, 0x111, 0x2, 0x2, 
       0x1464, 0x1466, 0x7, 0x135, 0x2, 0x2, 0x1465, 0x1463, 0x3, 0x2, 0x2, 
       0x2, 0x1465, 0x1466, 0x3, 0x2, 0x2, 0x2, 0x1466, 0x26f, 0x3, 0x2, 
       0x2, 0x2, 0x1467, 0x1468, 0x7, 0x1b9, 0x2, 0x2, 0x1468, 0x1469, 0x7, 
       0x23, 0x2, 0x2, 0x1469, 0x146a, 0x5, 0x3a, 0x1e, 0x2, 0x146a, 0x146b, 
       0x7, 0x24, 0x2, 0x2, 0x146b, 0x271, 0x3, 0x2, 0x2, 0x2, 0x146c, 0x1471, 
       0x5, 0x274, 0x13b, 0x2, 0x146d, 0x1471, 0x5, 0x27e, 0x140, 0x2, 0x146e, 
       0x1471, 0x5, 0x280, 0x141, 0x2, 0x146f, 0x1471, 0x5, 0x284, 0x143, 
       0x2, 0x1470, 0x146c, 0x3, 0x2, 0x2, 0x2, 0x1470, 0x146d, 0x3, 0x2, 
       0x2, 0x2, 0x1470, 0x146e, 0x3, 0x2, 0x2, 0x2, 0x1470, 0x146f, 0x3, 
       0x2, 0x2, 0x2, 0x1471, 0x273, 0x3, 0x2, 0x2, 0x2, 0x1472, 0x1473, 
       0x7, 0x92, 0x2, 0x2, 0x1473, 0x1474, 0x7, 0x2e6, 0x2, 0x2, 0x1474, 
       0x1475, 0x7, 0x102, 0x2, 0x2, 0x1475, 0x1476, 0x5, 0x45a, 0x22e, 
       0x2, 0x1476, 0x1478, 0x7, 0x277, 0x2, 0x2, 0x1477, 0x1479, 0x5, 0x498, 
       0x24d, 0x2, 0x1478, 0x1477, 0x3, 0x2, 0x2, 0x2, 0x1478, 0x1479, 0x3, 
       0x2, 0x2, 0x2, 0x1479, 0x147a, 0x3, 0x2, 0x2, 0x2, 0x147a, 0x147c, 
       0x9, 0x4b, 0x2, 0x2, 0x147b, 0x147d, 0x5, 0x276, 0x13c, 0x2, 0x147c, 
       0x147b, 0x3, 0x2, 0x2, 0x2, 0x147c, 0x147d, 0x3, 0x2, 0x2, 0x2, 0x147d, 
       0x147f, 0x3, 0x2, 0x2, 0x2, 0x147e, 0x1480, 0x5, 0x27a, 0x13e, 0x2, 
       0x147f, 0x147e, 0x3, 0x2, 0x2, 0x2, 0x147f, 0x1480, 0x3, 0x2, 0x2, 
       0x2, 0x1480, 0x1482, 0x3, 0x2, 0x2, 0x2, 0x1481, 0x1483, 0x5, 0x27c, 
       0x13f, 0x2, 0x1482, 0x1481, 0x3, 0x2, 0x2, 0x2, 0x1482, 0x1483, 0x3, 
       0x2, 0x2, 0x2, 0x1483, 0x275, 0x3, 0x2, 0x2, 0x2, 0x1484, 0x1486, 
       0x7, 0x2e8, 0x2, 0x2, 0x1485, 0x1487, 0x5, 0x498, 0x24d, 0x2, 0x1486, 
       0x1485, 0x3, 0x2, 0x2, 0x2, 0x1486, 0x1487, 0x3, 0x2, 0x2, 0x2, 0x1487, 
       0x1488, 0x3, 0x2, 0x2, 0x2, 0x1488, 0x148f, 0x5, 0x278, 0x13d, 0x2, 
       0x1489, 0x148b, 0x7, 0x20, 0x2, 0x2, 0x148a, 0x1489, 0x3, 0x2, 0x2, 
       0x2, 0x148a, 0x148b, 0x3, 0x2, 0x2, 0x2, 0x148b, 0x148c, 0x3, 0x2, 
       0x2, 0x2, 0x148c, 0x148e, 0x5, 0x278, 0x13d, 0x2, 0x148d, 0x148a, 
       0x3, 0x2, 0x2, 0x2, 0x148e, 0x1491, 0x3, 0x2, 0x2, 0x2, 0x148f, 0x148d, 
       0x3, 0x2, 0x2, 0x2, 0x148f, 0x1490, 0x3, 0x2, 0x2, 0x2, 0x1490, 0x277, 
       0x3, 0x2, 0x2, 0x2, 0x1491, 0x148f, 0x3, 0x2, 0x2, 0x2, 0x1492, 0x1495, 
       0x7, 0x6, 0x2, 0x2, 0x1493, 0x1494, 0x7, 0x12, 0x2, 0x2, 0x1494, 
       0x1496, 0x7, 0x6, 0x2, 0x2, 0x1495, 0x1493, 0x3, 0x2, 0x2, 0x2, 0x1495, 
       0x1496, 0x3, 0x2, 0x2, 0x2, 0x1496, 0x279, 0x3, 0x2, 0x2, 0x2, 0x1497, 
       0x1499, 0x7, 0x2e5, 0x2, 0x2, 0x1498, 0x149a, 0x5, 0x498, 0x24d, 
       0x2, 0x1499, 0x1498, 0x3, 0x2, 0x2, 0x2, 0x1499, 0x149a, 0x3, 0x2, 
       0x2, 0x2, 0x149a, 0x149b, 0x3, 0x2, 0x2, 0x2, 0x149b, 0x149c, 0x7, 
       0x6, 0x2, 0x2, 0x149c, 0x27b, 0x3, 0x2, 0x2, 0x2, 0x149d, 0x149e, 
       0x9, 0x4c, 0x2, 0x2, 0x149e, 0x27d, 0x3, 0x2, 0x2, 0x2, 0x149f, 0x14a0, 
       0x7, 0x3d, 0x2, 0x2, 0x14a0, 0x14a1, 0x7, 0x2e6, 0x2, 0x2, 0x14a1, 
       0x14a2, 0x7, 0x102, 0x2, 0x2, 0x14a2, 0x14a4, 0x5, 0x454, 0x22b, 
       0x2, 0x14a3, 0x14a5, 0x5, 0x276, 0x13c, 0x2, 0x14a4, 0x14a3, 0x3, 
       0x2, 0x2, 0x2, 0x14a4, 0x14a5, 0x3, 0x2, 0x2, 0x2, 0x14a5, 0x14a7, 
       0x3, 0x2, 0x2, 0x2, 0x14a6, 0x14a8, 0x5, 0x27a, 0x13e, 0x2, 0x14a7, 
       0x14a6, 0x3, 0x2, 0x2, 0x2, 0x14a7, 0x14a8, 0x3, 0x2, 0x2, 0x2, 0x14a8, 
       0x14aa, 0x3, 0x2, 0x2, 0x2, 0x14a9, 0x14ab, 0x5, 0x27c, 0x13f, 0x2, 
       0x14aa, 0x14a9, 0x3, 0x2, 0x2, 0x2, 0x14aa, 0x14ab, 0x3, 0x2, 0x2, 
       0x2, 0x14ab, 0x14ad, 0x3, 0x2, 0x2, 0x2, 0x14ac, 0x14ae, 0x7, 0xef, 
       0x2, 0x2, 0x14ad, 0x14ac, 0x3, 0x2, 0x2, 0x2, 0x14ad, 0x14ae, 0x3, 
       0x2, 0x2, 0x2, 0x14ae, 0x27f, 0x3, 0x2, 0x2, 0x2, 0x14af, 0x14b0, 
       0x7, 0x21b, 0x2, 0x2, 0x14b0, 0x14b1, 0x7, 0x2e6, 0x2, 0x2, 0x14b1, 
       0x14b2, 0x7, 0x102, 0x2, 0x2, 0x14b2, 0x14b5, 0x5, 0x45a, 0x22e, 
       0x2, 0x14b3, 0x14b4, 0x7, 0xf1, 0x2, 0x2, 0x14b4, 0x14b6, 0x5, 0x282, 
       0x142, 0x2, 0x14b5, 0x14b3, 0x3, 0x2, 0x2, 0x2, 0x14b5, 0x14b6, 0x3, 
       0x2, 0x2, 0x2, 0x14b6, 0x281, 0x3, 0x2, 0x2, 0x2, 0x14b7, 0x14be, 
       0x5, 0x468, 0x235, 0x2, 0x14b8, 0x14ba, 0x7, 0x20, 0x2, 0x2, 0x14b9, 
       0x14b8, 0x3, 0x2, 0x2, 0x2, 0x14b9, 0x14ba, 0x3, 0x2, 0x2, 0x2, 0x14ba, 
       0x14bb, 0x3, 0x2, 0x2, 0x2, 0x14bb, 0x14bd, 0x5, 0x468, 0x235, 0x2, 
       0x14bc, 0x14b9, 0x3, 0x2, 0x2, 0x2, 0x14bd, 0x14c0, 0x3, 0x2, 0x2, 
       0x2, 0x14be, 0x14bc, 0x3, 0x2, 0x2, 0x2, 0x14be, 0x14bf, 0x3, 0x2, 
       0x2, 0x2, 0x14bf, 0x283, 0x3, 0x2, 0x2, 0x2, 0x14c0, 0x14be, 0x3, 
       0x2, 0x2, 0x2, 0x14c1, 0x14c2, 0x7, 0xc1, 0x2, 0x2, 0x14c2, 0x14c3, 
       0x7, 0x2e6, 0x2, 0x2, 0x14c3, 0x14c4, 0x7, 0x102, 0x2, 0x2, 0x14c4, 
       0x14c6, 0x5, 0x454, 0x22b, 0x2, 0x14c5, 0x14c7, 0x7, 0xef, 0x2, 0x2, 
       0x14c6, 0x14c5, 0x3, 0x2, 0x2, 0x2, 0x14c6, 0x14c7, 0x3, 0x2, 0x2, 
       0x2, 0x14c7, 0x285, 0x3, 0x2, 0x2, 0x2, 0x14c8, 0x14cf, 0x5, 0x288, 
       0x145, 0x2, 0x14c9, 0x14cf, 0x5, 0x28a, 0x146, 0x2, 0x14ca, 0x14cf, 
       0x5, 0x28e, 0x148, 0x2, 0x14cb, 0x14cf, 0x5, 0x290, 0x149, 0x2, 0x14cc, 
       0x14cd, 0x6, 0x144, 0x7c, 0x2, 0x14cd, 0x14cf, 0x5, 0x292, 0x14a, 
       0x2, 0x14ce, 0x14c8, 0x3, 0x2, 0x2, 0x2, 0x14ce, 0x14c9, 0x3, 0x2, 
       0x2, 0x2, 0x14ce, 0x14ca, 0x3, 0x2, 0x2, 0x2, 0x14ce, 0x14cb, 0x3, 
       0x2, 0x2, 0x2, 0x14ce, 0x14cc, 0x3, 0x2, 0x2, 0x2, 0x14cf, 0x287, 
       0x3, 0x2, 0x2, 0x2, 0x14d0, 0x14d1, 0x9, 0x4d, 0x2, 0x2, 0x14d1, 
       0x14d4, 0x5, 0x440, 0x221, 0x2, 0x14d2, 0x14d5, 0x5, 0x476, 0x23c, 
       0x2, 0x14d3, 0x14d5, 0x5, 0x408, 0x205, 0x2, 0x14d4, 0x14d2, 0x3, 
       0x2, 0x2, 0x2, 0x14d4, 0x14d3, 0x3, 0x2, 0x2, 0x2, 0x14d4, 0x14d5, 
       0x3, 0x2, 0x2, 0x2, 0x14d5, 0x289, 0x3, 0x2, 0x2, 0x2, 0x14d6, 0x14df, 
       0x9, 0x4d, 0x2, 0x2, 0x14d7, 0x14d8, 0x6, 0x146, 0x7d, 0x2, 0x14d8, 
       0x14e0, 0x7, 0xe0, 0x2, 0x2, 0x14d9, 0x14da, 0x6, 0x146, 0x7e, 0x2, 
       0x14da, 0x14e0, 0x7, 0x1b8, 0x2, 0x2, 0x14db, 0x14dc, 0x6, 0x146, 
       0x7f, 0x2, 0x14dc, 0x14dd, 0x7, 0xf2, 0x2, 0x2, 0x14dd, 0x14de, 0x7, 
       0x9, 0x2, 0x2, 0x14de, 0x14e0, 0x5, 0x48e, 0x248, 0x2, 0x14df, 0x14d7, 
       0x3, 0x2, 0x2, 0x2, 0x14df, 0x14d9, 0x3, 0x2, 0x2, 0x2, 0x14df, 0x14db, 
       0x3, 0x2, 0x2, 0x2, 0x14df, 0x14e0, 0x3, 0x2, 0x2, 0x2, 0x14e0, 0x14e1, 
       0x3, 0x2, 0x2, 0x2, 0x14e1, 0x14e2, 0x5, 0x28c, 0x147, 0x2, 0x14e2, 
       0x28b, 0x3, 0x2, 0x2, 0x2, 0x14e3, 0x14f0, 0x5, 0x110, 0x89, 0x2, 
       0x14e4, 0x14e9, 0x6, 0x147, 0x80, 0x2, 0x14e5, 0x14ea, 0x5, 0xe4, 
       0x73, 0x2, 0x14e6, 0x14ea, 0x5, 0xf0, 0x79, 0x2, 0x14e7, 0x14ea, 
       0x5, 0x10e, 0x88, 0x2, 0x14e8, 0x14ea, 0x5, 0x19c, 0xcf, 0x2, 0x14e9, 
       0x14e5, 0x3, 0x2, 0x2, 0x2, 0x14e9, 0x14e6, 0x3, 0x2, 0x2, 0x2, 0x14e9, 
       0x14e7, 0x3, 0x2, 0x2, 0x2, 0x14e9, 0x14e8, 0x3, 0x2, 0x2, 0x2, 0x14ea, 
       0x14f0, 0x3, 0x2, 0x2, 0x2, 0x14eb, 0x14ec, 0x6, 0x147, 0x81, 0x2, 
       0x14ec, 0x14ed, 0x7, 0xf1, 0x2, 0x2, 0x14ed, 0x14ee, 0x7, 0x85, 0x2, 
       0x2, 0x14ee, 0x14f0, 0x5, 0x468, 0x235, 0x2, 0x14ef, 0x14e3, 0x3, 
       0x2, 0x2, 0x2, 0x14ef, 0x14e4, 0x3, 0x2, 0x2, 0x2, 0x14ef, 0x14eb, 
       0x3, 0x2, 0x2, 0x2, 0x14f0, 0x28d, 0x3, 0x2, 0x2, 0x2, 0x14f1, 0x14f2, 
       0x7, 0x107, 0x2, 0x2, 0x14f2, 0x14f3, 0x5, 0x48e, 0x248, 0x2, 0x14f3, 
       0x28f, 0x3, 0x2, 0x2, 0x2, 0x14f4, 0x14f5, 0x7, 0x28c, 0x2, 0x2, 
       0x14f5, 0x14f6, 0x5, 0x45a, 0x22e, 0x2, 0x14f6, 0x291, 0x3, 0x2, 
       0x2, 0x2, 0x14f7, 0x14f8, 0x7, 0x2eb, 0x2, 0x2, 0x14f8, 0x293, 0x3, 
       0x2, 0x2, 0x2, 0x14f9, 0x14fa, 0x8, 0x14b, 0x1, 0x2, 0x14fa, 0x1500, 
       0x5, 0x296, 0x14c, 0x2, 0x14fb, 0x14fd, 0x7, 0x128, 0x2, 0x2, 0x14fc, 
       0x14fe, 0x5, 0x2e8, 0x175, 0x2, 0x14fd, 0x14fc, 0x3, 0x2, 0x2, 0x2, 
       0x14fd, 0x14fe, 0x3, 0x2, 0x2, 0x2, 0x14fe, 0x14ff, 0x3, 0x2, 0x2, 
       0x2, 0x14ff, 0x1501, 0x9, 0x4e, 0x2, 0x2, 0x1500, 0x14fb, 0x3, 0x2, 
       0x2, 0x2, 0x1500, 0x1501, 0x3, 0x2, 0x2, 0x2, 0x1501, 0x1505, 0x3, 
       0x2, 0x2, 0x2, 0x1502, 0x1503, 0x7, 0x196, 0x2, 0x2, 0x1503, 0x1505, 
       0x5, 0x294, 0x14b, 0x6, 0x1504, 0x14f9, 0x3, 0x2, 0x2, 0x2, 0x1504, 
       0x1502, 0x3, 0x2, 0x2, 0x2, 0x1505, 0x1511, 0x3, 0x2, 0x2, 0x2, 0x1506, 
       0x1507, 0xc, 0x5, 0x2, 0x2, 0x1507, 0x1508, 0x9, 0x4f, 0x2, 0x2, 
       0x1508, 0x1510, 0x5, 0x294, 0x14b, 0x6, 0x1509, 0x150a, 0xc, 0x4, 
       0x2, 0x2, 0x150a, 0x150b, 0x7, 0x2af, 0x2, 0x2, 0x150b, 0x1510, 0x5, 
       0x294, 0x14b, 0x5, 0x150c, 0x150d, 0xc, 0x3, 0x2, 0x2, 0x150d, 0x150e, 
       0x9, 0x50, 0x2, 0x2, 0x150e, 0x1510, 0x5, 0x294, 0x14b, 0x4, 0x150f, 
       0x1506, 0x3, 0x2, 0x2, 0x2, 0x150f, 0x1509, 0x3, 0x2, 0x2, 0x2, 0x150f, 
       0x150c, 0x3, 0x2, 0x2, 0x2, 0x1510, 0x1513, 0x3, 0x2, 0x2, 0x2, 0x1511, 
       0x150f, 0x3, 0x2, 0x2, 0x2, 0x1511, 0x1512, 0x3, 0x2, 0x2, 0x2, 0x1512, 
       0x295, 0x3, 0x2, 0x2, 0x2, 0x1513, 0x1511, 0x3, 0x2, 0x2, 0x2, 0x1514, 
       0x1515, 0x8, 0x14c, 0x1, 0x2, 0x1515, 0x1516, 0x5, 0x29a, 0x14e, 
       0x2, 0x1516, 0x1528, 0x3, 0x2, 0x2, 0x2, 0x1517, 0x1518, 0xc, 0x5, 
       0x2, 0x2, 0x1518, 0x151a, 0x7, 0x128, 0x2, 0x2, 0x1519, 0x151b, 0x5, 
       0x2e8, 0x175, 0x2, 0x151a, 0x1519, 0x3, 0x2, 0x2, 0x2, 0x151a, 0x151b, 
       0x3, 0x2, 0x2, 0x2, 0x151b, 0x151c, 0x3, 0x2, 0x2, 0x2, 0x151c, 0x1527, 
       0x7, 0x19b, 0x2, 0x2, 0x151d, 0x151e, 0xc, 0x4, 0x2, 0x2, 0x151e, 
       0x151f, 0x5, 0x298, 0x14d, 0x2, 0x151f, 0x1520, 0x5, 0x29a, 0x14e, 
       0x2, 0x1520, 0x1527, 0x3, 0x2, 0x2, 0x2, 0x1521, 0x1522, 0xc, 0x3, 
       0x2, 0x2, 0x1522, 0x1523, 0x5, 0x298, 0x14d, 0x2, 0x1523, 0x1524, 
       0x9, 0x51, 0x2, 0x2, 0x1524, 0x1525, 0x5, 0x11c, 0x8f, 0x2, 0x1525, 
       0x1527, 0x3, 0x2, 0x2, 0x2, 0x1526, 0x1517, 0x3, 0x2, 0x2, 0x2, 0x1526, 
       0x151d, 0x3, 0x2, 0x2, 0x2, 0x1526, 0x1521, 0x3, 0x2, 0x2, 0x2, 0x1527, 
       0x152a, 0x3, 0x2, 0x2, 0x2, 0x1528, 0x1526, 0x3, 0x2, 0x2, 0x2, 0x1528, 
       0x1529, 0x3, 0x2, 0x2, 0x2, 0x1529, 0x297, 0x3, 0x2, 0x2, 0x2, 0x152a, 
       0x1528, 0x3, 0x2, 0x2, 0x2, 0x152b, 0x152c, 0x9, 0x52, 0x2, 0x2, 
       0x152c, 0x299, 0x3, 0x2, 0x2, 0x2, 0x152d, 0x153b, 0x5, 0x29e, 0x150, 
       0x2, 0x152e, 0x1530, 0x5, 0x2e8, 0x175, 0x2, 0x152f, 0x152e, 0x3, 
       0x2, 0x2, 0x2, 0x152f, 0x1530, 0x3, 0x2, 0x2, 0x2, 0x1530, 0x1531, 
       0x3, 0x2, 0x2, 0x2, 0x1531, 0x153c, 0x5, 0x29c, 0x14f, 0x2, 0x1532, 
       0x1533, 0x6, 0x14e, 0x88, 0x2, 0x1533, 0x1535, 0x7, 0x2fe, 0x2, 0x2, 
       0x1534, 0x1536, 0x7, 0x2bd, 0x2, 0x2, 0x1535, 0x1534, 0x3, 0x2, 0x2, 
       0x2, 0x1535, 0x1536, 0x3, 0x2, 0x2, 0x2, 0x1536, 0x1537, 0x3, 0x2, 
       0x2, 0x2, 0x1537, 0x153c, 0x5, 0x2f4, 0x17b, 0x2, 0x1538, 0x1539, 
       0x7, 0x229, 0x2, 0x2, 0x1539, 0x153a, 0x7, 0x13a, 0x2, 0x2, 0x153a, 
       0x153c, 0x5, 0x29e, 0x150, 0x2, 0x153b, 0x152f, 0x3, 0x2, 0x2, 0x2, 
       0x153b, 0x1532, 0x3, 0x2, 0x2, 0x2, 0x153b, 0x1538, 0x3, 0x2, 0x2, 
       0x2, 0x153b, 0x153c, 0x3, 0x2, 0x2, 0x2, 0x153c, 0x29b, 0x3, 0x2, 
       0x2, 0x2, 0x153d, 0x1543, 0x7, 0x123, 0x2, 0x2, 0x153e, 0x1544, 0x5, 
       0x11c, 0x8f, 0x2, 0x153f, 0x1540, 0x7, 0x23, 0x2, 0x2, 0x1540, 0x1541, 
       0x5, 0x2e4, 0x173, 0x2, 0x1541, 0x1542, 0x7, 0x24, 0x2, 0x2, 0x1542, 
       0x1544, 0x3, 0x2, 0x2, 0x2, 0x1543, 0x153e, 0x3, 0x2, 0x2, 0x2, 0x1543, 
       0x153f, 0x3, 0x2, 0x2, 0x2, 0x1544, 0x1553, 0x3, 0x2, 0x2, 0x2, 0x1545, 
       0x1546, 0x7, 0x50, 0x2, 0x2, 0x1546, 0x1547, 0x5, 0x29e, 0x150, 0x2, 
       0x1547, 0x1548, 0x7, 0x41, 0x2, 0x2, 0x1548, 0x1549, 0x5, 0x29a, 
       0x14e, 0x2, 0x1549, 0x1553, 0x3, 0x2, 0x2, 0x2, 0x154a, 0x154b, 0x7, 
       0x13a, 0x2, 0x2, 0x154b, 0x154e, 0x5, 0x2a0, 0x151, 0x2, 0x154c, 
       0x154d, 0x7, 0xd5, 0x2, 0x2, 0x154d, 0x154f, 0x5, 0x2a0, 0x151, 0x2, 
       0x154e, 0x154c, 0x3, 0x2, 0x2, 0x2, 0x154e, 0x154f, 0x3, 0x2, 0x2, 
       0x2, 0x154f, 0x1553, 0x3, 0x2, 0x2, 0x2, 0x1550, 0x1551, 0x7, 0x1e0, 
       0x2, 0x2, 0x1551, 0x1553, 0x5, 0x29e, 0x150, 0x2, 0x1552, 0x153d, 
       0x3, 0x2, 0x2, 0x2, 0x1552, 0x1545, 0x3, 0x2, 0x2, 0x2, 0x1552, 0x154a, 
       0x3, 0x2, 0x2, 0x2, 0x1552, 0x1550, 0x3, 0x2, 0x2, 0x2, 0x1553, 0x29d, 
       0x3, 0x2, 0x2, 0x2, 0x1554, 0x1555, 0x8, 0x150, 0x1, 0x2, 0x1555, 
       0x1556, 0x5, 0x2a0, 0x151, 0x2, 0x1556, 0x1571, 0x3, 0x2, 0x2, 0x2, 
       0x1557, 0x1558, 0xc, 0x9, 0x2, 0x2, 0x1558, 0x1559, 0x7, 0x1c, 0x2, 
       0x2, 0x1559, 0x1570, 0x5, 0x29e, 0x150, 0xa, 0x155a, 0x155b, 0xc, 
       0x8, 0x2, 0x2, 0x155b, 0x155c, 0x9, 0x53, 0x2, 0x2, 0x155c, 0x1570, 
       0x5, 0x29e, 0x150, 0x9, 0x155d, 0x155e, 0xc, 0x7, 0x2, 0x2, 0x155e, 
       0x155f, 0x9, 0x54, 0x2, 0x2, 0x155f, 0x1570, 0x5, 0x29e, 0x150, 0x8, 
       0x1560, 0x1561, 0xc, 0x5, 0x2, 0x2, 0x1561, 0x1562, 0x9, 0x55, 0x2, 
       0x2, 0x1562, 0x1570, 0x5, 0x29e, 0x150, 0x6, 0x1563, 0x1564, 0xc, 
       0x4, 0x2, 0x2, 0x1564, 0x1565, 0x7, 0x1b, 0x2, 0x2, 0x1565, 0x1570, 
       0x5, 0x29e, 0x150, 0x5, 0x1566, 0x1567, 0xc, 0x3, 0x2, 0x2, 0x1567, 
       0x1568, 0x7, 0x1e, 0x2, 0x2, 0x1568, 0x1570, 0x5, 0x29e, 0x150, 0x4, 
       0x1569, 0x156a, 0xc, 0x6, 0x2, 0x2, 0x156a, 0x156b, 0x9, 0x54, 0x2, 
       0x2, 0x156b, 0x156c, 0x7, 0x11f, 0x2, 0x2, 0x156c, 0x156d, 0x5, 0x294, 
       0x14b, 0x2, 0x156d, 0x156e, 0x5, 0x2ec, 0x177, 0x2, 0x156e, 0x1570, 
       0x3, 0x2, 0x2, 0x2, 0x156f, 0x1557, 0x3, 0x2, 0x2, 0x2, 0x156f, 0x155a, 
       0x3, 0x2, 0x2, 0x2, 0x156f, 0x155d, 0x3, 0x2, 0x2, 0x2, 0x156f, 0x1560, 
       0x3, 0x2, 0x2, 0x2, 0x156f, 0x1563, 0x3, 0x2, 0x2, 0x2, 0x156f, 0x1566, 
       0x3, 0x2, 0x2, 0x2, 0x156f, 0x1569, 0x3, 0x2, 0x2, 0x2, 0x1570, 0x1573, 
       0x3, 0x2, 0x2, 0x2, 0x1571, 0x156f, 0x3, 0x2, 0x2, 0x2, 0x1571, 0x1572, 
       0x3, 0x2, 0x2, 0x2, 0x1572, 0x29f, 0x3, 0x2, 0x2, 0x2, 0x1573, 0x1571, 
       0x3, 0x2, 0x2, 0x2, 0x1574, 0x1575, 0x8, 0x151, 0x1, 0x2, 0x1575, 
       0x15dd, 0x5, 0x2d4, 0x16b, 0x2, 0x1576, 0x1578, 0x5, 0x408, 0x205, 
       0x2, 0x1577, 0x1579, 0x5, 0x2a4, 0x153, 0x2, 0x1578, 0x1577, 0x3, 
       0x2, 0x2, 0x2, 0x1578, 0x1579, 0x3, 0x2, 0x2, 0x2, 0x1579, 0x15dd, 
       0x3, 0x2, 0x2, 0x2, 0x157a, 0x15dd, 0x5, 0x2bc, 0x15f, 0x2, 0x157b, 
       0x15dd, 0x5, 0x2ce, 0x168, 0x2, 0x157c, 0x15dd, 0x5, 0x46e, 0x238, 
       0x2, 0x157d, 0x15dd, 0x7, 0x2e, 0x2, 0x2, 0x157e, 0x15dd, 0x5, 0x2a6, 
       0x154, 0x2, 0x157f, 0x1580, 0x6, 0x151, 0x90, 0x2, 0x1580, 0x15dd, 
       0x5, 0x2a8, 0x155, 0x2, 0x1581, 0x1582, 0x6, 0x151, 0x91, 0x2, 0x1582, 
       0x15dd, 0x5, 0x2aa, 0x156, 0x2, 0x1583, 0x1584, 0x9, 0x56, 0x2, 0x2, 
       0x1584, 0x15dd, 0x5, 0x2a0, 0x151, 0x10, 0x1585, 0x1586, 0x5, 0x2ea, 
       0x176, 0x2, 0x1586, 0x1587, 0x5, 0x2a0, 0x151, 0xf, 0x1587, 0x15dd, 
       0x3, 0x2, 0x2, 0x2, 0x1588, 0x158a, 0x7, 0x20a, 0x2, 0x2, 0x1589, 
       0x1588, 0x3, 0x2, 0x2, 0x2, 0x1589, 0x158a, 0x3, 0x2, 0x2, 0x2, 0x158a, 
       0x158b, 0x3, 0x2, 0x2, 0x2, 0x158b, 0x158c, 0x7, 0x23, 0x2, 0x2, 
       0x158c, 0x158d, 0x5, 0x2e4, 0x173, 0x2, 0x158d, 0x158e, 0x7, 0x24, 
       0x2, 0x2, 0x158e, 0x15dd, 0x3, 0x2, 0x2, 0x2, 0x158f, 0x1591, 0x7, 
       0xdb, 0x2, 0x2, 0x1590, 0x158f, 0x3, 0x2, 0x2, 0x2, 0x1590, 0x1591, 
       0x3, 0x2, 0x2, 0x2, 0x1591, 0x1592, 0x3, 0x2, 0x2, 0x2, 0x1592, 0x15dd, 
       0x5, 0x11c, 0x8f, 0x2, 0x1593, 0x1594, 0x7, 0x25, 0x2, 0x2, 0x1594, 
       0x1595, 0x5, 0x45a, 0x22e, 0x2, 0x1595, 0x1596, 0x5, 0x294, 0x14b, 
       0x2, 0x1596, 0x1597, 0x7, 0x26, 0x2, 0x2, 0x1597, 0x15dd, 0x3, 0x2, 
       0x2, 0x2, 0x1598, 0x1599, 0x7, 0x165, 0x2, 0x2, 0x1599, 0x159a, 0x5, 
       0x2b6, 0x15c, 0x2, 0x159a, 0x159b, 0x7, 0x39, 0x2, 0x2, 0x159b, 0x159c, 
       0x7, 0x23, 0x2, 0x2, 0x159c, 0x159e, 0x5, 0x29e, 0x150, 0x2, 0x159d, 
       0x159f, 0x5, 0x2ba, 0x15e, 0x2, 0x159e, 0x159d, 0x3, 0x2, 0x2, 0x2, 
       0x159e, 0x159f, 0x3, 0x2, 0x2, 0x2, 0x159f, 0x15a0, 0x3, 0x2, 0x2, 
       0x2, 0x15a0, 0x15a1, 0x7, 0x24, 0x2, 0x2, 0x15a1, 0x15dd, 0x3, 0x2, 
       0x2, 0x2, 0x15a2, 0x15a3, 0x7, 0x52, 0x2, 0x2, 0x15a3, 0x15dd, 0x5, 
       0x2a0, 0x151, 0xa, 0x15a4, 0x15a5, 0x7, 0x66, 0x2, 0x2, 0x15a5, 0x15a6, 
       0x7, 0x23, 0x2, 0x2, 0x15a6, 0x15a7, 0x5, 0x294, 0x14b, 0x2, 0x15a7, 
       0x15a8, 0x7, 0x43, 0x2, 0x2, 0x15a8, 0x15aa, 0x5, 0x2e2, 0x172, 0x2, 
       0x15a9, 0x15ab, 0x5, 0x2a2, 0x152, 0x2, 0x15aa, 0x15a9, 0x3, 0x2, 
       0x2, 0x2, 0x15aa, 0x15ab, 0x3, 0x2, 0x2, 0x2, 0x15ab, 0x15ac, 0x3, 
       0x2, 0x2, 0x2, 0x15ac, 0x15ad, 0x7, 0x24, 0x2, 0x2, 0x15ad, 0x15dd, 
       0x3, 0x2, 0x2, 0x2, 0x15ae, 0x15b0, 0x7, 0x65, 0x2, 0x2, 0x15af, 
       0x15b1, 0x5, 0x294, 0x14b, 0x2, 0x15b0, 0x15af, 0x3, 0x2, 0x2, 0x2, 
       0x15b0, 0x15b1, 0x3, 0x2, 0x2, 0x2, 0x15b1, 0x15b5, 0x3, 0x2, 0x2, 
       0x2, 0x15b2, 0x15b3, 0x5, 0x2dc, 0x16f, 0x2, 0x15b3, 0x15b4, 0x5, 
       0x2de, 0x170, 0x2, 0x15b4, 0x15b6, 0x3, 0x2, 0x2, 0x2, 0x15b5, 0x15b2, 
       0x3, 0x2, 0x2, 0x2, 0x15b6, 0x15b7, 0x3, 0x2, 0x2, 0x2, 0x15b7, 0x15b5, 
       0x3, 0x2, 0x2, 0x2, 0x15b7, 0x15b8, 0x3, 0x2, 0x2, 0x2, 0x15b8, 0x15ba, 
       0x3, 0x2, 0x2, 0x2, 0x15b9, 0x15bb, 0x5, 0x2e0, 0x171, 0x2, 0x15ba, 
       0x15b9, 0x3, 0x2, 0x2, 0x2, 0x15ba, 0x15bb, 0x3, 0x2, 0x2, 0x2, 0x15bb, 
       0x15bc, 0x3, 0x2, 0x2, 0x2, 0x15bc, 0x15bd, 0x7, 0xcc, 0x2, 0x2, 
       0x15bd, 0x15dd, 0x3, 0x2, 0x2, 0x2, 0x15be, 0x15bf, 0x7, 0x8f, 0x2, 
       0x2, 0x15bf, 0x15c0, 0x7, 0x23, 0x2, 0x2, 0x15c0, 0x15c1, 0x5, 0x294, 
       0x14b, 0x2, 0x15c1, 0x15c2, 0x7, 0x20, 0x2, 0x2, 0x15c2, 0x15c3, 
       0x5, 0x2e2, 0x172, 0x2, 0x15c3, 0x15c4, 0x7, 0x24, 0x2, 0x2, 0x15c4, 
       0x15dd, 0x3, 0x2, 0x2, 0x2, 0x15c5, 0x15c6, 0x7, 0x8f, 0x2, 0x2, 
       0x15c6, 0x15c7, 0x7, 0x23, 0x2, 0x2, 0x15c7, 0x15c8, 0x5, 0x294, 
       0x14b, 0x2, 0x15c8, 0x15c9, 0x7, 0x28d, 0x2, 0x2, 0x15c9, 0x15ca, 
       0x5, 0x39c, 0x1cf, 0x2, 0x15ca, 0x15cb, 0x7, 0x24, 0x2, 0x2, 0x15cb, 
       0x15dd, 0x3, 0x2, 0x2, 0x2, 0x15cc, 0x15cd, 0x7, 0xae, 0x2, 0x2, 
       0x15cd, 0x15ce, 0x7, 0x23, 0x2, 0x2, 0x15ce, 0x15cf, 0x5, 0x462, 
       0x232, 0x2, 0x15cf, 0x15d0, 0x7, 0x24, 0x2, 0x2, 0x15d0, 0x15dd, 
       0x3, 0x2, 0x2, 0x2, 0x15d1, 0x15d2, 0x7, 0x292, 0x2, 0x2, 0x15d2, 
       0x15d3, 0x7, 0x23, 0x2, 0x2, 0x15d3, 0x15d4, 0x5, 0x462, 0x232, 0x2, 
       0x15d4, 0x15d5, 0x7, 0x24, 0x2, 0x2, 0x15d5, 0x15dd, 0x3, 0x2, 0x2, 
       0x2, 0x15d6, 0x15d7, 0x7, 0x11f, 0x2, 0x2, 0x15d7, 0x15d8, 0x5, 0x294, 
       0x14b, 0x2, 0x15d8, 0x15d9, 0x5, 0x2ec, 0x177, 0x2, 0x15d9, 0x15da, 
       0x7, 0x11, 0x2, 0x2, 0x15da, 0x15db, 0x5, 0x294, 0x14b, 0x2, 0x15db, 
       0x15dd, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x1574, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x1576, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x157a, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x157b, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x157c, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x157d, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x157e, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x157f, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x1581, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x1583, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x1585, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x1589, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x1590, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x1593, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x1598, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x15a2, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x15a4, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x15ae, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x15be, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x15c5, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x15cc, 0x3, 0x2, 0x2, 0x2, 0x15dc, 
       0x15d1, 0x3, 0x2, 0x2, 0x2, 0x15dc, 0x15d6, 0x3, 0x2, 0x2, 0x2, 0x15dd, 
       0x15e6, 0x3, 0x2, 0x2, 0x2, 0x15de, 0x15df, 0xc, 0x11, 0x2, 0x2, 
       0x15df, 0x15e0, 0x7, 0x4, 0x2, 0x2, 0x15e0, 0x15e5, 0x5, 0x2a0, 0x151, 
       0x12, 0x15e1, 0x15e2, 0xc, 0x17, 0x2, 0x2, 0x15e2, 0x15e3, 0x7, 0x76, 
       0x2, 0x2, 0x15e3, 0x15e5, 0x5, 0x48e, 0x248, 0x2, 0x15e4, 0x15de, 
       0x3, 0x2, 0x2, 0x2, 0x15e4, 0x15e1, 0x3, 0x2, 0x2, 0x2, 0x15e5, 0x15e8, 
       0x3, 0x2, 0x2, 0x2, 0x15e6, 0x15e4, 0x3, 0x2, 0x2, 0x2, 0x15e6, 0x15e7, 
       0x3, 0x2, 0x2, 0x2, 0x15e7, 0x2a1, 0x3, 0x2, 0x2, 0x2, 0x15e8, 0x15e6, 
       0x3, 0x2, 0x2, 0x2, 0x15e9, 0x15ea, 0x6, 0x152, 0x94, 0x2, 0x15ea, 
       0x15eb, 0x7, 0x2fc, 0x2, 0x2, 0x15eb, 0x2a3, 0x3, 0x2, 0x2, 0x2, 
       0x15ec, 0x15ed, 0x6, 0x153, 0x95, 0x2, 0x15ed, 0x15ee, 0x7, 0x28, 
       0x2, 0x2, 0x15ee, 0x15f3, 0x5, 0x474, 0x23b, 0x2, 0x15ef, 0x15f0, 
       0x6, 0x153, 0x96, 0x2, 0x15f0, 0x15f1, 0x7, 0x29, 0x2, 0x2, 0x15f1, 
       0x15f3, 0x5, 0x474, 0x23b, 0x2, 0x15f2, 0x15ec, 0x3, 0x2, 0x2, 0x2, 
       0x15f2, 0x15ef, 0x3, 0x2, 0x2, 0x2, 0x15f3, 0x2a5, 0x3, 0x2, 0x2, 
       0x2, 0x15f4, 0x15f5, 0x7, 0x4c, 0x2, 0x2, 0x15f5, 0x15f7, 0x7, 0x23, 
       0x2, 0x2, 0x15f6, 0x15f8, 0x7, 0xbd, 0x2, 0x2, 0x15f7, 0x15f6, 0x3, 
       0x2, 0x2, 0x2, 0x15f7, 0x15f8, 0x3, 0x2, 0x2, 0x2, 0x15f8, 0x15f9, 
       0x3, 0x2, 0x2, 0x2, 0x15f9, 0x15fa, 0x5, 0x2b4, 0x15b, 0x2, 0x15fa, 
       0x15fd, 0x7, 0x24, 0x2, 0x2, 0x15fb, 0x15fc, 0x6, 0x154, 0x97, 0x2, 
       0x15fc, 0x15fe, 0x5, 0x2ac, 0x157, 0x2, 0x15fd, 0x15fb, 0x3, 0x2, 
       0x2, 0x2, 0x15fd, 0x15fe, 0x3, 0x2, 0x2, 0x2, 0x15fe, 0x1678, 0x3, 
       0x2, 0x2, 0x2, 0x15ff, 0x1600, 0x9, 0x57, 0x2, 0x2, 0x1600, 0x1601, 
       0x7, 0x23, 0x2, 0x2, 0x1601, 0x1602, 0x5, 0x2b4, 0x15b, 0x2, 0x1602, 
       0x1605, 0x7, 0x24, 0x2, 0x2, 0x1603, 0x1604, 0x6, 0x154, 0x98, 0x2, 
       0x1604, 0x1606, 0x5, 0x2ac, 0x157, 0x2, 0x1605, 0x1603, 0x3, 0x2, 
       0x2, 0x2, 0x1605, 0x1606, 0x3, 0x2, 0x2, 0x2, 0x1606, 0x1678, 0x3, 
       0x2, 0x2, 0x2, 0x1607, 0x1608, 0x6, 0x154, 0x99, 0x2, 0x1608, 0x1678, 
       0x5, 0x2b2, 0x15a, 0x2, 0x1609, 0x160a, 0x7, 0x90, 0x2, 0x2, 0x160a, 
       0x160c, 0x7, 0x23, 0x2, 0x2, 0x160b, 0x160d, 0x7, 0x3c, 0x2, 0x2, 
       0x160c, 0x160b, 0x3, 0x2, 0x2, 0x2, 0x160c, 0x160d, 0x3, 0x2, 0x2, 
       0x2, 0x160d, 0x160e, 0x3, 0x2, 0x2, 0x2, 0x160e, 0x160f, 0x7, 0x13, 
       0x2, 0x2, 0x160f, 0x1612, 0x7, 0x24, 0x2, 0x2, 0x1610, 0x1611, 0x6, 
       0x154, 0x9a, 0x2, 0x1611, 0x1613, 0x5, 0x2ac, 0x157, 0x2, 0x1612, 
       0x1610, 0x3, 0x2, 0x2, 0x2, 0x1612, 0x1613, 0x3, 0x2, 0x2, 0x2, 0x1613, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x1614, 0x1615, 0x7, 0x90, 0x2, 0x2, 
       0x1615, 0x161d, 0x7, 0x23, 0x2, 0x2, 0x1616, 0x1618, 0x7, 0x3c, 0x2, 
       0x2, 0x1617, 0x1616, 0x3, 0x2, 0x2, 0x2, 0x1617, 0x1618, 0x3, 0x2, 
       0x2, 0x2, 0x1618, 0x1619, 0x3, 0x2, 0x2, 0x2, 0x1619, 0x161e, 0x7, 
       0x13, 0x2, 0x2, 0x161a, 0x161e, 0x5, 0x2b4, 0x15b, 0x2, 0x161b, 0x161c, 
       0x7, 0xbd, 0x2, 0x2, 0x161c, 0x161e, 0x5, 0x2e4, 0x173, 0x2, 0x161d, 
       0x1617, 0x3, 0x2, 0x2, 0x2, 0x161d, 0x161a, 0x3, 0x2, 0x2, 0x2, 0x161d, 
       0x161b, 0x3, 0x2, 0x2, 0x2, 0x161e, 0x161f, 0x3, 0x2, 0x2, 0x2, 0x161f, 
       0x1622, 0x7, 0x24, 0x2, 0x2, 0x1620, 0x1621, 0x6, 0x154, 0x9b, 0x2, 
       0x1621, 0x1623, 0x5, 0x2ac, 0x157, 0x2, 0x1622, 0x1620, 0x3, 0x2, 
       0x2, 0x2, 0x1622, 0x1623, 0x3, 0x2, 0x2, 0x2, 0x1623, 0x1678, 0x3, 
       0x2, 0x2, 0x2, 0x1624, 0x1625, 0x7, 0x17d, 0x2, 0x2, 0x1625, 0x1627, 
       0x7, 0x23, 0x2, 0x2, 0x1626, 0x1628, 0x7, 0xbd, 0x2, 0x2, 0x1627, 
       0x1626, 0x3, 0x2, 0x2, 0x2, 0x1627, 0x1628, 0x3, 0x2, 0x2, 0x2, 0x1628, 
       0x1629, 0x3, 0x2, 0x2, 0x2, 0x1629, 0x162a, 0x5, 0x2b4, 0x15b, 0x2, 
       0x162a, 0x162d, 0x7, 0x24, 0x2, 0x2, 0x162b, 0x162c, 0x6, 0x154, 
       0x9c, 0x2, 0x162c, 0x162e, 0x5, 0x2ac, 0x157, 0x2, 0x162d, 0x162b, 
       0x3, 0x2, 0x2, 0x2, 0x162d, 0x162e, 0x3, 0x2, 0x2, 0x2, 0x162e, 0x1678, 
       0x3, 0x2, 0x2, 0x2, 0x162f, 0x1630, 0x7, 0x16b, 0x2, 0x2, 0x1630, 
       0x1632, 0x7, 0x23, 0x2, 0x2, 0x1631, 0x1633, 0x7, 0xbd, 0x2, 0x2, 
       0x1632, 0x1631, 0x3, 0x2, 0x2, 0x2, 0x1632, 0x1633, 0x3, 0x2, 0x2, 
       0x2, 0x1633, 0x1634, 0x3, 0x2, 0x2, 0x2, 0x1634, 0x1635, 0x5, 0x2b4, 
       0x15b, 0x2, 0x1635, 0x1638, 0x7, 0x24, 0x2, 0x2, 0x1636, 0x1637, 
       0x6, 0x154, 0x9d, 0x2, 0x1637, 0x1639, 0x5, 0x2ac, 0x157, 0x2, 0x1638, 
       0x1636, 0x3, 0x2, 0x2, 0x2, 0x1638, 0x1639, 0x3, 0x2, 0x2, 0x2, 0x1639, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x163a, 0x163b, 0x7, 0x247, 0x2, 0x2, 
       0x163b, 0x163c, 0x7, 0x23, 0x2, 0x2, 0x163c, 0x163d, 0x5, 0x2b4, 
       0x15b, 0x2, 0x163d, 0x1640, 0x7, 0x24, 0x2, 0x2, 0x163e, 0x163f, 
       0x6, 0x154, 0x9e, 0x2, 0x163f, 0x1641, 0x5, 0x2ac, 0x157, 0x2, 0x1640, 
       0x163e, 0x3, 0x2, 0x2, 0x2, 0x1640, 0x1641, 0x3, 0x2, 0x2, 0x2, 0x1641, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x1642, 0x1643, 0x7, 0x297, 0x2, 0x2, 
       0x1643, 0x1644, 0x7, 0x23, 0x2, 0x2, 0x1644, 0x1645, 0x5, 0x2b4, 
       0x15b, 0x2, 0x1645, 0x1648, 0x7, 0x24, 0x2, 0x2, 0x1646, 0x1647, 
       0x6, 0x154, 0x9f, 0x2, 0x1647, 0x1649, 0x5, 0x2ac, 0x157, 0x2, 0x1648, 
       0x1646, 0x3, 0x2, 0x2, 0x2, 0x1648, 0x1649, 0x3, 0x2, 0x2, 0x2, 0x1649, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x164a, 0x164b, 0x7, 0x244, 0x2, 0x2, 
       0x164b, 0x164c, 0x7, 0x23, 0x2, 0x2, 0x164c, 0x164d, 0x5, 0x2b4, 
       0x15b, 0x2, 0x164d, 0x1650, 0x7, 0x24, 0x2, 0x2, 0x164e, 0x164f, 
       0x6, 0x154, 0xa0, 0x2, 0x164f, 0x1651, 0x5, 0x2ac, 0x157, 0x2, 0x1650, 
       0x164e, 0x3, 0x2, 0x2, 0x2, 0x1650, 0x1651, 0x3, 0x2, 0x2, 0x2, 0x1651, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x1652, 0x1653, 0x7, 0x29a, 0x2, 0x2, 
       0x1653, 0x1654, 0x7, 0x23, 0x2, 0x2, 0x1654, 0x1655, 0x5, 0x2b4, 
       0x15b, 0x2, 0x1655, 0x1658, 0x7, 0x24, 0x2, 0x2, 0x1656, 0x1657, 
       0x6, 0x154, 0xa1, 0x2, 0x1657, 0x1659, 0x5, 0x2ac, 0x157, 0x2, 0x1658, 
       0x1656, 0x3, 0x2, 0x2, 0x2, 0x1658, 0x1659, 0x3, 0x2, 0x2, 0x2, 0x1659, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x165a, 0x165b, 0x7, 0x254, 0x2, 0x2, 
       0x165b, 0x165d, 0x7, 0x23, 0x2, 0x2, 0x165c, 0x165e, 0x7, 0xbd, 0x2, 
       0x2, 0x165d, 0x165c, 0x3, 0x2, 0x2, 0x2, 0x165d, 0x165e, 0x3, 0x2, 
       0x2, 0x2, 0x165e, 0x165f, 0x3, 0x2, 0x2, 0x2, 0x165f, 0x1660, 0x5, 
       0x2b4, 0x15b, 0x2, 0x1660, 0x1663, 0x7, 0x24, 0x2, 0x2, 0x1661, 0x1662, 
       0x6, 0x154, 0xa2, 0x2, 0x1662, 0x1664, 0x5, 0x2ac, 0x157, 0x2, 0x1663, 
       0x1661, 0x3, 0x2, 0x2, 0x2, 0x1663, 0x1664, 0x3, 0x2, 0x2, 0x2, 0x1664, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x1665, 0x1666, 0x7, 0x103, 0x2, 0x2, 
       0x1666, 0x1668, 0x7, 0x23, 0x2, 0x2, 0x1667, 0x1669, 0x7, 0xbd, 0x2, 
       0x2, 0x1668, 0x1667, 0x3, 0x2, 0x2, 0x2, 0x1668, 0x1669, 0x3, 0x2, 
       0x2, 0x2, 0x1669, 0x166a, 0x3, 0x2, 0x2, 0x2, 0x166a, 0x166c, 0x5, 
       0x2e4, 0x173, 0x2, 0x166b, 0x166d, 0x5, 0x14c, 0xa7, 0x2, 0x166c, 
       0x166b, 0x3, 0x2, 0x2, 0x2, 0x166c, 0x166d, 0x3, 0x2, 0x2, 0x2, 0x166d, 
       0x1670, 0x3, 0x2, 0x2, 0x2, 0x166e, 0x166f, 0x7, 0x214, 0x2, 0x2, 
       0x166f, 0x1671, 0x5, 0x476, 0x23c, 0x2, 0x1670, 0x166e, 0x3, 0x2, 
       0x2, 0x2, 0x1670, 0x1671, 0x3, 0x2, 0x2, 0x2, 0x1671, 0x1672, 0x3, 
       0x2, 0x2, 0x2, 0x1672, 0x1675, 0x7, 0x24, 0x2, 0x2, 0x1673, 0x1674, 
       0x6, 0x154, 0xa3, 0x2, 0x1674, 0x1676, 0x5, 0x2ac, 0x157, 0x2, 0x1675, 
       0x1673, 0x3, 0x2, 0x2, 0x2, 0x1675, 0x1676, 0x3, 0x2, 0x2, 0x2, 0x1676, 
       0x1678, 0x3, 0x2, 0x2, 0x2, 0x1677, 0x15f4, 0x3, 0x2, 0x2, 0x2, 0x1677, 
       0x15ff, 0x3, 0x2, 0x2, 0x2, 0x1677, 0x1607, 0x3, 0x2, 0x2, 0x2, 0x1677, 
       0x1609, 0x3, 0x2, 0x2, 0x2, 0x1677, 0x1614, 0x3, 0x2, 0x2, 0x2, 0x1677, 
       0x1624, 0x3, 0x2, 0x2, 0x2, 0x1677, 0x162f, 0x3, 0x2, 0x2, 0x2, 0x1677, 
       0x163a, 0x3, 0x2, 0x2, 0x2, 0x1677, 0x1642, 0x3, 0x2, 0x2, 0x2, 0x1677, 
       0x164a, 0x3, 0x2, 0x2, 0x2, 0x1677, 0x1652, 0x3, 0x2, 0x2, 0x2, 0x1677, 
       0x165a, 0x3, 0x2, 0x2, 0x2, 0x1677, 0x1665, 0x3, 0x2, 0x2, 0x2, 0x1678, 
       0x2a7, 0x3, 0x2, 0x2, 0x2, 0x1679, 0x167a, 0x7, 0x2c1, 0x2, 0x2, 
       0x167a, 0x167b, 0x7, 0x23, 0x2, 0x2, 0x167b, 0x167c, 0x5, 0x2e4, 
       0x173, 0x2, 0x167c, 0x167d, 0x7, 0x24, 0x2, 0x2, 0x167d, 0x2a9, 0x3, 
       0x2, 0x2, 0x2, 0x167e, 0x167f, 0x9, 0x58, 0x2, 0x2, 0x167f, 0x1680, 
       0x5, 0x496, 0x24c, 0x2, 0x1680, 0x1681, 0x5, 0x2ac, 0x157, 0x2, 0x1681, 
       0x16a9, 0x3, 0x2, 0x2, 0x2, 0x1682, 0x1683, 0x7, 0x2d1, 0x2, 0x2, 
       0x1683, 0x1684, 0x5, 0x2f4, 0x17b, 0x2, 0x1684, 0x1685, 0x5, 0x2ac, 
       0x157, 0x2, 0x1685, 0x16a9, 0x3, 0x2, 0x2, 0x2, 0x1686, 0x1687, 0x9, 
       0x59, 0x2, 0x2, 0x1687, 0x1688, 0x7, 0x23, 0x2, 0x2, 0x1688, 0x168a, 
       0x5, 0x294, 0x14b, 0x2, 0x1689, 0x168b, 0x5, 0x2ae, 0x158, 0x2, 0x168a, 
       0x1689, 0x3, 0x2, 0x2, 0x2, 0x168a, 0x168b, 0x3, 0x2, 0x2, 0x2, 0x168b, 
       0x168c, 0x3, 0x2, 0x2, 0x2, 0x168c, 0x168e, 0x7, 0x24, 0x2, 0x2, 
       0x168d, 0x168f, 0x5, 0x2b0, 0x159, 0x2, 0x168e, 0x168d, 0x3, 0x2, 
       0x2, 0x2, 0x168e, 0x168f, 0x3, 0x2, 0x2, 0x2, 0x168f, 0x1690, 0x3, 
       0x2, 0x2, 0x2, 0x1690, 0x1691, 0x5, 0x2ac, 0x157, 0x2, 0x1691, 0x16a9, 
       0x3, 0x2, 0x2, 0x2, 0x1692, 0x1693, 0x9, 0x5a, 0x2, 0x2, 0x1693, 
       0x1695, 0x5, 0x2f2, 0x17a, 0x2, 0x1694, 0x1696, 0x5, 0x2b0, 0x159, 
       0x2, 0x1695, 0x1694, 0x3, 0x2, 0x2, 0x2, 0x1695, 0x1696, 0x3, 0x2, 
       0x2, 0x2, 0x1696, 0x1697, 0x3, 0x2, 0x2, 0x2, 0x1697, 0x1698, 0x5, 
       0x2ac, 0x157, 0x2, 0x1698, 0x16a9, 0x3, 0x2, 0x2, 0x2, 0x1699, 0x169a, 
       0x7, 0x2d0, 0x2, 0x2, 0x169a, 0x169b, 0x7, 0x23, 0x2, 0x2, 0x169b, 
       0x169c, 0x5, 0x294, 0x14b, 0x2, 0x169c, 0x169d, 0x7, 0x20, 0x2, 0x2, 
       0x169d, 0x169e, 0x5, 0x2a0, 0x151, 0x2, 0x169e, 0x16a1, 0x7, 0x24, 
       0x2, 0x2, 0x169f, 0x16a0, 0x7, 0xf4, 0x2, 0x2, 0x16a0, 0x16a2, 0x9, 
       0x5b, 0x2, 0x2, 0x16a1, 0x169f, 0x3, 0x2, 0x2, 0x2, 0x16a1, 0x16a2, 
       0x3, 0x2, 0x2, 0x2, 0x16a2, 0x16a4, 0x3, 0x2, 0x2, 0x2, 0x16a3, 0x16a5, 
       0x5, 0x2b0, 0x159, 0x2, 0x16a4, 0x16a3, 0x3, 0x2, 0x2, 0x2, 0x16a4, 
       0x16a5, 0x3, 0x2, 0x2, 0x2, 0x16a5, 0x16a6, 0x3, 0x2, 0x2, 0x2, 0x16a6, 
       0x16a7, 0x5, 0x2ac, 0x157, 0x2, 0x16a7, 0x16a9, 0x3, 0x2, 0x2, 0x2, 
       0x16a8, 0x167e, 0x3, 0x2, 0x2, 0x2, 0x16a8, 0x1682, 0x3, 0x2, 0x2, 
       0x2, 0x16a8, 0x1686, 0x3, 0x2, 0x2, 0x2, 0x16a8, 0x1692, 0x3, 0x2, 
       0x2, 0x2, 0x16a8, 0x1699, 0x3, 0x2, 0x2, 0x2, 0x16a9, 0x2ab, 0x3, 
       0x2, 0x2, 0x2, 0x16aa, 0x16ad, 0x7, 0x2d4, 0x2, 0x2, 0x16ab, 0x16ae, 
       0x5, 0x456, 0x22c, 0x2, 0x16ac, 0x16ae, 0x5, 0x132, 0x9a, 0x2, 0x16ad, 
       0x16ab, 0x3, 0x2, 0x2, 0x2, 0x16ad, 0x16ac, 0x3, 0x2, 0x2, 0x2, 0x16ae, 
       0x2ad, 0x3, 0x2, 0x2, 0x2, 0x16af, 0x16b2, 0x7, 0x20, 0x2, 0x2, 0x16b0, 
       0x16b3, 0x5, 0x46a, 0x236, 0x2, 0x16b1, 0x16b3, 0x7, 0x2e, 0x2, 0x2, 
       0x16b2, 0x16b0, 0x3, 0x2, 0x2, 0x2, 0x16b2, 0x16b1, 0x3, 0x2, 0x2, 
       0x2, 0x16b3, 0x16b6, 0x3, 0x2, 0x2, 0x2, 0x16b4, 0x16b5, 0x7, 0x20, 
       0x2, 0x2, 0x16b5, 0x16b7, 0x5, 0x294, 0x14b, 0x2, 0x16b6, 0x16b4, 
       0x3, 0x2, 0x2, 0x2, 0x16b6, 0x16b7, 0x3, 0x2, 0x2, 0x2, 0x16b7, 0x2af, 
       0x3, 0x2, 0x2, 0x2, 0x16b8, 0x16b9, 0x9, 0x5c, 0x2, 0x2, 0x16b9, 
       0x16ba, 0x7, 0x2d2, 0x2, 0x2, 0x16ba, 0x2b1, 0x3, 0x2, 0x2, 0x2, 
       0x16bb, 0x16bc, 0x7, 0x2bc, 0x2, 0x2, 0x16bc, 0x16bd, 0x7, 0x23, 
       0x2, 0x2, 0x16bd, 0x16be, 0x5, 0x2b4, 0x15b, 0x2, 0x16be, 0x16c0, 
       0x7, 0x24, 0x2, 0x2, 0x16bf, 0x16c1, 0x5, 0x2ac, 0x157, 0x2, 0x16c0, 
       0x16bf, 0x3, 0x2, 0x2, 0x2, 0x16c0, 0x16c1, 0x3, 0x2, 0x2, 0x2, 0x16c1, 
       0x16cc, 0x3, 0x2, 0x2, 0x2, 0x16c2, 0x16c3, 0x7, 0x2bb, 0x2, 0x2, 
       0x16c3, 0x16c4, 0x7, 0x23, 0x2, 0x2, 0x16c4, 0x16c5, 0x5, 0x2b4, 
       0x15b, 0x2, 0x16c5, 0x16c6, 0x7, 0x20, 0x2, 0x2, 0x16c6, 0x16c7, 
       0x5, 0x2b4, 0x15b, 0x2, 0x16c7, 0x16c9, 0x7, 0x24, 0x2, 0x2, 0x16c8, 
       0x16ca, 0x5, 0x2ac, 0x157, 0x2, 0x16c9, 0x16c8, 0x3, 0x2, 0x2, 0x2, 
       0x16c9, 0x16ca, 0x3, 0x2, 0x2, 0x2, 0x16ca, 0x16cc, 0x3, 0x2, 0x2, 
       0x2, 0x16cb, 0x16bb, 0x3, 0x2, 0x2, 0x2, 0x16cb, 0x16c2, 0x3, 0x2, 
       0x2, 0x2, 0x16cc, 0x2b3, 0x3, 0x2, 0x2, 0x2, 0x16cd, 0x16cf, 0x7, 
       0x3c, 0x2, 0x2, 0x16ce, 0x16cd, 0x3, 0x2, 0x2, 0x2, 0x16ce, 0x16cf, 
       0x3, 0x2, 0x2, 0x2, 0x16cf, 0x16d0, 0x3, 0x2, 0x2, 0x2, 0x16d0, 0x16d1, 
       0x5, 0x294, 0x14b, 0x2, 0x16d1, 0x2b5, 0x3, 0x2, 0x2, 0x2, 0x16d2, 
       0x16d8, 0x5, 0x2b8, 0x15d, 0x2, 0x16d3, 0x16d4, 0x7, 0x23, 0x2, 0x2, 
       0x16d4, 0x16d5, 0x5, 0x2b8, 0x15d, 0x2, 0x16d5, 0x16d6, 0x7, 0x24, 
       0x2, 0x2, 0x16d6, 0x16d8, 0x3, 0x2, 0x2, 0x2, 0x16d7, 0x16d2, 0x3, 
       0x2, 0x2, 0x2, 0x16d7, 0x16d3, 0x3, 0x2, 0x2, 0x2, 0x16d8, 0x2b7, 
       0x3, 0x2, 0x2, 0x2, 0x16d9, 0x16de, 0x5, 0x462, 0x232, 0x2, 0x16da, 
       0x16db, 0x7, 0x20, 0x2, 0x2, 0x16db, 0x16dd, 0x5, 0x462, 0x232, 0x2, 
       0x16dc, 0x16da, 0x3, 0x2, 0x2, 0x2, 0x16dd, 0x16e0, 0x3, 0x2, 0x2, 
       0x2, 0x16de, 0x16dc, 0x3, 0x2, 0x2, 0x2, 0x16de, 0x16df, 0x3, 0x2, 
       0x2, 0x2, 0x16df, 0x2b9, 0x3, 0x2, 0x2, 0x2, 0x16e0, 0x16de, 0x3, 
       0x2, 0x2, 0x2, 0x16e1, 0x16e2, 0x7, 0x123, 0x2, 0x2, 0x16e2, 0x16e3, 
       0x7, 0x5b, 0x2, 0x2, 0x16e3, 0x16f1, 0x7, 0x17e, 0x2, 0x2, 0x16e4, 
       0x16e5, 0x7, 0x123, 0x2, 0x2, 0x16e5, 0x16e6, 0x7, 0x18b, 0x2, 0x2, 
       0x16e6, 0x16e7, 0x7, 0x132, 0x2, 0x2, 0x16e7, 0x16eb, 0x7, 0x17e, 
       0x2, 0x2, 0x16e8, 0x16e9, 0x7, 0x2a4, 0x2, 0x2, 0x16e9, 0x16ea, 0x7, 
       0x1d2, 0x2, 0x2, 0x16ea, 0x16ec, 0x7, 0xdd, 0x2, 0x2, 0x16eb, 0x16e8, 
       0x3, 0x2, 0x2, 0x2, 0x16eb, 0x16ec, 0x3, 0x2, 0x2, 0x2, 0x16ec, 0x16f1, 
       0x3, 0x2, 0x2, 0x2, 0x16ed, 0x16ee, 0x7, 0x2a4, 0x2, 0x2, 0x16ee, 
       0x16ef, 0x7, 0x1d2, 0x2, 0x2, 0x16ef, 0x16f1, 0x7, 0xdd, 0x2, 0x2, 
       0x16f0, 0x16e1, 0x3, 0x2, 0x2, 0x2, 0x16f0, 0x16e4, 0x3, 0x2, 0x2, 
       0x2, 0x16f0, 0x16ed, 0x3, 0x2, 0x2, 0x2, 0x16f1, 0x2bb, 0x3, 0x2, 
       0x2, 0x2, 0x16f2, 0x16f3, 0x7, 0x6d, 0x2, 0x2, 0x16f3, 0x16f4, 0x7, 
       0x23, 0x2, 0x2, 0x16f4, 0x16f7, 0x5, 0x2e4, 0x173, 0x2, 0x16f5, 0x16f6, 
       0x7, 0x28d, 0x2, 0x2, 0x16f6, 0x16f8, 0x5, 0x39c, 0x1cf, 0x2, 0x16f7, 
       0x16f5, 0x3, 0x2, 0x2, 0x2, 0x16f7, 0x16f8, 0x3, 0x2, 0x2, 0x2, 0x16f8, 
       0x16f9, 0x3, 0x2, 0x2, 0x2, 0x16f9, 0x16fa, 0x7, 0x24, 0x2, 0x2, 
       0x16fa, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x16fb, 0x16fd, 0x7, 0x99, 0x2, 
       0x2, 0x16fc, 0x16fe, 0x5, 0x496, 0x24c, 0x2, 0x16fd, 0x16fc, 0x3, 
       0x2, 0x2, 0x2, 0x16fd, 0x16fe, 0x3, 0x2, 0x2, 0x2, 0x16fe, 0x1805, 
       0x3, 0x2, 0x2, 0x2, 0x16ff, 0x1700, 0x7, 0xa4, 0x2, 0x2, 0x1700, 
       0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x1701, 0x1702, 0x7, 0xa9, 0x2, 0x2, 
       0x1702, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x1703, 0x1704, 0x7, 0x10e, 
       0x2, 0x2, 0x1704, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x1705, 0x1706, 
       0x7, 0x11b, 0x2, 0x2, 0x1706, 0x1707, 0x7, 0x23, 0x2, 0x2, 0x1707, 
       0x1708, 0x5, 0x294, 0x14b, 0x2, 0x1708, 0x1709, 0x7, 0x20, 0x2, 0x2, 
       0x1709, 0x170a, 0x5, 0x294, 0x14b, 0x2, 0x170a, 0x170b, 0x7, 0x20, 
       0x2, 0x2, 0x170b, 0x170c, 0x5, 0x294, 0x14b, 0x2, 0x170c, 0x170d, 
       0x7, 0x20, 0x2, 0x2, 0x170d, 0x170e, 0x5, 0x294, 0x14b, 0x2, 0x170e, 
       0x170f, 0x7, 0x24, 0x2, 0x2, 0x170f, 0x1805, 0x3, 0x2, 0x2, 0x2, 
       0x1710, 0x1711, 0x7, 0x11f, 0x2, 0x2, 0x1711, 0x1712, 0x7, 0x23, 
       0x2, 0x2, 0x1712, 0x1715, 0x5, 0x294, 0x14b, 0x2, 0x1713, 0x1714, 
       0x7, 0x20, 0x2, 0x2, 0x1714, 0x1716, 0x5, 0x294, 0x14b, 0x2, 0x1715, 
       0x1713, 0x3, 0x2, 0x2, 0x2, 0x1716, 0x1717, 0x3, 0x2, 0x2, 0x2, 0x1717, 
       0x1715, 0x3, 0x2, 0x2, 0x2, 0x1717, 0x1718, 0x3, 0x2, 0x2, 0x2, 0x1718, 
       0x1719, 0x3, 0x2, 0x2, 0x2, 0x1719, 0x171a, 0x7, 0x24, 0x2, 0x2, 
       0x171a, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x171b, 0x171c, 0x7, 0x137, 0x2, 
       0x2, 0x171c, 0x171d, 0x7, 0x23, 0x2, 0x2, 0x171d, 0x171e, 0x5, 0x294, 
       0x14b, 0x2, 0x171e, 0x171f, 0x7, 0x20, 0x2, 0x2, 0x171f, 0x1720, 
       0x5, 0x294, 0x14b, 0x2, 0x1720, 0x1721, 0x7, 0x24, 0x2, 0x2, 0x1721, 
       0x1805, 0x3, 0x2, 0x2, 0x2, 0x1722, 0x1723, 0x7, 0x17b, 0x2, 0x2, 
       0x1723, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x1724, 0x1725, 0x7, 0x182, 
       0x2, 0x2, 0x1725, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x1726, 0x1727, 
       0x7, 0x202, 0x2, 0x2, 0x1727, 0x1728, 0x7, 0x23, 0x2, 0x2, 0x1728, 
       0x1729, 0x5, 0x294, 0x14b, 0x2, 0x1729, 0x172a, 0x7, 0x20, 0x2, 0x2, 
       0x172a, 0x172b, 0x5, 0x294, 0x14b, 0x2, 0x172b, 0x172c, 0x7, 0x24, 
       0x2, 0x2, 0x172c, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x172d, 0x172e, 0x7, 
       0x210, 0x2, 0x2, 0x172e, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x172f, 
       0x1730, 0x7, 0x26a, 0x2, 0x2, 0x1730, 0x1805, 0x5, 0x2f2, 0x17a, 
       0x2, 0x1731, 0x1732, 0x7, 0x267, 0x2, 0x2, 0x1732, 0x1733, 0x7, 0x23, 
       0x2, 0x2, 0x1733, 0x1736, 0x5, 0x294, 0x14b, 0x2, 0x1734, 0x1735, 
       0x7, 0x20, 0x2, 0x2, 0x1735, 0x1737, 0x5, 0x294, 0x14b, 0x2, 0x1736, 
       0x1734, 0x3, 0x2, 0x2, 0x2, 0x1736, 0x1737, 0x3, 0x2, 0x2, 0x2, 0x1737, 
       0x1738, 0x3, 0x2, 0x2, 0x2, 0x1738, 0x1739, 0x7, 0x24, 0x2, 0x2, 
       0x1739, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x173a, 0x1805, 0x5, 0x2ca, 0x166, 
       0x2, 0x173b, 0x173c, 0x7, 0x28a, 0x2, 0x2, 0x173c, 0x1805, 0x5, 0x496, 
       0x24c, 0x2, 0x173d, 0x173e, 0x7, 0x292, 0x2, 0x2, 0x173e, 0x1805, 
       0x5, 0x2f2, 0x17a, 0x2, 0x173f, 0x1740, 0x7, 0x2b1, 0x2, 0x2, 0x1740, 
       0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x1741, 0x1742, 0x9, 0x5d, 0x2, 0x2, 
       0x1742, 0x1743, 0x7, 0x23, 0x2, 0x2, 0x1743, 0x1744, 0x5, 0x294, 
       0x14b, 0x2, 0x1744, 0x174a, 0x7, 0x20, 0x2, 0x2, 0x1745, 0x174b, 
       0x5, 0x294, 0x14b, 0x2, 0x1746, 0x1747, 0x7, 0x11f, 0x2, 0x2, 0x1747, 
       0x1748, 0x5, 0x294, 0x14b, 0x2, 0x1748, 0x1749, 0x5, 0x2ec, 0x177, 
       0x2, 0x1749, 0x174b, 0x3, 0x2, 0x2, 0x2, 0x174a, 0x1745, 0x3, 0x2, 
       0x2, 0x2, 0x174a, 0x1746, 0x3, 0x2, 0x2, 0x2, 0x174b, 0x174c, 0x3, 
       0x2, 0x2, 0x2, 0x174c, 0x174d, 0x7, 0x24, 0x2, 0x2, 0x174d, 0x1805, 
       0x3, 0x2, 0x2, 0x2, 0x174e, 0x1750, 0x7, 0x95, 0x2, 0x2, 0x174f, 
       0x1751, 0x5, 0x496, 0x24c, 0x2, 0x1750, 0x174f, 0x3, 0x2, 0x2, 0x2, 
       0x1750, 0x1751, 0x3, 0x2, 0x2, 0x2, 0x1751, 0x1805, 0x3, 0x2, 0x2, 
       0x2, 0x1752, 0x1754, 0x7, 0x9c, 0x2, 0x2, 0x1753, 0x1755, 0x5, 0x2c0, 
       0x161, 0x2, 0x1754, 0x1753, 0x3, 0x2, 0x2, 0x2, 0x1754, 0x1755, 0x3, 
       0x2, 0x2, 0x2, 0x1755, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x1756, 0x1757, 
       0x9, 0x5e, 0x2, 0x2, 0x1757, 0x1758, 0x7, 0x23, 0x2, 0x2, 0x1758, 
       0x1759, 0x5, 0x294, 0x14b, 0x2, 0x1759, 0x175a, 0x7, 0x20, 0x2, 0x2, 
       0x175a, 0x175b, 0x7, 0x11f, 0x2, 0x2, 0x175b, 0x175c, 0x5, 0x294, 
       0x14b, 0x2, 0x175c, 0x175d, 0x5, 0x2ec, 0x177, 0x2, 0x175d, 0x175e, 
       0x7, 0x24, 0x2, 0x2, 0x175e, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x175f, 
       0x1760, 0x7, 0xe2, 0x2, 0x2, 0x1760, 0x1761, 0x7, 0x23, 0x2, 0x2, 
       0x1761, 0x1762, 0x5, 0x2ec, 0x177, 0x2, 0x1762, 0x1763, 0x7, 0xf4, 
       0x2, 0x2, 0x1763, 0x1764, 0x5, 0x294, 0x14b, 0x2, 0x1764, 0x1765, 
       0x7, 0x24, 0x2, 0x2, 0x1765, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x1766, 
       0x1767, 0x7, 0xfe, 0x2, 0x2, 0x1767, 0x1768, 0x7, 0x23, 0x2, 0x2, 
       0x1768, 0x1769, 0x5, 0x2c8, 0x165, 0x2, 0x1769, 0x176a, 0x7, 0x20, 
       0x2, 0x2, 0x176a, 0x176b, 0x5, 0x294, 0x14b, 0x2, 0x176b, 0x176c, 
       0x7, 0x24, 0x2, 0x2, 0x176c, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x176d, 
       0x176f, 0x7, 0x197, 0x2, 0x2, 0x176e, 0x1770, 0x5, 0x2c0, 0x161, 
       0x2, 0x176f, 0x176e, 0x3, 0x2, 0x2, 0x2, 0x176f, 0x1770, 0x3, 0x2, 
       0x2, 0x2, 0x1770, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x1771, 0x1772, 0x7, 
       0x1c2, 0x2, 0x2, 0x1772, 0x1773, 0x7, 0x23, 0x2, 0x2, 0x1773, 0x1774, 
       0x5, 0x29e, 0x150, 0x2, 0x1774, 0x1775, 0x7, 0x123, 0x2, 0x2, 0x1775, 
       0x1776, 0x5, 0x294, 0x14b, 0x2, 0x1776, 0x1777, 0x7, 0x24, 0x2, 0x2, 
       0x1777, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x1778, 0x1805, 0x5, 0x2cc, 0x167, 
       0x2, 0x1779, 0x177b, 0x7, 0x259, 0x2, 0x2, 0x177a, 0x177c, 0x5, 0x2c0, 
       0x161, 0x2, 0x177b, 0x177a, 0x3, 0x2, 0x2, 0x2, 0x177b, 0x177c, 0x3, 
       0x2, 0x2, 0x2, 0x177c, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x177d, 0x177e, 
       0x9, 0x5f, 0x2, 0x2, 0x177e, 0x177f, 0x7, 0x23, 0x2, 0x2, 0x177f, 
       0x1780, 0x5, 0x2ee, 0x178, 0x2, 0x1780, 0x1781, 0x7, 0x20, 0x2, 0x2, 
       0x1781, 0x1782, 0x5, 0x294, 0x14b, 0x2, 0x1782, 0x1783, 0x7, 0x20, 
       0x2, 0x2, 0x1783, 0x1784, 0x5, 0x294, 0x14b, 0x2, 0x1784, 0x1785, 
       0x7, 0x24, 0x2, 0x2, 0x1785, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x1786, 
       0x1788, 0x7, 0x28e, 0x2, 0x2, 0x1787, 0x1789, 0x5, 0x496, 0x24c, 
       0x2, 0x1788, 0x1787, 0x3, 0x2, 0x2, 0x2, 0x1788, 0x1789, 0x3, 0x2, 
       0x2, 0x2, 0x1789, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x178a, 0x178c, 0x7, 
       0x290, 0x2, 0x2, 0x178b, 0x178d, 0x5, 0x2c0, 0x161, 0x2, 0x178c, 
       0x178b, 0x3, 0x2, 0x2, 0x2, 0x178c, 0x178d, 0x3, 0x2, 0x2, 0x2, 0x178d, 
       0x1805, 0x3, 0x2, 0x2, 0x2, 0x178e, 0x1790, 0x7, 0x28f, 0x2, 0x2, 
       0x178f, 0x1791, 0x5, 0x2c0, 0x161, 0x2, 0x1790, 0x178f, 0x3, 0x2, 
       0x2, 0x2, 0x1790, 0x1791, 0x3, 0x2, 0x2, 0x2, 0x1791, 0x1805, 0x3, 
       0x2, 0x2, 0x2, 0x1792, 0x1793, 0x7, 0x45, 0x2, 0x2, 0x1793, 0x1805, 
       0x5, 0x2f2, 0x17a, 0x2, 0x1794, 0x1795, 0x7, 0x6c, 0x2, 0x2, 0x1795, 
       0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x1796, 0x1797, 0x7, 0x74, 0x2, 0x2, 
       0x1797, 0x1805, 0x5, 0x2f0, 0x179, 0x2, 0x1798, 0x1799, 0x7, 0x77, 
       0x2, 0x2, 0x1799, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x179a, 0x179b, 
       0x7, 0x9d, 0x2, 0x2, 0x179b, 0x1805, 0x5, 0x496, 0x24c, 0x2, 0x179c, 
       0x179d, 0x7, 0x110, 0x2, 0x2, 0x179d, 0x179e, 0x7, 0x23, 0x2, 0x2, 
       0x179e, 0x179f, 0x5, 0x294, 0x14b, 0x2, 0x179f, 0x17a0, 0x7, 0x20, 
       0x2, 0x2, 0x17a0, 0x17a1, 0x5, 0x294, 0x14b, 0x2, 0x17a1, 0x17a2, 
       0x7, 0x20, 0x2, 0x2, 0x17a2, 0x17a3, 0x5, 0x294, 0x14b, 0x2, 0x17a3, 
       0x17a4, 0x7, 0x24, 0x2, 0x2, 0x17a4, 0x1805, 0x3, 0x2, 0x2, 0x2, 
       0x17a5, 0x17a6, 0x7, 0xf2, 0x2, 0x2, 0x17a6, 0x17a7, 0x7, 0x23, 0x2, 
       0x2, 0x17a7, 0x17a8, 0x5, 0x294, 0x14b, 0x2, 0x17a8, 0x17a9, 0x7, 
       0x20, 0x2, 0x2, 0x17a9, 0x17ac, 0x5, 0x294, 0x14b, 0x2, 0x17aa, 0x17ab, 
       0x7, 0x20, 0x2, 0x2, 0x17ab, 0x17ad, 0x5, 0x294, 0x14b, 0x2, 0x17ac, 
       0x17aa, 0x3, 0x2, 0x2, 0x2, 0x17ac, 0x17ad, 0x3, 0x2, 0x2, 0x2, 0x17ad, 
       0x17ae, 0x3, 0x2, 0x2, 0x2, 0x17ae, 0x17af, 0x7, 0x24, 0x2, 0x2, 
       0x17af, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x17b0, 0x17b1, 0x7, 0x176, 0x2, 
       0x2, 0x17b1, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x17b2, 0x17b3, 0x7, 
       0x181, 0x2, 0x2, 0x17b3, 0x17b4, 0x7, 0x23, 0x2, 0x2, 0x17b4, 0x17b5, 
       0x5, 0x294, 0x14b, 0x2, 0x17b5, 0x17b6, 0x7, 0x20, 0x2, 0x2, 0x17b6, 
       0x17b7, 0x5, 0x294, 0x14b, 0x2, 0x17b7, 0x17b8, 0x7, 0x24, 0x2, 0x2, 
       0x17b8, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x17b9, 0x17ba, 0x6, 0x15f, 0xa4, 
       0x2, 0x17ba, 0x17bb, 0x7, 0x1a1, 0x2, 0x2, 0x17bb, 0x17bc, 0x7, 0x23, 
       0x2, 0x2, 0x17bc, 0x17bd, 0x5, 0x47a, 0x23e, 0x2, 0x17bd, 0x17be, 
       0x7, 0x24, 0x2, 0x2, 0x17be, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x17bf, 
       0x17c0, 0x6, 0x15f, 0xa5, 0x2, 0x17c0, 0x17c1, 0x7, 0x1ba, 0x2, 0x2, 
       0x17c1, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x17c2, 0x17c3, 0x7, 0x1d1, 
       0x2, 0x2, 0x17c3, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x17c4, 0x17c5, 
       0x7, 0x1ed, 0x2, 0x2, 0x17c5, 0x17c6, 0x7, 0x23, 0x2, 0x2, 0x17c6, 
       0x17c7, 0x5, 0x294, 0x14b, 0x2, 0x17c7, 0x17c8, 0x7, 0x20, 0x2, 0x2, 
       0x17c8, 0x17c9, 0x5, 0x294, 0x14b, 0x2, 0x17c9, 0x17ca, 0x7, 0x24, 
       0x2, 0x2, 0x17ca, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x17cb, 0x17cc, 0x7, 
       0x1ee, 0x2, 0x2, 0x17cc, 0x17cd, 0x7, 0x23, 0x2, 0x2, 0x17cd, 0x17ce, 
       0x5, 0x294, 0x14b, 0x2, 0x17ce, 0x17cf, 0x7, 0x20, 0x2, 0x2, 0x17cf, 
       0x17d0, 0x5, 0x294, 0x14b, 0x2, 0x17d0, 0x17d1, 0x7, 0x20, 0x2, 0x2, 
       0x17d1, 0x17d2, 0x5, 0x294, 0x14b, 0x2, 0x17d2, 0x17d3, 0x7, 0x24, 
       0x2, 0x2, 0x17d3, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x17d4, 0x17d5, 0x7, 
       0x200, 0x2, 0x2, 0x17d5, 0x1805, 0x5, 0x2f2, 0x17a, 0x2, 0x17d6, 
       0x17d7, 0x7, 0x208, 0x2, 0x2, 0x17d7, 0x1805, 0x5, 0x496, 0x24c, 
       0x2, 0x17d8, 0x17d9, 0x7, 0x275, 0x2, 0x2, 0x17d9, 0x17da, 0x7, 0x23, 
       0x2, 0x2, 0x17da, 0x17db, 0x5, 0x294, 0x14b, 0x2, 0x17db, 0x17dc, 
       0x7, 0x20, 0x2, 0x2, 0x17dc, 0x17dd, 0x5, 0x294, 0x14b, 0x2, 0x17dd, 
       0x17de, 0x7, 0x24, 0x2, 0x2, 0x17de, 0x1805, 0x3, 0x2, 0x2, 0x2, 
       0x17df, 0x17e0, 0x7, 0x29f, 0x2, 0x2, 0x17e0, 0x17e1, 0x7, 0x23, 
       0x2, 0x2, 0x17e1, 0x17e4, 0x5, 0x294, 0x14b, 0x2, 0x17e2, 0x17e3, 
       0x7, 0x20, 0x2, 0x2, 0x17e3, 0x17e5, 0x5, 0x294, 0x14b, 0x2, 0x17e4, 
       0x17e2, 0x3, 0x2, 0x2, 0x2, 0x17e4, 0x17e5, 0x3, 0x2, 0x2, 0x2, 0x17e5, 
       0x17e6, 0x3, 0x2, 0x2, 0x2, 0x17e6, 0x17e7, 0x7, 0x24, 0x2, 0x2, 
       0x17e7, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x17e8, 0x17e9, 0x6, 0x15f, 0xa6, 
       0x2, 0x17e9, 0x17ea, 0x7, 0x2a0, 0x2, 0x2, 0x17ea, 0x17eb, 0x7, 0x23, 
       0x2, 0x2, 0x17eb, 0x17ff, 0x5, 0x294, 0x14b, 0x2, 0x17ec, 0x17ed, 
       0x7, 0x43, 0x2, 0x2, 0x17ed, 0x17ee, 0x7, 0x6d, 0x2, 0x2, 0x17ee, 
       0x17f0, 0x5, 0x398, 0x1cd, 0x2, 0x17ef, 0x17ec, 0x3, 0x2, 0x2, 0x2, 
       0x17ef, 0x17f0, 0x3, 0x2, 0x2, 0x2, 0x17f0, 0x17f3, 0x3, 0x2, 0x2, 
       0x2, 0x17f1, 0x17f2, 0x6, 0x15f, 0xa7, 0x2, 0x17f2, 0x17f4, 0x5, 
       0x2c4, 0x163, 0x2, 0x17f3, 0x17f1, 0x3, 0x2, 0x2, 0x2, 0x17f3, 0x17f4, 
       0x3, 0x2, 0x2, 0x2, 0x17f4, 0x1800, 0x3, 0x2, 0x2, 0x2, 0x17f5, 0x17f6, 
       0x7, 0x43, 0x2, 0x2, 0x17f6, 0x17f7, 0x7, 0x52, 0x2, 0x2, 0x17f7, 
       0x1800, 0x5, 0x398, 0x1cd, 0x2, 0x17f8, 0x17f9, 0x7, 0x20, 0x2, 0x2, 
       0x17f9, 0x17fa, 0x5, 0x466, 0x234, 0x2, 0x17fa, 0x17fb, 0x7, 0x20, 
       0x2, 0x2, 0x17fb, 0x17fc, 0x5, 0x466, 0x234, 0x2, 0x17fc, 0x17fd, 
       0x7, 0x20, 0x2, 0x2, 0x17fd, 0x17fe, 0x5, 0x466, 0x234, 0x2, 0x17fe, 
       0x1800, 0x3, 0x2, 0x2, 0x2, 0x17ff, 0x17ef, 0x3, 0x2, 0x2, 0x2, 0x17ff, 
       0x17f5, 0x3, 0x2, 0x2, 0x2, 0x17ff, 0x17f8, 0x3, 0x2, 0x2, 0x2, 0x1800, 
       0x1801, 0x3, 0x2, 0x2, 0x2, 0x1801, 0x1802, 0x7, 0x24, 0x2, 0x2, 
       0x1802, 0x1805, 0x3, 0x2, 0x2, 0x2, 0x1803, 0x1805, 0x5, 0x2be, 0x160, 
       0x2, 0x1804, 0x16f2, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x16fb, 0x3, 0x2, 
       0x2, 0x2, 0x1804, 0x16ff, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1701, 0x3, 
       0x2, 0x2, 0x2, 0x1804, 0x1703, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1705, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1710, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x171b, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1722, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1724, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1726, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x172d, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x172f, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1731, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x173a, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x173b, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x173d, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x173f, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1741, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x174e, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1752, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1756, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x175f, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1766, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x176d, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1771, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1778, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1779, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x177d, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1786, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x178a, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x178e, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1792, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1794, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x1796, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1798, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x179a, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x179c, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x17a5, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x17b0, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x17b2, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x17b9, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x17bf, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x17c2, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x17c4, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x17cb, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x17d4, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x17d6, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x17d8, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x17df, 
       0x3, 0x2, 0x2, 0x2, 0x1804, 0x17e8, 0x3, 0x2, 0x2, 0x2, 0x1804, 0x1803, 
       0x3, 0x2, 0x2, 0x2, 0x1805, 0x2bd, 0x3, 0x2, 0x2, 0x2, 0x1806, 0x1807, 
       0x6, 0x160, 0xa8, 0x2, 0x1807, 0x1808, 0x7, 0x8b, 0x2, 0x2, 0x1808, 
       0x1809, 0x7, 0x23, 0x2, 0x2, 0x1809, 0x180a, 0x5, 0x294, 0x14b, 0x2, 
       0x180a, 0x180b, 0x7, 0x20, 0x2, 0x2, 0x180b, 0x180c, 0x5, 0x294, 
       0x14b, 0x2, 0x180c, 0x180d, 0x7, 0x24, 0x2, 0x2, 0x180d, 0x1826, 
       0x3, 0x2, 0x2, 0x2, 0x180e, 0x180f, 0x7, 0xfc, 0x2, 0x2, 0x180f, 
       0x1811, 0x7, 0x23, 0x2, 0x2, 0x1810, 0x1812, 0x5, 0x2e4, 0x173, 0x2, 
       0x1811, 0x1810, 0x3, 0x2, 0x2, 0x2, 0x1811, 0x1812, 0x3, 0x2, 0x2, 
       0x2, 0x1812, 0x1813, 0x3, 0x2, 0x2, 0x2, 0x1813, 0x1826, 0x7, 0x24, 
       0x2, 0x2, 0x1814, 0x1815, 0x7, 0x13e, 0x2, 0x2, 0x1815, 0x1826, 0x5, 
       0x2f0, 0x179, 0x2, 0x1816, 0x1817, 0x7, 0x183, 0x2, 0x2, 0x1817, 
       0x1826, 0x5, 0x2f0, 0x179, 0x2, 0x1818, 0x1819, 0x7, 0x184, 0x2, 
       0x2, 0x1819, 0x1826, 0x5, 0x2f0, 0x179, 0x2, 0x181a, 0x181b, 0x7, 
       0x185, 0x2, 0x2, 0x181b, 0x1826, 0x5, 0x2f0, 0x179, 0x2, 0x181c, 
       0x181d, 0x7, 0x1bf, 0x2, 0x2, 0x181d, 0x181e, 0x7, 0x23, 0x2, 0x2, 
       0x181e, 0x181f, 0x5, 0x294, 0x14b, 0x2, 0x181f, 0x1820, 0x7, 0x20, 
       0x2, 0x2, 0x1820, 0x1821, 0x5, 0x294, 0x14b, 0x2, 0x1821, 0x1822, 
       0x7, 0x24, 0x2, 0x2, 0x1822, 0x1826, 0x3, 0x2, 0x2, 0x2, 0x1823, 
       0x1824, 0x7, 0x1c0, 0x2, 0x2, 0x1824, 0x1826, 0x5, 0x2f0, 0x179, 
       0x2, 0x1825, 0x1806, 0x3, 0x2, 0x2, 0x2, 0x1825, 0x180e, 0x3, 0x2, 
       0x2, 0x2, 0x1825, 0x1814, 0x3, 0x2, 0x2, 0x2, 0x1825, 0x1816, 0x3, 
       0x2, 0x2, 0x2, 0x1825, 0x1818, 0x3, 0x2, 0x2, 0x2, 0x1825, 0x181a, 
       0x3, 0x2, 0x2, 0x2, 0x1825, 0x181c, 0x3, 0x2, 0x2, 0x2, 0x1825, 0x1823, 
       0x3, 0x2, 0x2, 0x2, 0x1826, 0x2bf, 0x3, 0x2, 0x2, 0x2, 0x1827, 0x1829, 
       0x7, 0x23, 0x2, 0x2, 0x1828, 0x182a, 0x5, 0x2c2, 0x162, 0x2, 0x1829, 
       0x1828, 0x3, 0x2, 0x2, 0x2, 0x1829, 0x182a, 0x3, 0x2, 0x2, 0x2, 0x182a, 
       0x182b, 0x3, 0x2, 0x2, 0x2, 0x182b, 0x182c, 0x7, 0x24, 0x2, 0x2, 
       0x182c, 0x2c1, 0x3, 0x2, 0x2, 0x2, 0x182d, 0x182e, 0x6, 0x162, 0xa9, 
       0x2, 0x182e, 0x182f, 0x7, 0x6, 0x2, 0x2, 0x182f, 0x2c3, 0x3, 0x2, 
       0x2, 0x2, 0x1830, 0x183d, 0x7, 0x139, 0x2, 0x2, 0x1831, 0x1832, 0x5, 
       0x468, 0x235, 0x2, 0x1832, 0x1833, 0x7, 0x12, 0x2, 0x2, 0x1833, 0x1834, 
       0x5, 0x468, 0x235, 0x2, 0x1834, 0x183e, 0x3, 0x2, 0x2, 0x2, 0x1835, 
       0x183a, 0x5, 0x2c6, 0x164, 0x2, 0x1836, 0x1837, 0x7, 0x20, 0x2, 0x2, 
       0x1837, 0x1839, 0x5, 0x2c6, 0x164, 0x2, 0x1838, 0x1836, 0x3, 0x2, 
       0x2, 0x2, 0x1839, 0x183c, 0x3, 0x2, 0x2, 0x2, 0x183a, 0x1838, 0x3, 
       0x2, 0x2, 0x2, 0x183a, 0x183b, 0x3, 0x2, 0x2, 0x2, 0x183b, 0x183e, 
       0x3, 0x2, 0x2, 0x2, 0x183c, 0x183a, 0x3, 0x2, 0x2, 0x2, 0x183d, 0x1831, 
       0x3, 0x2, 0x2, 0x2, 0x183d, 0x1835, 0x3, 0x2, 0x2, 0x2, 0x183e, 0x2c5, 
       0x3, 0x2, 0x2, 0x2, 0x183f, 0x1845, 0x5, 0x468, 0x235, 0x2, 0x1840, 
       0x1842, 0x9, 0x23, 0x2, 0x2, 0x1841, 0x1843, 0x7, 0x200, 0x2, 0x2, 
       0x1842, 0x1841, 0x3, 0x2, 0x2, 0x2, 0x1842, 0x1843, 0x3, 0x2, 0x2, 
       0x2, 0x1843, 0x1846, 0x3, 0x2, 0x2, 0x2, 0x1844, 0x1846, 0x7, 0x200, 
       0x2, 0x2, 0x1845, 0x1840, 0x3, 0x2, 0x2, 0x2, 0x1845, 0x1844, 0x3, 
       0x2, 0x2, 0x2, 0x1845, 0x1846, 0x3, 0x2, 0x2, 0x2, 0x1846, 0x2c7, 
       0x3, 0x2, 0x2, 0x2, 0x1847, 0x1848, 0x9, 0x60, 0x2, 0x2, 0x1848, 
       0x2c9, 0x3, 0x2, 0x2, 0x2, 0x1849, 0x184a, 0x7, 0x273, 0x2, 0x2, 
       0x184a, 0x1862, 0x7, 0x23, 0x2, 0x2, 0x184b, 0x184e, 0x5, 0x294, 
       0x14b, 0x2, 0x184c, 0x184d, 0x7, 0xf4, 0x2, 0x2, 0x184d, 0x184f, 
       0x5, 0x294, 0x14b, 0x2, 0x184e, 0x184c, 0x3, 0x2, 0x2, 0x2, 0x184e, 
       0x184f, 0x3, 0x2, 0x2, 0x2, 0x184f, 0x1863, 0x3, 0x2, 0x2, 0x2, 0x1850, 
       0x1852, 0x7, 0x134, 0x2, 0x2, 0x1851, 0x1853, 0x5, 0x294, 0x14b, 
       0x2, 0x1852, 0x1851, 0x3, 0x2, 0x2, 0x2, 0x1852, 0x1853, 0x3, 0x2, 
       0x2, 0x2, 0x1853, 0x1854, 0x3, 0x2, 0x2, 0x2, 0x1854, 0x1855, 0x7, 
       0xf4, 0x2, 0x2, 0x1855, 0x1863, 0x5, 0x294, 0x14b, 0x2, 0x1856, 0x1858, 
       0x7, 0x26f, 0x2, 0x2, 0x1857, 0x1859, 0x5, 0x294, 0x14b, 0x2, 0x1858, 
       0x1857, 0x3, 0x2, 0x2, 0x2, 0x1858, 0x1859, 0x3, 0x2, 0x2, 0x2, 0x1859, 
       0x185a, 0x3, 0x2, 0x2, 0x2, 0x185a, 0x185b, 0x7, 0xf4, 0x2, 0x2, 
       0x185b, 0x1863, 0x5, 0x294, 0x14b, 0x2, 0x185c, 0x185e, 0x7, 0x5d, 
       0x2, 0x2, 0x185d, 0x185f, 0x5, 0x294, 0x14b, 0x2, 0x185e, 0x185d, 
       0x3, 0x2, 0x2, 0x2, 0x185e, 0x185f, 0x3, 0x2, 0x2, 0x2, 0x185f, 0x1860, 
       0x3, 0x2, 0x2, 0x2, 0x1860, 0x1861, 0x7, 0xf4, 0x2, 0x2, 0x1861, 
       0x1863, 0x5, 0x294, 0x14b, 0x2, 0x1862, 0x184b, 0x3, 0x2, 0x2, 0x2, 
       0x1862, 0x1850, 0x3, 0x2, 0x2, 0x2, 0x1862, 0x1856, 0x3, 0x2, 0x2, 
       0x2, 0x1862, 0x185c, 0x3, 0x2, 0x2, 0x2, 0x1863, 0x1864, 0x3, 0x2, 
       0x2, 0x2, 0x1864, 0x1865, 0x7, 0x24, 0x2, 0x2, 0x1865, 0x2cb, 0x3, 
       0x2, 0x2, 0x2, 0x1866, 0x1867, 0x7, 0x253, 0x2, 0x2, 0x1867, 0x1868, 
       0x7, 0x23, 0x2, 0x2, 0x1868, 0x1875, 0x5, 0x294, 0x14b, 0x2, 0x1869, 
       0x186a, 0x7, 0x20, 0x2, 0x2, 0x186a, 0x186d, 0x5, 0x294, 0x14b, 0x2, 
       0x186b, 0x186c, 0x7, 0x20, 0x2, 0x2, 0x186c, 0x186e, 0x5, 0x294, 
       0x14b, 0x2, 0x186d, 0x186b, 0x3, 0x2, 0x2, 0x2, 0x186d, 0x186e, 0x3, 
       0x2, 0x2, 0x2, 0x186e, 0x1876, 0x3, 0x2, 0x2, 0x2, 0x186f, 0x1870, 
       0x7, 0xf4, 0x2, 0x2, 0x1870, 0x1873, 0x5, 0x294, 0x14b, 0x2, 0x1871, 
       0x1872, 0x7, 0xf1, 0x2, 0x2, 0x1872, 0x1874, 0x5, 0x294, 0x14b, 0x2, 
       0x1873, 0x1871, 0x3, 0x2, 0x2, 0x2, 0x1873, 0x1874, 0x3, 0x2, 0x2, 
       0x2, 0x1874, 0x1876, 0x3, 0x2, 0x2, 0x2, 0x1875, 0x1869, 0x3, 0x2, 
       0x2, 0x2, 0x1875, 0x186f, 0x3, 0x2, 0x2, 0x2, 0x1876, 0x1877, 0x3, 
       0x2, 0x2, 0x2, 0x1877, 0x1878, 0x7, 0x24, 0x2, 0x2, 0x1878, 0x2cd, 
       0x3, 0x2, 0x2, 0x2, 0x1879, 0x187a, 0x5, 0x458, 0x22d, 0x2, 0x187a, 
       0x187c, 0x7, 0x23, 0x2, 0x2, 0x187b, 0x187d, 0x5, 0x2d0, 0x169, 0x2, 
       0x187c, 0x187b, 0x3, 0x2, 0x2, 0x2, 0x187c, 0x187d, 0x3, 0x2, 0x2, 
       0x2, 0x187d, 0x187e, 0x3, 0x2, 0x2, 0x2, 0x187e, 0x187f, 0x7, 0x24, 
       0x2, 0x2, 0x187f, 0x1888, 0x3, 0x2, 0x2, 0x2, 0x1880, 0x1881, 0x5, 
       0x460, 0x231, 0x2, 0x1881, 0x1883, 0x7, 0x23, 0x2, 0x2, 0x1882, 0x1884, 
       0x5, 0x2e4, 0x173, 0x2, 0x1883, 0x1882, 0x3, 0x2, 0x2, 0x2, 0x1883, 
       0x1884, 0x3, 0x2, 0x2, 0x2, 0x1884, 0x1885, 0x3, 0x2, 0x2, 0x2, 0x1885, 
       0x1886, 0x7, 0x24, 0x2, 0x2, 0x1886, 0x1888, 0x3, 0x2, 0x2, 0x2, 
       0x1887, 0x1879, 0x3, 0x2, 0x2, 0x2, 0x1887, 0x1880, 0x3, 0x2, 0x2, 
       0x2, 0x1888, 0x2cf, 0x3, 0x2, 0x2, 0x2, 0x1889, 0x188e, 0x5, 0x2d2, 
       0x16a, 0x2, 0x188a, 0x188b, 0x7, 0x20, 0x2, 0x2, 0x188b, 0x188d, 
       0x5, 0x2d2, 0x16a, 0x2, 0x188c, 0x188a, 0x3, 0x2, 0x2, 0x2, 0x188d, 
       0x1890, 0x3, 0x2, 0x2, 0x2, 0x188e, 0x188c, 0x3, 0x2, 0x2, 0x2, 0x188e, 
       0x188f, 0x3, 0x2, 0x2, 0x2, 0x188f, 0x2d1, 0x3, 0x2, 0x2, 0x2, 0x1890, 
       0x188e, 0x3, 0x2, 0x2, 0x2, 0x1891, 0x1893, 0x5, 0x294, 0x14b, 0x2, 
       0x1892, 0x1894, 0x5, 0x160, 0xb1, 0x2, 0x1893, 0x1892, 0x3, 0x2, 
       0x2, 0x2, 0x1893, 0x1894, 0x3, 0x2, 0x2, 0x2, 0x1894, 0x2d3, 0x3, 
       0x2, 0x2, 0x2, 0x1895, 0x1898, 0x5, 0x2d6, 0x16c, 0x2, 0x1896, 0x1897, 
       0x7, 0xa, 0x2, 0x2, 0x1897, 0x1899, 0x5, 0x294, 0x14b, 0x2, 0x1898, 
       0x1896, 0x3, 0x2, 0x2, 0x2, 0x1898, 0x1899, 0x3, 0x2, 0x2, 0x2, 0x1899, 
       0x189c, 0x3, 0x2, 0x2, 0x2, 0x189a, 0x189c, 0x5, 0x2d8, 0x16d, 0x2, 
       0x189b, 0x1895, 0x3, 0x2, 0x2, 0x2, 0x189b, 0x189a, 0x3, 0x2, 0x2, 
       0x2, 0x189c, 0x2d5, 0x3, 0x2, 0x2, 0x2, 0x189d, 0x189e, 0x7, 0x2a, 
       0x2, 0x2, 0x189e, 0x18a1, 0x5, 0x48e, 0x248, 0x2, 0x189f, 0x18a1, 
       0x7, 0x2b, 0x2, 0x2, 0x18a0, 0x189d, 0x3, 0x2, 0x2, 0x2, 0x18a0, 
       0x189f, 0x3, 0x2, 0x2, 0x2, 0x18a1, 0x2d7, 0x3, 0x2, 0x2, 0x2, 0x18a2, 
       0x18a4, 0x7, 0x2c, 0x2, 0x2, 0x18a3, 0x18a5, 0x5, 0x49c, 0x24f, 0x2, 
       0x18a4, 0x18a3, 0x3, 0x2, 0x2, 0x2, 0x18a4, 0x18a5, 0x3, 0x2, 0x2, 
       0x2, 0x18a5, 0x18a6, 0x3, 0x2, 0x2, 0x2, 0x18a6, 0x18a8, 0x5, 0x48e, 
       0x248, 0x2, 0x18a7, 0x18a9, 0x5, 0x464, 0x233, 0x2, 0x18a8, 0x18a7, 
       0x3, 0x2, 0x2, 0x2, 0x18a8, 0x18a9, 0x3, 0x2, 0x2, 0x2, 0x18a9, 0x2d9, 
       0x3, 0x2, 0x2, 0x2, 0x18aa, 0x18ab, 0x6, 0x16e, 0xaa, 0x2, 0x18ab, 
       0x18ad, 0x5, 0x45a, 0x22e, 0x2, 0x18ac, 0x18ae, 0x5, 0x464, 0x233, 
       0x2, 0x18ad, 0x18ac, 0x3, 0x2, 0x2, 0x2, 0x18ad, 0x18ae, 0x3, 0x2, 
       0x2, 0x2, 0x18ae, 0x18b5, 0x3, 0x2, 0x2, 0x2, 0x18af, 0x18b0, 0x6, 
       0x16e, 0xab, 0x2, 0x18b0, 0x18b2, 0x5, 0x490, 0x249, 0x2, 0x18b1, 
       0x18b3, 0x5, 0x464, 0x233, 0x2, 0x18b2, 0x18b1, 0x3, 0x2, 0x2, 0x2, 
       0x18b2, 0x18b3, 0x3, 0x2, 0x2, 0x2, 0x18b3, 0x18b5, 0x3, 0x2, 0x2, 
       0x2, 0x18b4, 0x18aa, 0x3, 0x2, 0x2, 0x2, 0x18b4, 0x18af, 0x3, 0x2, 
       0x2, 0x2, 0x18b5, 0x18b9, 0x3, 0x2, 0x2, 0x2, 0x18b6, 0x18b7, 0x7, 
       0xae, 0x2, 0x2, 0x18b7, 0x18b9, 0x5, 0x464, 0x233, 0x2, 0x18b8, 0x18b4, 
       0x3, 0x2, 0x2, 0x2, 0x18b8, 0x18b6, 0x3, 0x2, 0x2, 0x2, 0x18b9, 0x2db, 
       0x3, 0x2, 0x2, 0x2, 0x18ba, 0x18bb, 0x7, 0x2a1, 0x2, 0x2, 0x18bb, 
       0x18bc, 0x5, 0x294, 0x14b, 0x2, 0x18bc, 0x2dd, 0x3, 0x2, 0x2, 0x2, 
       0x18bd, 0x18be, 0x7, 0x266, 0x2, 0x2, 0x18be, 0x18bf, 0x5, 0x294, 
       0x14b, 0x2, 0x18bf, 0x2df, 0x3, 0x2, 0x2, 0x2, 0x18c0, 0x18c1, 0x7, 
       0xc7, 0x2, 0x2, 0x18c1, 0x18c2, 0x5, 0x294, 0x14b, 0x2, 0x18c2, 0x2e1, 
       0x3, 0x2, 0x2, 0x2, 0x18c3, 0x18c5, 0x7, 0x52, 0x2, 0x2, 0x18c4, 
       0x18c6, 0x5, 0x38e, 0x1c8, 0x2, 0x18c5, 0x18c4, 0x3, 0x2, 0x2, 0x2, 
       0x18c5, 0x18c6, 0x3, 0x2, 0x2, 0x2, 0x18c6, 0x18f1, 0x3, 0x2, 0x2, 
       0x2, 0x18c7, 0x18c9, 0x7, 0x6d, 0x2, 0x2, 0x18c8, 0x18ca, 0x5, 0x38e, 
       0x1c8, 0x2, 0x18c9, 0x18c8, 0x3, 0x2, 0x2, 0x2, 0x18c9, 0x18ca, 0x3, 
       0x2, 0x2, 0x2, 0x18ca, 0x18cc, 0x3, 0x2, 0x2, 0x2, 0x18cb, 0x18cd, 
       0x5, 0x392, 0x1ca, 0x2, 0x18cc, 0x18cb, 0x3, 0x2, 0x2, 0x2, 0x18cc, 
       0x18cd, 0x3, 0x2, 0x2, 0x2, 0x18cd, 0x18f1, 0x3, 0x2, 0x2, 0x2, 0x18ce, 
       0x18d0, 0x5, 0x386, 0x1c4, 0x2, 0x18cf, 0x18d1, 0x5, 0x38e, 0x1c8, 
       0x2, 0x18d0, 0x18cf, 0x3, 0x2, 0x2, 0x2, 0x18d0, 0x18d1, 0x3, 0x2, 
       0x2, 0x2, 0x18d1, 0x18f1, 0x3, 0x2, 0x2, 0x2, 0x18d2, 0x18d4, 0x7, 
       0x221, 0x2, 0x2, 0x18d3, 0x18d5, 0x7, 0x121, 0x2, 0x2, 0x18d4, 0x18d3, 
       0x3, 0x2, 0x2, 0x2, 0x18d4, 0x18d5, 0x3, 0x2, 0x2, 0x2, 0x18d5, 0x18f1, 
       0x3, 0x2, 0x2, 0x2, 0x18d6, 0x18d8, 0x7, 0x284, 0x2, 0x2, 0x18d7, 
       0x18d9, 0x7, 0x121, 0x2, 0x2, 0x18d8, 0x18d7, 0x3, 0x2, 0x2, 0x2, 
       0x18d8, 0x18d9, 0x3, 0x2, 0x2, 0x2, 0x18d9, 0x18f1, 0x3, 0x2, 0x2, 
       0x2, 0x18da, 0x18f1, 0x7, 0xa4, 0x2, 0x2, 0x18db, 0x18dd, 0x7, 0x26a, 
       0x2, 0x2, 0x18dc, 0x18de, 0x5, 0x39a, 0x1ce, 0x2, 0x18dd, 0x18dc, 
       0x3, 0x2, 0x2, 0x2, 0x18dd, 0x18de, 0x3, 0x2, 0x2, 0x2, 0x18de, 0x18f1, 
       0x3, 0x2, 0x2, 0x2, 0x18df, 0x18e1, 0x7, 0xa1, 0x2, 0x2, 0x18e0, 
       0x18e2, 0x5, 0x39a, 0x1ce, 0x2, 0x18e1, 0x18e0, 0x3, 0x2, 0x2, 0x2, 
       0x18e1, 0x18e2, 0x3, 0x2, 0x2, 0x2, 0x18e2, 0x18f1, 0x3, 0x2, 0x2, 
       0x2, 0x18e3, 0x18e5, 0x7, 0xac, 0x2, 0x2, 0x18e4, 0x18e6, 0x5, 0x488, 
       0x245, 0x2, 0x18e5, 0x18e4, 0x3, 0x2, 0x2, 0x2, 0x18e5, 0x18e6, 0x3, 
       0x2, 0x2, 0x2, 0x18e6, 0x18f1, 0x3, 0x2, 0x2, 0x2, 0x18e7, 0x18e8, 
       0x6, 0x172, 0xac, 0x2, 0x18e8, 0x18f1, 0x7, 0x12d, 0x2, 0x2, 0x18e9, 
       0x18ea, 0x6, 0x172, 0xad, 0x2, 0x18ea, 0x18f1, 0x5, 0x38c, 0x1c7, 
       0x2, 0x18eb, 0x18ec, 0x6, 0x172, 0xae, 0x2, 0x18ec, 0x18ee, 0x7, 
       0xec, 0x2, 0x2, 0x18ed, 0x18ef, 0x5, 0x48a, 0x246, 0x2, 0x18ee, 0x18ed, 
       0x3, 0x2, 0x2, 0x2, 0x18ee, 0x18ef, 0x3, 0x2, 0x2, 0x2, 0x18ef, 0x18f1, 
       0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18c3, 0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18c7, 
       0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18ce, 0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18d2, 
       0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18d6, 0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18da, 
       0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18db, 0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18df, 
       0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18e3, 0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18e7, 
       0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18e9, 0x3, 0x2, 0x2, 0x2, 0x18f0, 0x18eb, 
       0x3, 0x2, 0x2, 0x2, 0x18f1, 0x2e3, 0x3, 0x2, 0x2, 0x2, 0x18f2, 0x18f7, 
       0x5, 0x294, 0x14b, 0x2, 0x18f3, 0x18f4, 0x7, 0x20, 0x2, 0x2, 0x18f4, 
       0x18f6, 0x5, 0x294, 0x14b, 0x2, 0x18f5, 0x18f3, 0x3, 0x2, 0x2, 0x2, 
       0x18f6, 0x18f9, 0x3, 0x2, 0x2, 0x2, 0x18f7, 0x18f5, 0x3, 0x2, 0x2, 
       0x2, 0x18f7, 0x18f8, 0x3, 0x2, 0x2, 0x2, 0x18f8, 0x2e5, 0x3, 0x2, 
       0x2, 0x2, 0x18f9, 0x18f7, 0x3, 0x2, 0x2, 0x2, 0x18fa, 0x18fb, 0x7, 
       0x6d, 0x2, 0x2, 0x18fb, 0x18fe, 0x7, 0x21b, 0x2, 0x2, 0x18fc, 0x18fe, 
       0x7, 0x6c, 0x2, 0x2, 0x18fd, 0x18fa, 0x3, 0x2, 0x2, 0x2, 0x18fd, 
       0x18fc, 0x3, 0x2, 0x2, 0x2, 0x18fe, 0x2e7, 0x3, 0x2, 0x2, 0x2, 0x18ff, 
       0x1900, 0x9, 0x61, 0x2, 0x2, 0x1900, 0x2e9, 0x3, 0x2, 0x2, 0x2, 0x1901, 
       0x1902, 0x9, 0x62, 0x2, 0x2, 0x1902, 0x2eb, 0x3, 0x2, 0x2, 0x2, 0x1903, 
       0x1906, 0x5, 0x2ee, 0x178, 0x2, 0x1904, 0x1906, 0x9, 0x63, 0x2, 0x2, 
       0x1905, 0x1903, 0x3, 0x2, 0x2, 0x2, 0x1905, 0x1904, 0x3, 0x2, 0x2, 
       0x2, 0x1906, 0x2ed, 0x3, 0x2, 0x2, 0x2, 0x1907, 0x1908, 0x9, 0x64, 
       0x2, 0x2, 0x1908, 0x2ef, 0x3, 0x2, 0x2, 0x2, 0x1909, 0x190a, 0x7, 
       0x23, 0x2, 0x2, 0x190a, 0x190b, 0x5, 0x2e4, 0x173, 0x2, 0x190b, 0x190c, 
       0x7, 0x24, 0x2, 0x2, 0x190c, 0x2f1, 0x3, 0x2, 0x2, 0x2, 0x190d, 0x190e, 
       0x7, 0x23, 0x2, 0x2, 0x190e, 0x190f, 0x5, 0x294, 0x14b, 0x2, 0x190f, 
       0x1910, 0x7, 0x24, 0x2, 0x2, 0x1910, 0x2f3, 0x3, 0x2, 0x2, 0x2, 0x1911, 
       0x1912, 0x7, 0x23, 0x2, 0x2, 0x1912, 0x1913, 0x5, 0x2a0, 0x151, 0x2, 
       0x1913, 0x1914, 0x7, 0x24, 0x2, 0x2, 0x1914, 0x2f5, 0x3, 0x2, 0x2, 
       0x2, 0x1915, 0x191a, 0x5, 0x2f8, 0x17d, 0x2, 0x1916, 0x1917, 0x7, 
       0x20, 0x2, 0x2, 0x1917, 0x1919, 0x5, 0x2f8, 0x17d, 0x2, 0x1918, 0x1916, 
       0x3, 0x2, 0x2, 0x2, 0x1919, 0x191c, 0x3, 0x2, 0x2, 0x2, 0x191a, 0x1918, 
       0x3, 0x2, 0x2, 0x2, 0x191a, 0x191b, 0x3, 0x2, 0x2, 0x2, 0x191b, 0x2f7, 
       0x3, 0x2, 0x2, 0x2, 0x191c, 0x191a, 0x3, 0x2, 0x2, 0x2, 0x191d, 0x191f, 
       0x5, 0x294, 0x14b, 0x2, 0x191e, 0x1920, 0x5, 0x14e, 0xa8, 0x2, 0x191f, 
       0x191e, 0x3, 0x2, 0x2, 0x2, 0x191f, 0x1920, 0x3, 0x2, 0x2, 0x2, 0x1920, 
       0x2f9, 0x3, 0x2, 0x2, 0x2, 0x1921, 0x1926, 0x5, 0x2fc, 0x17f, 0x2, 
       0x1922, 0x1923, 0x7, 0x20, 0x2, 0x2, 0x1923, 0x1925, 0x5, 0x2fc, 
       0x17f, 0x2, 0x1924, 0x1922, 0x3, 0x2, 0x2, 0x2, 0x1925, 0x1928, 0x3, 
       0x2, 0x2, 0x2, 0x1926, 0x1924, 0x3, 0x2, 0x2, 0x2, 0x1926, 0x1927, 
       0x3, 0x2, 0x2, 0x2, 0x1927, 0x2fb, 0x3, 0x2, 0x2, 0x2, 0x1928, 0x1926, 
       0x3, 0x2, 0x2, 0x2, 0x1929, 0x192a, 0x5, 0x294, 0x14b, 0x2, 0x192a, 
       0x2fd, 0x3, 0x2, 0x2, 0x2, 0x192b, 0x192c, 0x6, 0x180, 0xaf, 0x2, 
       0x192c, 0x192d, 0x7, 0xf1, 0x2, 0x2, 0x192d, 0x192e, 0x7, 0x6b, 0x2, 
       0x2, 0x192e, 0x192f, 0x5, 0x47c, 0x23f, 0x2, 0x192f, 0x2ff, 0x3, 
       0x2, 0x2, 0x2, 0x1930, 0x193e, 0x5, 0x8, 0x5, 0x2, 0x1931, 0x193e, 
       0x5, 0x302, 0x182, 0x2, 0x1932, 0x193e, 0x5, 0x304, 0x183, 0x2, 0x1933, 
       0x193e, 0x5, 0x30c, 0x187, 0x2, 0x1934, 0x193e, 0x5, 0x310, 0x189, 
       0x2, 0x1935, 0x193e, 0x5, 0x312, 0x18a, 0x2, 0x1936, 0x193e, 0x5, 
       0x318, 0x18d, 0x2, 0x1937, 0x193e, 0x5, 0x31a, 0x18e, 0x2, 0x1938, 
       0x193e, 0x5, 0x336, 0x19c, 0x2, 0x1939, 0x193e, 0x5, 0x334, 0x19b, 
       0x2, 0x193a, 0x193e, 0x5, 0x348, 0x1a5, 0x2, 0x193b, 0x193e, 0x5, 
       0x34c, 0x1a7, 0x2, 0x193c, 0x193e, 0x5, 0x34a, 0x1a6, 0x2, 0x193d, 
       0x1930, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x1931, 0x3, 0x2, 0x2, 0x2, 0x193d, 
       0x1932, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x1933, 0x3, 0x2, 0x2, 0x2, 0x193d, 
       0x1934, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x1935, 0x3, 0x2, 0x2, 0x2, 0x193d, 
       0x1936, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x1937, 0x3, 0x2, 0x2, 0x2, 0x193d, 
       0x1938, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x1939, 0x3, 0x2, 0x2, 0x2, 0x193d, 
       0x193a, 0x3, 0x2, 0x2, 0x2, 0x193d, 0x193b, 0x3, 0x2, 0x2, 0x2, 0x193d, 
       0x193c, 0x3, 0x2, 0x2, 0x2, 0x193e, 0x301, 0x3, 0x2, 0x2, 0x2, 0x193f, 
       0x1940, 0x7, 0x1ff, 0x2, 0x2, 0x1940, 0x1941, 0x5, 0x294, 0x14b, 
       0x2, 0x1941, 0x303, 0x3, 0x2, 0x2, 0x2, 0x1942, 0x1943, 0x7, 0x110, 
       0x2, 0x2, 0x1943, 0x1944, 0x5, 0x306, 0x184, 0x2, 0x1944, 0x1945, 
       0x7, 0xcc, 0x2, 0x2, 0x1945, 0x1946, 0x7, 0x110, 0x2, 0x2, 0x1946, 
       0x305, 0x3, 0x2, 0x2, 0x2, 0x1947, 0x1948, 0x5, 0x294, 0x14b, 0x2, 
       0x1948, 0x194d, 0x5, 0x308, 0x185, 0x2, 0x1949, 0x194a, 0x7, 0xc8, 
       0x2, 0x2, 0x194a, 0x194e, 0x5, 0x306, 0x184, 0x2, 0x194b, 0x194c, 
       0x7, 0xc7, 0x2, 0x2, 0x194c, 0x194e, 0x5, 0x30a, 0x186, 0x2, 0x194d, 
       0x1949, 0x3, 0x2, 0x2, 0x2, 0x194d, 0x194b, 0x3, 0x2, 0x2, 0x2, 0x194d, 
       0x194e, 0x3, 0x2, 0x2, 0x2, 0x194e, 0x307, 0x3, 0x2, 0x2, 0x2, 0x194f, 
       0x1950, 0x7, 0x266, 0x2, 0x2, 0x1950, 0x1951, 0x5, 0x30a, 0x186, 
       0x2, 0x1951, 0x309, 0x3, 0x2, 0x2, 0x2, 0x1952, 0x1953, 0x5, 0x300, 
       0x181, 0x2, 0x1953, 0x1954, 0x7, 0x21, 0x2, 0x2, 0x1954, 0x1956, 
       0x3, 0x2, 0x2, 0x2, 0x1955, 0x1952, 0x3, 0x2, 0x2, 0x2, 0x1956, 0x1957, 
       0x3, 0x2, 0x2, 0x2, 0x1957, 0x1955, 0x3, 0x2, 0x2, 0x2, 0x1957, 0x1958, 
       0x3, 0x2, 0x2, 0x2, 0x1958, 0x30b, 0x3, 0x2, 0x2, 0x2, 0x1959, 0x195b, 
       0x7, 0x65, 0x2, 0x2, 0x195a, 0x195c, 0x5, 0x294, 0x14b, 0x2, 0x195b, 
       0x195a, 0x3, 0x2, 0x2, 0x2, 0x195b, 0x195c, 0x3, 0x2, 0x2, 0x2, 0x195c, 
       0x1960, 0x3, 0x2, 0x2, 0x2, 0x195d, 0x195e, 0x5, 0x2dc, 0x16f, 0x2, 
       0x195e, 0x195f, 0x5, 0x308, 0x185, 0x2, 0x195f, 0x1961, 0x3, 0x2, 
       0x2, 0x2, 0x1960, 0x195d, 0x3, 0x2, 0x2, 0x2, 0x1961, 0x1962, 0x3, 
       0x2, 0x2, 0x2, 0x1962, 0x1960, 0x3, 0x2, 0x2, 0x2, 0x1962, 0x1963, 
       0x3, 0x2, 0x2, 0x2, 0x1963, 0x1965, 0x3, 0x2, 0x2, 0x2, 0x1964, 0x1966, 
       0x5, 0x30e, 0x188, 0x2, 0x1965, 0x1964, 0x3, 0x2, 0x2, 0x2, 0x1965, 
       0x1966, 0x3, 0x2, 0x2, 0x2, 0x1966, 0x1967, 0x3, 0x2, 0x2, 0x2, 0x1967, 
       0x1968, 0x7, 0xcc, 0x2, 0x2, 0x1968, 0x1969, 0x7, 0x65, 0x2, 0x2, 
       0x1969, 0x30d, 0x3, 0x2, 0x2, 0x2, 0x196a, 0x196b, 0x7, 0xc7, 0x2, 
       0x2, 0x196b, 0x196c, 0x5, 0x30a, 0x186, 0x2, 0x196c, 0x30f, 0x3, 
       0x2, 0x2, 0x2, 0x196d, 0x196e, 0x5, 0x314, 0x18b, 0x2, 0x196e, 0x1970, 
       0x5, 0x316, 0x18c, 0x2, 0x196f, 0x1971, 0x5, 0x44a, 0x226, 0x2, 0x1970, 
       0x196f, 0x3, 0x2, 0x2, 0x2, 0x1970, 0x1971, 0x3, 0x2, 0x2, 0x2, 0x1971, 
       0x311, 0x3, 0x2, 0x2, 0x2, 0x1972, 0x1973, 0x5, 0x316, 0x18c, 0x2, 
       0x1973, 0x313, 0x3, 0x2, 0x2, 0x2, 0x1974, 0x1975, 0x5, 0x448, 0x225, 
       0x2, 0x1975, 0x1976, 0x7, 0x22, 0x2, 0x2, 0x1976, 0x315, 0x3, 0x2, 
       0x2, 0x2, 0x1977, 0x1979, 0x7, 0x4f, 0x2, 0x2, 0x1978, 0x197a, 0x5, 
       0x322, 0x192, 0x2, 0x1979, 0x1978, 0x3, 0x2, 0x2, 0x2, 0x1979, 0x197a, 
       0x3, 0x2, 0x2, 0x2, 0x197a, 0x197c, 0x3, 0x2, 0x2, 0x2, 0x197b, 0x197d, 
       0x5, 0x30a, 0x186, 0x2, 0x197c, 0x197b, 0x3, 0x2, 0x2, 0x2, 0x197c, 
       0x197d, 0x3, 0x2, 0x2, 0x2, 0x197d, 0x197e, 0x3, 0x2, 0x2, 0x2, 0x197e, 
       0x197f, 0x7, 0xcc, 0x2, 0x2, 0x197f, 0x317, 0x3, 0x2, 0x2, 0x2, 0x1980, 
       0x1981, 0x5, 0x314, 0x18b, 0x2, 0x1981, 0x1983, 0x5, 0x31a, 0x18e, 
       0x2, 0x1982, 0x1984, 0x5, 0x44a, 0x226, 0x2, 0x1983, 0x1982, 0x3, 
       0x2, 0x2, 0x2, 0x1983, 0x1984, 0x3, 0x2, 0x2, 0x2, 0x1984, 0x319, 
       0x3, 0x2, 0x2, 0x2, 0x1985, 0x1989, 0x5, 0x31c, 0x18f, 0x2, 0x1986, 
       0x1989, 0x5, 0x31e, 0x190, 0x2, 0x1987, 0x1989, 0x5, 0x320, 0x191, 
       0x2, 0x1988, 0x1985, 0x3, 0x2, 0x2, 0x2, 0x1988, 0x1986, 0x3, 0x2, 
       0x2, 0x2, 0x1988, 0x1987, 0x3, 0x2, 0x2, 0x2, 0x1989, 0x31b, 0x3, 
       0x2, 0x2, 0x2, 0x198a, 0x198b, 0x7, 0x14b, 0x2, 0x2, 0x198b, 0x198c, 
       0x5, 0x30a, 0x186, 0x2, 0x198c, 0x198d, 0x7, 0xcc, 0x2, 0x2, 0x198d, 
       0x198e, 0x7, 0x14b, 0x2, 0x2, 0x198e, 0x31d, 0x3, 0x2, 0x2, 0x2, 
       0x198f, 0x1990, 0x7, 0x2a3, 0x2, 0x2, 0x1990, 0x1991, 0x5, 0x294, 
       0x14b, 0x2, 0x1991, 0x1992, 0x7, 0xc0, 0x2, 0x2, 0x1992, 0x1993, 
       0x5, 0x30a, 0x186, 0x2, 0x1993, 0x1994, 0x7, 0xcc, 0x2, 0x2, 0x1994, 
       0x1995, 0x7, 0x2a3, 0x2, 0x2, 0x1995, 0x31f, 0x3, 0x2, 0x2, 0x2, 
       0x1996, 0x1997, 0x7, 0x1ed, 0x2, 0x2, 0x1997, 0x1998, 0x5, 0x30a, 
       0x186, 0x2, 0x1998, 0x1999, 0x7, 0x285, 0x2, 0x2, 0x1999, 0x199a, 
       0x5, 0x294, 0x14b, 0x2, 0x199a, 0x199b, 0x7, 0xcc, 0x2, 0x2, 0x199b, 
       0x199c, 0x7, 0x1ed, 0x2, 0x2, 0x199c, 0x321, 0x3, 0x2, 0x2, 0x2, 
       0x199d, 0x199e, 0x5, 0x324, 0x193, 0x2, 0x199e, 0x199f, 0x7, 0x21, 
       0x2, 0x2, 0x199f, 0x19a1, 0x3, 0x2, 0x2, 0x2, 0x19a0, 0x199d, 0x3, 
       0x2, 0x2, 0x2, 0x19a1, 0x19a2, 0x3, 0x2, 0x2, 0x2, 0x19a2, 0x19a0, 
       0x3, 0x2, 0x2, 0x2, 0x19a2, 0x19a3, 0x3, 0x2, 0x2, 0x2, 0x19a3, 0x323, 
       0x3, 0x2, 0x2, 0x2, 0x19a4, 0x19a9, 0x5, 0x326, 0x194, 0x2, 0x19a5, 
       0x19a9, 0x5, 0x328, 0x195, 0x2, 0x19a6, 0x19a9, 0x5, 0x32e, 0x198, 
       0x2, 0x19a7, 0x19a9, 0x5, 0x332, 0x19a, 0x2, 0x19a8, 0x19a4, 0x3, 
       0x2, 0x2, 0x2, 0x19a8, 0x19a5, 0x3, 0x2, 0x2, 0x2, 0x19a8, 0x19a6, 
       0x3, 0x2, 0x2, 0x2, 0x19a8, 0x19a7, 0x3, 0x2, 0x2, 0x2, 0x19a9, 0x325, 
       0x3, 0x2, 0x2, 0x2, 0x19aa, 0x19ab, 0x7, 0xad, 0x2, 0x2, 0x19ab, 
       0x19ac, 0x5, 0x45c, 0x22f, 0x2, 0x19ac, 0x19ae, 0x5, 0x384, 0x1c3, 
       0x2, 0x19ad, 0x19af, 0x5, 0x3ce, 0x1e8, 0x2, 0x19ae, 0x19ad, 0x3, 
       0x2, 0x2, 0x2, 0x19ae, 0x19af, 0x3, 0x2, 0x2, 0x2, 0x19af, 0x19b2, 
       0x3, 0x2, 0x2, 0x2, 0x19b0, 0x19b1, 0x7, 0xae, 0x2, 0x2, 0x19b1, 
       0x19b3, 0x5, 0x294, 0x14b, 0x2, 0x19b2, 0x19b0, 0x3, 0x2, 0x2, 0x2, 
       0x19b2, 0x19b3, 0x3, 0x2, 0x2, 0x2, 0x19b3, 0x327, 0x3, 0x2, 0x2, 
       0x2, 0x19b4, 0x19b5, 0x7, 0xad, 0x2, 0x2, 0x19b5, 0x19b6, 0x5, 0x45a, 
       0x22e, 0x2, 0x19b6, 0x19b7, 0x7, 0x84, 0x2, 0x2, 0x19b7, 0x19b8, 
       0x7, 0xf1, 0x2, 0x2, 0x19b8, 0x19b9, 0x5, 0x32a, 0x196, 0x2, 0x19b9, 
       0x329, 0x3, 0x2, 0x2, 0x2, 0x19ba, 0x19bd, 0x5, 0x466, 0x234, 0x2, 
       0x19bb, 0x19bd, 0x5, 0x32c, 0x197, 0x2, 0x19bc, 0x19ba, 0x3, 0x2, 
       0x2, 0x2, 0x19bc, 0x19bb, 0x3, 0x2, 0x2, 0x2, 0x19bd, 0x32b, 0x3, 
       0x2, 0x2, 0x2, 0x19be, 0x19c0, 0x7, 0x22e, 0x2, 0x2, 0x19bf, 0x19c1, 
       0x7, 0x293, 0x2, 0x2, 0x19c0, 0x19bf, 0x3, 0x2, 0x2, 0x2, 0x19c0, 
       0x19c1, 0x3, 0x2, 0x2, 0x2, 0x19c1, 0x19c2, 0x3, 0x2, 0x2, 0x2, 0x19c2, 
       0x19c3, 0x5, 0x47a, 0x23e, 0x2, 0x19c3, 0x32d, 0x3, 0x2, 0x2, 0x2, 
       0x19c4, 0x19c5, 0x7, 0xad, 0x2, 0x2, 0x19c5, 0x19c6, 0x9, 0x65, 0x2, 
       0x2, 0x19c6, 0x19c7, 0x7, 0x104, 0x2, 0x2, 0x19c7, 0x19c8, 0x7, 0xf1, 
       0x2, 0x2, 0x19c8, 0x19cd, 0x5, 0x330, 0x199, 0x2, 0x19c9, 0x19ca, 
       0x7, 0x20, 0x2, 0x2, 0x19ca, 0x19cc, 0x5, 0x330, 0x199, 0x2, 0x19cb, 
       0x19c9, 0x3, 0x2, 0x2, 0x2, 0x19cc, 0x19cf, 0x3, 0x2, 0x2, 0x2, 0x19cd, 
       0x19cb, 0x3, 0x2, 0x2, 0x2, 0x19cd, 0x19ce, 0x3, 0x2, 0x2, 0x2, 0x19ce, 
       0x19d0, 0x3, 0x2, 0x2, 0x2, 0x19cf, 0x19cd, 0x3, 0x2, 0x2, 0x2, 0x19d0, 
       0x19d1, 0x5, 0x300, 0x181, 0x2, 0x19d1, 0x32f, 0x3, 0x2, 0x2, 0x2, 
       0x19d2, 0x19da, 0x5, 0x32a, 0x196, 0x2, 0x19d3, 0x19da, 0x5, 0x45a, 
       0x22e, 0x2, 0x19d4, 0x19da, 0x7, 0x22f, 0x2, 0x2, 0x19d5, 0x19d6, 
       0x5, 0x2e8, 0x175, 0x2, 0x19d6, 0x19d7, 0x7, 0xf3, 0x2, 0x2, 0x19d7, 
       0x19da, 0x3, 0x2, 0x2, 0x2, 0x19d8, 0x19da, 0x7, 0x22d, 0x2, 0x2, 
       0x19d9, 0x19d2, 0x3, 0x2, 0x2, 0x2, 0x19d9, 0x19d3, 0x3, 0x2, 0x2, 
       0x2, 0x19d9, 0x19d4, 0x3, 0x2, 0x2, 0x2, 0x19d9, 0x19d5, 0x3, 0x2, 
       0x2, 0x2, 0x19d9, 0x19d8, 0x3, 0x2, 0x2, 0x2, 0x19da, 0x331, 0x3, 
       0x2, 0x2, 0x2, 0x19db, 0x19dc, 0x7, 0xad, 0x2, 0x2, 0x19dc, 0x19dd, 
       0x5, 0x45a, 0x22e, 0x2, 0x19dd, 0x19de, 0x7, 0x9a, 0x2, 0x2, 0x19de, 
       0x19df, 0x7, 0xf1, 0x2, 0x2, 0x19df, 0x19e0, 0x5, 0x110, 0x89, 0x2, 
       0x19e0, 0x333, 0x3, 0x2, 0x2, 0x2, 0x19e1, 0x19e2, 0x7, 0x12b, 0x2, 
       0x2, 0x19e2, 0x19e3, 0x5, 0x44a, 0x226, 0x2, 0x19e3, 0x335, 0x3, 
       0x2, 0x2, 0x2, 0x19e4, 0x19e5, 0x7, 0x136, 0x2, 0x2, 0x19e5, 0x19e6, 
       0x5, 0x44a, 0x226, 0x2, 0x19e6, 0x337, 0x3, 0x2, 0x2, 0x2, 0x19e7, 
       0x19eb, 0x7, 0xf8, 0x2, 0x2, 0x19e8, 0x19ec, 0x7, 0x96, 0x2, 0x2, 
       0x19e9, 0x19ea, 0x6, 0x19d, 0xb0, 0x2, 0x19ea, 0x19ec, 0x7, 0x23c, 
       0x2, 0x2, 0x19eb, 0x19e8, 0x3, 0x2, 0x2, 0x2, 0x19eb, 0x19e9, 0x3, 
       0x2, 0x2, 0x2, 0x19eb, 0x19ec, 0x3, 0x2, 0x2, 0x2, 0x19ec, 0x19ed, 
       0x3, 0x2, 0x2, 0x2, 0x19ed, 0x1a00, 0x7, 0xb8, 0x2, 0x2, 0x19ee, 
       0x19f3, 0x5, 0x33c, 0x19f, 0x2, 0x19ef, 0x19f0, 0x7, 0x20, 0x2, 0x2, 
       0x19f0, 0x19f2, 0x5, 0x33c, 0x19f, 0x2, 0x19f1, 0x19ef, 0x3, 0x2, 
       0x2, 0x2, 0x19f2, 0x19f5, 0x3, 0x2, 0x2, 0x2, 0x19f3, 0x19f1, 0x3, 
       0x2, 0x2, 0x2, 0x19f3, 0x19f4, 0x3, 0x2, 0x2, 0x2, 0x19f4, 0x1a01, 
       0x3, 0x2, 0x2, 0x2, 0x19f5, 0x19f3, 0x3, 0x2, 0x2, 0x2, 0x19f6, 0x19f7, 
       0x7, 0x84, 0x2, 0x2, 0x19f7, 0x19f8, 0x5, 0x33a, 0x19e, 0x2, 0x19f8, 
       0x19fd, 0x5, 0x33e, 0x1a0, 0x2, 0x19f9, 0x19fa, 0x7, 0x20, 0x2, 0x2, 
       0x19fa, 0x19fc, 0x5, 0x33e, 0x1a0, 0x2, 0x19fb, 0x19f9, 0x3, 0x2, 
       0x2, 0x2, 0x19fc, 0x19ff, 0x3, 0x2, 0x2, 0x2, 0x19fd, 0x19fb, 0x3, 
       0x2, 0x2, 0x2, 0x19fd, 0x19fe, 0x3, 0x2, 0x2, 0x2, 0x19fe, 0x1a01, 
       0x3, 0x2, 0x2, 0x2, 0x19ff, 0x19fd, 0x3, 0x2, 0x2, 0x2, 0x1a00, 0x19ee, 
       0x3, 0x2, 0x2, 0x2, 0x1a00, 0x19f6, 0x3, 0x2, 0x2, 0x2, 0x1a01, 0x339, 
       0x3, 0x2, 0x2, 0x2, 0x1a02, 0x1a06, 0x5, 0x46e, 0x238, 0x2, 0x1a03, 
       0x1a06, 0x5, 0x2d4, 0x16b, 0x2, 0x1a04, 0x1a06, 0x5, 0x460, 0x231, 
       0x2, 0x1a05, 0x1a02, 0x3, 0x2, 0x2, 0x2, 0x1a05, 0x1a03, 0x3, 0x2, 
       0x2, 0x2, 0x1a05, 0x1a04, 0x3, 0x2, 0x2, 0x2, 0x1a06, 0x33b, 0x3, 
       0x2, 0x2, 0x2, 0x1a07, 0x1a0a, 0x5, 0x2d4, 0x16b, 0x2, 0x1a08, 0x1a0a, 
       0x5, 0x45a, 0x22e, 0x2, 0x1a09, 0x1a07, 0x3, 0x2, 0x2, 0x2, 0x1a09, 
       0x1a08, 0x3, 0x2, 0x2, 0x2, 0x1a0a, 0x1a0b, 0x3, 0x2, 0x2, 0x2, 0x1a0b, 
       0x1a0c, 0x7, 0x9, 0x2, 0x2, 0x1a0c, 0x1a0d, 0x9, 0x66, 0x2, 0x2, 
       0x1a0d, 0x33d, 0x3, 0x2, 0x2, 0x2, 0x1a0e, 0x1a11, 0x5, 0x2d4, 0x16b, 
       0x2, 0x1a0f, 0x1a11, 0x5, 0x45a, 0x22e, 0x2, 0x1a10, 0x1a0e, 0x3, 
       0x2, 0x2, 0x2, 0x1a10, 0x1a0f, 0x3, 0x2, 0x2, 0x2, 0x1a11, 0x1a12, 
       0x3, 0x2, 0x2, 0x2, 0x1a12, 0x1a15, 0x7, 0x9, 0x2, 0x2, 0x1a13, 0x1a16, 
       0x5, 0x340, 0x1a1, 0x2, 0x1a14, 0x1a16, 0x7, 0x1fd, 0x2, 0x2, 0x1a15, 
       0x1a13, 0x3, 0x2, 0x2, 0x2, 0x1a15, 0x1a14, 0x3, 0x2, 0x2, 0x2, 0x1a16, 
       0x33f, 0x3, 0x2, 0x2, 0x2, 0x1a17, 0x1a18, 0x9, 0x67, 0x2, 0x2, 0x1a18, 
       0x341, 0x3, 0x2, 0x2, 0x2, 0x1a19, 0x1a1c, 0x7, 0x220, 0x2, 0x2, 
       0x1a1a, 0x1a1d, 0x5, 0x45a, 0x22e, 0x2, 0x1a1b, 0x1a1d, 0x5, 0x32c, 
       0x197, 0x2, 0x1a1c, 0x1a1a, 0x3, 0x2, 0x2, 0x2, 0x1a1c, 0x1a1b, 0x3, 
       0x2, 0x2, 0x2, 0x1a1d, 0x1a27, 0x3, 0x2, 0x2, 0x2, 0x1a1e, 0x1a1f, 
       0x7, 0x21b, 0x2, 0x2, 0x1a1f, 0x1a24, 0x5, 0x346, 0x1a4, 0x2, 0x1a20, 
       0x1a21, 0x7, 0x20, 0x2, 0x2, 0x1a21, 0x1a23, 0x5, 0x346, 0x1a4, 0x2, 
       0x1a22, 0x1a20, 0x3, 0x2, 0x2, 0x2, 0x1a23, 0x1a26, 0x3, 0x2, 0x2, 
       0x2, 0x1a24, 0x1a22, 0x3, 0x2, 0x2, 0x2, 0x1a24, 0x1a25, 0x3, 0x2, 
       0x2, 0x2, 0x1a25, 0x1a28, 0x3, 0x2, 0x2, 0x2, 0x1a26, 0x1a24, 0x3, 
       0x2, 0x2, 0x2, 0x1a27, 0x1a1e, 0x3, 0x2, 0x2, 0x2, 0x1a27, 0x1a28, 
       0x3, 0x2, 0x2, 0x2, 0x1a28, 0x343, 0x3, 0x2, 0x2, 0x2, 0x1a29, 0x1a2f, 
       0x7, 0x1f9, 0x2, 0x2, 0x1a2a, 0x1a2c, 0x7, 0x22e, 0x2, 0x2, 0x1a2b, 
       0x1a2d, 0x7, 0x293, 0x2, 0x2, 0x1a2c, 0x1a2b, 0x3, 0x2, 0x2, 0x2, 
       0x1a2c, 0x1a2d, 0x3, 0x2, 0x2, 0x2, 0x1a2d, 0x1a2e, 0x3, 0x2, 0x2, 
       0x2, 0x1a2e, 0x1a30, 0x5, 0x48e, 0x248, 0x2, 0x1a2f, 0x1a2a, 0x3, 
       0x2, 0x2, 0x2, 0x1a2f, 0x1a30, 0x3, 0x2, 0x2, 0x2, 0x1a30, 0x1a3a, 
       0x3, 0x2, 0x2, 0x2, 0x1a31, 0x1a32, 0x7, 0x21b, 0x2, 0x2, 0x1a32, 
       0x1a37, 0x5, 0x346, 0x1a4, 0x2, 0x1a33, 0x1a34, 0x7, 0x20, 0x2, 0x2, 
       0x1a34, 0x1a36, 0x5, 0x346, 0x1a4, 0x2, 0x1a35, 0x1a33, 0x3, 0x2, 
       0x2, 0x2, 0x1a36, 0x1a39, 0x3, 0x2, 0x2, 0x2, 0x1a37, 0x1a35, 0x3, 
       0x2, 0x2, 0x2, 0x1a37, 0x1a38, 0x3, 0x2, 0x2, 0x2, 0x1a38, 0x1a3b, 
       0x3, 0x2, 0x2, 0x2, 0x1a39, 0x1a37, 0x3, 0x2, 0x2, 0x2, 0x1a3a, 0x1a31, 
       0x3, 0x2, 0x2, 0x2, 0x1a3a, 0x1a3b, 0x3, 0x2, 0x2, 0x2, 0x1a3b, 0x345, 
       0x3, 0x2, 0x2, 0x2, 0x1a3c, 0x1a3d, 0x5, 0x340, 0x1a1, 0x2, 0x1a3d, 
       0x1a3e, 0x7, 0x9, 0x2, 0x2, 0x1a3e, 0x1a3f, 0x5, 0x33a, 0x19e, 0x2, 
       0x1a3f, 0x347, 0x3, 0x2, 0x2, 0x2, 0x1a40, 0x1a41, 0x7, 0x1a7, 0x2, 
       0x2, 0x1a41, 0x1a42, 0x5, 0x45a, 0x22e, 0x2, 0x1a42, 0x349, 0x3, 
       0x2, 0x2, 0x2, 0x1a43, 0x1a44, 0x7, 0x73, 0x2, 0x2, 0x1a44, 0x1a45, 
       0x5, 0x45a, 0x22e, 0x2, 0x1a45, 0x34b, 0x3, 0x2, 0x2, 0x2, 0x1a46, 
       0x1a4b, 0x7, 0xe6, 0x2, 0x2, 0x1a47, 0x1a49, 0x7, 0x192, 0x2, 0x2, 
       0x1a48, 0x1a47, 0x3, 0x2, 0x2, 0x2, 0x1a48, 0x1a49, 0x3, 0x2, 0x2, 
       0x2, 0x1a49, 0x1a4a, 0x3, 0x2, 0x2, 0x2, 0x1a4a, 0x1a4c, 0x7, 0xf4, 
       0x2, 0x2, 0x1a4b, 0x1a48, 0x3, 0x2, 0x2, 0x2, 0x1a4b, 0x1a4c, 0x3, 
       0x2, 0x2, 0x2, 0x1a4c, 0x1a4d, 0x3, 0x2, 0x2, 0x2, 0x1a4d, 0x1a4e, 
       0x5, 0x45a, 0x22e, 0x2, 0x1a4e, 0x1a4f, 0x7, 0x120, 0x2, 0x2, 0x1a4f, 
       0x1a50, 0x5, 0x45c, 0x22f, 0x2, 0x1a50, 0x34d, 0x3, 0x2, 0x2, 0x2, 
       0x1a51, 0x1a52, 0x7, 0x47, 0x2, 0x2, 0x1a52, 0x1a5f, 0x5, 0x294, 
       0x14b, 0x2, 0x1a53, 0x1a54, 0x7, 0xd8, 0x2, 0x2, 0x1a54, 0x1a55, 
       0x5, 0x294, 0x14b, 0x2, 0x1a55, 0x1a58, 0x5, 0x2ec, 0x177, 0x2, 0x1a56, 
       0x1a57, 0x7, 0x23e, 0x2, 0x2, 0x1a57, 0x1a59, 0x5, 0x294, 0x14b, 
       0x2, 0x1a58, 0x1a56, 0x3, 0x2, 0x2, 0x2, 0x1a58, 0x1a59, 0x3, 0x2, 
       0x2, 0x2, 0x1a59, 0x1a5c, 0x3, 0x2, 0x2, 0x2, 0x1a5a, 0x1a5b, 0x7, 
       0xcd, 0x2, 0x2, 0x1a5b, 0x1a5d, 0x5, 0x294, 0x14b, 0x2, 0x1a5c, 0x1a5a, 
       0x3, 0x2, 0x2, 0x2, 0x1a5c, 0x1a5d, 0x3, 0x2, 0x2, 0x2, 0x1a5d, 0x1a5f, 
       0x3, 0x2, 0x2, 0x2, 0x1a5e, 0x1a51, 0x3, 0x2, 0x2, 0x2, 0x1a5e, 0x1a53, 
       0x3, 0x2, 0x2, 0x2, 0x1a5f, 0x34f, 0x3, 0x2, 0x2, 0x2, 0x1a60, 0x1a61, 
       0x5, 0x402, 0x202, 0x2, 0x1a61, 0x1a63, 0x5, 0x35c, 0x1af, 0x2, 0x1a62, 
       0x1a64, 0x5, 0x352, 0x1aa, 0x2, 0x1a63, 0x1a62, 0x3, 0x2, 0x2, 0x2, 
       0x1a63, 0x1a64, 0x3, 0x2, 0x2, 0x2, 0x1a64, 0x351, 0x3, 0x2, 0x2, 
       0x2, 0x1a65, 0x1a66, 0x6, 0x1aa, 0xb1, 0x2, 0x1a66, 0x1a69, 0x5, 
       0x354, 0x1ab, 0x2, 0x1a67, 0x1a69, 0x5, 0x366, 0x1b4, 0x2, 0x1a68, 
       0x1a65, 0x3, 0x2, 0x2, 0x2, 0x1a68, 0x1a67, 0x3, 0x2, 0x2, 0x2, 0x1a69, 
       0x353, 0x3, 0x2, 0x2, 0x2, 0x1a6a, 0x1a6b, 0x7, 0x6f, 0x2, 0x2, 0x1a6b, 
       0x1a6c, 0x5, 0x2f2, 0x17a, 0x2, 0x1a6c, 0x355, 0x3, 0x2, 0x2, 0x2, 
       0x1a6d, 0x1a6f, 0x7, 0x196, 0x2, 0x2, 0x1a6e, 0x1a6d, 0x3, 0x2, 0x2, 
       0x2, 0x1a6e, 0x1a6f, 0x3, 0x2, 0x2, 0x2, 0x1a6f, 0x1a70, 0x3, 0x2, 
       0x2, 0x2, 0x1a70, 0x1a71, 0x7, 0x2fb, 0x2, 0x2, 0x1a71, 0x357, 0x3, 
       0x2, 0x2, 0x2, 0x1a72, 0x1a74, 0x9, 0x28, 0x2, 0x2, 0x1a73, 0x1a75, 
       0x5, 0x74, 0x3b, 0x2, 0x1a74, 0x1a73, 0x3, 0x2, 0x2, 0x2, 0x1a74, 
       0x1a75, 0x3, 0x2, 0x2, 0x2, 0x1a75, 0x1a76, 0x3, 0x2, 0x2, 0x2, 0x1a76, 
       0x1a7a, 0x5, 0x372, 0x1ba, 0x2, 0x1a77, 0x1a79, 0x5, 0x376, 0x1bc, 
       0x2, 0x1a78, 0x1a77, 0x3, 0x2, 0x2, 0x2, 0x1a79, 0x1a7c, 0x3, 0x2, 
       0x2, 0x2, 0x1a7a, 0x1a78, 0x3, 0x2, 0x2, 0x2, 0x1a7a, 0x1a7b, 0x3, 
       0x2, 0x2, 0x2, 0x1a7b, 0x1abe, 0x3, 0x2, 0x2, 0x2, 0x1a7c, 0x1a7a, 
       0x3, 0x2, 0x2, 0x2, 0x1a7d, 0x1a7f, 0x7, 0xf6, 0x2, 0x2, 0x1a7e, 
       0x1a80, 0x5, 0x192, 0xca, 0x2, 0x1a7f, 0x1a7e, 0x3, 0x2, 0x2, 0x2, 
       0x1a7f, 0x1a80, 0x3, 0x2, 0x2, 0x2, 0x1a80, 0x1a82, 0x3, 0x2, 0x2, 
       0x2, 0x1a81, 0x1a83, 0x5, 0x40c, 0x207, 0x2, 0x1a82, 0x1a81, 0x3, 
       0x2, 0x2, 0x2, 0x1a82, 0x1a83, 0x3, 0x2, 0x2, 0x2, 0x1a83, 0x1a84, 
       0x3, 0x2, 0x2, 0x2, 0x1a84, 0x1a88, 0x5, 0x372, 0x1ba, 0x2, 0x1a85, 
       0x1a87, 0x5, 0x37e, 0x1c0, 0x2, 0x1a86, 0x1a85, 0x3, 0x2, 0x2, 0x2, 
       0x1a87, 0x1a8a, 0x3, 0x2, 0x2, 0x2, 0x1a88, 0x1a86, 0x3, 0x2, 0x2, 
       0x2, 0x1a88, 0x1a89, 0x3, 0x2, 0x2, 0x2, 0x1a89, 0x1abe, 0x3, 0x2, 
       0x2, 0x2, 0x1a8a, 0x1a88, 0x3, 0x2, 0x2, 0x2, 0x1a8b, 0x1a8d, 0x7, 
       0x22b, 0x2, 0x2, 0x1a8c, 0x1a8e, 0x5, 0x192, 0xca, 0x2, 0x1a8d, 0x1a8c, 
       0x3, 0x2, 0x2, 0x2, 0x1a8d, 0x1a8e, 0x3, 0x2, 0x2, 0x2, 0x1a8e, 0x1a90, 
       0x3, 0x2, 0x2, 0x2, 0x1a8f, 0x1a91, 0x5, 0x40c, 0x207, 0x2, 0x1a90, 
       0x1a8f, 0x3, 0x2, 0x2, 0x2, 0x1a90, 0x1a91, 0x3, 0x2, 0x2, 0x2, 0x1a91, 
       0x1a92, 0x3, 0x2, 0x2, 0x2, 0x1a92, 0x1a96, 0x5, 0x372, 0x1ba, 0x2, 
       0x1a93, 0x1a95, 0x5, 0x380, 0x1c1, 0x2, 0x1a94, 0x1a93, 0x3, 0x2, 
       0x2, 0x2, 0x1a95, 0x1a98, 0x3, 0x2, 0x2, 0x2, 0x1a96, 0x1a94, 0x3, 
       0x2, 0x2, 0x2, 0x1a96, 0x1a97, 0x3, 0x2, 0x2, 0x2, 0x1a97, 0x1abe, 
       0x3, 0x2, 0x2, 0x2, 0x1a98, 0x1a96, 0x3, 0x2, 0x2, 0x2, 0x1a99, 0x1a9b, 
       0x5, 0x35a, 0x1ae, 0x2, 0x1a9a, 0x1a99, 0x3, 0x2, 0x2, 0x2, 0x1a9a, 
       0x1a9b, 0x3, 0x2, 0x2, 0x2, 0x1a9b, 0x1abb, 0x3, 0x2, 0x2, 0x2, 0x1a9c, 
       0x1a9d, 0x7, 0x1c8, 0x2, 0x2, 0x1a9d, 0x1aa3, 0x7, 0x130, 0x2, 0x2, 
       0x1a9e, 0x1aa0, 0x7, 0x281, 0x2, 0x2, 0x1a9f, 0x1aa1, 0x5, 
  };
  static uint16_t serializedATNSegment3[] = {
    0x192, 0xca, 0x2, 0x1aa0, 0x1a9f, 0x3, 0x2, 0x2, 0x2, 0x1aa0, 0x1aa1, 
       0x3, 0x2, 0x2, 0x2, 0x1aa1, 0x1aa3, 0x3, 0x2, 0x2, 0x2, 0x1aa2, 0x1a9c, 
       0x3, 0x2, 0x2, 0x2, 0x1aa2, 0x1a9e, 0x3, 0x2, 0x2, 0x2, 0x1aa3, 0x1aa5, 
       0x3, 0x2, 0x2, 0x2, 0x1aa4, 0x1aa6, 0x5, 0x74, 0x3b, 0x2, 0x1aa5, 
       0x1aa4, 0x3, 0x2, 0x2, 0x2, 0x1aa5, 0x1aa6, 0x3, 0x2, 0x2, 0x2, 0x1aa6, 
       0x1aa7, 0x3, 0x2, 0x2, 0x2, 0x1aa7, 0x1aab, 0x5, 0x372, 0x1ba, 0x2, 
       0x1aa8, 0x1aaa, 0x5, 0x376, 0x1bc, 0x2, 0x1aa9, 0x1aa8, 0x3, 0x2, 
       0x2, 0x2, 0x1aaa, 0x1aad, 0x3, 0x2, 0x2, 0x2, 0x1aab, 0x1aa9, 0x3, 
       0x2, 0x2, 0x2, 0x1aab, 0x1aac, 0x3, 0x2, 0x2, 0x2, 0x1aac, 0x1abc, 
       0x3, 0x2, 0x2, 0x2, 0x1aad, 0x1aab, 0x3, 0x2, 0x2, 0x2, 0x1aae, 0x1aaf, 
       0x7, 0xf0, 0x2, 0x2, 0x1aaf, 0x1ab1, 0x7, 0x130, 0x2, 0x2, 0x1ab0, 
       0x1ab2, 0x5, 0x40c, 0x207, 0x2, 0x1ab1, 0x1ab0, 0x3, 0x2, 0x2, 0x2, 
       0x1ab1, 0x1ab2, 0x3, 0x2, 0x2, 0x2, 0x1ab2, 0x1ab3, 0x3, 0x2, 0x2, 
       0x2, 0x1ab3, 0x1ab4, 0x5, 0x36a, 0x1b6, 0x2, 0x1ab4, 0x1ab5, 0x5, 
       0x366, 0x1b4, 0x2, 0x1ab5, 0x1abc, 0x3, 0x2, 0x2, 0x2, 0x1ab6, 0x1ab9, 
       0x5, 0x354, 0x1ab, 0x2, 0x1ab7, 0x1ab8, 0x6, 0x1ad, 0xb2, 0x2, 0x1ab8, 
       0x1aba, 0x5, 0x356, 0x1ac, 0x2, 0x1ab9, 0x1ab7, 0x3, 0x2, 0x2, 0x2, 
       0x1ab9, 0x1aba, 0x3, 0x2, 0x2, 0x2, 0x1aba, 0x1abc, 0x3, 0x2, 0x2, 
       0x2, 0x1abb, 0x1aa2, 0x3, 0x2, 0x2, 0x2, 0x1abb, 0x1aae, 0x3, 0x2, 
       0x2, 0x2, 0x1abb, 0x1ab6, 0x3, 0x2, 0x2, 0x2, 0x1abc, 0x1abe, 0x3, 
       0x2, 0x2, 0x2, 0x1abd, 0x1a72, 0x3, 0x2, 0x2, 0x2, 0x1abd, 0x1a7d, 
       0x3, 0x2, 0x2, 0x2, 0x1abd, 0x1a8b, 0x3, 0x2, 0x2, 0x2, 0x1abd, 0x1a9a, 
       0x3, 0x2, 0x2, 0x2, 0x1abe, 0x359, 0x3, 0x2, 0x2, 0x2, 0x1abf, 0x1ac1, 
       0x7, 0x87, 0x2, 0x2, 0x1ac0, 0x1ac2, 0x5, 0x45a, 0x22e, 0x2, 0x1ac1, 
       0x1ac0, 0x3, 0x2, 0x2, 0x2, 0x1ac1, 0x1ac2, 0x3, 0x2, 0x2, 0x2, 0x1ac2, 
       0x35b, 0x3, 0x2, 0x2, 0x2, 0x1ac3, 0x1ae7, 0x5, 0x384, 0x1c3, 0x2, 
       0x1ac4, 0x1ac6, 0x5, 0x35e, 0x1b0, 0x2, 0x1ac5, 0x1ac4, 0x3, 0x2, 
       0x2, 0x2, 0x1ac6, 0x1ac9, 0x3, 0x2, 0x2, 0x2, 0x1ac7, 0x1ac5, 0x3, 
       0x2, 0x2, 0x2, 0x1ac7, 0x1ac8, 0x3, 0x2, 0x2, 0x2, 0x1ac8, 0x1ae8, 
       0x3, 0x2, 0x2, 0x2, 0x1ac9, 0x1ac7, 0x3, 0x2, 0x2, 0x2, 0x1aca, 0x1acc, 
       0x6, 0x1af, 0xb3, 0x2, 0x1acb, 0x1acd, 0x5, 0x3ce, 0x1e8, 0x2, 0x1acc, 
       0x1acb, 0x3, 0x2, 0x2, 0x2, 0x1acc, 0x1acd, 0x3, 0x2, 0x2, 0x2, 0x1acd, 
       0x1ad0, 0x3, 0x2, 0x2, 0x2, 0x1ace, 0x1acf, 0x7, 0xfa, 0x2, 0x2, 
       0x1acf, 0x1ad1, 0x7, 0x3e, 0x2, 0x2, 0x1ad0, 0x1ace, 0x3, 0x2, 0x2, 
       0x2, 0x1ad0, 0x1ad1, 0x3, 0x2, 0x2, 0x2, 0x1ad1, 0x1ad2, 0x3, 0x2, 
       0x2, 0x2, 0x1ad2, 0x1ad3, 0x7, 0x43, 0x2, 0x2, 0x1ad3, 0x1ad5, 0x5, 
       0x2f2, 0x17a, 0x2, 0x1ad4, 0x1ad6, 0x9, 0x68, 0x2, 0x2, 0x1ad5, 0x1ad4, 
       0x3, 0x2, 0x2, 0x2, 0x1ad5, 0x1ad6, 0x3, 0x2, 0x2, 0x2, 0x1ad6, 0x1ae5, 
       0x3, 0x2, 0x2, 0x2, 0x1ad7, 0x1adb, 0x6, 0x1af, 0xb4, 0x2, 0x1ad8, 
       0x1ada, 0x5, 0x364, 0x1b3, 0x2, 0x1ad9, 0x1ad8, 0x3, 0x2, 0x2, 0x2, 
       0x1ada, 0x1add, 0x3, 0x2, 0x2, 0x2, 0x1adb, 0x1ad9, 0x3, 0x2, 0x2, 
       0x2, 0x1adb, 0x1adc, 0x3, 0x2, 0x2, 0x2, 0x1adc, 0x1ae6, 0x3, 0x2, 
       0x2, 0x2, 0x1add, 0x1adb, 0x3, 0x2, 0x2, 0x2, 0x1ade, 0x1ae2, 0x6, 
       0x1af, 0xb5, 0x2, 0x1adf, 0x1ae1, 0x5, 0x35e, 0x1b0, 0x2, 0x1ae0, 
       0x1adf, 0x3, 0x2, 0x2, 0x2, 0x1ae1, 0x1ae4, 0x3, 0x2, 0x2, 0x2, 0x1ae2, 
       0x1ae0, 0x3, 0x2, 0x2, 0x2, 0x1ae2, 0x1ae3, 0x3, 0x2, 0x2, 0x2, 0x1ae3, 
       0x1ae6, 0x3, 0x2, 0x2, 0x2, 0x1ae4, 0x1ae2, 0x3, 0x2, 0x2, 0x2, 0x1ae5, 
       0x1ad7, 0x3, 0x2, 0x2, 0x2, 0x1ae5, 0x1ade, 0x3, 0x2, 0x2, 0x2, 0x1ae6, 
       0x1ae8, 0x3, 0x2, 0x2, 0x2, 0x1ae7, 0x1ac7, 0x3, 0x2, 0x2, 0x2, 0x1ae7, 
       0x1aca, 0x3, 0x2, 0x2, 0x2, 0x1ae8, 0x35d, 0x3, 0x2, 0x2, 0x2, 0x1ae9, 
       0x1aeb, 0x7, 0x196, 0x2, 0x2, 0x1aea, 0x1ae9, 0x3, 0x2, 0x2, 0x2, 
       0x1aea, 0x1aeb, 0x3, 0x2, 0x2, 0x2, 0x1aeb, 0x1aec, 0x3, 0x2, 0x2, 
       0x2, 0x1aec, 0x1b1e, 0x5, 0x484, 0x243, 0x2, 0x1aed, 0x1aee, 0x6, 
       0x1b0, 0xb6, 0x2, 0x1aee, 0x1aef, 0x7, 0x196, 0x2, 0x2, 0x1aef, 0x1b1e, 
       0x7, 0x2f1, 0x2, 0x2, 0x1af0, 0x1af8, 0x7, 0xae, 0x2, 0x2, 0x1af1, 
       0x1af9, 0x5, 0x470, 0x239, 0x2, 0x1af2, 0x1af4, 0x7, 0x197, 0x2, 
       0x2, 0x1af3, 0x1af5, 0x5, 0x2c0, 0x161, 0x2, 0x1af4, 0x1af3, 0x3, 
       0x2, 0x2, 0x2, 0x1af4, 0x1af5, 0x3, 0x2, 0x2, 0x2, 0x1af5, 0x1af9, 
       0x3, 0x2, 0x2, 0x2, 0x1af6, 0x1af7, 0x6, 0x1b0, 0xb7, 0x2, 0x1af7, 
       0x1af9, 0x5, 0x2f2, 0x17a, 0x2, 0x1af8, 0x1af1, 0x3, 0x2, 0x2, 0x2, 
       0x1af8, 0x1af2, 0x3, 0x2, 0x2, 0x2, 0x1af8, 0x1af6, 0x3, 0x2, 0x2, 
       0x2, 0x1af9, 0x1b1e, 0x3, 0x2, 0x2, 0x2, 0x1afa, 0x1afb, 0x7, 0x1a2, 
       0x2, 0x2, 0x1afb, 0x1afc, 0x7, 0x286, 0x2, 0x2, 0x1afc, 0x1afe, 0x7, 
       0x197, 0x2, 0x2, 0x1afd, 0x1aff, 0x5, 0x2c0, 0x161, 0x2, 0x1afe, 
       0x1afd, 0x3, 0x2, 0x2, 0x2, 0x1afe, 0x1aff, 0x3, 0x2, 0x2, 0x2, 0x1aff, 
       0x1b1e, 0x3, 0x2, 0x2, 0x2, 0x1b00, 0x1b1e, 0x7, 0x4a, 0x2, 0x2, 
       0x1b01, 0x1b02, 0x7, 0x216, 0x2, 0x2, 0x1b02, 0x1b03, 0x7, 0xae, 
       0x2, 0x2, 0x1b03, 0x1b1e, 0x7, 0x293, 0x2, 0x2, 0x1b04, 0x1b06, 0x7, 
       0x1c8, 0x2, 0x2, 0x1b05, 0x1b04, 0x3, 0x2, 0x2, 0x2, 0x1b05, 0x1b06, 
       0x3, 0x2, 0x2, 0x2, 0x1b06, 0x1b07, 0x3, 0x2, 0x2, 0x2, 0x1b07, 0x1b1e, 
       0x7, 0x130, 0x2, 0x2, 0x1b08, 0x1b0a, 0x7, 0x281, 0x2, 0x2, 0x1b09, 
       0x1b0b, 0x7, 0x130, 0x2, 0x2, 0x1b0a, 0x1b09, 0x3, 0x2, 0x2, 0x2, 
       0x1b0a, 0x1b0b, 0x3, 0x2, 0x2, 0x2, 0x1b0b, 0x1b1e, 0x3, 0x2, 0x2, 
       0x2, 0x1b0c, 0x1b0d, 0x7, 0x7c, 0x2, 0x2, 0x1b0d, 0x1b1e, 0x5, 0x47a, 
       0x23e, 0x2, 0x1b0e, 0x1b1e, 0x5, 0x3ce, 0x1e8, 0x2, 0x1b0f, 0x1b10, 
       0x7, 0x7b, 0x2, 0x2, 0x1b10, 0x1b1e, 0x5, 0x360, 0x1b1, 0x2, 0x1b11, 
       0x1b12, 0x7, 0x249, 0x2, 0x2, 0x1b12, 0x1b1e, 0x5, 0x362, 0x1b2, 
       0x2, 0x1b13, 0x1b14, 0x6, 0x1b0, 0xb8, 0x2, 0x1b14, 0x1b15, 0x7, 
       0x2e4, 0x2, 0x2, 0x1b15, 0x1b1e, 0x5, 0x46c, 0x237, 0x2, 0x1b16, 
       0x1b18, 0x6, 0x1b0, 0xb9, 0x2, 0x1b17, 0x1b19, 0x5, 0x35a, 0x1ae, 
       0x2, 0x1b18, 0x1b17, 0x3, 0x2, 0x2, 0x2, 0x1b18, 0x1b19, 0x3, 0x2, 
       0x2, 0x2, 0x1b19, 0x1b1a, 0x3, 0x2, 0x2, 0x2, 0x1b1a, 0x1b1e, 0x5, 
       0x354, 0x1ab, 0x2, 0x1b1b, 0x1b1c, 0x6, 0x1b0, 0xba, 0x2, 0x1b1c, 
       0x1b1e, 0x5, 0x356, 0x1ac, 0x2, 0x1b1d, 0x1aea, 0x3, 0x2, 0x2, 0x2, 
       0x1b1d, 0x1aed, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1af0, 0x3, 0x2, 0x2, 
       0x2, 0x1b1d, 0x1afa, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b00, 0x3, 0x2, 
       0x2, 0x2, 0x1b1d, 0x1b01, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b05, 0x3, 
       0x2, 0x2, 0x2, 0x1b1d, 0x1b08, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b0c, 
       0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b0e, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b0f, 
       0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b11, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b13, 
       0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b16, 0x3, 0x2, 0x2, 0x2, 0x1b1d, 0x1b1b, 
       0x3, 0x2, 0x2, 0x2, 0x1b1e, 0x35f, 0x3, 0x2, 0x2, 0x2, 0x1b1f, 0x1b20, 
       0x9, 0x69, 0x2, 0x2, 0x1b20, 0x361, 0x3, 0x2, 0x2, 0x2, 0x1b21, 0x1b22, 
       0x9, 0x6a, 0x2, 0x2, 0x1b22, 0x363, 0x3, 0x2, 0x2, 0x2, 0x1b23, 0x1b25, 
       0x7, 0x281, 0x2, 0x2, 0x1b24, 0x1b26, 0x7, 0x130, 0x2, 0x2, 0x1b25, 
       0x1b24, 0x3, 0x2, 0x2, 0x2, 0x1b25, 0x1b26, 0x3, 0x2, 0x2, 0x2, 0x1b26, 
       0x1b32, 0x3, 0x2, 0x2, 0x2, 0x1b27, 0x1b28, 0x7, 0x7c, 0x2, 0x2, 
       0x1b28, 0x1b32, 0x5, 0x476, 0x23c, 0x2, 0x1b29, 0x1b2b, 0x5, 0x2e8, 
       0x175, 0x2, 0x1b2a, 0x1b29, 0x3, 0x2, 0x2, 0x2, 0x1b2a, 0x1b2b, 0x3, 
       0x2, 0x2, 0x2, 0x1b2b, 0x1b2c, 0x3, 0x2, 0x2, 0x2, 0x1b2c, 0x1b32, 
       0x7, 0x19b, 0x2, 0x2, 0x1b2d, 0x1b2f, 0x7, 0x1c8, 0x2, 0x2, 0x1b2e, 
       0x1b2d, 0x3, 0x2, 0x2, 0x2, 0x1b2e, 0x1b2f, 0x3, 0x2, 0x2, 0x2, 0x1b2f, 
       0x1b30, 0x3, 0x2, 0x2, 0x2, 0x1b30, 0x1b32, 0x7, 0x130, 0x2, 0x2, 
       0x1b31, 0x1b23, 0x3, 0x2, 0x2, 0x2, 0x1b31, 0x1b27, 0x3, 0x2, 0x2, 
       0x2, 0x1b31, 0x1b2a, 0x3, 0x2, 0x2, 0x2, 0x1b31, 0x1b2e, 0x3, 0x2, 
       0x2, 0x2, 0x1b32, 0x365, 0x3, 0x2, 0x2, 0x2, 0x1b33, 0x1b34, 0x7, 
       0x1df, 0x2, 0x2, 0x1b34, 0x1b36, 0x5, 0x440, 0x221, 0x2, 0x1b35, 
       0x1b37, 0x5, 0x45e, 0x230, 0x2, 0x1b36, 0x1b35, 0x3, 0x2, 0x2, 0x2, 
       0x1b36, 0x1b37, 0x3, 0x2, 0x2, 0x2, 0x1b37, 0x1b3a, 0x3, 0x2, 0x2, 
       0x2, 0x1b38, 0x1b39, 0x7, 0x165, 0x2, 0x2, 0x1b39, 0x1b3b, 0x9, 0x6b, 
       0x2, 0x2, 0x1b3a, 0x1b38, 0x3, 0x2, 0x2, 0x2, 0x1b3a, 0x1b3b, 0x3, 
       0x2, 0x2, 0x2, 0x1b3b, 0x1b4c, 0x3, 0x2, 0x2, 0x2, 0x1b3c, 0x1b3d, 
       0x7, 0x1a2, 0x2, 0x2, 0x1b3d, 0x1b3e, 0x7, 0x286, 0x2, 0x2, 0x1b3e, 
       0x1b42, 0x5, 0x368, 0x1b5, 0x2, 0x1b3f, 0x1b40, 0x7, 0x1a2, 0x2, 
       0x2, 0x1b40, 0x1b41, 0x7, 0xb3, 0x2, 0x2, 0x1b41, 0x1b43, 0x5, 0x368, 
       0x1b5, 0x2, 0x1b42, 0x1b3f, 0x3, 0x2, 0x2, 0x2, 0x1b42, 0x1b43, 0x3, 
       0x2, 0x2, 0x2, 0x1b43, 0x1b4d, 0x3, 0x2, 0x2, 0x2, 0x1b44, 0x1b45, 
       0x7, 0x1a2, 0x2, 0x2, 0x1b45, 0x1b46, 0x7, 0xb3, 0x2, 0x2, 0x1b46, 
       0x1b4a, 0x5, 0x368, 0x1b5, 0x2, 0x1b47, 0x1b48, 0x7, 0x1a2, 0x2, 
       0x2, 0x1b48, 0x1b49, 0x7, 0x286, 0x2, 0x2, 0x1b49, 0x1b4b, 0x5, 0x368, 
       0x1b5, 0x2, 0x1b4a, 0x1b47, 0x3, 0x2, 0x2, 0x2, 0x1b4a, 0x1b4b, 0x3, 
       0x2, 0x2, 0x2, 0x1b4b, 0x1b4d, 0x3, 0x2, 0x2, 0x2, 0x1b4c, 0x1b3c, 
       0x3, 0x2, 0x2, 0x2, 0x1b4c, 0x1b44, 0x3, 0x2, 0x2, 0x2, 0x1b4c, 0x1b4d, 
       0x3, 0x2, 0x2, 0x2, 0x1b4d, 0x367, 0x3, 0x2, 0x2, 0x2, 0x1b4e, 0x1b54, 
       0x9, 0x4, 0x2, 0x2, 0x1b4f, 0x1b50, 0x7, 0x21b, 0x2, 0x2, 0x1b50, 
       0x1b54, 0x5, 0x484, 0x243, 0x2, 0x1b51, 0x1b52, 0x7, 0x198, 0x2, 
       0x2, 0x1b52, 0x1b54, 0x7, 0x35, 0x2, 0x2, 0x1b53, 0x1b4e, 0x3, 0x2, 
       0x2, 0x2, 0x1b53, 0x1b4f, 0x3, 0x2, 0x2, 0x2, 0x1b53, 0x1b51, 0x3, 
       0x2, 0x2, 0x2, 0x1b54, 0x369, 0x3, 0x2, 0x2, 0x2, 0x1b55, 0x1b56, 
       0x7, 0x23, 0x2, 0x2, 0x1b56, 0x1b5b, 0x5, 0x36c, 0x1b7, 0x2, 0x1b57, 
       0x1b58, 0x7, 0x20, 0x2, 0x2, 0x1b58, 0x1b5a, 0x5, 0x36c, 0x1b7, 0x2, 
       0x1b59, 0x1b57, 0x3, 0x2, 0x2, 0x2, 0x1b5a, 0x1b5d, 0x3, 0x2, 0x2, 
       0x2, 0x1b5b, 0x1b59, 0x3, 0x2, 0x2, 0x2, 0x1b5b, 0x1b5c, 0x3, 0x2, 
       0x2, 0x2, 0x1b5c, 0x1b5e, 0x3, 0x2, 0x2, 0x2, 0x1b5d, 0x1b5b, 0x3, 
       0x2, 0x2, 0x2, 0x1b5e, 0x1b5f, 0x7, 0x24, 0x2, 0x2, 0x1b5f, 0x36b, 
       0x3, 0x2, 0x2, 0x2, 0x1b60, 0x1b62, 0x5, 0x45a, 0x22e, 0x2, 0x1b61, 
       0x1b63, 0x5, 0x38e, 0x1c8, 0x2, 0x1b62, 0x1b61, 0x3, 0x2, 0x2, 0x2, 
       0x1b62, 0x1b63, 0x3, 0x2, 0x2, 0x2, 0x1b63, 0x1b65, 0x3, 0x2, 0x2, 
       0x2, 0x1b64, 0x1b66, 0x5, 0x14e, 0xa8, 0x2, 0x1b65, 0x1b64, 0x3, 
       0x2, 0x2, 0x2, 0x1b65, 0x1b66, 0x3, 0x2, 0x2, 0x2, 0x1b66, 0x36d, 
       0x3, 0x2, 0x2, 0x2, 0x1b67, 0x1b68, 0x7, 0x23, 0x2, 0x2, 0x1b68, 
       0x1b6d, 0x5, 0x370, 0x1b9, 0x2, 0x1b69, 0x1b6a, 0x7, 0x20, 0x2, 0x2, 
       0x1b6a, 0x1b6c, 0x5, 0x370, 0x1b9, 0x2, 0x1b6b, 0x1b69, 0x3, 0x2, 
       0x2, 0x2, 0x1b6c, 0x1b6f, 0x3, 0x2, 0x2, 0x2, 0x1b6d, 0x1b6b, 0x3, 
       0x2, 0x2, 0x2, 0x1b6d, 0x1b6e, 0x3, 0x2, 0x2, 0x2, 0x1b6e, 0x1b70, 
       0x3, 0x2, 0x2, 0x2, 0x1b6f, 0x1b6d, 0x3, 0x2, 0x2, 0x2, 0x1b70, 0x1b71, 
       0x7, 0x24, 0x2, 0x2, 0x1b71, 0x36f, 0x3, 0x2, 0x2, 0x2, 0x1b72, 0x1b78, 
       0x5, 0x36c, 0x1b7, 0x2, 0x1b73, 0x1b75, 0x5, 0x2f2, 0x17a, 0x2, 0x1b74, 
       0x1b76, 0x5, 0x14e, 0xa8, 0x2, 0x1b75, 0x1b74, 0x3, 0x2, 0x2, 0x2, 
       0x1b75, 0x1b76, 0x3, 0x2, 0x2, 0x2, 0x1b76, 0x1b78, 0x3, 0x2, 0x2, 
       0x2, 0x1b77, 0x1b72, 0x3, 0x2, 0x2, 0x2, 0x1b77, 0x1b73, 0x3, 0x2, 
       0x2, 0x2, 0x1b78, 0x371, 0x3, 0x2, 0x2, 0x2, 0x1b79, 0x1b7a, 0x6, 
       0x1ba, 0xbb, 0x2, 0x1b7a, 0x1b7e, 0x5, 0x36e, 0x1b8, 0x2, 0x1b7b, 
       0x1b7c, 0x6, 0x1ba, 0xbc, 0x2, 0x1b7c, 0x1b7e, 0x5, 0x36a, 0x1b6, 
       0x2, 0x1b7d, 0x1b79, 0x3, 0x2, 0x2, 0x2, 0x1b7d, 0x1b7b, 0x3, 0x2, 
       0x2, 0x2, 0x1b7e, 0x373, 0x3, 0x2, 0x2, 0x2, 0x1b7f, 0x1b80, 0x9, 
       0x6c, 0x2, 0x2, 0x1b80, 0x375, 0x3, 0x2, 0x2, 0x2, 0x1b81, 0x1b84, 
       0x5, 0x378, 0x1bd, 0x2, 0x1b82, 0x1b84, 0x5, 0x37c, 0x1bf, 0x2, 0x1b83, 
       0x1b81, 0x3, 0x2, 0x2, 0x2, 0x1b83, 0x1b82, 0x3, 0x2, 0x2, 0x2, 0x1b84, 
       0x377, 0x3, 0x2, 0x2, 0x2, 0x1b85, 0x1b87, 0x7, 0x12f, 0x2, 0x2, 
       0x1b86, 0x1b88, 0x7, 0x9, 0x2, 0x2, 0x1b87, 0x1b86, 0x3, 0x2, 0x2, 
       0x2, 0x1b87, 0x1b88, 0x3, 0x2, 0x2, 0x2, 0x1b88, 0x1b89, 0x3, 0x2, 
       0x2, 0x2, 0x1b89, 0x1b90, 0x5, 0x466, 0x234, 0x2, 0x1b8a, 0x1b8b, 
       0x6, 0x1bd, 0xbd, 0x2, 0x1b8b, 0x1b8c, 0x7, 0x7c, 0x2, 0x2, 0x1b8c, 
       0x1b90, 0x5, 0x47a, 0x23e, 0x2, 0x1b8d, 0x1b8e, 0x6, 0x1bd, 0xbe, 
       0x2, 0x1b8e, 0x1b90, 0x5, 0x37a, 0x1be, 0x2, 0x1b8f, 0x1b85, 0x3, 
       0x2, 0x2, 0x2, 0x1b8f, 0x1b8a, 0x3, 0x2, 0x2, 0x2, 0x1b8f, 0x1b8d, 
       0x3, 0x2, 0x2, 0x2, 0x1b90, 0x379, 0x3, 0x2, 0x2, 0x2, 0x1b91, 0x1b92, 
       0x9, 0x6d, 0x2, 0x2, 0x1b92, 0x37b, 0x3, 0x2, 0x2, 0x2, 0x1b93, 0x1b94, 
       0x9, 0x6e, 0x2, 0x2, 0x1b94, 0x1b95, 0x5, 0x374, 0x1bb, 0x2, 0x1b95, 
       0x37d, 0x3, 0x2, 0x2, 0x2, 0x1b96, 0x1b9b, 0x5, 0x378, 0x1bd, 0x2, 
       0x1b97, 0x1b98, 0x7, 0x2a4, 0x2, 0x2, 0x1b98, 0x1b99, 0x7, 0x1b5, 
       0x2, 0x2, 0x1b99, 0x1b9b, 0x5, 0x45a, 0x22e, 0x2, 0x1b9a, 0x1b96, 
       0x3, 0x2, 0x2, 0x2, 0x1b9a, 0x1b97, 0x3, 0x2, 0x2, 0x2, 0x1b9b, 0x37f, 
       0x3, 0x2, 0x2, 0x2, 0x1b9c, 0x1b9d, 0x5, 0x378, 0x1bd, 0x2, 0x1b9d, 
       0x381, 0x3, 0x2, 0x2, 0x2, 0x1b9e, 0x1b9f, 0x5, 0x384, 0x1c3, 0x2, 
       0x1b9f, 0x1ba0, 0x7, 0x2, 0x2, 0x3, 0x1ba0, 0x383, 0x3, 0x2, 0x2, 
       0x2, 0x1ba1, 0x1ba3, 0x9, 0x6f, 0x2, 0x2, 0x1ba2, 0x1ba4, 0x5, 0x38e, 
       0x1c8, 0x2, 0x1ba3, 0x1ba2, 0x3, 0x2, 0x2, 0x2, 0x1ba3, 0x1ba4, 0x3, 
       0x2, 0x2, 0x2, 0x1ba4, 0x1ba6, 0x3, 0x2, 0x2, 0x2, 0x1ba5, 0x1ba7, 
       0x5, 0x390, 0x1c9, 0x2, 0x1ba6, 0x1ba5, 0x3, 0x2, 0x2, 0x2, 0x1ba6, 
       0x1ba7, 0x3, 0x2, 0x2, 0x2, 0x1ba7, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1ba8, 
       0x1bae, 0x7, 0x1d9, 0x2, 0x2, 0x1ba9, 0x1bab, 0x7, 0xbf, 0x2, 0x2, 
       0x1baa, 0x1bac, 0x7, 0x1c4, 0x2, 0x2, 0x1bab, 0x1baa, 0x3, 0x2, 0x2, 
       0x2, 0x1bab, 0x1bac, 0x3, 0x2, 0x2, 0x2, 0x1bac, 0x1bae, 0x3, 0x2, 
       0x2, 0x2, 0x1bad, 0x1ba8, 0x3, 0x2, 0x2, 0x2, 0x1bad, 0x1ba9, 0x3, 
       0x2, 0x2, 0x2, 0x1bae, 0x1bb0, 0x3, 0x2, 0x2, 0x2, 0x1baf, 0x1bb1, 
       0x5, 0x48c, 0x247, 0x2, 0x1bb0, 0x1baf, 0x3, 0x2, 0x2, 0x2, 0x1bb0, 
       0x1bb1, 0x3, 0x2, 0x2, 0x2, 0x1bb1, 0x1bb3, 0x3, 0x2, 0x2, 0x2, 0x1bb2, 
       0x1bb4, 0x5, 0x390, 0x1c9, 0x2, 0x1bb3, 0x1bb2, 0x3, 0x2, 0x2, 0x2, 
       0x1bb3, 0x1bb4, 0x3, 0x2, 0x2, 0x2, 0x1bb4, 0x1c35, 0x3, 0x2, 0x2, 
       0x2, 0x1bb5, 0x1bb7, 0x9, 0x70, 0x2, 0x2, 0x1bb6, 0x1bb8, 0x5, 0x488, 
       0x245, 0x2, 0x1bb7, 0x1bb6, 0x3, 0x2, 0x2, 0x2, 0x1bb7, 0x1bb8, 0x3, 
       0x2, 0x2, 0x2, 0x1bb8, 0x1bba, 0x3, 0x2, 0x2, 0x2, 0x1bb9, 0x1bbb, 
       0x5, 0x390, 0x1c9, 0x2, 0x1bba, 0x1bb9, 0x3, 0x2, 0x2, 0x2, 0x1bba, 
       0x1bbb, 0x3, 0x2, 0x2, 0x2, 0x1bbb, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bbc, 
       0x1bbe, 0x7, 0x57, 0x2, 0x2, 0x1bbd, 0x1bbf, 0x5, 0x38e, 0x1c8, 0x2, 
       0x1bbe, 0x1bbd, 0x3, 0x2, 0x2, 0x2, 0x1bbe, 0x1bbf, 0x3, 0x2, 0x2, 
       0x2, 0x1bbf, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bc0, 0x1c35, 0x9, 0x71, 
       0x2, 0x2, 0x1bc1, 0x1bc3, 0x7, 0x6d, 0x2, 0x2, 0x1bc2, 0x1bc4, 0x5, 
       0x38e, 0x1c8, 0x2, 0x1bc3, 0x1bc2, 0x3, 0x2, 0x2, 0x2, 0x1bc3, 0x1bc4, 
       0x3, 0x2, 0x2, 0x2, 0x1bc4, 0x1bc6, 0x3, 0x2, 0x2, 0x2, 0x1bc5, 0x1bc7, 
       0x5, 0x392, 0x1ca, 0x2, 0x1bc6, 0x1bc5, 0x3, 0x2, 0x2, 0x2, 0x1bc6, 
       0x1bc7, 0x3, 0x2, 0x2, 0x2, 0x1bc7, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bc8, 
       0x1bca, 0x5, 0x386, 0x1c4, 0x2, 0x1bc9, 0x1bcb, 0x5, 0x38e, 0x1c8, 
       0x2, 0x1bca, 0x1bc9, 0x3, 0x2, 0x2, 0x2, 0x1bca, 0x1bcb, 0x3, 0x2, 
       0x2, 0x2, 0x1bcb, 0x1bcd, 0x3, 0x2, 0x2, 0x2, 0x1bcc, 0x1bce, 0x7, 
       0x52, 0x2, 0x2, 0x1bcd, 0x1bcc, 0x3, 0x2, 0x2, 0x2, 0x1bcd, 0x1bce, 
       0x3, 0x2, 0x2, 0x2, 0x1bce, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bcf, 0x1bd1, 
       0x7, 0x52, 0x2, 0x2, 0x1bd0, 0x1bd2, 0x5, 0x38e, 0x1c8, 0x2, 0x1bd1, 
       0x1bd0, 0x3, 0x2, 0x2, 0x2, 0x1bd1, 0x1bd2, 0x3, 0x2, 0x2, 0x2, 0x1bd2, 
       0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bd3, 0x1bd4, 0x7, 0x6d, 0x2, 0x2, 
       0x1bd4, 0x1bd7, 0x7, 0x298, 0x2, 0x2, 0x1bd5, 0x1bd7, 0x7, 0x295, 
       0x2, 0x2, 0x1bd6, 0x1bd3, 0x3, 0x2, 0x2, 0x2, 0x1bd6, 0x1bd5, 0x3, 
       0x2, 0x2, 0x2, 0x1bd7, 0x1bd8, 0x3, 0x2, 0x2, 0x2, 0x1bd8, 0x1bda, 
       0x5, 0x38e, 0x1c8, 0x2, 0x1bd9, 0x1bdb, 0x5, 0x392, 0x1ca, 0x2, 0x1bda, 
       0x1bd9, 0x3, 0x2, 0x2, 0x2, 0x1bda, 0x1bdb, 0x3, 0x2, 0x2, 0x2, 0x1bdb, 
       0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bdc, 0x1bdd, 0x7, 0x18a, 0x2, 0x2, 
       0x1bdd, 0x1be7, 0x7, 0x295, 0x2, 0x2, 0x1bde, 0x1be7, 0x7, 0x19e, 
       0x2, 0x2, 0x1bdf, 0x1be0, 0x7, 0x18d, 0x2, 0x2, 0x1be0, 0x1be7, 0x7, 
       0x295, 0x2, 0x2, 0x1be1, 0x1be2, 0x7, 0x18a, 0x2, 0x2, 0x1be2, 0x1be3, 
       0x7, 0x6d, 0x2, 0x2, 0x1be3, 0x1be7, 0x7, 0x298, 0x2, 0x2, 0x1be4, 
       0x1be5, 0x7, 0x18d, 0x2, 0x2, 0x1be5, 0x1be7, 0x7, 0x298, 0x2, 0x2, 
       0x1be6, 0x1bdc, 0x3, 0x2, 0x2, 0x2, 0x1be6, 0x1bde, 0x3, 0x2, 0x2, 
       0x2, 0x1be6, 0x1bdf, 0x3, 0x2, 0x2, 0x2, 0x1be6, 0x1be1, 0x3, 0x2, 
       0x2, 0x2, 0x1be6, 0x1be4, 0x3, 0x2, 0x2, 0x2, 0x1be7, 0x1be8, 0x3, 
       0x2, 0x2, 0x2, 0x1be8, 0x1bea, 0x5, 0x38e, 0x1c8, 0x2, 0x1be9, 0x1beb, 
       0x7, 0x52, 0x2, 0x2, 0x1bea, 0x1be9, 0x3, 0x2, 0x2, 0x2, 0x1bea, 
       0x1beb, 0x3, 0x2, 0x2, 0x2, 0x1beb, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bec, 
       0x1bed, 0x7, 0x294, 0x2, 0x2, 0x1bed, 0x1c35, 0x5, 0x38e, 0x1c8, 
       0x2, 0x1bee, 0x1bf0, 0x7, 0x2b1, 0x2, 0x2, 0x1bef, 0x1bf1, 0x5, 0x38e, 
       0x1c8, 0x2, 0x1bf0, 0x1bef, 0x3, 0x2, 0x2, 0x2, 0x1bf0, 0x1bf1, 0x3, 
       0x2, 0x2, 0x2, 0x1bf1, 0x1bf3, 0x3, 0x2, 0x2, 0x2, 0x1bf2, 0x1bf4, 
       0x5, 0x390, 0x1c9, 0x2, 0x1bf3, 0x1bf2, 0x3, 0x2, 0x2, 0x2, 0x1bf3, 
       0x1bf4, 0x3, 0x2, 0x2, 0x2, 0x1bf4, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bf5, 
       0x1c35, 0x7, 0xa4, 0x2, 0x2, 0x1bf6, 0x1bf8, 0x7, 0x26a, 0x2, 0x2, 
       0x1bf7, 0x1bf9, 0x5, 0x39a, 0x1ce, 0x2, 0x1bf8, 0x1bf7, 0x3, 0x2, 
       0x2, 0x2, 0x1bf8, 0x1bf9, 0x3, 0x2, 0x2, 0x2, 0x1bf9, 0x1c35, 0x3, 
       0x2, 0x2, 0x2, 0x1bfa, 0x1bfc, 0x7, 0x267, 0x2, 0x2, 0x1bfb, 0x1bfd, 
       0x5, 0x39a, 0x1ce, 0x2, 0x1bfc, 0x1bfb, 0x3, 0x2, 0x2, 0x2, 0x1bfc, 
       0x1bfd, 0x3, 0x2, 0x2, 0x2, 0x1bfd, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1bfe, 
       0x1c00, 0x7, 0xa1, 0x2, 0x2, 0x1bff, 0x1c01, 0x5, 0x39a, 0x1ce, 0x2, 
       0x1c00, 0x1bff, 0x3, 0x2, 0x2, 0x2, 0x1c00, 0x1c01, 0x3, 0x2, 0x2, 
       0x2, 0x1c01, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1c02, 0x1c35, 0x7, 0x26b, 
       0x2, 0x2, 0x1c03, 0x1c05, 0x7, 0x59, 0x2, 0x2, 0x1c04, 0x1c06, 0x5, 
       0x38e, 0x1c8, 0x2, 0x1c05, 0x1c04, 0x3, 0x2, 0x2, 0x2, 0x1c05, 0x1c06, 
       0x3, 0x2, 0x2, 0x2, 0x1c06, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1c07, 0x1c35, 
       0x9, 0x72, 0x2, 0x2, 0x1c08, 0x1c09, 0x7, 0x14a, 0x2, 0x2, 0x1c09, 
       0x1c35, 0x7, 0x294, 0x2, 0x2, 0x1c0a, 0x1c0e, 0x7, 0x14a, 0x2, 0x2, 
       0x1c0b, 0x1c0c, 0x7, 0x6d, 0x2, 0x2, 0x1c0c, 0x1c0f, 0x7, 0x298, 
       0x2, 0x2, 0x1c0d, 0x1c0f, 0x7, 0x295, 0x2, 0x2, 0x1c0e, 0x1c0b, 0x3, 
       0x2, 0x2, 0x2, 0x1c0e, 0x1c0d, 0x3, 0x2, 0x2, 0x2, 0x1c0e, 0x1c0f, 
       0x3, 0x2, 0x2, 0x2, 0x1c0f, 0x1c11, 0x3, 0x2, 0x2, 0x2, 0x1c10, 0x1c12, 
       0x5, 0x392, 0x1ca, 0x2, 0x1c11, 0x1c10, 0x3, 0x2, 0x2, 0x2, 0x1c11, 
       0x1c12, 0x3, 0x2, 0x2, 0x2, 0x1c12, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1c13, 
       0x1c15, 0x7, 0x26d, 0x2, 0x2, 0x1c14, 0x1c16, 0x5, 0x392, 0x1ca, 
       0x2, 0x1c15, 0x1c14, 0x3, 0x2, 0x2, 0x2, 0x1c15, 0x1c16, 0x3, 0x2, 
       0x2, 0x2, 0x1c16, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1c17, 0x1c19, 0x7, 
       0x264, 0x2, 0x2, 0x1c18, 0x1c1a, 0x5, 0x38e, 0x1c8, 0x2, 0x1c19, 
       0x1c18, 0x3, 0x2, 0x2, 0x2, 0x1c19, 0x1c1a, 0x3, 0x2, 0x2, 0x2, 0x1c1a, 
       0x1c1c, 0x3, 0x2, 0x2, 0x2, 0x1c1b, 0x1c1d, 0x5, 0x392, 0x1ca, 0x2, 
       0x1c1c, 0x1c1b, 0x3, 0x2, 0x2, 0x2, 0x1c1c, 0x1c1d, 0x3, 0x2, 0x2, 
       0x2, 0x1c1d, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1c1e, 0x1c20, 0x7, 0x171, 
       0x2, 0x2, 0x1c1f, 0x1c21, 0x5, 0x392, 0x1ca, 0x2, 0x1c20, 0x1c1f, 
       0x3, 0x2, 0x2, 0x2, 0x1c20, 0x1c21, 0x3, 0x2, 0x2, 0x2, 0x1c21, 0x1c35, 
       0x3, 0x2, 0x2, 0x2, 0x1c22, 0x1c24, 0x7, 0x148, 0x2, 0x2, 0x1c23, 
       0x1c25, 0x5, 0x392, 0x1ca, 0x2, 0x1c24, 0x1c23, 0x3, 0x2, 0x2, 0x2, 
       0x1c24, 0x1c25, 0x3, 0x2, 0x2, 0x2, 0x1c25, 0x1c35, 0x3, 0x2, 0x2, 
       0x2, 0x1c26, 0x1c27, 0x7, 0xd1, 0x2, 0x2, 0x1c27, 0x1c29, 0x5, 0x472, 
       0x23a, 0x2, 0x1c28, 0x1c2a, 0x5, 0x392, 0x1ca, 0x2, 0x1c29, 0x1c28, 
       0x3, 0x2, 0x2, 0x2, 0x1c29, 0x1c2a, 0x3, 0x2, 0x2, 0x2, 0x1c2a, 0x1c35, 
       0x3, 0x2, 0x2, 0x2, 0x1c2b, 0x1c2c, 0x7, 0x21b, 0x2, 0x2, 0x1c2c, 
       0x1c2e, 0x5, 0x472, 0x23a, 0x2, 0x1c2d, 0x1c2f, 0x5, 0x392, 0x1ca, 
       0x2, 0x1c2e, 0x1c2d, 0x3, 0x2, 0x2, 0x2, 0x1c2e, 0x1c2f, 0x3, 0x2, 
       0x2, 0x2, 0x1c2f, 0x1c35, 0x3, 0x2, 0x2, 0x2, 0x1c30, 0x1c35, 0x7, 
       0x216, 0x2, 0x2, 0x1c31, 0x1c32, 0x6, 0x1c3, 0xbf, 0x2, 0x1c32, 0x1c35, 
       0x7, 0x12d, 0x2, 0x2, 0x1c33, 0x1c35, 0x9, 0x73, 0x2, 0x2, 0x1c34, 
       0x1ba1, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1bad, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1bb5, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1bbc, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1bc0, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1bc1, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1bc8, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1bcf, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1bd6, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1be6, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1bec, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1bee, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1bf5, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1bf6, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1bfa, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1bfe, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1c02, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c03, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1c07, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c08, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1c0a, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c13, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1c17, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c1e, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1c22, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c26, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1c2b, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c30, 0x3, 0x2, 0x2, 0x2, 0x1c34, 
       0x1c31, 0x3, 0x2, 0x2, 0x2, 0x1c34, 0x1c33, 0x3, 0x2, 0x2, 0x2, 0x1c35, 
       0x385, 0x3, 0x2, 0x2, 0x2, 0x1c36, 0x1c3a, 0x7, 0x18d, 0x2, 0x2, 
       0x1c37, 0x1c38, 0x7, 0x18a, 0x2, 0x2, 0x1c38, 0x1c3a, 0x7, 0x6d, 
       0x2, 0x2, 0x1c39, 0x1c36, 0x3, 0x2, 0x2, 0x2, 0x1c39, 0x1c37, 0x3, 
       0x2, 0x2, 0x2, 0x1c3a, 0x387, 0x3, 0x2, 0x2, 0x2, 0x1c3b, 0x1c3c, 
       0x7, 0x6d, 0x2, 0x2, 0x1c3c, 0x1c3f, 0x7, 0x298, 0x2, 0x2, 0x1c3d, 
       0x1c3f, 0x7, 0x295, 0x2, 0x2, 0x1c3e, 0x1c3b, 0x3, 0x2, 0x2, 0x2, 
       0x1c3e, 0x1c3d, 0x3, 0x2, 0x2, 0x2, 0x1c3f, 0x389, 0x3, 0x2, 0x2, 
       0x2, 0x1c40, 0x1c41, 0x7, 0x18a, 0x2, 0x2, 0x1c41, 0x1c4b, 0x7, 0x295, 
       0x2, 0x2, 0x1c42, 0x1c4b, 0x7, 0x19e, 0x2, 0x2, 0x1c43, 0x1c44, 0x7, 
       0x18d, 0x2, 0x2, 0x1c44, 0x1c4b, 0x7, 0x295, 0x2, 0x2, 0x1c45, 0x1c46, 
       0x7, 0x18a, 0x2, 0x2, 0x1c46, 0x1c47, 0x7, 0x6d, 0x2, 0x2, 0x1c47, 
       0x1c4b, 0x7, 0x298, 0x2, 0x2, 0x1c48, 0x1c49, 0x7, 0x18d, 0x2, 0x2, 
       0x1c49, 0x1c4b, 0x7, 0x298, 0x2, 0x2, 0x1c4a, 0x1c40, 0x3, 0x2, 0x2, 
       0x2, 0x1c4a, 0x1c42, 0x3, 0x2, 0x2, 0x2, 0x1c4a, 0x1c43, 0x3, 0x2, 
       0x2, 0x2, 0x1c4a, 0x1c45, 0x3, 0x2, 0x2, 0x2, 0x1c4a, 0x1c48, 0x3, 
       0x2, 0x2, 0x2, 0x1c4b, 0x38b, 0x3, 0x2, 0x2, 0x2, 0x1c4c, 0x1c52, 
       0x7, 0x1d9, 0x2, 0x2, 0x1c4d, 0x1c4f, 0x7, 0xbf, 0x2, 0x2, 0x1c4e, 
       0x1c50, 0x7, 0x1c4, 0x2, 0x2, 0x1c4f, 0x1c4e, 0x3, 0x2, 0x2, 0x2, 
       0x1c4f, 0x1c50, 0x3, 0x2, 0x2, 0x2, 0x1c50, 0x1c52, 0x3, 0x2, 0x2, 
       0x2, 0x1c51, 0x1c4c, 0x3, 0x2, 0x2, 0x2, 0x1c51, 0x1c4d, 0x3, 0x2, 
       0x2, 0x2, 0x1c52, 0x38d, 0x3, 0x2, 0x2, 0x2, 0x1c53, 0x1c56, 0x7, 
       0x23, 0x2, 0x2, 0x1c54, 0x1c57, 0x5, 0x46c, 0x237, 0x2, 0x1c55, 0x1c57, 
       0x7, 0x31, 0x2, 0x2, 0x1c56, 0x1c54, 0x3, 0x2, 0x2, 0x2, 0x1c56, 
       0x1c55, 0x3, 0x2, 0x2, 0x2, 0x1c57, 0x1c58, 0x3, 0x2, 0x2, 0x2, 0x1c58, 
       0x1c59, 0x7, 0x24, 0x2, 0x2, 0x1c59, 0x38f, 0x3, 0x2, 0x2, 0x2, 0x1c5a, 
       0x1c5c, 0x9, 0x74, 0x2, 0x2, 0x1c5b, 0x1c5a, 0x3, 0x2, 0x2, 0x2, 
       0x1c5c, 0x1c5d, 0x3, 0x2, 0x2, 0x2, 0x1c5d, 0x1c5b, 0x3, 0x2, 0x2, 
       0x2, 0x1c5d, 0x1c5e, 0x3, 0x2, 0x2, 0x2, 0x1c5e, 0x391, 0x3, 0x2, 
       0x2, 0x2, 0x1c5f, 0x1c6e, 0x5, 0x394, 0x1cb, 0x2, 0x1c60, 0x1c6e, 
       0x5, 0x396, 0x1cc, 0x2, 0x1c61, 0x1c6e, 0x7, 0x60, 0x2, 0x2, 0x1c62, 
       0x1c63, 0x5, 0x2e6, 0x174, 0x2, 0x1c63, 0x1c65, 0x5, 0x39c, 0x1cf, 
       0x2, 0x1c64, 0x1c66, 0x7, 0x52, 0x2, 0x2, 0x1c65, 0x1c64, 0x3, 0x2, 
       0x2, 0x2, 0x1c65, 0x1c66, 0x3, 0x2, 0x2, 0x2, 0x1c66, 0x1c6e, 0x3, 
       0x2, 0x2, 0x2, 0x1c67, 0x1c6b, 0x7, 0x52, 0x2, 0x2, 0x1c68, 0x1c69, 
       0x5, 0x2e6, 0x174, 0x2, 0x1c69, 0x1c6a, 0x5, 0x39c, 0x1cf, 0x2, 0x1c6a, 
       0x1c6c, 0x3, 0x2, 0x2, 0x2, 0x1c6b, 0x1c68, 0x3, 0x2, 0x2, 0x2, 0x1c6b, 
       0x1c6c, 0x3, 0x2, 0x2, 0x2, 0x1c6c, 0x1c6e, 0x3, 0x2, 0x2, 0x2, 0x1c6d, 
       0x1c5f, 0x3, 0x2, 0x2, 0x2, 0x1c6d, 0x1c60, 0x3, 0x2, 0x2, 0x2, 0x1c6d, 
       0x1c61, 0x3, 0x2, 0x2, 0x2, 0x1c6d, 0x1c62, 0x3, 0x2, 0x2, 0x2, 0x1c6d, 
       0x1c67, 0x3, 0x2, 0x2, 0x2, 0x1c6e, 0x393, 0x3, 0x2, 0x2, 0x2, 0x1c6f, 
       0x1c71, 0x7, 0x45, 0x2, 0x2, 0x1c70, 0x1c72, 0x7, 0x52, 0x2, 0x2, 
       0x1c71, 0x1c70, 0x3, 0x2, 0x2, 0x2, 0x1c71, 0x1c72, 0x3, 0x2, 0x2, 
       0x2, 0x1c72, 0x1c76, 0x3, 0x2, 0x2, 0x2, 0x1c73, 0x1c74, 0x7, 0x52, 
       0x2, 0x2, 0x1c74, 0x1c76, 0x7, 0x45, 0x2, 0x2, 0x1c75, 0x1c6f, 0x3, 
       0x2, 0x2, 0x2, 0x1c75, 0x1c73, 0x3, 0x2, 0x2, 0x2, 0x1c76, 0x395, 
       0x3, 0x2, 0x2, 0x2, 0x1c77, 0x1c79, 0x7, 0x27e, 0x2, 0x2, 0x1c78, 
       0x1c7a, 0x7, 0x52, 0x2, 0x2, 0x1c79, 0x1c78, 0x3, 0x2, 0x2, 0x2, 
       0x1c79, 0x1c7a, 0x3, 0x2, 0x2, 0x2, 0x1c7a, 0x1c7e, 0x3, 0x2, 0x2, 
       0x2, 0x1c7b, 0x1c7c, 0x7, 0x52, 0x2, 0x2, 0x1c7c, 0x1c7e, 0x7, 0x27e, 
       0x2, 0x2, 0x1c7d, 0x1c77, 0x3, 0x2, 0x2, 0x2, 0x1c7d, 0x1c7b, 0x3, 
       0x2, 0x2, 0x2, 0x1c7e, 0x397, 0x3, 0x2, 0x2, 0x2, 0x1c7f, 0x1c80, 
       0x7, 0x23, 0x2, 0x2, 0x1c80, 0x1c81, 0x5, 0x468, 0x235, 0x2, 0x1c81, 
       0x1c82, 0x7, 0x24, 0x2, 0x2, 0x1c82, 0x399, 0x3, 0x2, 0x2, 0x2, 0x1c83, 
       0x1c84, 0x6, 0x1ce, 0xc0, 0x2, 0x1c84, 0x1c85, 0x7, 0x23, 0x2, 0x2, 
       0x1c85, 0x1c86, 0x7, 0x6, 0x2, 0x2, 0x1c86, 0x1c87, 0x7, 0x24, 0x2, 
       0x2, 0x1c87, 0x39b, 0x3, 0x2, 0x2, 0x2, 0x1c88, 0x1c8d, 0x5, 0x48e, 
       0x248, 0x2, 0x1c89, 0x1c8d, 0x7, 0x52, 0x2, 0x2, 0x1c8a, 0x1c8b, 
       0x6, 0x1cf, 0xc1, 0x2, 0x1c8b, 0x1c8d, 0x7, 0xae, 0x2, 0x2, 0x1c8c, 
       0x1c88, 0x3, 0x2, 0x2, 0x2, 0x1c8c, 0x1c89, 0x3, 0x2, 0x2, 0x2, 0x1c8c, 
       0x1c8a, 0x3, 0x2, 0x2, 0x2, 0x1c8d, 0x39d, 0x3, 0x2, 0x2, 0x2, 0x1c8e, 
       0x1c92, 0x5, 0x48e, 0x248, 0x2, 0x1c8f, 0x1c90, 0x6, 0x1d0, 0xc2, 
       0x2, 0x1c90, 0x1c92, 0x7, 0xae, 0x2, 0x2, 0x1c91, 0x1c8e, 0x3, 0x2, 
       0x2, 0x2, 0x1c91, 0x1c8f, 0x3, 0x2, 0x2, 0x2, 0x1c92, 0x39f, 0x3, 
       0x2, 0x2, 0x2, 0x1c93, 0x1c9a, 0x5, 0x3a4, 0x1d3, 0x2, 0x1c94, 0x1c96, 
       0x7, 0x20, 0x2, 0x2, 0x1c95, 0x1c94, 0x3, 0x2, 0x2, 0x2, 0x1c95, 
       0x1c96, 0x3, 0x2, 0x2, 0x2, 0x1c96, 0x1c97, 0x3, 0x2, 0x2, 0x2, 0x1c97, 
       0x1c99, 0x5, 0x3a4, 0x1d3, 0x2, 0x1c98, 0x1c95, 0x3, 0x2, 0x2, 0x2, 
       0x1c99, 0x1c9c, 0x3, 0x2, 0x2, 0x2, 0x1c9a, 0x1c98, 0x3, 0x2, 0x2, 
       0x2, 0x1c9a, 0x1c9b, 0x3, 0x2, 0x2, 0x2, 0x1c9b, 0x3a1, 0x3, 0x2, 
       0x2, 0x2, 0x1c9c, 0x1c9a, 0x3, 0x2, 0x2, 0x2, 0x1c9d, 0x1c9f, 0x5, 
       0x3a4, 0x1d3, 0x2, 0x1c9e, 0x1c9d, 0x3, 0x2, 0x2, 0x2, 0x1c9f, 0x1ca0, 
       0x3, 0x2, 0x2, 0x2, 0x1ca0, 0x1c9e, 0x3, 0x2, 0x2, 0x2, 0x1ca0, 0x1ca1, 
       0x3, 0x2, 0x2, 0x2, 0x1ca1, 0x3a3, 0x3, 0x2, 0x2, 0x2, 0x1ca2, 0x1ca4, 
       0x7, 0xd0, 0x2, 0x2, 0x1ca3, 0x1ca5, 0x7, 0x9, 0x2, 0x2, 0x1ca4, 
       0x1ca3, 0x3, 0x2, 0x2, 0x2, 0x1ca4, 0x1ca5, 0x3, 0x2, 0x2, 0x2, 0x1ca5, 
       0x1ca6, 0x3, 0x2, 0x2, 0x2, 0x1ca6, 0x1d25, 0x5, 0x438, 0x21d, 0x2, 
       0x1ca7, 0x1ca8, 0x6, 0x1d3, 0xc3, 0x2, 0x1ca8, 0x1caa, 0x7, 0x2f2, 
       0x2, 0x2, 0x1ca9, 0x1cab, 0x5, 0x498, 0x24d, 0x2, 0x1caa, 0x1ca9, 
       0x3, 0x2, 0x2, 0x2, 0x1caa, 0x1cab, 0x3, 0x2, 0x2, 0x2, 0x1cab, 0x1cae, 
       0x3, 0x2, 0x2, 0x2, 0x1cac, 0x1caf, 0x7, 0x19b, 0x2, 0x2, 0x1cad, 
       0x1caf, 0x5, 0x48e, 0x248, 0x2, 0x1cae, 0x1cac, 0x3, 0x2, 0x2, 0x2, 
       0x1cae, 0x1cad, 0x3, 0x2, 0x2, 0x2, 0x1caf, 0x1d25, 0x3, 0x2, 0x2, 
       0x2, 0x1cb0, 0x1cb2, 0x7, 0x168, 0x2, 0x2, 0x1cb1, 0x1cb3, 0x7, 0x9, 
       0x2, 0x2, 0x1cb2, 0x1cb1, 0x3, 0x2, 0x2, 0x2, 0x1cb2, 0x1cb3, 0x3, 
       0x2, 0x2, 0x2, 0x1cb3, 0x1cb4, 0x3, 0x2, 0x2, 0x2, 0x1cb4, 0x1d25, 
       0x5, 0x46a, 0x236, 0x2, 0x1cb5, 0x1cb7, 0x7, 0x17c, 0x2, 0x2, 0x1cb6, 
       0x1cb8, 0x7, 0x9, 0x2, 0x2, 0x1cb7, 0x1cb6, 0x3, 0x2, 0x2, 0x2, 0x1cb7, 
       0x1cb8, 0x3, 0x2, 0x2, 0x2, 0x1cb8, 0x1cb9, 0x3, 0x2, 0x2, 0x2, 0x1cb9, 
       0x1d25, 0x5, 0x46a, 0x236, 0x2, 0x1cba, 0x1cbc, 0x7, 0x4b, 0x2, 0x2, 
       0x1cbb, 0x1cbd, 0x7, 0x9, 0x2, 0x2, 0x1cbc, 0x1cbb, 0x3, 0x2, 0x2, 
       0x2, 0x1cbc, 0x1cbd, 0x3, 0x2, 0x2, 0x2, 0x1cbd, 0x1cbe, 0x3, 0x2, 
       0x2, 0x2, 0x1cbe, 0x1d25, 0x5, 0x466, 0x234, 0x2, 0x1cbf, 0x1cc1, 
       0x7, 0x1ba, 0x2, 0x2, 0x1cc0, 0x1cc2, 0x7, 0x9, 0x2, 0x2, 0x1cc1, 
       0x1cc0, 0x3, 0x2, 0x2, 0x2, 0x1cc1, 0x1cc2, 0x3, 0x2, 0x2, 0x2, 0x1cc2, 
       0x1cc3, 0x3, 0x2, 0x2, 0x2, 0x1cc3, 0x1d25, 0x5, 0x474, 0x23b, 0x2, 
       0x1cc4, 0x1cc6, 0x7, 0x7c, 0x2, 0x2, 0x1cc5, 0x1cc7, 0x7, 0x9, 0x2, 
       0x2, 0x1cc6, 0x1cc5, 0x3, 0x2, 0x2, 0x2, 0x1cc6, 0x1cc7, 0x3, 0x2, 
       0x2, 0x2, 0x1cc7, 0x1cc8, 0x3, 0x2, 0x2, 0x2, 0x1cc8, 0x1d25, 0x5, 
       0x474, 0x23b, 0x2, 0x1cc9, 0x1cca, 0x6, 0x1d3, 0xc4, 0x2, 0x1cca, 
       0x1ccc, 0x7, 0x82, 0x2, 0x2, 0x1ccb, 0x1ccd, 0x7, 0x9, 0x2, 0x2, 
       0x1ccc, 0x1ccb, 0x3, 0x2, 0x2, 0x2, 0x1ccc, 0x1ccd, 0x3, 0x2, 0x2, 
       0x2, 0x1ccd, 0x1cce, 0x3, 0x2, 0x2, 0x2, 0x1cce, 0x1d25, 0x5, 0x476, 
       0x23c, 0x2, 0x1ccf, 0x1cd0, 0x6, 0x1d3, 0xc5, 0x2, 0x1cd0, 0x1cd2, 
       0x7, 0xcb, 0x2, 0x2, 0x1cd1, 0x1cd3, 0x7, 0x9, 0x2, 0x2, 0x1cd2, 
       0x1cd1, 0x3, 0x2, 0x2, 0x2, 0x1cd2, 0x1cd3, 0x3, 0x2, 0x2, 0x2, 0x1cd3, 
       0x1cd4, 0x3, 0x2, 0x2, 0x2, 0x1cd4, 0x1d25, 0x5, 0x476, 0x23c, 0x2, 
       0x1cd5, 0x1cd7, 0x7, 0x4a, 0x2, 0x2, 0x1cd6, 0x1cd8, 0x7, 0x9, 0x2, 
       0x2, 0x1cd7, 0x1cd6, 0x3, 0x2, 0x2, 0x2, 0x1cd7, 0x1cd8, 0x3, 0x2, 
       0x2, 0x2, 0x1cd8, 0x1cd9, 0x3, 0x2, 0x2, 0x2, 0x1cd9, 0x1d25, 0x5, 
       0x46a, 0x236, 0x2, 0x1cda, 0x1cdc, 0x7, 0x1b3, 0x2, 0x2, 0x1cdb, 
       0x1cdd, 0x7, 0x9, 0x2, 0x2, 0x1cdc, 0x1cdb, 0x3, 0x2, 0x2, 0x2, 0x1cdc, 
       0x1cdd, 0x3, 0x2, 0x2, 0x2, 0x1cdd, 0x1cde, 0x3, 0x2, 0x2, 0x2, 0x1cde, 
       0x1d25, 0x5, 0x3a6, 0x1d4, 0x2, 0x1cdf, 0x1ce0, 0x6, 0x1d3, 0xc6, 
       0x2, 0x1ce0, 0x1ce2, 0x9, 0x75, 0x2, 0x2, 0x1ce1, 0x1ce3, 0x7, 0x9, 
       0x2, 0x2, 0x1ce2, 0x1ce1, 0x3, 0x2, 0x2, 0x2, 0x1ce2, 0x1ce3, 0x3, 
       0x2, 0x2, 0x2, 0x1ce3, 0x1ce4, 0x3, 0x2, 0x2, 0x2, 0x1ce4, 0x1d25, 
       0x5, 0x3a6, 0x1d4, 0x2, 0x1ce5, 0x1ce7, 0x9, 0x76, 0x2, 0x2, 0x1ce6, 
       0x1ce8, 0x7, 0x9, 0x2, 0x2, 0x1ce7, 0x1ce6, 0x3, 0x2, 0x2, 0x2, 0x1ce7, 
       0x1ce8, 0x3, 0x2, 0x2, 0x2, 0x1ce8, 0x1ce9, 0x3, 0x2, 0x2, 0x2, 0x1ce9, 
       0x1d25, 0x5, 0x466, 0x234, 0x2, 0x1cea, 0x1cec, 0x7, 0xb2, 0x2, 0x2, 
       0x1ceb, 0x1ced, 0x7, 0x9, 0x2, 0x2, 0x1cec, 0x1ceb, 0x3, 0x2, 0x2, 
       0x2, 0x1cec, 0x1ced, 0x3, 0x2, 0x2, 0x2, 0x1ced, 0x1cee, 0x3, 0x2, 
       0x2, 0x2, 0x1cee, 0x1d25, 0x5, 0x466, 0x234, 0x2, 0x1cef, 0x1cf1, 
       0x7, 0x209, 0x2, 0x2, 0x1cf0, 0x1cf2, 0x7, 0x9, 0x2, 0x2, 0x1cf1, 
       0x1cf0, 0x3, 0x2, 0x2, 0x2, 0x1cf1, 0x1cf2, 0x3, 0x2, 0x2, 0x2, 0x1cf2, 
       0x1cf3, 0x3, 0x2, 0x2, 0x2, 0x1cf3, 0x1d25, 0x9, 0x77, 0x2, 0x2, 
       0x1cf4, 0x1cf6, 0x7, 0x280, 0x2, 0x2, 0x1cf5, 0x1cf7, 0x7, 0x9, 0x2, 
       0x2, 0x1cf6, 0x1cf5, 0x3, 0x2, 0x2, 0x2, 0x1cf6, 0x1cf7, 0x3, 0x2, 
       0x2, 0x2, 0x1cf7, 0x1cf8, 0x3, 0x2, 0x2, 0x2, 0x1cf8, 0x1cf9, 0x7, 
       0x23, 0x2, 0x2, 0x1cf9, 0x1cfa, 0x5, 0x442, 0x222, 0x2, 0x1cfa, 0x1cfb, 
       0x7, 0x24, 0x2, 0x2, 0x1cfb, 0x1d25, 0x3, 0x2, 0x2, 0x2, 0x1cfc, 
       0x1d25, 0x5, 0x3ac, 0x1d7, 0x2, 0x1cfd, 0x1d25, 0x5, 0x3a8, 0x1d5, 
       0x2, 0x1cfe, 0x1d00, 0x7, 0x11c, 0x2, 0x2, 0x1cff, 0x1d01, 0x7, 0x9, 
       0x2, 0x2, 0x1d00, 0x1cff, 0x3, 0x2, 0x2, 0x2, 0x1d00, 0x1d01, 0x3, 
       0x2, 0x2, 0x2, 0x1d01, 0x1d02, 0x3, 0x2, 0x2, 0x2, 0x1d02, 0x1d25, 
       0x9, 0x78, 0x2, 0x2, 0x1d03, 0x1d04, 0x7, 0xa0, 0x2, 0x2, 0x1d04, 
       0x1d06, 0x7, 0xb9, 0x2, 0x2, 0x1d05, 0x1d07, 0x7, 0x9, 0x2, 0x2, 
       0x1d06, 0x1d05, 0x3, 0x2, 0x2, 0x2, 0x1d06, 0x1d07, 0x3, 0x2, 0x2, 
       0x2, 0x1d07, 0x1d08, 0x3, 0x2, 0x2, 0x2, 0x1d08, 0x1d25, 0x5, 0x476, 
       0x23c, 0x2, 0x1d09, 0x1d0a, 0x7, 0x115, 0x2, 0x2, 0x1d0a, 0x1d0c, 
       0x7, 0xb9, 0x2, 0x2, 0x1d0b, 0x1d0d, 0x7, 0x9, 0x2, 0x2, 0x1d0c, 
       0x1d0b, 0x3, 0x2, 0x2, 0x2, 0x1d0c, 0x1d0d, 0x3, 0x2, 0x2, 0x2, 0x1d0d, 
       0x1d0e, 0x3, 0x2, 0x2, 0x2, 0x1d0e, 0x1d25, 0x5, 0x476, 0x23c, 0x2, 
       0x1d0f, 0x1d15, 0x7, 0x25c, 0x2, 0x2, 0x1d10, 0x1d12, 0x6, 0x1d3, 
       0xc7, 0x2, 0x1d11, 0x1d13, 0x7, 0x9, 0x2, 0x2, 0x1d12, 0x1d11, 0x3, 
       0x2, 0x2, 0x2, 0x1d12, 0x1d13, 0x3, 0x2, 0x2, 0x2, 0x1d13, 0x1d16, 
       0x3, 0x2, 0x2, 0x2, 0x1d14, 0x1d16, 0x3, 0x2, 0x2, 0x2, 0x1d15, 0x1d10, 
       0x3, 0x2, 0x2, 0x2, 0x1d15, 0x1d14, 0x3, 0x2, 0x2, 0x2, 0x1d16, 0x1d17, 
       0x3, 0x2, 0x2, 0x2, 0x1d17, 0x1d25, 0x5, 0x45a, 0x22e, 0x2, 0x1d18, 
       0x1d19, 0x7, 0x249, 0x2, 0x2, 0x1d19, 0x1d25, 0x9, 0x79, 0x2, 0x2, 
       0x1d1a, 0x1d1c, 0x7, 0x85, 0x2, 0x2, 0x1d1b, 0x1d1d, 0x7, 0x9, 0x2, 
       0x2, 0x1d1c, 0x1d1b, 0x3, 0x2, 0x2, 0x2, 0x1d1c, 0x1d1d, 0x3, 0x2, 
       0x2, 0x2, 0x1d1d, 0x1d1e, 0x3, 0x2, 0x2, 0x2, 0x1d1e, 0x1d25, 0x5, 
       0x476, 0x23c, 0x2, 0x1d1f, 0x1d21, 0x7, 0x12f, 0x2, 0x2, 0x1d20, 
       0x1d22, 0x7, 0x9, 0x2, 0x2, 0x1d21, 0x1d20, 0x3, 0x2, 0x2, 0x2, 0x1d21, 
       0x1d22, 0x3, 0x2, 0x2, 0x2, 0x1d22, 0x1d23, 0x3, 0x2, 0x2, 0x2, 0x1d23, 
       0x1d25, 0x5, 0x466, 0x234, 0x2, 0x1d24, 0x1ca2, 0x3, 0x2, 0x2, 0x2, 
       0x1d24, 0x1ca7, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cb0, 0x3, 0x2, 0x2, 
       0x2, 0x1d24, 0x1cb5, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cba, 0x3, 0x2, 
       0x2, 0x2, 0x1d24, 0x1cbf, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cc4, 0x3, 
       0x2, 0x2, 0x2, 0x1d24, 0x1cc9, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1ccf, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cd5, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cda, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cdf, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1ce5, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cea, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cef, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cf4, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cfc, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cfd, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1cfe, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1d03, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1d09, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1d0f, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1d18, 
       0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1d1a, 0x3, 0x2, 0x2, 0x2, 0x1d24, 0x1d1f, 
       0x3, 0x2, 0x2, 0x2, 0x1d25, 0x3a5, 0x3, 0x2, 0x2, 0x2, 0x1d26, 0x1d29, 
       0x5, 0x466, 0x234, 0x2, 0x1d27, 0x1d29, 0x7, 0xae, 0x2, 0x2, 0x1d28, 
       0x1d26, 0x3, 0x2, 0x2, 0x2, 0x1d28, 0x1d27, 0x3, 0x2, 0x2, 0x2, 0x1d29, 
       0x3a7, 0x3, 0x2, 0x2, 0x2, 0x1d2a, 0x1d2c, 0x7, 0xae, 0x2, 0x2, 0x1d2b, 
       0x1d2a, 0x3, 0x2, 0x2, 0x2, 0x1d2b, 0x1d2c, 0x3, 0x2, 0x2, 0x2, 0x1d2c, 
       0x1d2d, 0x3, 0x2, 0x2, 0x2, 0x1d2d, 0x1d2f, 0x7, 0x76, 0x2, 0x2, 
       0x1d2e, 0x1d30, 0x7, 0x9, 0x2, 0x2, 0x1d2f, 0x1d2e, 0x3, 0x2, 0x2, 
       0x2, 0x1d2f, 0x1d30, 0x3, 0x2, 0x2, 0x2, 0x1d30, 0x1d31, 0x3, 0x2, 
       0x2, 0x2, 0x1d31, 0x1d32, 0x5, 0x39e, 0x1d0, 0x2, 0x1d32, 0x3a9, 
       0x3, 0x2, 0x2, 0x2, 0x1d33, 0x1d35, 0x7, 0xae, 0x2, 0x2, 0x1d34, 
       0x1d33, 0x3, 0x2, 0x2, 0x2, 0x1d34, 0x1d35, 0x3, 0x2, 0x2, 0x2, 0x1d35, 
       0x1d36, 0x3, 0x2, 0x2, 0x2, 0x1d36, 0x1d38, 0x7, 0xcb, 0x2, 0x2, 
       0x1d37, 0x1d39, 0x7, 0x9, 0x2, 0x2, 0x1d38, 0x1d37, 0x3, 0x2, 0x2, 
       0x2, 0x1d38, 0x1d39, 0x3, 0x2, 0x2, 0x2, 0x1d39, 0x1d3a, 0x3, 0x2, 
       0x2, 0x2, 0x1d3a, 0x1d3b, 0x5, 0x474, 0x23b, 0x2, 0x1d3b, 0x3ab, 
       0x3, 0x2, 0x2, 0x2, 0x1d3c, 0x1d3e, 0x7, 0xae, 0x2, 0x2, 0x1d3d, 
       0x1d3c, 0x3, 0x2, 0x2, 0x2, 0x1d3d, 0x1d3e, 0x3, 0x2, 0x2, 0x2, 0x1d3e, 
       0x1d3f, 0x3, 0x2, 0x2, 0x2, 0x1d3f, 0x1d41, 0x5, 0x2e6, 0x174, 0x2, 
       0x1d40, 0x1d42, 0x7, 0x9, 0x2, 0x2, 0x1d41, 0x1d40, 0x3, 0x2, 0x2, 
       0x2, 0x1d41, 0x1d42, 0x3, 0x2, 0x2, 0x2, 0x1d42, 0x1d43, 0x3, 0x2, 
       0x2, 0x2, 0x1d43, 0x1d44, 0x5, 0x39c, 0x1cf, 0x2, 0x1d44, 0x3ad, 
       0x3, 0x2, 0x2, 0x2, 0x1d45, 0x1d46, 0x7, 0x1b9, 0x2, 0x2, 0x1d46, 
       0x1d47, 0x7, 0x5f, 0x2, 0x2, 0x1d47, 0x1d4a, 0x5, 0x3b0, 0x1d9, 0x2, 
       0x1d48, 0x1d49, 0x7, 0x1b8, 0x2, 0x2, 0x1d49, 0x1d4b, 0x5, 0x468, 
       0x235, 0x2, 0x1d4a, 0x1d48, 0x3, 0x2, 0x2, 0x2, 0x1d4a, 0x1d4b, 0x3, 
       0x2, 0x2, 0x2, 0x1d4b, 0x1d4d, 0x3, 0x2, 0x2, 0x2, 0x1d4c, 0x1d4e, 
       0x5, 0x3b2, 0x1da, 0x2, 0x1d4d, 0x1d4c, 0x3, 0x2, 0x2, 0x2, 0x1d4d, 
       0x1d4e, 0x3, 0x2, 0x2, 0x2, 0x1d4e, 0x1d50, 0x3, 0x2, 0x2, 0x2, 0x1d4f, 
       0x1d51, 0x5, 0x3b6, 0x1dc, 0x2, 0x1d50, 0x1d4f, 0x3, 0x2, 0x2, 0x2, 
       0x1d50, 0x1d51, 0x3, 0x2, 0x2, 0x2, 0x1d51, 0x3af, 0x3, 0x2, 0x2, 
       0x2, 0x1d52, 0x1d54, 0x7, 0x13c, 0x2, 0x2, 0x1d53, 0x1d52, 0x3, 0x2, 
       0x2, 0x2, 0x1d53, 0x1d54, 0x3, 0x2, 0x2, 0x2, 0x1d54, 0x1d55, 0x3, 
       0x2, 0x2, 0x2, 0x1d55, 0x1d57, 0x7, 0x130, 0x2, 0x2, 0x1d56, 0x1d58, 
       0x5, 0x3b4, 0x1db, 0x2, 0x1d57, 0x1d56, 0x3, 0x2, 0x2, 0x2, 0x1d57, 
       0x1d58, 0x3, 0x2, 0x2, 0x2, 0x1d58, 0x1d59, 0x3, 0x2, 0x2, 0x2, 0x1d59, 
       0x1d5b, 0x7, 0x23, 0x2, 0x2, 0x1d5a, 0x1d5c, 0x5, 0x45c, 0x22f, 0x2, 
       0x1d5b, 0x1d5a, 0x3, 0x2, 0x2, 0x2, 0x1d5b, 0x1d5c, 0x3, 0x2, 0x2, 
       0x2, 0x1d5c, 0x1d5d, 0x3, 0x2, 0x2, 0x2, 0x1d5d, 0x1d74, 0x7, 0x24, 
       0x2, 0x2, 0x1d5e, 0x1d60, 0x7, 0x13c, 0x2, 0x2, 0x1d5f, 0x1d5e, 0x3, 
       0x2, 0x2, 0x2, 0x1d5f, 0x1d60, 0x3, 0x2, 0x2, 0x2, 0x1d60, 0x1d61, 
       0x3, 0x2, 0x2, 0x2, 0x1d61, 0x1d62, 0x7, 0x105, 0x2, 0x2, 0x1d62, 
       0x1d63, 0x7, 0x23, 0x2, 0x2, 0x1d63, 0x1d64, 0x5, 0x29e, 0x150, 0x2, 
       0x1d64, 0x1d65, 0x7, 0x24, 0x2, 0x2, 0x1d65, 0x1d74, 0x3, 0x2, 0x2, 
       0x2, 0x1d66, 0x1d71, 0x9, 0x7a, 0x2, 0x2, 0x1d67, 0x1d68, 0x7, 0x23, 
       0x2, 0x2, 0x1d68, 0x1d69, 0x5, 0x29e, 0x150, 0x2, 0x1d69, 0x1d6a, 
       0x7, 0x24, 0x2, 0x2, 0x1d6a, 0x1d72, 0x3, 0x2, 0x2, 0x2, 0x1d6b, 
       0x1d6c, 0x7, 0x78, 0x2, 0x2, 0x1d6c, 0x1d6e, 0x7, 0x23, 0x2, 0x2, 
       0x1d6d, 0x1d6f, 0x5, 0x45c, 0x22f, 0x2, 0x1d6e, 0x1d6d, 0x3, 0x2, 
       0x2, 0x2, 0x1d6e, 0x1d6f, 0x3, 0x2, 0x2, 0x2, 0x1d6f, 0x1d70, 0x3, 
       0x2, 0x2, 0x2, 0x1d70, 0x1d72, 0x7, 0x24, 0x2, 0x2, 0x1d71, 0x1d67, 
       0x3, 0x2, 0x2, 0x2, 0x1d71, 0x1d6b, 0x3, 0x2, 0x2, 0x2, 0x1d72, 0x1d74, 
       0x3, 0x2, 0x2, 0x2, 0x1d73, 0x1d53, 0x3, 0x2, 0x2, 0x2, 0x1d73, 0x1d5f, 
       0x3, 0x2, 0x2, 0x2, 0x1d73, 0x1d66, 0x3, 0x2, 0x2, 0x2, 0x1d74, 0x3b1, 
       0x3, 0x2, 0x2, 0x2, 0x1d75, 0x1d76, 0x7, 0x251, 0x2, 0x2, 0x1d76, 
       0x1d78, 0x7, 0x5f, 0x2, 0x2, 0x1d77, 0x1d79, 0x7, 0x13c, 0x2, 0x2, 
       0x1d78, 0x1d77, 0x3, 0x2, 0x2, 0x2, 0x1d78, 0x1d79, 0x3, 0x2, 0x2, 
       0x2, 0x1d79, 0x1d84, 0x3, 0x2, 0x2, 0x2, 0x1d7a, 0x1d7b, 0x7, 0x105, 
       0x2, 0x2, 0x1d7b, 0x1d7c, 0x7, 0x23, 0x2, 0x2, 0x1d7c, 0x1d7d, 0x5, 
       0x29e, 0x150, 0x2, 0x1d7d, 0x1d7e, 0x7, 0x24, 0x2, 0x2, 0x1d7e, 0x1d85, 
       0x3, 0x2, 0x2, 0x2, 0x1d7f, 0x1d81, 0x7, 0x130, 0x2, 0x2, 0x1d80, 
       0x1d82, 0x5, 0x3b4, 0x1db, 0x2, 0x1d81, 0x1d80, 0x3, 0x2, 0x2, 0x2, 
       0x1d81, 0x1d82, 0x3, 0x2, 0x2, 0x2, 0x1d82, 0x1d83, 0x3, 0x2, 0x2, 
       0x2, 0x1d83, 0x1d85, 0x5, 0x45e, 0x230, 0x2, 0x1d84, 0x1d7a, 0x3, 
       0x2, 0x2, 0x2, 0x1d84, 0x1d7f, 0x3, 0x2, 0x2, 0x2, 0x1d85, 0x1d88, 
       0x3, 0x2, 0x2, 0x2, 0x1d86, 0x1d87, 0x7, 0x250, 0x2, 0x2, 0x1d87, 
       0x1d89, 0x5, 0x468, 0x235, 0x2, 0x1d88, 0x1d86, 0x3, 0x2, 0x2, 0x2, 
       0x1d88, 0x1d89, 0x3, 0x2, 0x2, 0x2, 0x1d89, 0x3b3, 0x3, 0x2, 0x2, 
       0x2, 0x1d8a, 0x1d8b, 0x6, 0x1db, 0xc8, 0x2, 0x1d8b, 0x1d8c, 0x7, 
       0x3b, 0x2, 0x2, 0x1d8c, 0x1d8d, 0x7, 0x9, 0x2, 0x2, 0x1d8d, 0x1d8e, 
       0x5, 0x468, 0x235, 0x2, 0x1d8e, 0x3b5, 0x3, 0x2, 0x2, 0x2, 0x1d8f, 
       0x1d90, 0x7, 0x23, 0x2, 0x2, 0x1d90, 0x1d95, 0x5, 0x3b8, 0x1dd, 0x2, 
       0x1d91, 0x1d92, 0x7, 0x20, 0x2, 0x2, 0x1d92, 0x1d94, 0x5, 0x3b8, 
       0x1dd, 0x2, 0x1d93, 0x1d91, 0x3, 0x2, 0x2, 0x2, 0x1d94, 0x1d97, 0x3, 
       0x2, 0x2, 0x2, 0x1d95, 0x1d93, 0x3, 0x2, 0x2, 0x2, 0x1d95, 0x1d96, 
       0x3, 0x2, 0x2, 0x2, 0x1d96, 0x1d98, 0x3, 0x2, 0x2, 0x2, 0x1d97, 0x1d95, 
       0x3, 0x2, 0x2, 0x2, 0x1d98, 0x1d99, 0x7, 0x24, 0x2, 0x2, 0x1d99, 
       0x3b7, 0x3, 0x2, 0x2, 0x2, 0x1d9a, 0x1d9b, 0x7, 0x1b9, 0x2, 0x2, 
       0x1d9b, 0x1da6, 0x5, 0x45a, 0x22e, 0x2, 0x1d9c, 0x1d9d, 0x7, 0x292, 
       0x2, 0x2, 0x1d9d, 0x1d9e, 0x7, 0x138, 0x2, 0x2, 0x1d9e, 0x1da1, 0x7, 
       0x265, 0x2, 0x2, 0x1d9f, 0x1da2, 0x5, 0x3c0, 0x1e1, 0x2, 0x1da0, 
       0x1da2, 0x7, 0x16e, 0x2, 0x2, 0x1da1, 0x1d9f, 0x3, 0x2, 0x2, 0x2, 
       0x1da1, 0x1da0, 0x3, 0x2, 0x2, 0x2, 0x1da2, 0x1da7, 0x3, 0x2, 0x2, 
       0x2, 0x1da3, 0x1da4, 0x7, 0x292, 0x2, 0x2, 0x1da4, 0x1da5, 0x7, 0x123, 
       0x2, 0x2, 0x1da5, 0x1da7, 0x5, 0x3ba, 0x1de, 0x2, 0x1da6, 0x1d9c, 
       0x3, 0x2, 0x2, 0x2, 0x1da6, 0x1da3, 0x3, 0x2, 0x2, 0x2, 0x1da6, 0x1da7, 
       0x3, 0x2, 0x2, 0x2, 0x1da7, 0x1dab, 0x3, 0x2, 0x2, 0x2, 0x1da8, 0x1daa, 
       0x5, 0x3bc, 0x1df, 0x2, 0x1da9, 0x1da8, 0x3, 0x2, 0x2, 0x2, 0x1daa, 
       0x1dad, 0x3, 0x2, 0x2, 0x2, 0x1dab, 0x1da9, 0x3, 0x2, 0x2, 0x2, 0x1dab, 
       0x1dac, 0x3, 0x2, 0x2, 0x2, 0x1dac, 0x1db9, 0x3, 0x2, 0x2, 0x2, 0x1dad, 
       0x1dab, 0x3, 0x2, 0x2, 0x2, 0x1dae, 0x1daf, 0x7, 0x23, 0x2, 0x2, 
       0x1daf, 0x1db4, 0x5, 0x3be, 0x1e0, 0x2, 0x1db0, 0x1db1, 0x7, 0x20, 
       0x2, 0x2, 0x1db1, 0x1db3, 0x5, 0x3be, 0x1e0, 0x2, 0x1db2, 0x1db0, 
       0x3, 0x2, 0x2, 0x2, 0x1db3, 0x1db6, 0x3, 0x2, 0x2, 0x2, 0x1db4, 0x1db2, 
       0x3, 0x2, 0x2, 0x2, 0x1db4, 0x1db5, 0x3, 0x2, 0x2, 0x2, 0x1db5, 0x1db7, 
       0x3, 0x2, 0x2, 0x2, 0x1db6, 0x1db4, 0x3, 0x2, 0x2, 0x2, 0x1db7, 0x1db8, 
       0x7, 0x24, 0x2, 0x2, 0x1db8, 0x1dba, 0x3, 0x2, 0x2, 0x2, 0x1db9, 
       0x1dae, 0x3, 0x2, 0x2, 0x2, 0x1db9, 0x1dba, 0x3, 0x2, 0x2, 0x2, 0x1dba, 
       0x3b9, 0x3, 0x2, 0x2, 0x2, 0x1dbb, 0x1dc8, 0x5, 0x3c0, 0x1e1, 0x2, 
       0x1dbc, 0x1dbd, 0x7, 0x23, 0x2, 0x2, 0x1dbd, 0x1dc2, 0x5, 0x3c0, 
       0x1e1, 0x2, 0x1dbe, 0x1dbf, 0x7, 0x20, 0x2, 0x2, 0x1dbf, 0x1dc1, 
       0x5, 0x3c0, 0x1e1, 0x2, 0x1dc0, 0x1dbe, 0x3, 0x2, 0x2, 0x2, 0x1dc1, 
       0x1dc4, 0x3, 0x2, 0x2, 0x2, 0x1dc2, 0x1dc0, 0x3, 0x2, 0x2, 0x2, 0x1dc2, 
       0x1dc3, 0x3, 0x2, 0x2, 0x2, 0x1dc3, 0x1dc5, 0x3, 0x2, 0x2, 0x2, 0x1dc4, 
       0x1dc2, 0x3, 0x2, 0x2, 0x2, 0x1dc5, 0x1dc6, 0x7, 0x24, 0x2, 0x2, 
       0x1dc6, 0x1dc8, 0x3, 0x2, 0x2, 0x2, 0x1dc7, 0x1dbb, 0x3, 0x2, 0x2, 
       0x2, 0x1dc7, 0x1dbc, 0x3, 0x2, 0x2, 0x2, 0x1dc8, 0x3bb, 0x3, 0x2, 
       0x2, 0x2, 0x1dc9, 0x1dcb, 0x7, 0x25c, 0x2, 0x2, 0x1dca, 0x1dcc, 0x7, 
       0x9, 0x2, 0x2, 0x1dcb, 0x1dca, 0x3, 0x2, 0x2, 0x2, 0x1dcb, 0x1dcc, 
       0x3, 0x2, 0x2, 0x2, 0x1dcc, 0x1dcd, 0x3, 0x2, 0x2, 0x2, 0x1dcd, 0x1dec, 
       0x5, 0x45a, 0x22e, 0x2, 0x1dce, 0x1dd0, 0x7, 0x249, 0x2, 0x2, 0x1dcf, 
       0x1dce, 0x3, 0x2, 0x2, 0x2, 0x1dcf, 0x1dd0, 0x3, 0x2, 0x2, 0x2, 0x1dd0, 
       0x1dd1, 0x3, 0x2, 0x2, 0x2, 0x1dd1, 0x1dd3, 0x7, 0xd0, 0x2, 0x2, 
       0x1dd2, 0x1dd4, 0x7, 0x9, 0x2, 0x2, 0x1dd3, 0x1dd2, 0x3, 0x2, 0x2, 
       0x2, 0x1dd3, 0x1dd4, 0x3, 0x2, 0x2, 0x2, 0x1dd4, 0x1dd5, 0x3, 0x2, 
       0x2, 0x2, 0x1dd5, 0x1dec, 0x5, 0x438, 0x21d, 0x2, 0x1dd6, 0x1dd8, 
       0x7, 0x193, 0x2, 0x2, 0x1dd7, 0x1dd9, 0x7, 0x9, 0x2, 0x2, 0x1dd8, 
       0x1dd7, 0x3, 0x2, 0x2, 0x2, 0x1dd8, 0x1dd9, 0x3, 0x2, 0x2, 0x2, 0x1dd9, 
       0x1dda, 0x3, 0x2, 0x2, 0x2, 0x1dda, 0x1dec, 0x5, 0x468, 0x235, 0x2, 
       0x1ddb, 0x1ddd, 0x9, 0x7b, 0x2, 0x2, 0x1ddc, 0x1dde, 0x7, 0x9, 0x2, 
       0x2, 0x1ddd, 0x1ddc, 0x3, 0x2, 0x2, 0x2, 0x1ddd, 0x1dde, 0x3, 0x2, 
       0x2, 0x2, 0x1dde, 0x1ddf, 0x3, 0x2, 0x2, 0x2, 0x1ddf, 0x1dec, 0x5, 
       0x468, 0x235, 0x2, 0x1de0, 0x1de1, 0x9, 0x7c, 0x2, 0x2, 0x1de1, 0x1de3, 
       0x7, 0xb9, 0x2, 0x2, 0x1de2, 0x1de4, 0x7, 0x9, 0x2, 0x2, 0x1de3, 
       0x1de2, 0x3, 0x2, 0x2, 0x2, 0x1de3, 0x1de4, 0x3, 0x2, 0x2, 0x2, 0x1de4, 
       0x1de5, 0x3, 0x2, 0x2, 0x2, 0x1de5, 0x1dec, 0x5, 0x47a, 0x23e, 0x2, 
       0x1de6, 0x1de8, 0x7, 0x7c, 0x2, 0x2, 0x1de7, 0x1de9, 0x7, 0x9, 0x2, 
       0x2, 0x1de8, 0x1de7, 0x3, 0x2, 0x2, 0x2, 0x1de8, 0x1de9, 0x3, 0x2, 
       0x2, 0x2, 0x1de9, 0x1dea, 0x3, 0x2, 0x2, 0x2, 0x1dea, 0x1dec, 0x5, 
       0x47a, 0x23e, 0x2, 0x1deb, 0x1dc9, 0x3, 0x2, 0x2, 0x2, 0x1deb, 0x1dcf, 
       0x3, 0x2, 0x2, 0x2, 0x1deb, 0x1dd6, 0x3, 0x2, 0x2, 0x2, 0x1deb, 0x1ddb, 
       0x3, 0x2, 0x2, 0x2, 0x1deb, 0x1de0, 0x3, 0x2, 0x2, 0x2, 0x1deb, 0x1de6, 
       0x3, 0x2, 0x2, 0x2, 0x1dec, 0x3bd, 0x3, 0x2, 0x2, 0x2, 0x1ded, 0x1dee, 
       0x7, 0x251, 0x2, 0x2, 0x1dee, 0x1df2, 0x5, 0x48e, 0x248, 0x2, 0x1def, 
       0x1df1, 0x5, 0x3bc, 0x1df, 0x2, 0x1df0, 0x1def, 0x3, 0x2, 0x2, 0x2, 
       0x1df1, 0x1df4, 0x3, 0x2, 0x2, 0x2, 0x1df2, 0x1df0, 0x3, 0x2, 0x2, 
       0x2, 0x1df2, 0x1df3, 0x3, 0x2, 0x2, 0x2, 0x1df3, 0x3bf, 0x3, 0x2, 
       0x2, 0x2, 0x1df4, 0x1df2, 0x3, 0x2, 0x2, 0x2, 0x1df5, 0x1df6, 0x7, 
       0x23, 0x2, 0x2, 0x1df6, 0x1dfb, 0x5, 0x3c2, 0x1e2, 0x2, 0x1df7, 0x1df8, 
       0x7, 0x20, 0x2, 0x2, 0x1df8, 0x1dfa, 0x5, 0x3c2, 0x1e2, 0x2, 0x1df9, 
       0x1df7, 0x3, 0x2, 0x2, 0x2, 0x1dfa, 0x1dfd, 0x3, 0x2, 0x2, 0x2, 0x1dfb, 
       0x1df9, 0x3, 0x2, 0x2, 0x2, 0x1dfb, 0x1dfc, 0x3, 0x2, 0x2, 0x2, 0x1dfc, 
       0x1dfe, 0x3, 0x2, 0x2, 0x2, 0x1dfd, 0x1dfb, 0x3, 0x2, 0x2, 0x2, 0x1dfe, 
       0x1dff, 0x7, 0x24, 0x2, 0x2, 0x1dff, 0x3c1, 0x3, 0x2, 0x2, 0x2, 0x1e00, 
       0x1e03, 0x5, 0x29e, 0x150, 0x2, 0x1e01, 0x1e03, 0x7, 0x16e, 0x2, 
       0x2, 0x1e02, 0x1e00, 0x3, 0x2, 0x2, 0x2, 0x1e02, 0x1e01, 0x3, 0x2, 
       0x2, 0x2, 0x1e03, 0x3c3, 0x3, 0x2, 0x2, 0x2, 0x1e04, 0x1e05, 0x7, 
       0xb0, 0x2, 0x2, 0x1e05, 0x1e06, 0x7, 0x9, 0x2, 0x2, 0x1e06, 0x1e07, 
       0x5, 0x3f4, 0x1fb, 0x2, 0x1e07, 0x3c5, 0x3, 0x2, 0x2, 0x2, 0x1e08, 
       0x1e09, 0x7, 0x110, 0x2, 0x2, 0x1e09, 0x1e0a, 0x7, 0xdb, 0x2, 0x2, 
       0x1e0a, 0x3c7, 0x3, 0x2, 0x2, 0x2, 0x1e0b, 0x1e0c, 0x7, 0x110, 0x2, 
       0x2, 0x1e0c, 0x1e0d, 0x5, 0x2e8, 0x175, 0x2, 0x1e0d, 0x1e0e, 0x7, 
       0xdb, 0x2, 0x2, 0x1e0e, 0x3c9, 0x3, 0x2, 0x2, 0x2, 0x1e0f, 0x1e11, 
       0x9, 0x7d, 0x2, 0x2, 0x1e10, 0x1e0f, 0x3, 0x2, 0x2, 0x2, 0x1e10, 
       0x1e11, 0x3, 0x2, 0x2, 0x2, 0x1e11, 0x1e12, 0x3, 0x2, 0x2, 0x2, 0x1e12, 
       0x1e13, 0x5, 0x3cc, 0x1e7, 0x2, 0x1e13, 0x3cb, 0x3, 0x2, 0x2, 0x2, 
       0x1e14, 0x1e15, 0x5, 0x446, 0x224, 0x2, 0x1e15, 0x1e16, 0x5, 0x3d0, 
       0x1e9, 0x2, 0x1e16, 0x3cd, 0x3, 0x2, 0x2, 0x2, 0x1e17, 0x1e18, 0x7, 
       0x76, 0x2, 0x2, 0x1e18, 0x1e19, 0x5, 0x39e, 0x1d0, 0x2, 0x1e19, 0x3cf, 
       0x3, 0x2, 0x2, 0x2, 0x1e1a, 0x1e1c, 0x5, 0x384, 0x1c3, 0x2, 0x1e1b, 
       0x1e1d, 0x5, 0x3ce, 0x1e8, 0x2, 0x1e1c, 0x1e1b, 0x3, 0x2, 0x2, 0x2, 
       0x1e1c, 0x1e1d, 0x3, 0x2, 0x2, 0x2, 0x1e1d, 0x3d1, 0x3, 0x2, 0x2, 
       0x2, 0x1e1e, 0x1e1f, 0x7, 0x23, 0x2, 0x2, 0x1e1f, 0x1e20, 0x5, 0x414, 
       0x20b, 0x2, 0x1e20, 0x1e21, 0x7, 0x20, 0x2, 0x2, 0x1e21, 0x1e22, 
       0x5, 0x414, 0x20b, 0x2, 0x1e22, 0x1e23, 0x7, 0x24, 0x2, 0x2, 0x1e23, 
       0x3d3, 0x3, 0x2, 0x2, 0x2, 0x1e24, 0x1e29, 0x5, 0x424, 0x213, 0x2, 
       0x1e25, 0x1e26, 0x7, 0x20, 0x2, 0x2, 0x1e26, 0x1e28, 0x5, 0x424, 
       0x213, 0x2, 0x1e27, 0x1e25, 0x3, 0x2, 0x2, 0x2, 0x1e28, 0x1e2b, 0x3, 
       0x2, 0x2, 0x2, 0x1e29, 0x1e27, 0x3, 0x2, 0x2, 0x2, 0x1e29, 0x1e2a, 
       0x3, 0x2, 0x2, 0x2, 0x1e2a, 0x3d5, 0x3, 0x2, 0x2, 0x2, 0x1e2b, 0x1e29, 
       0x3, 0x2, 0x2, 0x2, 0x1e2c, 0x1e31, 0x5, 0x3d8, 0x1ed, 0x2, 0x1e2d, 
       0x1e2e, 0x7, 0x20, 0x2, 0x2, 0x1e2e, 0x1e30, 0x5, 0x3d8, 0x1ed, 0x2, 
       0x1e2f, 0x1e2d, 0x3, 0x2, 0x2, 0x2, 0x1e30, 0x1e33, 0x3, 0x2, 0x2, 
       0x2, 0x1e31, 0x1e2f, 0x3, 0x2, 0x2, 0x2, 0x1e31, 0x1e32, 0x3, 0x2, 
       0x2, 0x2, 0x1e32, 0x3d7, 0x3, 0x2, 0x2, 0x2, 0x1e33, 0x1e31, 0x3, 
       0x2, 0x2, 0x2, 0x1e34, 0x1e35, 0x5, 0x408, 0x205, 0x2, 0x1e35, 0x1e38, 
       0x7, 0x9, 0x2, 0x2, 0x1e36, 0x1e39, 0x5, 0x294, 0x14b, 0x2, 0x1e37, 
       0x1e39, 0x7, 0xae, 0x2, 0x2, 0x1e38, 0x1e36, 0x3, 0x2, 0x2, 0x2, 
       0x1e38, 0x1e37, 0x3, 0x2, 0x2, 0x2, 0x1e39, 0x3d9, 0x3, 0x2, 0x2, 
       0x2, 0x1e3a, 0x1e3b, 0x5, 0x2e6, 0x174, 0x2, 0x1e3b, 0x1e3c, 0x5, 
       0x39c, 0x1cf, 0x2, 0x1e3c, 0x3db, 0x3, 0x2, 0x2, 0x2, 0x1e3d, 0x1e3f, 
       0x7, 0x78, 0x2, 0x2, 0x1e3e, 0x1e40, 0x5, 0x3de, 0x1f0, 0x2, 0x1e3f, 
       0x1e3e, 0x3, 0x2, 0x2, 0x2, 0x1e40, 0x1e41, 0x3, 0x2, 0x2, 0x2, 0x1e41, 
       0x1e3f, 0x3, 0x2, 0x2, 0x2, 0x1e41, 0x1e42, 0x3, 0x2, 0x2, 0x2, 0x1e42, 
       0x3dd, 0x3, 0x2, 0x2, 0x2, 0x1e43, 0x1e44, 0x7, 0x263, 0x2, 0x2, 
       0x1e44, 0x1e45, 0x7, 0x5f, 0x2, 0x2, 0x1e45, 0x1e50, 0x5, 0x476, 
       0x23c, 0x2, 0x1e46, 0x1e48, 0x7, 0x1ac, 0x2, 0x2, 0x1e47, 0x1e46, 
       0x3, 0x2, 0x2, 0x2, 0x1e47, 0x1e48, 0x3, 0x2, 0x2, 0x2, 0x1e48, 0x1e49, 
       0x3, 0x2, 0x2, 0x2, 0x1e49, 0x1e4a, 0x7, 0xca, 0x2, 0x2, 0x1e4a, 
       0x1e4b, 0x7, 0x5f, 0x2, 0x2, 0x1e4b, 0x1e50, 0x5, 0x476, 0x23c, 0x2, 
       0x1e4c, 0x1e4d, 0x7, 0xd4, 0x2, 0x2, 0x1e4d, 0x1e4e, 0x7, 0x5f, 0x2, 
       0x2, 0x1e4e, 0x1e50, 0x5, 0x476, 0x23c, 0x2, 0x1e4f, 0x1e43, 0x3, 
       0x2, 0x2, 0x2, 0x1e4f, 0x1e47, 0x3, 0x2, 0x2, 0x2, 0x1e4f, 0x1e4c, 
       0x3, 0x2, 0x2, 0x2, 0x1e50, 0x3df, 0x3, 0x2, 0x2, 0x2, 0x1e51, 0x1e53, 
       0x7, 0x13d, 0x2, 0x2, 0x1e52, 0x1e54, 0x5, 0x3e2, 0x1f2, 0x2, 0x1e53, 
       0x1e52, 0x3, 0x2, 0x2, 0x2, 0x1e54, 0x1e55, 0x3, 0x2, 0x2, 0x2, 0x1e55, 
       0x1e53, 0x3, 0x2, 0x2, 0x2, 0x1e55, 0x1e56, 0x3, 0x2, 0x2, 0x2, 0x1e56, 
       0x3e1, 0x3, 0x2, 0x2, 0x2, 0x1e57, 0x1e58, 0x9, 0x7e, 0x2, 0x2, 0x1e58, 
       0x1e59, 0x7, 0x5f, 0x2, 0x2, 0x1e59, 0x1e5a, 0x5, 0x476, 0x23c, 0x2, 
       0x1e5a, 0x3e3, 0x3, 0x2, 0x2, 0x2, 0x1e5b, 0x1e60, 0x5, 0x3f4, 0x1fb, 
       0x2, 0x1e5c, 0x1e5d, 0x7, 0x20, 0x2, 0x2, 0x1e5d, 0x1e5f, 0x5, 0x3f4, 
       0x1fb, 0x2, 0x1e5e, 0x1e5c, 0x3, 0x2, 0x2, 0x2, 0x1e5f, 0x1e62, 0x3, 
       0x2, 0x2, 0x2, 0x1e60, 0x1e5e, 0x3, 0x2, 0x2, 0x2, 0x1e60, 0x1e61, 
       0x3, 0x2, 0x2, 0x2, 0x1e61, 0x3e5, 0x3, 0x2, 0x2, 0x2, 0x1e62, 0x1e60, 
       0x3, 0x2, 0x2, 0x2, 0x1e63, 0x1e68, 0x5, 0x3ea, 0x1f6, 0x2, 0x1e64, 
       0x1e65, 0x7, 0x20, 0x2, 0x2, 0x1e65, 0x1e67, 0x5, 0x3ea, 0x1f6, 0x2, 
       0x1e66, 0x1e64, 0x3, 0x2, 0x2, 0x2, 0x1e67, 0x1e6a, 0x3, 0x2, 0x2, 
       0x2, 0x1e68, 0x1e66, 0x3, 0x2, 0x2, 0x2, 0x1e68, 0x1e69, 0x3, 0x2, 
       0x2, 0x2, 0x1e69, 0x3e7, 0x3, 0x2, 0x2, 0x2, 0x1e6a, 0x1e68, 0x3, 
       0x2, 0x2, 0x2, 0x1e6b, 0x1e70, 0x5, 0x3ec, 0x1f7, 0x2, 0x1e6c, 0x1e6d, 
       0x7, 0x20, 0x2, 0x2, 0x1e6d, 0x1e6f, 0x5, 0x3ec, 0x1f7, 0x2, 0x1e6e, 
       0x1e6c, 0x3, 0x2, 0x2, 0x2, 0x1e6f, 0x1e72, 0x3, 0x2, 0x2, 0x2, 0x1e70, 
       0x1e6e, 0x3, 0x2, 0x2, 0x2, 0x1e70, 0x1e71, 0x3, 0x2, 0x2, 0x2, 0x1e71, 
       0x3e9, 0x3, 0x2, 0x2, 0x2, 0x1e72, 0x1e70, 0x3, 0x2, 0x2, 0x2, 0x1e73, 
       0x1e89, 0x5, 0x3f4, 0x1fb, 0x2, 0x1e74, 0x1e87, 0x7, 0x10f, 0x2, 
       0x2, 0x1e75, 0x1e78, 0x7, 0x5f, 0x2, 0x2, 0x1e76, 0x1e77, 0x6, 0x1f6, 
       0xc9, 0x2, 0x1e77, 0x1e79, 0x7, 0x1ba, 0x2, 0x2, 0x1e78, 0x1e76, 
       0x3, 0x2, 0x2, 0x2, 0x1e78, 0x1e79, 0x3, 0x2, 0x2, 0x2, 0x1e79, 0x1e7a, 
       0x3, 0x2, 0x2, 0x2, 0x1e7a, 0x1e88, 0x5, 0x476, 0x23c, 0x2, 0x1e7b, 
       0x1e7c, 0x6, 0x1f6, 0xca, 0x2, 0x1e7c, 0x1e7d, 0x7, 0x2a4, 0x2, 0x2, 
       0x1e7d, 0x1e85, 0x5, 0x48e, 0x248, 0x2, 0x1e7e, 0x1e7f, 0x7, 0x43, 
       0x2, 0x2, 0x1e7f, 0x1e84, 0x5, 0x478, 0x23d, 0x2, 0x1e80, 0x1e81, 
       0x6, 0x1f6, 0xcb, 0x2, 0x1e81, 0x1e82, 0x7, 0x5f, 0x2, 0x2, 0x1e82, 
       0x1e84, 0x5, 0x476, 0x23c, 0x2, 0x1e83, 0x1e7e, 0x3, 0x2, 0x2, 0x2, 
       0x1e83, 0x1e80, 0x3, 0x2, 0x2, 0x2, 0x1e84, 0x1e86, 0x3, 0x2, 0x2, 
       0x2, 0x1e85, 0x1e83, 0x3, 0x2, 0x2, 0x2, 0x1e85, 0x1e86, 0x3, 0x2, 
       0x2, 0x2, 0x1e86, 0x1e88, 0x3, 0x2, 0x2, 0x2, 0x1e87, 0x1e75, 0x3, 
       0x2, 0x2, 0x2, 0x1e87, 0x1e7b, 0x3, 0x2, 0x2, 0x2, 0x1e88, 0x1e8a, 
       0x3, 0x2, 0x2, 0x2, 0x1e89, 0x1e74, 0x3, 0x2, 0x2, 0x2, 0x1e89, 0x1e8a, 
       0x3, 0x2, 0x2, 0x2, 0x1e8a, 0x3eb, 0x3, 0x2, 0x2, 0x2, 0x1e8b, 0x1ea8, 
       0x5, 0x3f4, 0x1fb, 0x2, 0x1e8c, 0x1ea3, 0x7, 0x10f, 0x2, 0x2, 0x1e8d, 
       0x1e8e, 0x7, 0x2a4, 0x2, 0x2, 0x1e8e, 0x1e90, 0x5, 0x48e, 0x248, 
       0x2, 0x1e8f, 0x1e8d, 0x3, 0x2, 0x2, 0x2, 0x1e8f, 0x1e90, 0x3, 0x2, 
       0x2, 0x2, 0x1e90, 0x1e91, 0x3, 0x2, 0x2, 0x2, 0x1e91, 0x1e92, 0x7, 
       0x5f, 0x2, 0x2, 0x1e92, 0x1e95, 0x5, 0x476, 0x23c, 0x2, 0x1e93, 0x1e94, 
       0x7, 0x1ee, 0x2, 0x2, 0x1e94, 0x1e96, 0x5, 0x476, 0x23c, 0x2, 0x1e95, 
       0x1e93, 0x3, 0x2, 0x2, 0x2, 0x1e95, 0x1e96, 0x3, 0x2, 0x2, 0x2, 0x1e96, 
       0x1e98, 0x3, 0x2, 0x2, 0x2, 0x1e97, 0x1e99, 0x5, 0x3ee, 0x1f8, 0x2, 
       0x1e98, 0x1e97, 0x3, 0x2, 0x2, 0x2, 0x1e98, 0x1e99, 0x3, 0x2, 0x2, 
       0x2, 0x1e99, 0x1ea4, 0x3, 0x2, 0x2, 0x2, 0x1e9a, 0x1e9b, 0x7, 0x2a4, 
       0x2, 0x2, 0x1e9b, 0x1ea1, 0x5, 0x48e, 0x248, 0x2, 0x1e9c, 0x1e9d, 
       0x7, 0x43, 0x2, 0x2, 0x1e9d, 0x1e9f, 0x5, 0x478, 0x23d, 0x2, 0x1e9e, 
       0x1ea0, 0x5, 0x3ee, 0x1f8, 0x2, 0x1e9f, 0x1e9e, 0x3, 0x2, 0x2, 0x2, 
       0x1e9f, 0x1ea0, 0x3, 0x2, 0x2, 0x2, 0x1ea0, 0x1ea2, 0x3, 0x2, 0x2, 
       0x2, 0x1ea1, 0x1e9c, 0x3, 0x2, 0x2, 0x2, 0x1ea1, 0x1ea2, 0x3, 0x2, 
       0x2, 0x2, 0x1ea2, 0x1ea4, 0x3, 0x2, 0x2, 0x2, 0x1ea3, 0x1e8f, 0x3, 
       0x2, 0x2, 0x2, 0x1ea3, 0x1e9a, 0x3, 0x2, 0x2, 0x2, 0x1ea3, 0x1ea4, 
       0x3, 0x2, 0x2, 0x2, 0x1ea4, 0x1ea9, 0x3, 0x2, 0x2, 0x2, 0x1ea5, 0x1ea7, 
       0x5, 0x3f0, 0x1f9, 0x2, 0x1ea6, 0x1ea5, 0x3, 0x2, 0x2, 0x2, 0x1ea6, 
       0x1ea7, 0x3, 0x2, 0x2, 0x2, 0x1ea7, 0x1ea9, 0x3, 0x2, 0x2, 0x2, 0x1ea8, 
       0x1e8c, 0x3, 0x2, 0x2, 0x2, 0x1ea8, 0x1ea6, 0x3, 0x2, 0x2, 0x2, 0x1ea9, 
       0x3ed, 0x3, 0x2, 0x2, 0x2, 0x1eaa, 0x1eab, 0x7, 0x2f8, 0x2, 0x2, 
       0x1eab, 0x1eac, 0x7, 0x96, 0x2, 0x2, 0x1eac, 0x1ead, 0x7, 0x1ba, 
       0x2, 0x2, 0x1ead, 0x3ef, 0x3, 0x2, 0x2, 0x2, 0x1eae, 0x1eaf, 0x7, 
       0xbb, 0x2, 0x2, 0x1eaf, 0x1eb0, 0x7, 0x2f9, 0x2, 0x2, 0x1eb0, 0x1eb1, 
       0x7, 0x1ba, 0x2, 0x2, 0x1eb1, 0x3f1, 0x3, 0x2, 0x2, 0x2, 0x1eb2, 
       0x1eb3, 0x7, 0x1ee, 0x2, 0x2, 0x1eb3, 0x1eb4, 0x5, 0x476, 0x23c, 
       0x2, 0x1eb4, 0x3f3, 0x3, 0x2, 0x2, 0x2, 0x1eb5, 0x1eb9, 0x5, 0x48e, 
       0x248, 0x2, 0x1eb6, 0x1eb7, 0x7, 0x2a, 0x2, 0x2, 0x1eb7, 0x1eba, 
       0x5, 0x48e, 0x248, 0x2, 0x1eb8, 0x1eba, 0x7, 0x2b, 0x2, 0x2, 0x1eb9, 
       0x1eb6, 0x3, 0x2, 0x2, 0x2, 0x1eb9, 0x1eb8, 0x3, 0x2, 0x2, 0x2, 0x1eb9, 
       0x1eba, 0x3, 0x2, 0x2, 0x2, 0x1eba, 0x1ec0, 0x3, 0x2, 0x2, 0x2, 0x1ebb, 
       0x1ebd, 0x7, 0x99, 0x2, 0x2, 0x1ebc, 0x1ebe, 0x5, 0x496, 0x24c, 0x2, 
       0x1ebd, 0x1ebc, 0x3, 0x2, 0x2, 0x2, 0x1ebd, 0x1ebe, 0x3, 0x2, 0x2, 
       0x2, 0x1ebe, 0x1ec0, 0x3, 0x2, 0x2, 0x2, 0x1ebf, 0x1eb5, 0x3, 0x2, 
       0x2, 0x2, 0x1ebf, 0x1ebb, 0x3, 0x2, 0x2, 0x2, 0x1ec0, 0x3f5, 0x3, 
       0x2, 0x2, 0x2, 0x1ec1, 0x1ec2, 0x7, 0x13a, 0x2, 0x2, 0x1ec2, 0x1ec3, 
       0x5, 0x474, 0x23b, 0x2, 0x1ec3, 0x3f7, 0x3, 0x2, 0x2, 0x2, 0x1ec4, 
       0x1ec7, 0x5, 0x3f6, 0x1fc, 0x2, 0x1ec5, 0x1ec7, 0x5, 0x162, 0xb2, 
       0x2, 0x1ec6, 0x1ec4, 0x3, 0x2, 0x2, 0x2, 0x1ec6, 0x1ec5, 0x3, 0x2, 
       0x2, 0x2, 0x1ec7, 0x3f9, 0x3, 0x2, 0x2, 0x2, 0x1ec8, 0x1ec9, 0x6, 
       0x1fe, 0xcc, 0x2, 0x1ec9, 0x1eca, 0x9, 0x7f, 0x2, 0x2, 0x1eca, 0x3fb, 
       0x3, 0x2, 0x2, 0x2, 0x1ecb, 0x1ecc, 0x9, 0x80, 0x2, 0x2, 0x1ecc, 
       0x3fd, 0x3, 0x2, 0x2, 0x2, 0x1ecd, 0x1ece, 0x6, 0x200, 0xcd, 0x2, 
       0x1ece, 0x1ecf, 0x7, 0x1b9, 0x2, 0x2, 0x1ecf, 0x1ed0, 0x5, 0x45e, 
       0x230, 0x2, 0x1ed0, 0x3ff, 0x3, 0x2, 0x2, 0x2, 0x1ed1, 0x1ed7, 0x5, 
       0x464, 0x233, 0x2, 0x1ed2, 0x1ed4, 0x5, 0x460, 0x231, 0x2, 0x1ed3, 
       0x1ed5, 0x5, 0x464, 0x233, 0x2, 0x1ed4, 0x1ed3, 0x3, 0x2, 0x2, 0x2, 
       0x1ed4, 0x1ed5, 0x3, 0x2, 0x2, 0x2, 0x1ed5, 0x1ed7, 0x3, 0x2, 0x2, 
       0x2, 0x1ed6, 0x1ed1, 0x3, 0x2, 0x2, 0x2, 0x1ed6, 0x1ed2, 0x3, 0x2, 
       0x2, 0x2, 0x1ed7, 0x401, 0x3, 0x2, 0x2, 0x2, 0x1ed8, 0x1ed9, 0x6, 
       0x202, 0xce, 0x2, 0x1ed9, 0x1edd, 0x5, 0x45a, 0x22e, 0x2, 0x1eda, 
       0x1edb, 0x6, 0x202, 0xcf, 0x2, 0x1edb, 0x1edd, 0x5, 0x400, 0x201, 
       0x2, 0x1edc, 0x1ed8, 0x3, 0x2, 0x2, 0x2, 0x1edc, 0x1eda, 0x3, 0x2, 
       0x2, 0x2, 0x1edd, 0x403, 0x3, 0x2, 0x2, 0x2, 0x1ede, 0x1edf, 0x5, 
       0x45a, 0x22e, 0x2, 0x1edf, 0x405, 0x3, 0x2, 0x2, 0x2, 0x1ee0, 0x1ee1, 
       0x7, 0x23, 0x2, 0x2, 0x1ee1, 0x1ee6, 0x5, 0x404, 0x203, 0x2, 0x1ee2, 
       0x1ee3, 0x7, 0x20, 0x2, 0x2, 0x1ee3, 0x1ee5, 0x5, 0x404, 0x203, 0x2, 
       0x1ee4, 0x1ee2, 0x3, 0x2, 0x2, 0x2, 0x1ee5, 0x1ee8, 0x3, 0x2, 0x2, 
       0x2, 0x1ee6, 0x1ee4, 0x3, 0x2, 0x2, 0x2, 0x1ee6, 0x1ee7, 0x3, 0x2, 
       0x2, 0x2, 0x1ee7, 0x1ee9, 0x3, 0x2, 0x2, 0x2, 0x1ee8, 0x1ee6, 0x3, 
       0x2, 0x2, 0x2, 0x1ee9, 0x1eea, 0x7, 0x24, 0x2, 0x2, 0x1eea, 0x407, 
       0x3, 0x2, 0x2, 0x2, 0x1eeb, 0x1eec, 0x5, 0x400, 0x201, 0x2, 0x1eec, 
       0x409, 0x3, 0x2, 0x2, 0x2, 0x1eed, 0x1ef0, 0x5, 0x408, 0x205, 0x2, 
       0x1eee, 0x1ef0, 0x5, 0x410, 0x209, 0x2, 0x1eef, 0x1eed, 0x3, 0x2, 
       0x2, 0x2, 0x1eef, 0x1eee, 0x3, 0x2, 0x2, 0x2, 0x1ef0, 0x40b, 0x3, 
       0x2, 0x2, 0x2, 0x1ef1, 0x1ef2, 0x5, 0x45a, 0x22e, 0x2, 0x1ef2, 0x40d, 
       0x3, 0x2, 0x2, 0x2, 0x1ef3, 0x1ef4, 0x5, 0x400, 0x201, 0x2, 0x1ef4, 
       0x40f, 0x3, 0x2, 0x2, 0x2, 0x1ef5, 0x1ef6, 0x5, 0x45a, 0x22e, 0x2, 
       0x1ef6, 0x1efa, 0x7, 0x1f, 0x2, 0x2, 0x1ef7, 0x1ef8, 0x5, 0x45a, 
       0x22e, 0x2, 0x1ef8, 0x1ef9, 0x7, 0x1f, 0x2, 0x2, 0x1ef9, 0x1efb, 
       0x3, 0x2, 0x2, 0x2, 0x1efa, 0x1ef7, 0x3, 0x2, 0x2, 0x2, 0x1efa, 0x1efb, 
       0x3, 0x2, 0x2, 0x2, 0x1efb, 0x1efc, 0x3, 0x2, 0x2, 0x2, 0x1efc, 0x1efd, 
       0x7, 0x13, 0x2, 0x2, 0x1efd, 0x411, 0x3, 0x2, 0x2, 0x2, 0x1efe, 0x1eff, 
       0x5, 0x45a, 0x22e, 0x2, 0x1eff, 0x413, 0x3, 0x2, 0x2, 0x2, 0x1f00, 
       0x1f01, 0x5, 0x45a, 0x22e, 0x2, 0x1f01, 0x415, 0x3, 0x2, 0x2, 0x2, 
       0x1f02, 0x1f03, 0x5, 0x460, 0x231, 0x2, 0x1f03, 0x417, 0x3, 0x2, 
       0x2, 0x2, 0x1f04, 0x1f05, 0x5, 0x460, 0x231, 0x2, 0x1f05, 0x419, 
       0x3, 0x2, 0x2, 0x2, 0x1f06, 0x1f07, 0x5, 0x460, 0x231, 0x2, 0x1f07, 
       0x41b, 0x3, 0x2, 0x2, 0x2, 0x1f08, 0x1f09, 0x5, 0x460, 0x231, 0x2, 
       0x1f09, 0x41d, 0x3, 0x2, 0x2, 0x2, 0x1f0a, 0x1f0b, 0x5, 0x460, 0x231, 
       0x2, 0x1f0b, 0x41f, 0x3, 0x2, 0x2, 0x2, 0x1f0c, 0x1f0d, 0x5, 0x460, 
       0x231, 0x2, 0x1f0d, 0x421, 0x3, 0x2, 0x2, 0x2, 0x1f0e, 0x1f11, 0x5, 
       0x460, 0x231, 0x2, 0x1f0f, 0x1f11, 0x5, 0x464, 0x233, 0x2, 0x1f10, 
       0x1f0e, 0x3, 0x2, 0x2, 0x2, 0x1f10, 0x1f0f, 0x3, 0x2, 0x2, 0x2, 0x1f11, 
       0x423, 0x3, 0x2, 0x2, 0x2, 0x1f12, 0x1f15, 0x5, 0x460, 0x231, 0x2, 
       0x1f13, 0x1f15, 0x5, 0x464, 0x233, 0x2, 0x1f14, 0x1f12, 0x3, 0x2, 
       0x2, 0x2, 0x1f14, 0x1f13, 0x3, 0x2, 0x2, 0x2, 0x1f15, 0x425, 0x3, 
       0x2, 0x2, 0x2, 0x1f16, 0x1f17, 0x5, 0x45a, 0x22e, 0x2, 0x1f17, 0x427, 
       0x3, 0x2, 0x2, 0x2, 0x1f18, 0x1f19, 0x5, 0x45a, 0x22e, 0x2, 0x1f19, 
       0x429, 0x3, 0x2, 0x2, 0x2, 0x1f1a, 0x1f1b, 0x5, 0x45a, 0x22e, 0x2, 
       0x1f1b, 0x42b, 0x3, 0x2, 0x2, 0x2, 0x1f1c, 0x1f1d, 0x5, 0x45a, 0x22e, 
       0x2, 0x1f1d, 0x42d, 0x3, 0x2, 0x2, 0x2, 0x1f1e, 0x1f1f, 0x5, 0x460, 
       0x231, 0x2, 0x1f1f, 0x42f, 0x3, 0x2, 0x2, 0x2, 0x1f20, 0x1f21, 0x5, 
       0x460, 0x231, 0x2, 0x1f21, 0x431, 0x3, 0x2, 0x2, 0x2, 0x1f22, 0x1f23, 
       0x5, 0x45a, 0x22e, 0x2, 0x1f23, 0x433, 0x3, 0x2, 0x2, 0x2, 0x1f24, 
       0x1f25, 0x5, 0x48e, 0x248, 0x2, 0x1f25, 0x435, 0x3, 0x2, 0x2, 0x2, 
       0x1f26, 0x1f27, 0x5, 0x48e, 0x248, 0x2, 0x1f27, 0x437, 0x3, 0x2, 
       0x2, 0x2, 0x1f28, 0x1f29, 0x5, 0x48e, 0x248, 0x2, 0x1f29, 0x439, 
       0x3, 0x2, 0x2, 0x2, 0x1f2a, 0x1f2d, 0x5, 0x460, 0x231, 0x2, 0x1f2b, 
       0x1f2d, 0x5, 0x464, 0x233, 0x2, 0x1f2c, 0x1f2a, 0x3, 0x2, 0x2, 0x2, 
       0x1f2c, 0x1f2b, 0x3, 0x2, 0x2, 0x2, 0x1f2d, 0x43b, 0x3, 0x2, 0x2, 
       0x2, 0x1f2e, 0x1f2f, 0x5, 0x414, 0x20b, 0x2, 0x1f2f, 0x1f30, 0x5, 
       0x464, 0x233, 0x2, 0x1f30, 0x43d, 0x3, 0x2, 0x2, 0x2, 0x1f31, 0x1f39, 
       0x5, 0x45a, 0x22e, 0x2, 0x1f32, 0x1f33, 0x7, 0x1f, 0x2, 0x2, 0x1f33, 
       0x1f3a, 0x7, 0x13, 0x2, 0x2, 0x1f34, 0x1f37, 0x5, 0x464, 0x233, 0x2, 
       0x1f35, 0x1f36, 0x7, 0x1f, 0x2, 0x2, 0x1f36, 0x1f38, 0x7, 0x13, 0x2, 
       0x2, 0x1f37, 0x1f35, 0x3, 0x2, 0x2, 0x2, 0x1f37, 0x1f38, 0x3, 0x2, 
       0x2, 0x2, 0x1f38, 0x1f3a, 0x3, 0x2, 0x2, 0x2, 0x1f39, 0x1f32, 0x3, 
       0x2, 0x2, 0x2, 0x1f39, 0x1f34, 0x3, 0x2, 0x2, 0x2, 0x1f39, 0x1f3a, 
       0x3, 0x2, 0x2, 0x2, 0x1f3a, 0x43f, 0x3, 0x2, 0x2, 0x2, 0x1f3b, 0x1f3e, 
       0x5, 0x460, 0x231, 0x2, 0x1f3c, 0x1f3e, 0x5, 0x464, 0x233, 0x2, 0x1f3d, 
       0x1f3b, 0x3, 0x2, 0x2, 0x2, 0x1f3d, 0x1f3c, 0x3, 0x2, 0x2, 0x2, 0x1f3e, 
       0x441, 0x3, 0x2, 0x2, 0x2, 0x1f3f, 0x1f44, 0x5, 0x440, 0x221, 0x2, 
       0x1f40, 0x1f41, 0x7, 0x20, 0x2, 0x2, 0x1f41, 0x1f43, 0x5, 0x440, 
       0x221, 0x2, 0x1f42, 0x1f40, 0x3, 0x2, 0x2, 0x2, 0x1f43, 0x1f46, 0x3, 
       0x2, 0x2, 0x2, 0x1f44, 0x1f42, 0x3, 0x2, 0x2, 0x2, 0x1f44, 0x1f45, 
       0x3, 0x2, 0x2, 0x2, 0x1f45, 0x443, 0x3, 0x2, 0x2, 0x2, 0x1f46, 0x1f44, 
       0x3, 0x2, 0x2, 0x2, 0x1f47, 0x1f4c, 0x5, 0x43e, 0x220, 0x2, 0x1f48, 
       0x1f49, 0x7, 0x20, 0x2, 0x2, 0x1f49, 0x1f4b, 0x5, 0x43e, 0x220, 0x2, 
       0x1f4a, 0x1f48, 0x3, 0x2, 0x2, 0x2, 0x1f4b, 0x1f4e, 0x3, 0x2, 0x2, 
       0x2, 0x1f4c, 0x1f4a, 0x3, 0x2, 0x2, 0x2, 0x1f4c, 0x1f4d, 0x3, 0x2, 
       0x2, 0x2, 0x1f4d, 0x445, 0x3, 0x2, 0x2, 0x2, 0x1f4e, 0x1f4c, 0x3, 
       0x2, 0x2, 0x2, 0x1f4f, 0x1f50, 0x5, 0x45a, 0x22e, 0x2, 0x1f50, 0x447, 
       0x3, 0x2, 0x2, 0x2, 0x1f51, 0x1f54, 0x5, 0x458, 0x22d, 0x2, 0x1f52, 
       0x1f54, 0x5, 0x4a6, 0x254, 0x2, 0x1f53, 0x1f51, 0x3, 0x2, 0x2, 0x2, 
       0x1f53, 0x1f52, 0x3, 0x2, 0x2, 0x2, 0x1f54, 0x449, 0x3, 0x2, 0x2, 
       0x2, 0x1f55, 0x1f56, 0x5, 0x448, 0x225, 0x2, 0x1f56, 0x44b, 0x3, 
       0x2, 0x2, 0x2, 0x1f57, 0x1f5a, 0x5, 0x458, 0x22d, 0x2, 0x1f58, 0x1f5a, 
       0x5, 0x4ac, 0x257, 0x2, 0x1f59, 0x1f57, 0x3, 0x2, 0x2, 0x2, 0x1f59, 
       0x1f58, 0x3, 0x2, 0x2, 0x2, 0x1f5a, 0x44d, 0x3, 0x2, 0x2, 0x2, 0x1f5b, 
       0x1f5c, 0x5, 0x44c, 0x227, 0x2, 0x1f5c, 0x44f, 0x3, 0x2, 0x2, 0x2, 
       0x1f5d, 0x1f5e, 0x5, 0x45a, 0x22e, 0x2, 0x1f5e, 0x451, 0x3, 0x2, 
       0x2, 0x2, 0x1f5f, 0x1f60, 0x5, 0x474, 0x23b, 0x2, 0x1f60, 0x453, 
       0x3, 0x2, 0x2, 0x2, 0x1f61, 0x1f62, 0x5, 0x45a, 0x22e, 0x2, 0x1f62, 
       0x455, 0x3, 0x2, 0x2, 0x2, 0x1f63, 0x1f64, 0x5, 0x45a, 0x22e, 0x2, 
       0x1f64, 0x457, 0x3, 0x2, 0x2, 0x2, 0x1f65, 0x1f69, 0x9, 0x81, 0x2, 
       0x2, 0x1f66, 0x1f67, 0x6, 0x22d, 0xd0, 0x2, 0x1f67, 0x1f69, 0x7, 
       0x305, 0x2, 0x2, 0x1f68, 0x1f65, 0x3, 0x2, 0x2, 0x2, 0x1f68, 0x1f66, 
       0x3, 0x2, 0x2, 0x2, 0x1f69, 0x459, 0x3, 0x2, 0x2, 0x2, 0x1f6a, 0x1f6d, 
       0x5, 0x458, 0x22d, 0x2, 0x1f6b, 0x1f6d, 0x5, 0x4a0, 0x251, 0x2, 0x1f6c, 
       0x1f6a, 0x3, 0x2, 0x2, 0x2, 0x1f6c, 0x1f6b, 0x3, 0x2, 0x2, 0x2, 0x1f6d, 
       0x45b, 0x3, 0x2, 0x2, 0x2, 0x1f6e, 0x1f73, 0x5, 0x45a, 0x22e, 0x2, 
       0x1f6f, 0x1f70, 0x7, 0x20, 0x2, 0x2, 0x1f70, 0x1f72, 0x5, 0x45a, 
       0x22e, 0x2, 0x1f71, 0x1f6f, 0x3, 0x2, 0x2, 0x2, 0x1f72, 0x1f75, 0x3, 
       0x2, 0x2, 0x2, 0x1f73, 0x1f71, 0x3, 0x2, 0x2, 0x2, 0x1f73, 0x1f74, 
       0x3, 0x2, 0x2, 0x2, 0x1f74, 0x45d, 0x3, 0x2, 0x2, 0x2, 0x1f75, 0x1f73, 
       0x3, 0x2, 0x2, 0x2, 0x1f76, 0x1f77, 0x7, 0x23, 0x2, 0x2, 0x1f77, 
       0x1f78, 0x5, 0x45c, 0x22f, 0x2, 0x1f78, 0x1f79, 0x7, 0x24, 0x2, 0x2, 
       0x1f79, 0x45f, 0x3, 0x2, 0x2, 0x2, 0x1f7a, 0x1f7c, 0x5, 0x45a, 0x22e, 
       0x2, 0x1f7b, 0x1f7d, 0x5, 0x464, 0x233, 0x2, 0x1f7c, 0x1f7b, 0x3, 
       0x2, 0x2, 0x2, 0x1f7c, 0x1f7d, 0x3, 0x2, 0x2, 0x2, 0x1f7d, 0x461, 
       0x3, 0x2, 0x2, 0x2, 0x1f7e, 0x1f83, 0x5, 0x45a, 0x22e, 0x2, 0x1f7f, 
       0x1f81, 0x5, 0x464, 0x233, 0x2, 0x1f80, 0x1f82, 0x5, 0x464, 0x233, 
       0x2, 0x1f81, 0x1f80, 0x3, 0x2, 0x2, 0x2, 0x1f81, 0x1f82, 0x3, 0x2, 
       0x2, 0x2, 0x1f82, 0x1f84, 0x3, 0x2, 0x2, 0x2, 0x1f83, 0x1f7f, 0x3, 
       0x2, 0x2, 0x2, 0x1f83, 0x1f84, 0x3, 0x2, 0x2, 0x2, 0x1f84, 0x1f8a, 
       0x3, 0x2, 0x2, 0x2, 0x1f85, 0x1f86, 0x6, 0x232, 0xd1, 0x2, 0x1f86, 
       0x1f87, 0x5, 0x464, 0x233, 0x2, 0x1f87, 0x1f88, 0x5, 0x464, 0x233, 
       0x2, 0x1f88, 0x1f8a, 0x3, 0x2, 0x2, 0x2, 0x1f89, 0x1f7e, 0x3, 0x2, 
       0x2, 0x2, 0x1f89, 0x1f85, 0x3, 0x2, 0x2, 0x2, 0x1f8a, 0x463, 0x3, 
       0x2, 0x2, 0x2, 0x1f8b, 0x1f8c, 0x7, 0x1f, 0x2, 0x2, 0x1f8c, 0x1f8d, 
       0x5, 0x45a, 0x22e, 0x2, 0x1f8d, 0x465, 0x3, 0x2, 0x2, 0x2, 0x1f8e, 
       0x1f8f, 0x9, 0x82, 0x2, 0x2, 0x1f8f, 0x467, 0x3, 0x2, 0x2, 0x2, 0x1f90, 
       0x1f91, 0x9, 0x83, 0x2, 0x2, 0x1f91, 0x469, 0x3, 0x2, 0x2, 0x2, 0x1f92, 
       0x1f93, 0x9, 0x84, 0x2, 0x2, 0x1f93, 0x46b, 0x3, 0x2, 0x2, 0x2, 0x1f94, 
       0x1f9a, 0x7, 0x6, 0x2, 0x2, 0x1f95, 0x1f96, 0x6, 0x237, 0xd2, 0x2, 
       0x1f96, 0x1f9a, 0x7, 0x2f, 0x2, 0x2, 0x1f97, 0x1f9a, 0x7, 0x8, 0x2, 
       0x2, 0x1f98, 0x1f9a, 0x7, 0x7, 0x2, 0x2, 0x1f99, 0x1f94, 0x3, 0x2, 
       0x2, 0x2, 0x1f99, 0x1f95, 0x3, 0x2, 0x2, 0x2, 0x1f99, 0x1f97, 0x3, 
       0x2, 0x2, 0x2, 0x1f99, 0x1f98, 0x3, 0x2, 0x2, 0x2, 0x1f9a, 0x46d, 
       0x3, 0x2, 0x2, 0x2, 0x1f9b, 0x1fa5, 0x5, 0x47a, 0x23e, 0x2, 0x1f9c, 
       0x1fa5, 0x5, 0x480, 0x241, 0x2, 0x1f9d, 0x1fa5, 0x5, 0x486, 0x244, 
       0x2, 0x1f9e, 0x1fa5, 0x5, 0x484, 0x243, 0x2, 0x1f9f, 0x1fa5, 0x5, 
       0x482, 0x242, 0x2, 0x1fa0, 0x1fa2, 0x7, 0x301, 0x2, 0x2, 0x1fa1, 
       0x1fa0, 0x3, 0x2, 0x2, 0x2, 0x1fa1, 0x1fa2, 0x3, 0x2, 0x2, 0x2, 0x1fa2, 
       0x1fa3, 0x3, 0x2, 0x2, 0x2, 0x1fa3, 0x1fa5, 0x9, 0x85, 0x2, 0x2, 
       0x1fa4, 0x1f9b, 0x3, 0x2, 0x2, 0x2, 0x1fa4, 0x1f9c, 0x3, 0x2, 0x2, 
       0x2, 0x1fa4, 0x1f9d, 0x3, 0x2, 0x2, 0x2, 0x1fa4, 0x1f9e, 0x3, 0x2, 
       0x2, 0x2, 0x1fa4, 0x1f9f, 0x3, 0x2, 0x2, 0x2, 0x1fa4, 0x1fa1, 0x3, 
       0x2, 0x2, 0x2, 0x1fa5, 0x46f, 0x3, 0x2, 0x2, 0x2, 0x1fa6, 0x1fac, 
       0x5, 0x46e, 0x238, 0x2, 0x1fa7, 0x1fa8, 0x7, 0x11, 0x2, 0x2, 0x1fa8, 
       0x1fac, 0x5, 0x466, 0x234, 0x2, 0x1fa9, 0x1faa, 0x7, 0x12, 0x2, 0x2, 
       0x1faa, 0x1fac, 0x5, 0x466, 0x234, 0x2, 0x1fab, 0x1fa6, 0x3, 0x2, 
       0x2, 0x2, 0x1fab, 0x1fa7, 0x3, 0x2, 0x2, 0x2, 0x1fab, 0x1fa9, 0x3, 
       0x2, 0x2, 0x2, 0x1fac, 0x471, 0x3, 0x2, 0x2, 0x2, 0x1fad, 0x1fae, 
       0x7, 0x23, 0x2, 0x2, 0x1fae, 0x1fb3, 0x5, 0x476, 0x23c, 0x2, 0x1faf, 
       0x1fb0, 0x7, 0x20, 0x2, 0x2, 0x1fb0, 0x1fb2, 0x5, 0x476, 0x23c, 0x2, 
       0x1fb1, 0x1faf, 0x3, 0x2, 0x2, 0x2, 0x1fb2, 0x1fb5, 0x3, 0x2, 0x2, 
       0x2, 0x1fb3, 0x1fb1, 0x3, 0x2, 0x2, 0x2, 0x1fb3, 0x1fb4, 0x3, 0x2, 
       0x2, 0x2, 0x1fb4, 0x1fb6, 0x3, 0x2, 0x2, 0x2, 0x1fb5, 0x1fb3, 0x3, 
       0x2, 0x2, 0x2, 0x1fb6, 0x1fb7, 0x7, 0x24, 0x2, 0x2, 0x1fb7, 0x473, 
       0x3, 0x2, 0x2, 0x2, 0x1fb8, 0x1fbc, 0x7, 0x306, 0x2, 0x2, 0x1fb9, 
       0x1fba, 0x6, 0x23b, 0xd3, 0x2, 0x1fba, 0x1fbc, 0x7, 0x305, 0x2, 0x2, 
       0x1fbb, 0x1fb8, 0x3, 0x2, 0x2, 0x2, 0x1fbb, 0x1fb9, 0x3, 0x2, 0x2, 
       0x2, 0x1fbc, 0x475, 0x3, 0x2, 0x2, 0x2, 0x1fbd, 0x1fc1, 0x5, 0x474, 
       0x23b, 0x2, 0x1fbe, 0x1fc1, 0x7, 0x2f, 0x2, 0x2, 0x1fbf, 0x1fc1, 
       0x7, 0x30, 0x2, 0x2, 0x1fc0, 0x1fbd, 0x3, 0x2, 0x2, 0x2, 0x1fc0, 
       0x1fbe, 0x3, 0x2, 0x2, 0x2, 0x1fc0, 0x1fbf, 0x3, 0x2, 0x2, 0x2, 0x1fc1, 
       0x477, 0x3, 0x2, 0x2, 0x2, 0x1fc2, 0x1fc6, 0x5, 0x474, 0x23b, 0x2, 
       0x1fc3, 0x1fc4, 0x6, 0x23d, 0xd4, 0x2, 0x1fc4, 0x1fc6, 0x7, 0x2f, 
       0x2, 0x2, 0x1fc5, 0x1fc2, 0x3, 0x2, 0x2, 0x2, 0x1fc5, 0x1fc3, 0x3, 
       0x2, 0x2, 0x2, 0x1fc6, 0x479, 0x3, 0x2, 0x2, 0x2, 0x1fc7, 0x1fc9, 
       0x7, 0x301, 0x2, 0x2, 0x1fc8, 0x1fc7, 0x3, 0x2, 0x2, 0x2, 0x1fc8, 
       0x1fc9, 0x3, 0x2, 0x2, 0x2, 0x1fc9, 0x1fca, 0x3, 0x2, 0x2, 0x2, 0x1fca, 
       0x1fcd, 0x5, 0x474, 0x23b, 0x2, 0x1fcb, 0x1fcd, 0x7, 0x303, 0x2, 
       0x2, 0x1fcc, 0x1fc8, 0x3, 0x2, 0x2, 0x2, 0x1fcc, 0x1fcb, 0x3, 0x2, 
       0x2, 0x2, 0x1fcd, 0x1fd1, 0x3, 0x2, 0x2, 0x2, 0x1fce, 0x1fd0, 0x5, 
       0x474, 0x23b, 0x2, 0x1fcf, 0x1fce, 0x3, 0x2, 0x2, 0x2, 0x1fd0, 0x1fd3, 
       0x3, 0x2, 0x2, 0x2, 0x1fd1, 0x1fcf, 0x3, 0x2, 0x2, 0x2, 0x1fd1, 0x1fd2, 
       0x3, 0x2, 0x2, 0x2, 0x1fd2, 0x47b, 0x3, 0x2, 0x2, 0x2, 0x1fd3, 0x1fd1, 
       0x3, 0x2, 0x2, 0x2, 0x1fd4, 0x1fd5, 0x5, 0x474, 0x23b, 0x2, 0x1fd5, 
       0x47d, 0x3, 0x2, 0x2, 0x2, 0x1fd6, 0x1fdb, 0x5, 0x474, 0x23b, 0x2, 
       0x1fd7, 0x1fd8, 0x7, 0x20, 0x2, 0x2, 0x1fd8, 0x1fda, 0x5, 0x474, 
       0x23b, 0x2, 0x1fd9, 0x1fd7, 0x3, 0x2, 0x2, 0x2, 0x1fda, 0x1fdd, 0x3, 
       0x2, 0x2, 0x2, 0x1fdb, 0x1fd9, 0x3, 0x2, 0x2, 0x2, 0x1fdb, 0x1fdc, 
       0x3, 0x2, 0x2, 0x2, 0x1fdc, 0x47f, 0x3, 0x2, 0x2, 0x2, 0x1fdd, 0x1fdb, 
       0x3, 0x2, 0x2, 0x2, 0x1fde, 0x1fdf, 0x9, 0x84, 0x2, 0x2, 0x1fdf, 
       0x481, 0x3, 0x2, 0x2, 0x2, 0x1fe0, 0x1fe1, 0x9, 0x86, 0x2, 0x2, 0x1fe1, 
       0x483, 0x3, 0x2, 0x2, 0x2, 0x1fe2, 0x1fe3, 0x9, 0x87, 0x2, 0x2, 0x1fe3, 
       0x485, 0x3, 0x2, 0x2, 0x2, 0x1fe4, 0x1fe5, 0x7, 0xa4, 0x2, 0x2, 0x1fe5, 
       0x1feb, 0x7, 0x306, 0x2, 0x2, 0x1fe6, 0x1fe7, 0x7, 0x26a, 0x2, 0x2, 
       0x1fe7, 0x1feb, 0x7, 0x306, 0x2, 0x2, 0x1fe8, 0x1fe9, 0x7, 0x267, 
       0x2, 0x2, 0x1fe9, 0x1feb, 0x7, 0x306, 0x2, 0x2, 0x1fea, 0x1fe4, 0x3, 
       0x2, 0x2, 0x2, 0x1fea, 0x1fe6, 0x3, 0x2, 0x2, 0x2, 0x1fea, 0x1fe8, 
       0x3, 0x2, 0x2, 0x2, 0x1feb, 0x487, 0x3, 0x2, 0x2, 0x2, 0x1fec, 0x1fef, 
       0x5, 0x38e, 0x1c8, 0x2, 0x1fed, 0x1fef, 0x5, 0x48c, 0x247, 0x2, 0x1fee, 
       0x1fec, 0x3, 0x2, 0x2, 0x2, 0x1fee, 0x1fed, 0x3, 0x2, 0x2, 0x2, 0x1fef, 
       0x489, 0x3, 0x2, 0x2, 0x2, 0x1ff0, 0x1ff1, 0x5, 0x48c, 0x247, 0x2, 
       0x1ff1, 0x48b, 0x3, 0x2, 0x2, 0x2, 0x1ff2, 0x1ff3, 0x7, 0x23, 0x2, 
       0x2, 0x1ff3, 0x1ff4, 0x7, 0x6, 0x2, 0x2, 0x1ff4, 0x1ff5, 0x7, 0x20, 
       0x2, 0x2, 0x1ff5, 0x1ff6, 0x7, 0x6, 0x2, 0x2, 0x1ff6, 0x1ff7, 0x7, 
       0x24, 0x2, 0x2, 0x1ff7, 0x48d, 0x3, 0x2, 0x2, 0x2, 0x1ff8, 0x1ffb, 
       0x7, 0x306, 0x2, 0x2, 0x1ff9, 0x1ffb, 0x5, 0x45a, 0x22e, 0x2, 0x1ffa, 
       0x1ff8, 0x3, 0x2, 0x2, 0x2, 0x1ffa, 0x1ff9, 0x3, 0x2, 0x2, 0x2, 0x1ffb, 
       0x48f, 0x3, 0x2, 0x2, 0x2, 0x1ffc, 0x1fff, 0x5, 0x458, 0x22d, 0x2, 
       0x1ffd, 0x1fff, 0x5, 0x4ae, 0x258, 0x2, 0x1ffe, 0x1ffc, 0x3, 0x2, 
       0x2, 0x2, 0x1ffe, 0x1ffd, 0x3, 0x2, 0x2, 0x2, 0x1fff, 0x491, 0x3, 
       0x2, 0x2, 0x2, 0x2000, 0x2003, 0x5, 0x44c, 0x227, 0x2, 0x2001, 0x2003, 
       0x5, 0x474, 0x23b, 0x2, 0x2002, 0x2000, 0x3, 0x2, 0x2, 0x2, 0x2002, 
       0x2001, 0x3, 0x2, 0x2, 0x2, 0x2003, 0x493, 0x3, 0x2, 0x2, 0x2, 0x2004, 
       0x2007, 0x5, 0x46c, 0x237, 0x2, 0x2005, 0x2007, 0x5, 0x458, 0x22d, 
       0x2, 0x2006, 0x2004, 0x3, 0x2, 0x2, 0x2, 0x2006, 0x2005, 0x3, 0x2, 
       0x2, 0x2, 0x2007, 0x495, 0x3, 0x2, 0x2, 0x2, 0x2008, 0x2009, 0x7, 
       0x23, 0x2, 0x2, 0x2009, 0x200a, 0x7, 0x24, 0x2, 0x2, 0x200a, 0x497, 
       0x3, 0x2, 0x2, 0x2, 0x200b, 0x200c, 0x9, 0x88, 0x2, 0x2, 0x200c, 
       0x499, 0x3, 0x2, 0x2, 0x2, 0x200d, 0x200e, 0x9, 0x89, 0x2, 0x2, 0x200e, 
       0x49b, 0x3, 0x2, 0x2, 0x2, 0x200f, 0x2010, 0x7, 0xff, 0x2, 0x2, 0x2010, 
       0x2016, 0x7, 0x1f, 0x2, 0x2, 0x2011, 0x2012, 0x7, 0x141, 0x2, 0x2, 
       0x2012, 0x2016, 0x7, 0x1f, 0x2, 0x2, 0x2013, 0x2014, 0x7, 0x217, 
       0x2, 0x2, 0x2014, 0x2016, 0x7, 0x1f, 0x2, 0x2, 0x2015, 0x200f, 0x3, 
       0x2, 0x2, 0x2, 0x2015, 0x2011, 0x3, 0x2, 0x2, 0x2, 0x2015, 0x2013, 
       0x3, 0x2, 0x2, 0x2, 0x2016, 0x49d, 0x3, 0x2, 0x2, 0x2, 0x2017, 0x2018, 
       0x7, 0x2b3, 0x2, 0x2, 0x2018, 0x2022, 0x7, 0x1f, 0x2, 0x2, 0x2019, 
       0x201a, 0x7, 0x2c2, 0x2, 0x2, 0x201a, 0x2022, 0x7, 0x1f, 0x2, 0x2, 
       0x201b, 0x201c, 0x7, 0xff, 0x2, 0x2, 0x201c, 0x2022, 0x7, 0x1f, 0x2, 
       0x2, 0x201d, 0x201e, 0x7, 0x141, 0x2, 0x2, 0x201e, 0x2022, 0x7, 0x1f, 
       0x2, 0x2, 0x201f, 0x2020, 0x7, 0x217, 0x2, 0x2, 0x2020, 0x2022, 0x7, 
       0x1f, 0x2, 0x2, 0x2021, 0x2017, 0x3, 0x2, 0x2, 0x2, 0x2021, 0x2019, 
       0x3, 0x2, 0x2, 0x2, 0x2021, 0x201b, 0x3, 0x2, 0x2, 0x2, 0x2021, 0x201d, 
       0x3, 0x2, 0x2, 0x2, 0x2021, 0x201f, 0x3, 0x2, 0x2, 0x2, 0x2022, 0x49f, 
       0x3, 0x2, 0x2, 0x2, 0x2023, 0x202b, 0x6, 0x251, 0xd5, 0x2, 0x2024, 
       0x202c, 0x5, 0x4a6, 0x254, 0x2, 0x2025, 0x202c, 0x5, 0x4b2, 0x25a, 
       0x2, 0x2026, 0x202c, 0x7, 0xda, 0x2, 0x2, 0x2027, 0x2028, 0x6, 0x251, 
       0xd6, 0x2, 0x2028, 0x202c, 0x7, 0x21f, 0x2, 0x2, 0x2029, 0x202a, 
       0x6, 0x251, 0xd7, 0x2, 0x202a, 0x202c, 0x7, 0x2eb, 0x2, 0x2, 0x202b, 
       0x2024, 0x3, 0x2, 0x2, 0x2, 0x202b, 0x2025, 0x3, 0x2, 0x2, 0x2, 0x202b, 
       0x2026, 0x3, 0x2, 0x2, 0x2, 0x202b, 0x2027, 0x3, 0x2, 0x2, 0x2, 0x202b, 
       0x2029, 0x3, 0x2, 0x2, 0x2, 0x202c, 0x2035, 0x3, 0x2, 0x2, 0x2, 0x202d, 
       0x2033, 0x5, 0x4aa, 0x256, 0x2, 0x202e, 0x2033, 0x5, 0x4a2, 0x252, 
       0x2, 0x202f, 0x2033, 0x5, 0x4a4, 0x253, 0x2, 0x2030, 0x2033, 0x5, 
       0x4a8, 0x255, 0x2, 0x2031, 0x2033, 0x5, 0x4b0, 0x259, 0x2, 0x2032, 
       0x202d, 0x3, 0x2, 0x2, 0x2, 0x2032, 0x202e, 0x3, 0x2, 0x2, 0x2, 0x2032, 
       0x202f, 0x3, 0x2, 0x2, 0x2, 0x2032, 0x2030, 0x3, 0x2, 0x2, 0x2, 0x2032, 
       0x2031, 0x3, 0x2, 0x2, 0x2, 0x2033, 0x2035, 0x3, 0x2, 0x2, 0x2, 0x2034, 
       0x2023, 0x3, 0x2, 0x2, 0x2, 0x2034, 0x2032, 0x3, 0x2, 0x2, 0x2, 0x2035, 
       0x4a1, 0x3, 0x2, 0x2, 0x2, 0x2036, 0x2037, 0x9, 0x8a, 0x2, 0x2, 0x2037, 
       0x4a3, 0x3, 0x2, 0x2, 0x2, 0x2038, 0x2039, 0x9, 0x8b, 0x2, 0x2, 0x2039, 
       0x4a5, 0x3, 0x2, 0x2, 0x2, 0x203a, 0x2045, 0x6, 0x254, 0xd8, 0x2, 
       0x203b, 0x2046, 0x5, 0x4b4, 0x25b, 0x2, 0x203c, 0x2046, 0x7, 0xd7, 
       0x2, 0x2, 0x203d, 0x2046, 0x7, 0xe7, 0x2, 0x2, 0x203e, 0x2046, 0x7, 
       0x194, 0x2, 0x2, 0x203f, 0x2046, 0x7, 0x1cb, 0x2, 0x2, 0x2040, 0x2046, 
       0x7, 0x1cf, 0x2, 0x2, 0x2041, 0x2046, 0x7, 0x1e7, 0x2, 0x2, 0x2042, 
       0x2046, 0x7, 0x1ef, 0x2, 0x2, 0x2043, 0x2046, 0x7, 0x2e6, 0x2, 0x2, 
       0x2044, 0x2046, 0x7, 0x255, 0x2, 0x2, 0x2045, 0x203b, 0x3, 0x2, 0x2, 
       0x2, 0x2045, 0x203c, 0x3, 0x2, 0x2, 0x2, 0x2045, 0x203d, 0x3, 0x2, 
       0x2, 0x2, 0x2045, 0x203e, 0x3, 0x2, 0x2, 0x2, 0x2045, 0x203f, 0x3, 
       0x2, 0x2, 0x2, 0x2045, 0x2040, 0x3, 0x2, 0x2, 0x2, 0x2045, 0x2041, 
       0x3, 0x2, 0x2, 0x2, 0x2045, 0x2042, 0x3, 0x2, 0x2, 0x2, 0x2045, 0x2043, 
       0x3, 0x2, 0x2, 0x2, 0x2045, 0x2044, 0x3, 0x2, 0x2, 0x2, 0x2046, 0x204d, 
       0x3, 0x2, 0x2, 0x2, 0x2047, 0x204b, 0x5, 0x4aa, 0x256, 0x2, 0x2048, 
       0x204b, 0x5, 0x4a8, 0x255, 0x2, 0x2049, 0x204b, 0x5, 0x4b0, 0x259, 
       0x2, 0x204a, 0x2047, 0x3, 0x2, 0x2, 0x2, 0x204a, 0x2048, 0x3, 0x2, 
       0x2, 0x2, 0x204a, 0x2049, 0x3, 0x2, 0x2, 0x2, 0x204b, 0x204d, 0x3, 
       0x2, 0x2, 0x2, 0x204c, 0x203a, 0x3, 0x2, 0x2, 0x2, 0x204c, 0x204a, 
       0x3, 0x2, 0x2, 0x2, 0x204d, 0x4a7, 0x3, 0x2, 0x2, 0x2, 0x204e, 0x204f, 
       0x9, 0x8c, 0x2, 0x2, 0x204f, 0x4a9, 0x3, 0x2, 0x2, 0x2, 0x2050, 0x2051, 
       0x9, 0x8d, 0x2, 0x2, 0x2051, 0x4ab, 0x3, 0x2, 0x2, 0x2, 0x2052, 0x2055, 
       0x6, 0x257, 0xd9, 0x2, 0x2053, 0x2056, 0x5, 0x4b4, 0x25b, 0x2, 0x2054, 
       0x2056, 0x5, 0x4b2, 0x25a, 0x2, 0x2055, 0x2053, 0x3, 0x2, 0x2, 0x2, 
       0x2055, 0x2054, 0x3, 0x2, 0x2, 0x2, 0x2056, 0x205d, 0x3, 0x2, 0x2, 
       0x2, 0x2057, 0x205b, 0x5, 0x4aa, 0x256, 0x2, 0x2058, 0x205b, 0x5, 
       0x4a4, 0x253, 0x2, 0x2059, 0x205b, 0x5, 0x4b0, 0x259, 0x2, 0x205a, 
       0x2057, 0x3, 0x2, 0x2, 0x2, 0x205a, 0x2058, 0x3, 0x2, 0x2, 0x2, 0x205a, 
       0x2059, 0x3, 0x2, 0x2, 0x2, 0x205b, 0x205d, 0x3, 0x2, 0x2, 0x2, 0x205c, 
       0x2052, 0x3, 0x2, 0x2, 0x2, 0x205c, 0x205a, 0x3, 0x2, 0x2, 0x2, 0x205d, 
       0x4ad, 0x3, 0x2, 0x2, 0x2, 0x205e, 0x2063, 0x5, 0x4aa, 0x256, 0x2, 
       0x205f, 0x2063, 0x5, 0x4a2, 0x252, 0x2, 0x2060, 0x2063, 0x5, 0x4a4, 
       0x253, 0x2, 0x2061, 0x2063, 0x5, 0x4a8, 0x255, 0x2, 0x2062, 0x205e, 
       0x3, 0x2, 0x2, 0x2, 0x2062, 0x205f, 0x3, 0x2, 0x2, 0x2, 0x2062, 0x2060, 
       0x3, 0x2, 0x2, 0x2, 0x2062, 0x2061, 0x3, 0x2, 0x2, 0x2, 0x2063, 0x4af, 
       0x3, 0x2, 0x2, 0x2, 0x2064, 0x2065, 0x9, 0x89, 0x2, 0x2, 0x2065, 
       0x4b1, 0x3, 0x2, 0x2, 0x2, 0x2066, 0x206c, 0x9, 0x8e, 0x2, 0x2, 0x2067, 
       0x2068, 0x6, 0x25a, 0xda, 0x2, 0x2068, 0x206c, 0x7, 0x21f, 0x2, 0x2, 
       0x2069, 0x206a, 0x6, 0x25a, 0xdb, 0x2, 0x206a, 0x206c, 0x7, 0x113, 
       0x2, 0x2, 0x206b, 0x2066, 0x3, 0x2, 0x2, 0x2, 0x206b, 0x2067, 0x3, 
       0x2, 0x2, 0x2, 0x206b, 0x2069, 0x3, 0x2, 0x2, 0x2, 0x206c, 0x4b3, 
       0x3, 0x2, 0x2, 0x2, 0x206d, 0x2077, 0x9, 0x8f, 0x2, 0x2, 0x206e, 
       0x206f, 0x6, 0x25b, 0xdc, 0x2, 0x206f, 0x2077, 0x7, 0x21f, 0x2, 0x2, 
       0x2070, 0x2071, 0x6, 0x25b, 0xdd, 0x2, 0x2071, 0x2077, 0x9, 0x90, 
       0x2, 0x2, 0x2072, 0x2073, 0x6, 0x25b, 0xde, 0x2, 0x2073, 0x2077, 
       0x9, 0x91, 0x2, 0x2, 0x2074, 0x2075, 0x6, 0x25b, 0xdf, 0x2, 0x2075, 
       0x2077, 0x7, 0x2b5, 0x2, 0x2, 0x2076, 0x206d, 0x3, 0x2, 0x2, 0x2, 
       0x2076, 0x206e, 0x3, 0x2, 0x2, 0x2, 0x2076, 0x2070, 0x3, 0x2, 0x2, 
       0x2, 0x2076, 0x2072, 0x3, 0x2, 0x2, 0x2, 0x2076, 0x2074, 0x3, 0x2, 
       0x2, 0x2, 0x2077, 0x4b5, 0x3, 0x2, 0x2, 0x2, 0x45c, 0x4ba, 0x4bf, 
       0x4c7, 0x4cb, 0x4ce, 0x4d0, 0x4f4, 0x4fc, 0x501, 0x511, 0x518, 0x51f, 
       0x522, 0x529, 0x52e, 0x531, 0x536, 0x53c, 0x53e, 0x542, 0x546, 0x54f, 
       0x553, 0x558, 0x55e, 0x565, 0x569, 0x56e, 0x573, 0x57a, 0x57d, 0x583, 
       0x586, 0x58d, 0x597, 0x59c, 0x5a1, 0x5a9, 0x5af, 0x5b3, 0x5b8, 0x5c1, 
       0x5c7, 0x5cd, 0x5d3, 0x5dd, 0x5e3, 0x5ec, 0x5fa, 0x5fe, 0x604, 0x608, 
       0x610, 0x614, 0x619, 0x61c, 0x622, 0x628, 0x62e, 0x632, 0x637, 0x63b, 
       0x63f, 0x647, 0x649, 0x650, 0x658, 0x660, 0x664, 0x67b, 0x68b, 0x68e, 
       0x697, 0x69c, 0x6a2, 0x6a7, 0x6ab, 0x6b0, 0x6b4, 0x6b8, 0x6bc, 0x6c1, 
       0x6c5, 0x6c7, 0x6d2, 0x6d7, 0x6dd, 0x6e5, 0x6ee, 0x6f3, 0x6f6, 0x6fb, 
       0x702, 0x70a, 0x70e, 0x713, 0x71a, 0x71f, 0x724, 0x72c, 0x730, 0x735, 
       0x738, 0x73b, 0x73e, 0x745, 0x74c, 0x750, 0x768, 0x76c, 0x772, 0x779, 
       0x77c, 0x780, 0x787, 0x78a, 0x78d, 0x790, 0x799, 0x7a0, 0x7a5, 0x7a8, 
       0x7ab, 0x7b1, 0x7b7, 0x7ba, 0x7bf, 0x7c9, 0x7cc, 0x7d2, 0x7d8, 0x7e2, 
       0x7e5, 0x7ed, 0x7f3, 0x7fe, 0x801, 0x806, 0x819, 0x81c, 0x81f, 0x825, 
       0x828, 0x82a, 0x830, 0x83a, 0x844, 0x847, 0x84a, 0x84f, 0x855, 0x862, 
       0x866, 0x86b, 0x874, 0x885, 0x898, 0x8a1, 0x8a4, 0x8ac, 0x8b1, 0x8b5, 
       0x8bc, 0x8c1, 0x8d0, 0x8d4, 0x8da, 0x8e0, 0x8e6, 0x8ec, 0x8f2, 0x8f7, 
       0x8fb, 0x903, 0x909, 0x90f, 0x914, 0x917, 0x91a, 0x923, 0x926, 0x931, 
       0x93d, 0x946, 0x94a, 0x953, 0x956, 0x95c, 0x95e, 0x962, 0x969, 0x976, 
       0x97d, 0x983, 0x986, 0x997, 0x9ab, 0x9af, 0x9b5, 0x9bb, 0x9c1, 0x9c6, 
       0x9cd, 0x9d4, 0x9d9, 0x9dc, 0x9e0, 0x9e4, 0x9e9, 0x9ed, 0x9f1, 0x9f7, 
       0x9fc, 0x9ff, 0xa03, 0xa09, 0xa0d, 0xa11, 0xa19, 0xa21, 0xa2a, 0xa33, 
       0xa40, 0xa43, 0xa47, 0xa4d, 0xa55, 0xa5a, 0xa5d, 0xa60, 0xa63, 0xa66, 
       0xa68, 0xa6e, 0xa70, 0xa7f, 0xa85, 0xa8c, 0xa8f, 0xa91, 0xa93, 0xa9d, 
       0xa9f, 0xaa3, 0xaa6, 0xaa9, 0xaad, 0xab3, 0xab6, 0xabc, 0xabf, 0xac8, 
       0xad1, 0xad5, 0xad9, 0xadf, 0xae4, 0xae9, 0xaee, 0xaf2, 0xafe, 0xb01, 
       0xb06, 0xb0c, 0xb0f, 0xb12, 0xb15, 0xb18, 0xb26, 0xb29, 0xb2d, 0xb31, 
       0xb37, 0xb3c, 0xb40, 0xb45, 0xb48, 0xb4c, 0xb52, 0xb57, 0xb60, 0xb64, 
       0xb68, 0xb6b, 0xb70, 0xb73, 0xb75, 0xb79, 0xb7c, 0xb82, 0xb84, 0xb8b, 
       0xb8f, 0xb91, 0xb96, 0xb9a, 0xb9e, 0xba4, 0xbac, 0xbb1, 0xbb4, 0xbb7, 
       0xbba, 0xbbd, 0xbc1, 0xbd0, 0xbd4, 0xbda, 0xbdd, 0xbe0, 0xbe6, 0xbeb, 
       0xbef, 0xbf2, 0xbfa, 0xbfc, 0xc09, 0xc15, 0xc1a, 0xc1d, 0xc20, 0xc25, 
       0xc2b, 0xc3b, 0xc4f, 0xc58, 0xc5c, 0xc63, 0xc68, 0xc71, 0xc78, 0xc83, 
       0xc8a, 0xc95, 0xc9c, 0xca0, 0xca6, 0xcab, 0xcb0, 0xcb4, 0xcba, 0xcc0, 
       0xcc2, 0xcc5, 0xcc9, 0xcd3, 0xcd8, 0xcdd, 0xce4, 0xced, 0xcf5, 0xcfa, 
       0xcfe, 0xd04, 0xd07, 0xd0a, 0xd0e, 0xd12, 0xd1c, 0xd20, 0xd23, 0xd26, 
       0xd2b, 0xd31, 0xd35, 0xd3b, 0xd3e, 0xd40, 0xd45, 0xd51, 0xd5a, 0xd67, 
       0xd6a, 0xd6f, 0xd76, 0xd7a, 0xd7e, 0xd80, 0xd8e, 0xd95, 0xd9e, 0xda4, 
       0xdad, 0xdb1, 0xdb5, 0xdbf, 0xdc1, 0xdc9, 0xdd0, 0xdd5, 0xdd9, 0xddd, 
       0xde0, 0xde6, 0xde9, 0xdec, 0xdf2, 0xdf9, 0xdfe, 0xe02, 0xe05, 0xe08, 
       0xe0b, 0xe0d, 0xe11, 0xe19, 0xe21, 0xe28, 0xe2e, 0xe32, 0xe37, 0xe3a, 
       0xe3d, 0xe40, 0xe42, 0xe47, 0xe50, 0xe5d, 0xe5f, 0xe63, 0xe69, 0xe6c, 
       0xe6f, 0xe75, 0xe7c, 0xe7e, 0xe86, 0xe8c, 0xe91, 0xe94, 0xe9b, 0xe9d, 
       0xea6, 0xeaf, 0xeb8, 0xec0, 0xec4, 0xecb, 0xece, 0xed0, 0xed8, 0xede, 
       0xee8, 0xeef, 0xf3b, 0xf49, 0xf51, 0xf54, 0xf60, 0xf65, 0xf6b, 0xf72, 
       0xf79, 0xf80, 0xf87, 0xf8e, 0xf95, 0xf98, 0xf9f, 0xfa7, 0xfaf, 0xfb9, 
       0xfbf, 0xfc3, 0xfc7, 0xfcc, 0xfcf, 0xfd1, 0xfda, 0xfe0, 0xfe7, 0xfec, 
       0xff1, 0xff6, 0xff9, 0x1000, 0x100d, 0x1013, 0x1019, 0x1020, 0x1028, 
       0x102e, 0x103a, 0x103c, 0x1042, 0x1046, 0x1048, 0x104c, 0x105a, 0x1060, 
       0x1068, 0x1074, 0x1078, 0x1086, 0x1088, 0x108f, 0x1097, 0x109a, 0x109f, 
       0x10a3, 0x10a9, 0x10ac, 0x10b1, 0x10bc, 0x10be, 0x10ca, 0x10cf, 0x10d7, 
       0x10dd, 0x10df, 0x10e1, 0x10e7, 0x10f3, 0x10f8, 0x10fa, 0x10fe, 0x1104, 
       0x1107, 0x110a, 0x1114, 0x1116, 0x111c, 0x1123, 0x1129, 0x1133, 0x1137, 
       0x113c, 0x114d, 0x115d, 0x1162, 0x116a, 0x1172, 0x1177, 0x117d, 0x1180, 
       0x1182, 0x118a, 0x1199, 0x119d, 0x11a1, 0x11a8, 0x11ae, 0x11b4, 0x11b6, 
       0x11ba, 0x11c5, 0x11cf, 0x11d4, 0x11d9, 0x11de, 0x11e6, 0x11ea, 0x11ef, 
       0x11f8, 0x1204, 0x1212, 0x121b, 0x121d, 0x1224, 0x122a, 0x122e, 0x1238, 
       0x123f, 0x1243, 0x1249, 0x124d, 0x1254, 0x1257, 0x1260, 0x1266, 0x126b, 
       0x1282, 0x1285, 0x1289, 0x1290, 0x1292, 0x1295, 0x129a, 0x129c, 0x12b1, 
       0x12b5, 0x12b7, 0x12bb, 0x12c7, 0x12ce, 0x12d7, 0x12de, 0x12e1, 0x12e5, 
       0x12e8, 0x12eb, 0x12ef, 0x12f2, 0x12f6, 0x12f9, 0x12fe, 0x1301, 0x1306, 
       0x1309, 0x130f, 0x1313, 0x1319, 0x131c, 0x1325, 0x1327, 0x132d, 0x1331, 
       0x1334, 0x1337, 0x133b, 0x1341, 0x1344, 0x1347, 0x1351, 0x1355, 0x135e, 
       0x1361, 0x1366, 0x1369, 0x136c, 0x1370, 0x1373, 0x1378, 0x137c, 0x1384, 
       0x1391, 0x13a3, 0x13a8, 0x13ad, 0x13b5, 0x13bb, 0x13bd, 0x13c1, 0x13c4, 
       0x13d2, 0x13dc, 0x13e0, 0x13e8, 0x13eb, 0x13ef, 0x13f9, 0x13fd, 0x1404, 
       0x1409, 0x1411, 0x1416, 0x141c, 0x1423, 0x1428, 0x142e, 0x1435, 0x143f, 
       0x1441, 0x1449, 0x144e, 0x1452, 0x1455, 0x145c, 0x1461, 0x1465, 0x1470, 
       0x1478, 0x147c, 0x147f, 0x1482, 0x1486, 0x148a, 0x148f, 0x1495, 0x1499, 
       0x14a4, 0x14a7, 0x14aa, 0x14ad, 0x14b5, 0x14b9, 0x14be, 0x14c6, 0x14ce, 
       0x14d4, 0x14df, 0x14e9, 0x14ef, 0x14fd, 0x1500, 0x1504, 0x150f, 0x1511, 
       0x151a, 0x1526, 0x1528, 0x152f, 0x1535, 0x153b, 0x1543, 0x154e, 0x1552, 
       0x156f, 0x1571, 0x1578, 0x1589, 0x1590, 0x159e, 0x15aa, 0x15b0, 0x15b7, 
       0x15ba, 0x15dc, 0x15e4, 0x15e6, 0x15f2, 0x15f7, 0x15fd, 0x1605, 0x160c, 
       0x1612, 0x1617, 0x161d, 0x1622, 0x1627, 0x162d, 0x1632, 0x1638, 0x1640, 
       0x1648, 0x1650, 0x1658, 0x165d, 0x1663, 0x1668, 0x166c, 0x1670, 0x1675, 
       0x1677, 0x168a, 0x168e, 0x1695, 0x16a1, 0x16a4, 0x16a8, 0x16ad, 0x16b2, 
       0x16b6, 0x16c0, 0x16c9, 0x16cb, 0x16ce, 0x16d7, 0x16de, 0x16eb, 0x16f0, 
       0x16f7, 0x16fd, 0x1717, 0x1736, 0x174a, 0x1750, 0x1754, 0x176f, 0x177b, 
       0x1788, 0x178c, 0x1790, 0x17ac, 0x17e4, 0x17ef, 0x17f3, 0x17ff, 0x1804, 
       0x1811, 0x1825, 0x1829, 0x183a, 0x183d, 0x1842, 0x1845, 0x184e, 0x1852, 
       0x1858, 0x185e, 0x1862, 0x186d, 0x1873, 0x1875, 0x187c, 0x1883, 0x1887, 
       0x188e, 0x1893, 0x1898, 0x189b, 0x18a0, 0x18a4, 0x18a8, 0x18ad, 0x18b2, 
       0x18b4, 0x18b8, 0x18c5, 0x18c9, 0x18cc, 0x18d0, 0x18d4, 0x18d8, 0x18dd, 
       0x18e1, 0x18e5, 0x18ee, 0x18f0, 0x18f7, 0x18fd, 0x1905, 0x191a, 0x191f, 
       0x1926, 0x193d, 0x194d, 0x1957, 0x195b, 0x1962, 0x1965, 0x1970, 0x1979, 
       0x197c, 0x1983, 0x1988, 0x19a2, 0x19a8, 0x19ae, 0x19b2, 0x19bc, 0x19c0, 
       0x19cd, 0x19d9, 0x19eb, 0x19f3, 0x19fd, 0x1a00, 0x1a05, 0x1a09, 0x1a10, 
       0x1a15, 0x1a1c, 0x1a24, 0x1a27, 0x1a2c, 0x1a2f, 0x1a37, 0x1a3a, 0x1a48, 
       0x1a4b, 0x1a58, 0x1a5c, 0x1a5e, 0x1a63, 0x1a68, 0x1a6e, 0x1a74, 0x1a7a, 
       0x1a7f, 0x1a82, 0x1a88, 0x1a8d, 0x1a90, 0x1a96, 0x1a9a, 0x1aa0, 0x1aa2, 
       0x1aa5, 0x1aab, 0x1ab1, 0x1ab9, 0x1abb, 0x1abd, 0x1ac1, 0x1ac7, 0x1acc, 
       0x1ad0, 0x1ad5, 0x1adb, 0x1ae2, 0x1ae5, 0x1ae7, 0x1aea, 0x1af4, 0x1af8, 
       0x1afe, 0x1b05, 0x1b0a, 0x1b18, 0x1b1d, 0x1b25, 0x1b2a, 0x1b2e, 0x1b31, 
       0x1b36, 0x1b3a, 0x1b42, 0x1b4a, 0x1b4c, 0x1b53, 0x1b5b, 0x1b62, 0x1b65, 
       0x1b6d, 0x1b75, 0x1b77, 0x1b7d, 0x1b83, 0x1b87, 0x1b8f, 0x1b9a, 0x1ba3, 
       0x1ba6, 0x1bab, 0x1bad, 0x1bb0, 0x1bb3, 0x1bb7, 0x1bba, 0x1bbe, 0x1bc3, 
       0x1bc6, 0x1bca, 0x1bcd, 0x1bd1, 0x1bd6, 0x1bda, 0x1be6, 0x1bea, 0x1bf0, 
       0x1bf3, 0x1bf8, 0x1bfc, 0x1c00, 0x1c05, 0x1c0e, 0x1c11, 0x1c15, 0x1c19, 
       0x1c1c, 0x1c20, 0x1c24, 0x1c29, 0x1c2e, 0x1c34, 0x1c39, 0x1c3e, 0x1c4a, 
       0x1c4f, 0x1c51, 0x1c56, 0x1c5d, 0x1c65, 0x1c6b, 0x1c6d, 0x1c71, 0x1c75, 
       0x1c79, 0x1c7d, 0x1c8c, 0x1c91, 0x1c95, 0x1c9a, 0x1ca0, 0x1ca4, 0x1caa, 
       0x1cae, 0x1cb2, 0x1cb7, 0x1cbc, 0x1cc1, 0x1cc6, 0x1ccc, 0x1cd2, 0x1cd7, 
       0x1cdc, 0x1ce2, 0x1ce7, 0x1cec, 0x1cf1, 0x1cf6, 0x1d00, 0x1d06, 0x1d0c, 
       0x1d12, 0x1d15, 0x1d1c, 0x1d21, 0x1d24, 0x1d28, 0x1d2b, 0x1d2f, 0x1d34, 
       0x1d38, 0x1d3d, 0x1d41, 0x1d4a, 0x1d4d, 0x1d50, 0x1d53, 0x1d57, 0x1d5b, 
       0x1d5f, 0x1d6e, 0x1d71, 0x1d73, 0x1d78, 0x1d81, 0x1d84, 0x1d88, 0x1d95, 
       0x1da1, 0x1da6, 0x1dab, 0x1db4, 0x1db9, 0x1dc2, 0x1dc7, 0x1dcb, 0x1dcf, 
       0x1dd3, 0x1dd8, 0x1ddd, 0x1de3, 0x1de8, 0x1deb, 0x1df2, 0x1dfb, 0x1e02, 
       0x1e10, 0x1e1c, 0x1e29, 0x1e31, 0x1e38, 0x1e41, 0x1e47, 0x1e4f, 0x1e55, 
       0x1e60, 0x1e68, 0x1e70, 0x1e78, 0x1e83, 0x1e85, 0x1e87, 0x1e89, 0x1e8f, 
       0x1e95, 0x1e98, 0x1e9f, 0x1ea1, 0x1ea3, 0x1ea6, 0x1ea8, 0x1eb9, 0x1ebd, 
       0x1ebf, 0x1ec6, 0x1ed4, 0x1ed6, 0x1edc, 0x1ee6, 0x1eef, 0x1efa, 0x1f10, 
       0x1f14, 0x1f2c, 0x1f37, 0x1f39, 0x1f3d, 0x1f44, 0x1f4c, 0x1f53, 0x1f59, 
       0x1f68, 0x1f6c, 0x1f73, 0x1f7c, 0x1f81, 0x1f83, 0x1f89, 0x1f99, 0x1fa1, 
       0x1fa4, 0x1fab, 0x1fb3, 0x1fbb, 0x1fc0, 0x1fc5, 0x1fc8, 0x1fcc, 0x1fd1, 
       0x1fdb, 0x1fea, 0x1fee, 0x1ffa, 0x1ffe, 0x2002, 0x2006, 0x2015, 0x2021, 
       0x202b, 0x2032, 0x2034, 0x2045, 0x204a, 0x204c, 0x2055, 0x205a, 0x205c, 
       0x2062, 0x206b, 0x2076, 
  };

  _serializedATN.insert(_serializedATN.end(), serializedATNSegment0,
    serializedATNSegment0 + sizeof(serializedATNSegment0) / sizeof(serializedATNSegment0[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment1,
    serializedATNSegment1 + sizeof(serializedATNSegment1) / sizeof(serializedATNSegment1[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment2,
    serializedATNSegment2 + sizeof(serializedATNSegment2) / sizeof(serializedATNSegment2[0]));
  _serializedATN.insert(_serializedATN.end(), serializedATNSegment3,
    serializedATNSegment3 + sizeof(serializedATNSegment3) / sizeof(serializedATNSegment3[0]));


  atn::ATNDeserializer deserializer;
  _atn = deserializer.deserialize(_serializedATN);

  size_t count = _atn.getNumberOfDecisions();
  _decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
  }
}

MySQLParser::Initializer MySQLParser::_init;
